["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-router/dist/umd/react-router.development.js"],"~:js","shadow$provide.module$node_modules$react_router$dist$umd$react_router_development = function(global, require, module, exports) {\n  (function(global, factory) {\n    \"object\" === typeof exports && \"undefined\" !== typeof module ? factory(exports, require(\"module$node_modules$react$index\"), require(\"module$node_modules$$remix_run$router$dist$router_cjs\")) : \"function\" === typeof define && define.amd ? define([\"exports\", \"react\", \"@remix-run/router\"], factory) : (global = \"undefined\" !== typeof globalThis ? globalThis : global || self, factory(global.ReactRouter = {}, global.React, global.RemixRouter));\n  })(this, function(exports, React, router) {\n    function _extends() {\n      _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i], key;\n          for (key in source) {\n            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function useInRouterContext() {\n      return null != React__namespace.useContext(LocationContext);\n    }\n    function useLocation() {\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"useLocation() may be used only in the context of a \\x3cRouter\\x3e component.\");\n      return React__namespace.useContext(LocationContext).location;\n    }\n    function useIsomorphicLayoutEffect(cb) {\n      React__namespace.useContext(NavigationContext).static || React__namespace.useLayoutEffect(cb);\n    }\n    function useNavigate() {\n      let {isDataRoute} = React__namespace.useContext(RouteContext);\n      return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n    }\n    function useNavigateUnstable() {\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"useNavigate() may be used only in the context of a \\x3cRouter\\x3e component.\");\n      let dataRouterContext = React__namespace.useContext(DataRouterContext), {basename, future, navigator} = React__namespace.useContext(NavigationContext), {matches} = React__namespace.useContext(RouteContext), {pathname:locationPathname} = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath)), activeRef = React__namespace.useRef(!1);\n      useIsomorphicLayoutEffect(() => {\n        activeRef.current = !0;\n      });\n      return React__namespace.useCallback(function(to, options) {\n        void 0 === options && (options = {});\n        router.UNSAFE_warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\");\n        activeRef.current && (\"number\" === typeof to ? navigator.go(to) : (to = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, \"path\" === options.relative), null == dataRouterContext && \"/\" !== basename && (to.pathname = \"/\" === to.pathname ? basename : router.joinPaths([basename, to.pathname])), (options.replace ? navigator.replace : navigator.push)(to, options.state, options)));\n      }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n    }\n    function useOutlet(context) {\n      let outlet = React__namespace.useContext(RouteContext).outlet;\n      return outlet ? React__namespace.createElement(OutletContext.Provider, {value:context}, outlet) : outlet;\n    }\n    function useResolvedPath(to, _temp2) {\n      let {relative} = void 0 === _temp2 ? {} : _temp2;\n      ({future:_temp2} = React__namespace.useContext(NavigationContext));\n      let {matches} = React__namespace.useContext(RouteContext), {pathname:locationPathname} = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, _temp2.v7_relativeSplatPath));\n      return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, \"path\" === relative), [to, routePathnamesJson, locationPathname, relative]);\n    }\n    function useRoutes(routes, locationArg) {\n      return useRoutesImpl(routes, locationArg);\n    }\n    function useRoutesImpl(routes, locationArg, dataRouterState, future) {\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"useRoutes() may be used only in the context of a \\x3cRouter\\x3e component.\");\n      let {navigator, static:isStatic} = React__namespace.useContext(NavigationContext), {matches:parentMatches} = React__namespace.useContext(RouteContext);\n      var routeMatch = parentMatches[parentMatches.length - 1];\n      let parentParams = routeMatch ? routeMatch.params : {};\n      var parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n      var parentPath = (routeMatch = routeMatch && routeMatch.route) && routeMatch.path || \"\";\n      warningOnce(parentPathname, !routeMatch || parentPath.endsWith(\"*\"), 'You rendered descendant \\x3cRoutes\\x3e (or called `useRoutes()`) at \"' + (parentPathname + '\" (under \\x3cRoute path\\x3d\"' + parentPath + '\"\\x3e) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent \\x3cRoute path\\x3d\"') + (parentPath + '\"\\x3e to \\x3cRoute path\\x3d\"') + ((\"/\" === parentPath ? \n      \"*\" : parentPath + \"/*\") + '\"\\x3e.'));\n      parentPathname = useLocation();\n      var location;\n      locationArg ? (parentPathname = \"string\" === typeof locationArg ? router.parsePath(locationArg) : locationArg, \"/\" === parentPathnameBase || (null == (location = parentPathname.pathname) ? 0 : location.startsWith(parentPathnameBase)) || router.UNSAFE_invariant(!1, 'When overriding the location using `\\x3cRoutes location\\x3e` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"' + \n      (parentPathnameBase + '\" but pathname \"') + (parentPathname.pathname + '\" was given in the `location` prop.')), location = parentPathname) : location = parentPathname;\n      parentPath = parentPathname = location.pathname || \"/\";\n      \"/\" !== parentPathnameBase && (parentPath = parentPathnameBase.replace(/^\\//, \"\").split(\"/\"), parentPath = \"/\" + parentPathname.replace(/^\\//, \"\").split(\"/\").slice(parentPath.length).join(\"/\"));\n      routes = !isStatic && dataRouterState && dataRouterState.matches && 0 < dataRouterState.matches.length ? dataRouterState.matches : router.matchRoutes(routes, {pathname:parentPath});\n      router.UNSAFE_warning(routeMatch || null != routes, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ');\n      router.UNSAFE_warning(null == routes || void 0 !== routes[routes.length - 1].route.element || void 0 !== routes[routes.length - 1].route.Component || void 0 !== routes[routes.length - 1].route.lazy, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" does not have an element or Component. This means it will render an \\x3cOutlet /\\x3e with a null value by default resulting in an \"empty\" page.');\n      dataRouterState = _renderMatches(routes && routes.map(match => Object.assign({}, match, {params:Object.assign({}, parentParams, match.params), pathname:router.joinPaths([parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]), pathnameBase:\"/\" === match.pathnameBase ? parentPathnameBase : router.joinPaths([parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])})), \n      parentMatches, dataRouterState, future);\n      return locationArg && dataRouterState ? React__namespace.createElement(LocationContext.Provider, {value:{location:_extends({pathname:\"/\", search:\"\", hash:\"\", state:null, key:\"default\"}, location), navigationType:router.Action.Pop}}, dataRouterState) : dataRouterState;\n    }\n    function RenderedRoute(_ref) {\n      let {routeContext, match, children} = _ref;\n      (_ref = React__namespace.useContext(DataRouterContext)) && _ref.static && _ref.staticContext && (match.route.errorElement || match.route.ErrorBoundary) && (_ref.staticContext._deepestRenderedBoundaryId = match.route.id);\n      return React__namespace.createElement(RouteContext.Provider, {value:routeContext}, children);\n    }\n    function _renderMatches(matches, parentMatches, dataRouterState, future) {\n      var _dataRouterState;\n      void 0 === parentMatches && (parentMatches = []);\n      void 0 === dataRouterState && (dataRouterState = null);\n      void 0 === future && (future = null);\n      if (null == matches) {\n        var _future;\n        if (!dataRouterState) {\n          return null;\n        }\n        if (dataRouterState.errors) {\n          matches = dataRouterState.matches;\n        } else if (null != (_future = future) && _future.v7_partialHydration && 0 === parentMatches.length && !dataRouterState.initialized && 0 < dataRouterState.matches.length) {\n          matches = dataRouterState.matches;\n        } else {\n          return null;\n        }\n      }\n      let renderedMatches = matches, errors = null == (_dataRouterState = dataRouterState) ? void 0 : _dataRouterState.errors;\n      null != errors && (matches = renderedMatches.findIndex(m => m.route.id && void 0 !== (null == errors ? void 0 : errors[m.route.id])), 0 <= matches || router.UNSAFE_invariant(!1, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, matches + 1)));\n      let renderFallback = !1, fallbackIndex = -1;\n      if (dataRouterState && future && future.v7_partialHydration) {\n        for (future = 0; future < renderedMatches.length; future++) {\n          matches = renderedMatches[future];\n          if (matches.route.HydrateFallback || matches.route.hydrateFallbackElement) {\n            fallbackIndex = future;\n          }\n          if (matches.route.id) {\n            let {loaderData, errors} = dataRouterState;\n            _dataRouterState = matches.route.loader && void 0 === loaderData[matches.route.id] && (!errors || void 0 === errors[matches.route.id]);\n            if (matches.route.lazy || _dataRouterState) {\n              renderFallback = !0;\n              renderedMatches = 0 <= fallbackIndex ? renderedMatches.slice(0, fallbackIndex + 1) : [renderedMatches[0]];\n              break;\n            }\n          }\n        }\n      }\n      return renderedMatches.reduceRight((outlet, match, index) => {\n        let error, shouldRenderHydrateFallback = !1, errorElement = null, hydrateFallbackElement = null;\n        dataRouterState && (error = errors && match.route.id ? errors[match.route.id] : void 0, errorElement = match.route.errorElement || defaultErrorElement, renderFallback && (0 > fallbackIndex && 0 === index ? (warningOnce(\"route-fallback\", !1, \"No `HydrateFallback` element provided to render during initial hydration\"), shouldRenderHydrateFallback = !0, hydrateFallbackElement = null) : fallbackIndex === index && (shouldRenderHydrateFallback = !0, hydrateFallbackElement = match.route.hydrateFallbackElement || \n        null)));\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1)), getChildren = () => {\n          let children;\n          children = error ? errorElement : shouldRenderHydrateFallback ? hydrateFallbackElement : match.route.Component ? React__namespace.createElement(match.route.Component, null) : match.route.element ? match.route.element : outlet;\n          return React__namespace.createElement(RenderedRoute, {match, routeContext:{outlet, matches, isDataRoute:null != dataRouterState}, children});\n        };\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || 0 === index) ? React__namespace.createElement(RenderErrorBoundary, {location:dataRouterState.location, revalidation:dataRouterState.revalidation, component:errorElement, error, children:getChildren(), routeContext:{outlet:null, matches, isDataRoute:!0}}) : getChildren();\n      }, null);\n    }\n    function getDataRouterConsoleError(hookName) {\n      return hookName + \" must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.\";\n    }\n    function useDataRouterContext(hookName) {\n      let ctx = React__namespace.useContext(DataRouterContext);\n      ctx || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));\n      return ctx;\n    }\n    function useDataRouterState(hookName) {\n      let state = React__namespace.useContext(DataRouterStateContext);\n      state || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));\n      return state;\n    }\n    function useCurrentRouteId(hookName) {\n      var route = React__namespace.useContext(RouteContext);\n      route || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));\n      route = route.matches[route.matches.length - 1];\n      route.route.id || router.UNSAFE_invariant(!1, hookName + ' can only be used on routes that contain a unique \"id\"');\n      return route.route.id;\n    }\n    function useRouteError() {\n      var _state$errors;\n      let error = React__namespace.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook.UseRouteError), routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n      return void 0 !== error ? error : null == (_state$errors = state.errors) ? void 0 : _state$errors[routeId];\n    }\n    function useAsyncValue() {\n      let value = React__namespace.useContext(AwaitContext);\n      return null == value ? void 0 : value._data;\n    }\n    function useNavigateStable() {\n      let {router:router$1} = useDataRouterContext(DataRouterHook.UseNavigateStable), id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable), activeRef = React__namespace.useRef(!1);\n      useIsomorphicLayoutEffect(() => {\n        activeRef.current = !0;\n      });\n      return React__namespace.useCallback(function(to, options) {\n        void 0 === options && (options = {});\n        router.UNSAFE_warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\");\n        activeRef.current && (\"number\" === typeof to ? router$1.navigate(to) : router$1.navigate(to, _extends({fromRouteId:id}, options)));\n      }, [router$1, id]);\n    }\n    function warningOnce(key, cond, message) {\n      cond || alreadyWarned$1[key] || (alreadyWarned$1[key] = !0, router.UNSAFE_warning(!1, message));\n    }\n    function logV6DeprecationWarnings(renderFuture, routerFuture) {\n      void 0 === (null == renderFuture ? void 0 : renderFuture.v7_startTransition) && logDeprecation(\"v7_startTransition\", \"React Router will begin wrapping state updates in `React.startTransition` in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_starttransition\");\n      void 0 !== (null == renderFuture ? void 0 : renderFuture.v7_relativeSplatPath) || routerFuture && routerFuture.v7_relativeSplatPath || logDeprecation(\"v7_relativeSplatPath\", \"Relative route resolution within Splat routes is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath\");\n      routerFuture && (void 0 === routerFuture.v7_fetcherPersist && logDeprecation(\"v7_fetcherPersist\", \"The persistence behavior of fetchers is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist\"), void 0 === routerFuture.v7_normalizeFormMethod && logDeprecation(\"v7_normalizeFormMethod\", \"Casing of `formMethod` fields is being normalized to uppercase in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod\"), void 0 === routerFuture.v7_partialHydration && \n      logDeprecation(\"v7_partialHydration\", \"`RouterProvider` hydration behavior is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_partialhydration\"), void 0 === routerFuture.v7_skipActionErrorRevalidation && logDeprecation(\"v7_skipActionErrorRevalidation\", \"The revalidation behavior after 4xx/5xx `action` responses is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation\"));\n    }\n    function DataRoutes(_ref2) {\n      let {routes, future, state} = _ref2;\n      return useRoutesImpl(routes, void 0, state, future);\n    }\n    function Route(_props) {\n      router.UNSAFE_invariant(!1, \"A \\x3cRoute\\x3e is only ever to be used as the child of \\x3cRoutes\\x3e element, never rendered directly. Please wrap your \\x3cRoute\\x3e in a \\x3cRoutes\\x3e.\");\n    }\n    function Router(_ref5) {\n      let {basename:basenameProp = \"/\", children = null, location:locationProp, navigationType = router.Action.Pop, navigator, static:staticProp = !1, future} = _ref5;\n      useInRouterContext() && router.UNSAFE_invariant(!1, \"You cannot render a \\x3cRouter\\x3e inside another \\x3cRouter\\x3e. You should never have more than one in your app.\");\n      let basename = basenameProp.replace(/^\\/*/, \"/\");\n      _ref5 = React__namespace.useMemo(() => ({basename, navigator, static:staticProp, future:_extends({v7_relativeSplatPath:!1}, future)}), [basename, future, navigator, staticProp]);\n      \"string\" === typeof locationProp && (locationProp = router.parsePath(locationProp));\n      let {pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\"} = locationProp, locationContext = React__namespace.useMemo(() => {\n        let trailingPathname = router.stripBasename(pathname, basename);\n        return null == trailingPathname ? null : {location:{pathname:trailingPathname, search, hash, state, key}, navigationType};\n      }, [basename, pathname, search, hash, state, key, navigationType]);\n      router.UNSAFE_warning(null != locationContext, '\\x3cRouter basename\\x3d\"' + basename + '\"\\x3e is not able to match the URL ' + ('\"' + pathname + search + hash + \"\\\" because it does not start with the basename, so the \\x3cRouter\\x3e won't render anything.\"));\n      return null == locationContext ? null : React__namespace.createElement(NavigationContext.Provider, {value:_ref5}, React__namespace.createElement(LocationContext.Provider, {children, value:locationContext}));\n    }\n    function ResolveAwait(_ref8) {\n      ({children:_ref8} = _ref8);\n      let data = useAsyncValue();\n      _ref8 = \"function\" === typeof _ref8 ? _ref8(data) : _ref8;\n      return React__namespace.createElement(React__namespace.Fragment, null, _ref8);\n    }\n    function createRoutesFromChildren(children, parentPath) {\n      void 0 === parentPath && (parentPath = []);\n      let routes = [];\n      React__namespace.Children.forEach(children, (element, index) => {\n        if (React__namespace.isValidElement(element)) {\n          if (index = [...parentPath, index], element.type === React__namespace.Fragment) {\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, index));\n          } else {\n            element.type !== Route && router.UNSAFE_invariant(!1, \"[\" + (\"string\" === typeof element.type ? element.type : element.type.name) + \"] is not a \\x3cRoute\\x3e component. All component children of \\x3cRoutes\\x3e must be a \\x3cRoute\\x3e or \\x3cReact.Fragment\\x3e\");\n            element.props.index && element.props.children && router.UNSAFE_invariant(!1, \"An index route cannot have child routes.\");\n            var route = {id:element.props.id || index.join(\"-\"), caseSensitive:element.props.caseSensitive, element:element.props.element, Component:element.props.Component, index:element.props.index, path:element.props.path, loader:element.props.loader, action:element.props.action, errorElement:element.props.errorElement, ErrorBoundary:element.props.ErrorBoundary, hasErrorBoundary:null != element.props.ErrorBoundary || null != element.props.errorElement, shouldRevalidate:element.props.shouldRevalidate, \n            handle:element.props.handle, lazy:element.props.lazy};\n            element.props.children && (route.children = createRoutesFromChildren(element.props.children, index));\n            routes.push(route);\n          }\n        }\n      });\n      return routes;\n    }\n    function mapRouteProperties(route) {\n      let updates = {hasErrorBoundary:null != route.ErrorBoundary || null != route.errorElement};\n      route.Component && (route.element && router.UNSAFE_warning(!1, \"You should not include both `Component` and `element` on your route - `Component` will be used.\"), Object.assign(updates, {element:React__namespace.createElement(route.Component), Component:void 0}));\n      route.HydrateFallback && (route.hydrateFallbackElement && router.UNSAFE_warning(!1, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\"), Object.assign(updates, {hydrateFallbackElement:React__namespace.createElement(route.HydrateFallback), HydrateFallback:void 0}));\n      route.ErrorBoundary && (route.errorElement && router.UNSAFE_warning(!1, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\"), Object.assign(updates, {errorElement:React__namespace.createElement(route.ErrorBoundary), ErrorBoundary:void 0}));\n      return updates;\n    }\n    var React__namespace = function(e) {\n      if (e && e.__esModule) {\n        return e;\n      }\n      var n = Object.create(null);\n      e && Object.keys(e).forEach(function(k) {\n        if (\"default\" !== k) {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {enumerable:!0, get:function() {\n            return e[k];\n          }});\n        }\n      });\n      n[\"default\"] = e;\n      return Object.freeze(n);\n    }(React);\n    const DataRouterContext = React__namespace.createContext(null);\n    DataRouterContext.displayName = \"DataRouter\";\n    const DataRouterStateContext = React__namespace.createContext(null);\n    DataRouterStateContext.displayName = \"DataRouterState\";\n    const AwaitContext = React__namespace.createContext(null);\n    AwaitContext.displayName = \"Await\";\n    const NavigationContext = React__namespace.createContext(null);\n    NavigationContext.displayName = \"Navigation\";\n    const LocationContext = React__namespace.createContext(null);\n    LocationContext.displayName = \"Location\";\n    const RouteContext = React__namespace.createContext({outlet:null, matches:[], isDataRoute:!1});\n    RouteContext.displayName = \"Route\";\n    const RouteErrorContext = React__namespace.createContext(null);\n    RouteErrorContext.displayName = \"RouteError\";\n    const OutletContext = React__namespace.createContext(null), defaultErrorElement = React__namespace.createElement(function() {\n      var error = useRouteError();\n      let message = router.isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error), stack = error instanceof Error ? error.stack : null, preStyles = {padding:\"0.5rem\", backgroundColor:\"rgba(200,200,200, 0.5)\"}, codeStyles = {padding:\"2px 4px\", backgroundColor:\"rgba(200,200,200, 0.5)\"};\n      console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n      error = React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"p\", null, \"\\ud83d\\udcbf Hey developer \\ud83d\\udc4b\"), React__namespace.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", React__namespace.createElement(\"code\", {style:codeStyles}, \"ErrorBoundary\"), \" or\", \" \", React__namespace.createElement(\"code\", {style:codeStyles}, \"errorElement\"), \" prop on your route.\"));\n      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"h2\", null, \"Unexpected Application Error!\"), React__namespace.createElement(\"h3\", {style:{fontStyle:\"italic\"}}, message), stack ? React__namespace.createElement(\"pre\", {style:preStyles}, stack) : null, error);\n    }, null);\n    class RenderErrorBoundary extends React__namespace.Component {\n      constructor(props) {\n        super(props);\n        this.state = {location:props.location, revalidation:props.revalidation, error:props.error};\n      }\n      static getDerivedStateFromError(error) {\n        return {error};\n      }\n      static getDerivedStateFromProps(props, state) {\n        return state.location !== props.location || \"idle\" !== state.revalidation && \"idle\" === props.revalidation ? {error:props.error, location:props.location, revalidation:props.revalidation} : {error:void 0 !== props.error ? props.error : state.error, location:state.location, revalidation:props.revalidation || state.revalidation};\n      }\n      componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n      }\n      render() {\n        return void 0 !== this.state.error ? React__namespace.createElement(RouteContext.Provider, {value:this.props.routeContext}, React__namespace.createElement(RouteErrorContext.Provider, {value:this.state.error, children:this.props.component})) : this.props.children;\n      }\n    }\n    var DataRouterHook = function(DataRouterHook) {\n      DataRouterHook.UseBlocker = \"useBlocker\";\n      DataRouterHook.UseRevalidator = \"useRevalidator\";\n      DataRouterHook.UseNavigateStable = \"useNavigate\";\n      return DataRouterHook;\n    }(DataRouterHook || {}), DataRouterStateHook = function(DataRouterStateHook) {\n      DataRouterStateHook.UseBlocker = \"useBlocker\";\n      DataRouterStateHook.UseLoaderData = \"useLoaderData\";\n      DataRouterStateHook.UseActionData = \"useActionData\";\n      DataRouterStateHook.UseRouteError = \"useRouteError\";\n      DataRouterStateHook.UseNavigation = \"useNavigation\";\n      DataRouterStateHook.UseRouteLoaderData = \"useRouteLoaderData\";\n      DataRouterStateHook.UseMatches = \"useMatches\";\n      DataRouterStateHook.UseRevalidator = \"useRevalidator\";\n      DataRouterStateHook.UseNavigateStable = \"useNavigate\";\n      DataRouterStateHook.UseRouteId = \"useRouteId\";\n      return DataRouterStateHook;\n    }(DataRouterStateHook || {});\n    let blockerId = 0;\n    const alreadyWarned$1 = {}, alreadyWarned = {}, logDeprecation = (flag, msg, link) => {\n      flag = \"⚠️ React Router Future Flag Warning: \" + msg + \". You can use the `\" + (flag + \"` future flag to opt-in early. For more information, see \") + (link + \".\");\n      alreadyWarned[flag] || (alreadyWarned[flag] = !0, console.warn(flag));\n    }, startTransitionImpl = React__namespace.startTransition;\n    var AwaitRenderStatus = function(AwaitRenderStatus) {\n      AwaitRenderStatus[AwaitRenderStatus.pending = 0] = \"pending\";\n      AwaitRenderStatus[AwaitRenderStatus.success = 1] = \"success\";\n      AwaitRenderStatus[AwaitRenderStatus.error = 2] = \"error\";\n      return AwaitRenderStatus;\n    }(AwaitRenderStatus || {});\n    const neverSettledPromise = new Promise(() => {\n    });\n    class AwaitErrorBoundary extends React__namespace.Component {\n      constructor(props) {\n        super(props);\n        this.state = {error:null};\n      }\n      static getDerivedStateFromError(error) {\n        return {error};\n      }\n      componentDidCatch(error, errorInfo) {\n        console.error(\"\\x3cAwait\\x3e caught the following error during render\", error, errorInfo);\n      }\n      render() {\n        let {children, errorElement, resolve} = this.props, promise = null, status = AwaitRenderStatus.pending;\n        if (resolve instanceof Promise) {\n          if (this.state.error) {\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(() => {\n            });\n            Object.defineProperty(promise, \"_tracked\", {get:() => !0});\n            Object.defineProperty(promise, \"_error\", {get:() => renderError});\n          } else {\n            resolve._tracked ? (promise = resolve, status = \"_error\" in promise ? AwaitRenderStatus.error : \"_data\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (status = AwaitRenderStatus.pending, Object.defineProperty(resolve, \"_tracked\", {get:() => !0}), promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {get:() => data}), error => Object.defineProperty(resolve, \"_error\", {get:() => error})));\n          }\n        } else {\n          status = AwaitRenderStatus.success, promise = Promise.resolve(), Object.defineProperty(promise, \"_tracked\", {get:() => !0}), Object.defineProperty(promise, \"_data\", {get:() => resolve});\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {\n          throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n          throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n          return React__namespace.createElement(AwaitContext.Provider, {value:promise, children:errorElement});\n        }\n        if (status === AwaitRenderStatus.success) {\n          return React__namespace.createElement(AwaitContext.Provider, {value:promise, children});\n        }\n        throw promise;\n      }\n    }\n    Object.defineProperty(exports, \"AbortedDeferredError\", {enumerable:!0, get:function() {\n      return router.AbortedDeferredError;\n    }});\n    Object.defineProperty(exports, \"NavigationType\", {enumerable:!0, get:function() {\n      return router.Action;\n    }});\n    Object.defineProperty(exports, \"createPath\", {enumerable:!0, get:function() {\n      return router.createPath;\n    }});\n    Object.defineProperty(exports, \"defer\", {enumerable:!0, get:function() {\n      return router.defer;\n    }});\n    Object.defineProperty(exports, \"generatePath\", {enumerable:!0, get:function() {\n      return router.generatePath;\n    }});\n    Object.defineProperty(exports, \"isRouteErrorResponse\", {enumerable:!0, get:function() {\n      return router.isRouteErrorResponse;\n    }});\n    Object.defineProperty(exports, \"json\", {enumerable:!0, get:function() {\n      return router.json;\n    }});\n    Object.defineProperty(exports, \"matchPath\", {enumerable:!0, get:function() {\n      return router.matchPath;\n    }});\n    Object.defineProperty(exports, \"matchRoutes\", {enumerable:!0, get:function() {\n      return router.matchRoutes;\n    }});\n    Object.defineProperty(exports, \"parsePath\", {enumerable:!0, get:function() {\n      return router.parsePath;\n    }});\n    Object.defineProperty(exports, \"redirect\", {enumerable:!0, get:function() {\n      return router.redirect;\n    }});\n    Object.defineProperty(exports, \"redirectDocument\", {enumerable:!0, get:function() {\n      return router.redirectDocument;\n    }});\n    Object.defineProperty(exports, \"replace\", {enumerable:!0, get:function() {\n      return router.replace;\n    }});\n    Object.defineProperty(exports, \"resolvePath\", {enumerable:!0, get:function() {\n      return router.resolvePath;\n    }});\n    exports.Await = function(_ref7) {\n      let {children, errorElement, resolve} = _ref7;\n      return React__namespace.createElement(AwaitErrorBoundary, {resolve, errorElement}, React__namespace.createElement(ResolveAwait, null, children));\n    };\n    exports.MemoryRouter = function(_ref3) {\n      let {basename, children, initialEntries, initialIndex, future} = _ref3;\n      _ref3 = React__namespace.useRef();\n      null == _ref3.current && (_ref3.current = router.createMemoryHistory({initialEntries, initialIndex, v5Compat:!0}));\n      let history = _ref3.current, [state, setStateImpl] = React__namespace.useState({action:history.action, location:history.location}), {v7_startTransition} = future || {}, setState = React__namespace.useCallback(newState => {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n      }, [setStateImpl, v7_startTransition]);\n      React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n      React__namespace.useEffect(() => logV6DeprecationWarnings(future), [future]);\n      return React__namespace.createElement(Router, {basename, children, location:state.location, navigationType:state.action, navigator:history, future});\n    };\n    exports.Navigate = function(_ref4) {\n      let {to, replace, state, relative} = _ref4;\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"\\x3cNavigate\\x3e may be used only in the context of a \\x3cRouter\\x3e component.\");\n      let {future, static:isStatic} = React__namespace.useContext(NavigationContext);\n      router.UNSAFE_warning(!isStatic, \"\\x3cNavigate\\x3e must not be used on the initial render in a \\x3cStaticRouter\\x3e. This is a no-op, but you should modify your code so the \\x3cNavigate\\x3e is only ever rendered in response to some user interaction or state change.\");\n      ({matches:_ref4} = React__namespace.useContext(RouteContext));\n      let {pathname:locationPathname} = useLocation(), navigate = useNavigate();\n      _ref4 = router.resolveTo(to, router.UNSAFE_getResolveToMatches(_ref4, future.v7_relativeSplatPath), locationPathname, \"path\" === relative);\n      let jsonPath = JSON.stringify(_ref4);\n      React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {replace, state, relative}), [navigate, jsonPath, relative, replace, state]);\n      return null;\n    };\n    exports.Outlet = function(props) {\n      return useOutlet(props.context);\n    };\n    exports.Route = Route;\n    exports.Router = Router;\n    exports.RouterProvider = function(_ref) {\n      let {fallbackElement, router:router$1, future} = _ref, [state, setStateImpl] = React__namespace.useState(router$1.state), {v7_startTransition} = future || {}, setState = React__namespace.useCallback(newState => {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n      }, [setStateImpl, v7_startTransition]);\n      React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);\n      React__namespace.useEffect(() => {\n        router.UNSAFE_warning(null == fallbackElement || !router$1.future.v7_partialHydration, \"`\\x3cRouterProvider fallbackElement\\x3e` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead\");\n      }, []);\n      let navigator = React__namespace.useMemo(() => ({createHref:router$1.createHref, encodeLocation:router$1.encodeLocation, go:n => router$1.navigate(n), push:(to, state, opts) => router$1.navigate(to, {state, preventScrollReset:null == opts ? void 0 : opts.preventScrollReset}), replace:(to, state, opts) => router$1.navigate(to, {replace:!0, state, preventScrollReset:null == opts ? void 0 : opts.preventScrollReset})}), [router$1]), basename = router$1.basename || \"/\";\n      _ref = React__namespace.useMemo(() => ({router:router$1, navigator, static:!1, basename}), [router$1, navigator, basename]);\n      React__namespace.useEffect(() => logV6DeprecationWarnings(future, router$1.future), [router$1, future]);\n      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(DataRouterContext.Provider, {value:_ref}, React__namespace.createElement(DataRouterStateContext.Provider, {value:state}, React__namespace.createElement(Router, {basename, location:state.location, navigationType:state.historyAction, navigator, future:{v7_relativeSplatPath:router$1.future.v7_relativeSplatPath}}, state.initialized || router$1.future.v7_partialHydration ? React__namespace.createElement(DataRoutes, \n      {routes:router$1.routes, future:router$1.future, state}) : fallbackElement))), null);\n    };\n    exports.Routes = function(_ref6) {\n      let {children, location} = _ref6;\n      return useRoutes(createRoutesFromChildren(children), location);\n    };\n    exports.UNSAFE_DataRouterContext = DataRouterContext;\n    exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\n    exports.UNSAFE_LocationContext = LocationContext;\n    exports.UNSAFE_NavigationContext = NavigationContext;\n    exports.UNSAFE_RouteContext = RouteContext;\n    exports.UNSAFE_logV6DeprecationWarnings = logV6DeprecationWarnings;\n    exports.UNSAFE_mapRouteProperties = mapRouteProperties;\n    exports.UNSAFE_useRouteId = function() {\n      return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n    };\n    exports.UNSAFE_useRoutesImpl = useRoutesImpl;\n    exports.createMemoryRouter = function(routes, opts) {\n      return router.createRouter({basename:null == opts ? void 0 : opts.basename, future:_extends({}, null == opts ? void 0 : opts.future, {v7_prependBasename:!0}), history:router.createMemoryHistory({initialEntries:null == opts ? void 0 : opts.initialEntries, initialIndex:null == opts ? void 0 : opts.initialIndex}), hydrationData:null == opts ? void 0 : opts.hydrationData, routes, mapRouteProperties, dataStrategy:null == opts ? void 0 : opts.dataStrategy, patchRoutesOnNavigation:null == opts ? void 0 : \n      opts.patchRoutesOnNavigation}).initialize();\n    };\n    exports.createRoutesFromChildren = createRoutesFromChildren;\n    exports.createRoutesFromElements = createRoutesFromChildren;\n    exports.renderMatches = function(matches) {\n      return _renderMatches(matches);\n    };\n    exports.useActionData = function() {\n      let state = useDataRouterState(DataRouterStateHook.UseActionData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n      return state.actionData ? state.actionData[routeId] : void 0;\n    };\n    exports.useAsyncError = function() {\n      let value = React__namespace.useContext(AwaitContext);\n      return null == value ? void 0 : value._error;\n    };\n    exports.useAsyncValue = useAsyncValue;\n    exports.useBlocker = function(shouldBlock) {\n      let {router:router$1, basename} = useDataRouterContext(DataRouterHook.UseBlocker), state = useDataRouterState(DataRouterStateHook.UseBlocker), [blockerKey, setBlockerKey] = React__namespace.useState(\"\"), blockerFunction = React__namespace.useCallback(arg => {\n        if (\"function\" !== typeof shouldBlock) {\n          return !!shouldBlock;\n        }\n        if (\"/\" === basename) {\n          return shouldBlock(arg);\n        }\n        let {currentLocation, nextLocation, historyAction} = arg;\n        return shouldBlock({currentLocation:_extends({}, currentLocation, {pathname:router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname}), nextLocation:_extends({}, nextLocation, {pathname:router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname}), historyAction});\n      }, [basename, shouldBlock]);\n      React__namespace.useEffect(() => {\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return () => router$1.deleteBlocker(key);\n      }, [router$1]);\n      React__namespace.useEffect(() => {\n        \"\" !== blockerKey && router$1.getBlocker(blockerKey, blockerFunction);\n      }, [router$1, blockerKey, blockerFunction]);\n      return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;\n    };\n    exports.useHref = function(to, _temp) {\n      ({relative:_temp} = void 0 === _temp ? {} : _temp);\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"useHref() may be used only in the context of a \\x3cRouter\\x3e component.\");\n      let {basename, navigator} = React__namespace.useContext(NavigationContext), {hash, pathname, search} = useResolvedPath(to, {relative:_temp});\n      to = pathname;\n      \"/\" !== basename && (to = \"/\" === pathname ? basename : router.joinPaths([basename, pathname]));\n      return navigator.createHref({pathname:to, search, hash});\n    };\n    exports.useInRouterContext = useInRouterContext;\n    exports.useLoaderData = function() {\n      let state = useDataRouterState(DataRouterStateHook.UseLoaderData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n      if (state.errors && null != state.errors[routeId]) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n      } else {\n        return state.loaderData[routeId];\n      }\n    };\n    exports.useLocation = useLocation;\n    exports.useMatch = function(pattern) {\n      useInRouterContext() || router.UNSAFE_invariant(!1, \"useMatch() may be used only in the context of a \\x3cRouter\\x3e component.\");\n      let {pathname} = useLocation();\n      return React__namespace.useMemo(() => router.matchPath(pattern, router.UNSAFE_decodePath(pathname)), [pathname, pattern]);\n    };\n    exports.useMatches = function() {\n      let {matches, loaderData} = useDataRouterState(DataRouterStateHook.UseMatches);\n      return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n    };\n    exports.useNavigate = useNavigate;\n    exports.useNavigation = function() {\n      return useDataRouterState(DataRouterStateHook.UseNavigation).navigation;\n    };\n    exports.useNavigationType = function() {\n      return React__namespace.useContext(LocationContext).navigationType;\n    };\n    exports.useOutlet = useOutlet;\n    exports.useOutletContext = function() {\n      return React__namespace.useContext(OutletContext);\n    };\n    exports.useParams = function() {\n      var {matches} = React__namespace.useContext(RouteContext);\n      return (matches = matches[matches.length - 1]) ? matches.params : {};\n    };\n    exports.useResolvedPath = useResolvedPath;\n    exports.useRevalidator = function() {\n      let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator), state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n      return React__namespace.useMemo(() => ({revalidate:dataRouterContext.router.revalidate, state:state.revalidation}), [dataRouterContext.router.revalidate, state.revalidation]);\n    };\n    exports.useRouteError = useRouteError;\n    exports.useRouteLoaderData = function(routeId) {\n      return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId];\n    };\n    exports.useRoutes = useRoutes;\n    Object.defineProperty(exports, \"__esModule\", {value:!0});\n  });\n};\n","~:source","shadow$provide[\"module$node_modules$react_router$dist$umd$react_router_development\"] = function(global,require,module,exports) {\n/**\n * React Router v6.30.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@remix-run/router')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'react', '@remix-run/router'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouter = {}, global.React, global.RemixRouter));\n})(this, (function (exports, React, router) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  // Create react-specific types from the agnostic types in @remix-run/router to\n  // export from react-router\n  const DataRouterContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterContext.displayName = \"DataRouter\";\n  }\n  const DataRouterStateContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n  }\n  const AwaitContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    AwaitContext.displayName = \"Await\";\n  }\n\n  /**\n   * A Navigator is a \"location changer\"; it's how you get to different locations.\n   *\n   * Every history instance conforms to the Navigator interface, but the\n   * distinction is useful primarily when it comes to the low-level `<Router>` API\n   * where both the location and a navigator must be provided separately in order\n   * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n   * and/or location were to be read directly from the history instance.\n   */\n\n  const NavigationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    NavigationContext.displayName = \"Navigation\";\n  }\n  const LocationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    LocationContext.displayName = \"Location\";\n  }\n  const RouteContext = /*#__PURE__*/React__namespace.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n  });\n  {\n    RouteContext.displayName = \"Route\";\n  }\n  const RouteErrorContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    RouteErrorContext.displayName = \"RouteError\";\n  }\n\n  /**\n   * Returns the full href for the given \"to\" value. This is useful for building\n   * custom links that are also accessible and preserve right-click behavior.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-href\n   */\n  function useHref(to, _temp) {\n    let {\n      relative\n    } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      basename,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      hash,\n      pathname,\n      search\n    } = useResolvedPath(to, {\n      relative\n    });\n    let joinedPathname = pathname;\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n      joinedPathname = pathname === \"/\" ? basename : router.joinPaths([basename, pathname]);\n    }\n    return navigator.createHref({\n      pathname: joinedPathname,\n      search,\n      hash\n    });\n  }\n\n  /**\n   * Returns true if this component is a descendant of a `<Router>`.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-in-router-context\n   */\n  function useInRouterContext() {\n    return React__namespace.useContext(LocationContext) != null;\n  }\n\n  /**\n   * Returns the current location object, which represents the current URL in web\n   * browsers.\n   *\n   * Note: If you're using this it may mean you're doing some of your own\n   * \"routing\" in your app, and we'd like to know what your use case is. We may\n   * be able to provide something higher-level to better suit your needs.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-location\n   */\n  function useLocation() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\")  : void 0;\n    return React__namespace.useContext(LocationContext).location;\n  }\n\n  /**\n   * Returns the current navigation action which describes how the router came to\n   * the current location, either by a pop, push, or replace on the history stack.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-navigation-type\n   */\n  function useNavigationType() {\n    return React__namespace.useContext(LocationContext).navigationType;\n  }\n\n  /**\n   * Returns a PathMatch object if the given pattern matches the current URL.\n   * This is useful for components that need to know \"active\" state, e.g.\n   * `<NavLink>`.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-match\n   */\n  function useMatch(pattern) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      pathname\n    } = useLocation();\n    return React__namespace.useMemo(() => router.matchPath(pattern, router.UNSAFE_decodePath(pathname)), [pathname, pattern]);\n  }\n\n  /**\n   * The interface for the navigate() function returned from useNavigate().\n   */\n\n  const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n  // Mute warnings for calls to useNavigate in SSR environments\n  function useIsomorphicLayoutEffect(cb) {\n    let isStatic = React__namespace.useContext(NavigationContext).static;\n    if (!isStatic) {\n      // We should be able to get rid of this once react 18.3 is released\n      // See: https://github.com/facebook/react/pull/26395\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(cb);\n    }\n  }\n\n  /**\n   * Returns an imperative method for changing the location. Used by `<Link>`s, but\n   * may also be used by other elements to change the location.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-navigate\n   */\n  function useNavigate() {\n    let {\n      isDataRoute\n    } = React__namespace.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n  }\n  function useNavigateUnstable() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\")  : void 0;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n    let {\n      basename,\n      future,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our history listener yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n      let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history (but only if we're not in a data router,\n      // otherwise it'll prepend the basename inside of the router).\n      // If this is a root navigation, then we navigate to the raw basename\n      // which allows the basename to have full control over the presence of a\n      // trailing slash on root links\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : router.joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n    return navigate;\n  }\n  const OutletContext = /*#__PURE__*/React__namespace.createContext(null);\n\n  /**\n   * Returns the context (if provided) for the child route at this level of the route\n   * hierarchy.\n   * @see https://reactrouter.com/v6/hooks/use-outlet-context\n   */\n  function useOutletContext() {\n    return React__namespace.useContext(OutletContext);\n  }\n\n  /**\n   * Returns the element for the child route at this level of the route\n   * hierarchy. Used internally by `<Outlet>` to render child routes.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-outlet\n   */\n  function useOutlet(context) {\n    let outlet = React__namespace.useContext(RouteContext).outlet;\n    if (outlet) {\n      return /*#__PURE__*/React__namespace.createElement(OutletContext.Provider, {\n        value: context\n      }, outlet);\n    }\n    return outlet;\n  }\n\n  /**\n   * Returns an object of key/value pairs of the dynamic params from the current\n   * URL that were matched by the route path.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-params\n   */\n  function useParams() {\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n  }\n\n  /**\n   * Resolves the pathname of the given `to` value against the current location.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-resolved-path\n   */\n  function useResolvedPath(to, _temp2) {\n    let {\n      relative\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      future\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n    return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n  }\n\n  /**\n   * Returns the element of the route that matched the current location, prepared\n   * with the correct context to render the remainder of the route tree. Route\n   * elements in the tree must render an `<Outlet>` to render their child route's\n   * element.\n   *\n   * @see https://reactrouter.com/v6/hooks/use-routes\n   */\n  function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n  }\n\n  // Internal implementation with accept optional param for RouterProvider usage\n  function useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      navigator,\n      static: isStatic\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches: parentMatches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    {\n      // You won't get a warning about 2 different <Routes> under a <Route>\n      // without a trailing *, but this is a best-effort warning anyway since we\n      // cannot even give the warning unless they land at the parent route.\n      //\n      // Example:\n      //\n      // <Routes>\n      //   {/* This route path MUST end with /* because otherwise\n      //       it will never match /blog/post/123 */}\n      //   <Route path=\"blog\" element={<Blog />} />\n      //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n      // </Routes>\n      //\n      // function Blog() {\n      //   return (\n      //     <Routes>\n      //       <Route path=\"post/:id\" element={<Post />} />\n      //     </Routes>\n      //   );\n      // }\n      let parentPath = parentRoute && parentRoute.path || \"\";\n      warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n      var _parsedLocationArg$pa;\n      let parsedLocationArg = typeof locationArg === \"string\" ? router.parsePath(locationArg) : locationArg;\n      !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? router.UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\"))  : void 0;\n      location = parsedLocationArg;\n    } else {\n      location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = pathname;\n    if (parentPathnameBase !== \"/\") {\n      // Determine the remaining pathname by removing the # of URL segments the\n      // parentPathnameBase has, instead of removing based on character count.\n      // This is because we can't guarantee that incoming/outgoing encodings/\n      // decodings will match exactly.\n      // We decode paths before matching on a per-segment basis with\n      // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\n      // match what `window.location.pathname` would reflect.  Those don't 100%\n      // align when it comes to encoded URI characters such as % and &.\n      //\n      // So we may end up with:\n      //   pathname:           \"/descendant/a%25b/match\"\n      //   parentPathnameBase: \"/descendant/a%b\"\n      //\n      // And the direct substring removal approach won't work :/\n      let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n      let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n      remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n    }\n    let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : router.matchRoutes(routes, {\n      pathname: remainingPathname\n    });\n    {\n      router.UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") ;\n      router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") ;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n      params: Object.assign({}, parentParams, match.params),\n      pathname: router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n      pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n    })), parentMatches, dataRouterState, future);\n\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n      return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n        value: {\n          location: _extends({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\"\n          }, location),\n          navigationType: router.Action.Pop\n        }\n      }, renderedMatches);\n    }\n    return renderedMatches;\n  }\n  function DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = router.isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n      padding: \"0.5rem\",\n      backgroundColor: lightgrey\n    };\n    let codeStyles = {\n      padding: \"2px 4px\",\n      backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    {\n      console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n      devInfo = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React__namespace.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React__namespace.createElement(\"h3\", {\n      style: {\n        fontStyle: \"italic\"\n      }\n    }, message), stack ? /*#__PURE__*/React__namespace.createElement(\"pre\", {\n      style: preStyles\n    }, stack) : null, devInfo);\n  }\n  const defaultErrorElement = /*#__PURE__*/React__namespace.createElement(DefaultErrorComponent, null);\n  class RenderErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        location: props.location,\n        revalidation: props.revalidation,\n        error: props.error\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n    static getDerivedStateFromProps(props, state) {\n      // When we get into an error state, the user will likely click \"back\" to the\n      // previous page that didn't have an error. Because this wraps the entire\n      // application, that will have no effect--the error page continues to display.\n      // This gives us a mechanism to recover from the error when the location changes.\n      //\n      // Whether we're in an error state or not, we update the location in state\n      // so that when we are in an error state, it gets reset when a new location\n      // comes in and the user recovers from the error.\n      if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n        return {\n          error: props.error,\n          location: props.location,\n          revalidation: props.revalidation\n        };\n      }\n\n      // If we're not changing locations, preserve the location but still surface\n      // any new errors that may come through. We retain the existing error, we do\n      // this because the error provided from the app state may be cleared without\n      // the location changing.\n      return {\n        error: props.error !== undefined ? props.error : state.error,\n        location: state.location,\n        revalidation: props.revalidation || state.revalidation\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      return this.state.error !== undefined ? /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n        value: this.props.routeContext\n      }, /*#__PURE__*/React__namespace.createElement(RouteErrorContext.Provider, {\n        value: this.state.error,\n        children: this.props.component\n      })) : this.props.children;\n    }\n  }\n  function RenderedRoute(_ref) {\n    let {\n      routeContext,\n      match,\n      children\n    } = _ref;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n      value: routeContext\n    }, children);\n  }\n  function _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState;\n    if (parentMatches === void 0) {\n      parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n      dataRouterState = null;\n    }\n    if (future === void 0) {\n      future = null;\n    }\n    if (matches == null) {\n      var _future;\n      if (!dataRouterState) {\n        return null;\n      }\n      if (dataRouterState.errors) {\n        // Don't bail if we have data router errors so we can render them in the\n        // boundary.  Use the pre-matched (or shimmed) matches\n        matches = dataRouterState.matches;\n      } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n        // Don't bail if we're initializing with partial hydration and we have\n        // router matches.  That means we're actively running `patchRoutesOnNavigation`\n        // so we should render down the partial matches to the appropriate\n        // `HydrateFallback`.  We only do this if `parentMatches` is empty so it\n        // only impacts the root matches for `RouterProvider` and no descendant\n        // `<Routes>`\n        matches = dataRouterState.matches;\n      } else {\n        return null;\n      }\n    }\n    let renderedMatches = matches;\n\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;\n    if (errors != null) {\n      let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);\n      !(errorIndex >= 0) ? router.UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\"))  : void 0;\n      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n      for (let i = 0; i < renderedMatches.length; i++) {\n        let match = renderedMatches[i];\n        // Track the deepest fallback up until the first route without data\n        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n          fallbackIndex = i;\n        }\n        if (match.route.id) {\n          let {\n            loaderData,\n            errors\n          } = dataRouterState;\n          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n          if (match.route.lazy || needsToRunLoader) {\n            // We found the first route that's not ready to render (waiting on\n            // lazy, or has a loader that hasn't run yet).  Flag that we need to\n            // render a fallback and render up until the appropriate fallback\n            renderFallback = true;\n            if (fallbackIndex >= 0) {\n              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n            } else {\n              renderedMatches = [renderedMatches[0]];\n            }\n            break;\n          }\n        }\n      }\n    }\n    return renderedMatches.reduceRight((outlet, match, index) => {\n      // Only data routers handle errors/fallbacks\n      let error;\n      let shouldRenderHydrateFallback = false;\n      let errorElement = null;\n      let hydrateFallbackElement = null;\n      if (dataRouterState) {\n        error = errors && match.route.id ? errors[match.route.id] : undefined;\n        errorElement = match.route.errorElement || defaultErrorElement;\n        if (renderFallback) {\n          if (fallbackIndex < 0 && index === 0) {\n            warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = null;\n          } else if (fallbackIndex === index) {\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n          }\n        }\n      }\n      let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n      let getChildren = () => {\n        let children;\n        if (error) {\n          children = errorElement;\n        } else if (shouldRenderHydrateFallback) {\n          children = hydrateFallbackElement;\n        } else if (match.route.Component) {\n          // Note: This is a de-optimized path since React won't re-use the\n          // ReactElement since it's identity changes with each new\n          // React.createElement call.  We keep this so folks can use\n          // `<Route Component={...}>` in `<Routes>` but generally `Component`\n          // usage is only advised in `RouterProvider` when we can convert it to\n          // `element` ahead of time.\n          children = /*#__PURE__*/React__namespace.createElement(match.route.Component, null);\n        } else if (match.route.element) {\n          children = match.route.element;\n        } else {\n          children = outlet;\n        }\n        return /*#__PURE__*/React__namespace.createElement(RenderedRoute, {\n          match: match,\n          routeContext: {\n            outlet,\n            matches,\n            isDataRoute: dataRouterState != null\n          },\n          children: children\n        });\n      };\n      // Only wrap in an error boundary within data router usages when we have an\n      // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n      // an ancestor ErrorBoundary/errorElement\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React__namespace.createElement(RenderErrorBoundary, {\n        location: dataRouterState.location,\n        revalidation: dataRouterState.revalidation,\n        component: errorElement,\n        error: error,\n        children: getChildren(),\n        routeContext: {\n          outlet: null,\n          matches,\n          isDataRoute: true\n        }\n      }) : getChildren();\n    }, null);\n  }\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n  }(DataRouterHook || {});\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n  }(DataRouterStateHook || {});\n  function getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.\";\n  }\n  function useDataRouterContext(hookName) {\n    let ctx = React__namespace.useContext(DataRouterContext);\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return ctx;\n  }\n  function useDataRouterState(hookName) {\n    let state = React__namespace.useContext(DataRouterStateContext);\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return state;\n  }\n  function useRouteContext(hookName) {\n    let route = React__namespace.useContext(RouteContext);\n    !route ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return route;\n  }\n\n  // Internal version with hookName-aware debugging\n  function useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ? router.UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\")  : void 0;\n    return thisRoute.route.id;\n  }\n\n  /**\n   * Returns the ID for the nearest contextual route\n   */\n  function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n  }\n\n  /**\n   * Returns the current navigation, defaulting to an \"idle\" navigation when\n   * no navigation is in progress\n   */\n  function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n  }\n\n  /**\n   * Returns a revalidate function for manually triggering revalidation, as well\n   * as the current state of any manual revalidations\n   */\n  function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return React__namespace.useMemo(() => ({\n      revalidate: dataRouterContext.router.revalidate,\n      state: state.revalidation\n    }), [dataRouterContext.router.revalidate, state.revalidation]);\n  }\n\n  /**\n   * Returns the active route matches, useful for accessing loaderData for\n   * parent/child routes or the route \"handle\" property\n   */\n  function useMatches() {\n    let {\n      matches,\n      loaderData\n    } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n  }\n\n  /**\n   * Returns the loader data for the nearest ancestor Route loader\n   */\n  function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n      console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n      return undefined;\n    }\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the loaderData for the given routeId\n   */\n  function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the action data for the nearest ancestor Route action\n   */\n  function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n  }\n\n  /**\n   * Returns the nearest ancestor Route error, which could be a loader/action\n   * error or a render error.  This is intended to be called from your\n   * ErrorBoundary/errorElement to display a proper error message.\n   */\n  function useRouteError() {\n    var _state$errors;\n    let error = React__namespace.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n      return error;\n    }\n\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n  }\n\n  /**\n   * Returns the happy-path data from the nearest ancestor `<Await />` value\n   */\n  function useAsyncValue() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n  }\n\n  /**\n   * Returns the error from the nearest ancestor `<Await />` value\n   */\n  function useAsyncError() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n  }\n  let blockerId = 0;\n\n  /**\n   * Allow the application to block navigations within the SPA and present the\n   * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n   * using half-filled form data.  This does not handle hard-reloads or\n   * cross-origin navigations.\n   */\n  function useBlocker(shouldBlock) {\n    let {\n      router: router$1,\n      basename\n    } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = React__namespace.useState(\"\");\n    let blockerFunction = React__namespace.useCallback(arg => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n\n      // If they provided us a function and we've got an active basename, strip\n      // it from the locations we expose to the user to match the behavior of\n      // useLocation\n      let {\n        currentLocation,\n        nextLocation,\n        historyAction\n      } = arg;\n      return shouldBlock({\n        currentLocation: _extends({}, currentLocation, {\n          pathname: router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        }),\n        nextLocation: _extends({}, nextLocation, {\n          pathname: router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        }),\n        historyAction\n      });\n    }, [basename, shouldBlock]);\n\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    React__namespace.useEffect(() => {\n      let key = String(++blockerId);\n      setBlockerKey(key);\n      return () => router$1.deleteBlocker(key);\n    }, [router$1]);\n\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    React__namespace.useEffect(() => {\n      if (blockerKey !== \"\") {\n        router$1.getBlocker(blockerKey, blockerFunction);\n      }\n    }, [router$1, blockerKey, blockerFunction]);\n\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;\n  }\n\n  /**\n   * Stable version of useNavigate that is used when we are in the context of\n   * a RouterProvider.\n   */\n  function useNavigateStable() {\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our router subscriber yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router$1.navigate(to);\n      } else {\n        router$1.navigate(to, _extends({\n          fromRouteId: id\n        }, options));\n      }\n    }, [router$1, id]);\n    return navigate;\n  }\n  const alreadyWarned$1 = {};\n  function warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned$1[key]) {\n      alreadyWarned$1[key] = true;\n      router.UNSAFE_warning(false, message) ;\n    }\n  }\n\n  const alreadyWarned = {};\n  function warnOnce(key, message) {\n    if (!alreadyWarned[message]) {\n      alreadyWarned[message] = true;\n      console.warn(message);\n    }\n  }\n  const logDeprecation = (flag, msg, link) => warnOnce(flag, \"\\u26A0\\uFE0F React Router Future Flag Warning: \" + msg + \". \" + (\"You can use the `\" + flag + \"` future flag to opt-in early. \") + (\"For more information, see \" + link + \".\"));\n  function logV6DeprecationWarnings(renderFuture, routerFuture) {\n    if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === undefined) {\n      logDeprecation(\"v7_startTransition\", \"React Router will begin wrapping state updates in `React.startTransition` in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_starttransition\");\n    }\n    if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === undefined && (!routerFuture || !routerFuture.v7_relativeSplatPath)) {\n      logDeprecation(\"v7_relativeSplatPath\", \"Relative route resolution within Splat routes is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath\");\n    }\n    if (routerFuture) {\n      if (routerFuture.v7_fetcherPersist === undefined) {\n        logDeprecation(\"v7_fetcherPersist\", \"The persistence behavior of fetchers is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist\");\n      }\n      if (routerFuture.v7_normalizeFormMethod === undefined) {\n        logDeprecation(\"v7_normalizeFormMethod\", \"Casing of `formMethod` fields is being normalized to uppercase in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod\");\n      }\n      if (routerFuture.v7_partialHydration === undefined) {\n        logDeprecation(\"v7_partialHydration\", \"`RouterProvider` hydration behavior is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_partialhydration\");\n      }\n      if (routerFuture.v7_skipActionErrorRevalidation === undefined) {\n        logDeprecation(\"v7_skipActionErrorRevalidation\", \"The revalidation behavior after 4xx/5xx `action` responses is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation\");\n      }\n    }\n  }\n\n  /**\n    Webpack + React 17 fails to compile on any of the following because webpack\n    complains that `startTransition` doesn't exist in `React`:\n    * import { startTransition } from \"react\"\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\n    * import * as React from from \"react\";\n      const START_TRANSITION = \"startTransition\";\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n    However, that introduces webpack/terser minification issues in production builds\n    in React 18 where minification/obfuscation ends up removing the call of\n    React.startTransition entirely from the first half of the ternary.  Grabbing\n    this exported reference once up front resolves that issue.\n\n    See https://github.com/remix-run/react-router/issues/10579\n  */\n  const START_TRANSITION = \"startTransition\";\n  const startTransitionImpl = React__namespace[START_TRANSITION];\n\n  /**\n   * Given a Remix Router instance, render the appropriate UI\n   */\n  function RouterProvider(_ref) {\n    let {\n      fallbackElement,\n      router: router$1,\n      future\n    } = _ref;\n    let [state, setStateImpl] = React__namespace.useState(router$1.state);\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      if (v7_startTransition && startTransitionImpl) {\n        startTransitionImpl(() => setStateImpl(newState));\n      } else {\n        setStateImpl(newState);\n      }\n    }, [setStateImpl, v7_startTransition]);\n\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);\n    React__namespace.useEffect(() => {\n      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") ;\n      // Only log this once on initial mount\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = React__namespace.useMemo(() => {\n      return {\n        createHref: router$1.createHref,\n        encodeLocation: router$1.encodeLocation,\n        go: n => router$1.navigate(n),\n        push: (to, state, opts) => router$1.navigate(to, {\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        }),\n        replace: (to, state, opts) => router$1.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        })\n      };\n    }, [router$1]);\n    let basename = router$1.basename || \"/\";\n    let dataRouterContext = React__namespace.useMemo(() => ({\n      router: router$1,\n      navigator,\n      static: false,\n      basename\n    }), [router$1, navigator, basename]);\n    React__namespace.useEffect(() => logV6DeprecationWarnings(future, router$1.future), [router$1, future]);\n\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(DataRouterContext.Provider, {\n      value: dataRouterContext\n    }, /*#__PURE__*/React__namespace.createElement(DataRouterStateContext.Provider, {\n      value: state\n    }, /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator,\n      future: {\n        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath\n      }\n    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n      routes: router$1.routes,\n      future: router$1.future,\n      state: state\n    }) : fallbackElement))), null);\n  }\n  function DataRoutes(_ref2) {\n    let {\n      routes,\n      future,\n      state\n    } = _ref2;\n    return useRoutesImpl(routes, undefined, state, future);\n  }\n  /**\n   * A `<Router>` that stores all entries in memory.\n   *\n   * @see https://reactrouter.com/v6/router-components/memory-router\n   */\n  function MemoryRouter(_ref3) {\n    let {\n      basename,\n      children,\n      initialEntries,\n      initialIndex,\n      future\n    } = _ref3;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createMemoryHistory({\n        initialEntries,\n        initialIndex,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    React__namespace.useEffect(() => logV6DeprecationWarnings(future), [future]);\n    return /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history,\n      future: future\n    });\n  }\n  /**\n   * Changes the current location.\n   *\n   * Note: This API is mostly useful in React.Component subclasses that are not\n   * able to use hooks. In functional components, we recommend you use the\n   * `useNavigate` hook instead.\n   *\n   * @see https://reactrouter.com/v6/components/navigate\n   */\n  function Navigate(_ref4) {\n    let {\n      to,\n      replace,\n      state,\n      relative\n    } = _ref4;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      future,\n      static: isStatic\n    } = React__namespace.useContext(NavigationContext);\n    router.UNSAFE_warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") ;\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let navigate = useNavigate();\n\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = router.resolveTo(to, router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {\n      replace,\n      state,\n      relative\n    }), [navigate, jsonPath, relative, replace, state]);\n    return null;\n  }\n  /**\n   * Renders the child route's element, if there is one.\n   *\n   * @see https://reactrouter.com/v6/components/outlet\n   */\n  function Outlet(props) {\n    return useOutlet(props.context);\n  }\n  /**\n   * Declares an element that should be rendered at a certain URL path.\n   *\n   * @see https://reactrouter.com/v6/components/route\n   */\n  function Route(_props) {\n    router.UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\")  ;\n  }\n  /**\n   * Provides location context for the rest of the app.\n   *\n   * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n   * router that is more specific to your environment such as a `<BrowserRouter>`\n   * in web browsers or a `<StaticRouter>` for server rendering.\n   *\n   * @see https://reactrouter.com/v6/router-components/router\n   */\n  function Router(_ref5) {\n    let {\n      basename: basenameProp = \"/\",\n      children = null,\n      location: locationProp,\n      navigationType = router.Action.Pop,\n      navigator,\n      static: staticProp = false,\n      future\n    } = _ref5;\n    !!useInRouterContext() ? router.UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\")  : void 0;\n\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React__namespace.useMemo(() => ({\n      basename,\n      navigator,\n      static: staticProp,\n      future: _extends({\n        v7_relativeSplatPath: false\n      }, future)\n    }), [basename, future, navigator, staticProp]);\n    if (typeof locationProp === \"string\") {\n      locationProp = router.parsePath(locationProp);\n    }\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n      state = null,\n      key = \"default\"\n    } = locationProp;\n    let locationContext = React__namespace.useMemo(() => {\n      let trailingPathname = router.stripBasename(pathname, basename);\n      if (trailingPathname == null) {\n        return null;\n      }\n      return {\n        location: {\n          pathname: trailingPathname,\n          search,\n          hash,\n          state,\n          key\n        },\n        navigationType\n      };\n    }, [basename, pathname, search, hash, state, key, navigationType]);\n    router.UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") ;\n    if (locationContext == null) {\n      return null;\n    }\n    return /*#__PURE__*/React__namespace.createElement(NavigationContext.Provider, {\n      value: navigationContext\n    }, /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n      children: children,\n      value: locationContext\n    }));\n  }\n  /**\n   * A container for a nested tree of `<Route>` elements that renders the branch\n   * that best matches the current location.\n   *\n   * @see https://reactrouter.com/v6/components/routes\n   */\n  function Routes(_ref6) {\n    let {\n      children,\n      location\n    } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n  }\n  /**\n   * Component to use for rendering lazily loaded data from returning defer()\n   * in a loader function\n   */\n  function Await(_ref7) {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = _ref7;\n    return /*#__PURE__*/React__namespace.createElement(AwaitErrorBoundary, {\n      resolve: resolve,\n      errorElement: errorElement\n    }, /*#__PURE__*/React__namespace.createElement(ResolveAwait, null, children));\n  }\n  var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n  }(AwaitRenderStatus || {});\n  const neverSettledPromise = new Promise(() => {});\n  class AwaitErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        error: null\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      let {\n        children,\n        errorElement,\n        resolve\n      } = this.props;\n      let promise = null;\n      let status = AwaitRenderStatus.pending;\n      if (!(resolve instanceof Promise)) {\n        // Didn't get a promise - provide as a resolved promise\n        status = AwaitRenderStatus.success;\n        promise = Promise.resolve();\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_data\", {\n          get: () => resolve\n        });\n      } else if (this.state.error) {\n        // Caught a render error, provide it as a rejected promise\n        status = AwaitRenderStatus.error;\n        let renderError = this.state.error;\n        promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_error\", {\n          get: () => renderError\n        });\n      } else if (resolve._tracked) {\n        // Already tracked promise - check contents\n        promise = resolve;\n        status = \"_error\" in promise ? AwaitRenderStatus.error : \"_data\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n      } else {\n        // Raw (untracked) promise - track it\n        status = AwaitRenderStatus.pending;\n        Object.defineProperty(resolve, \"_tracked\", {\n          get: () => true\n        });\n        promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n          get: () => data\n        }), error => Object.defineProperty(resolve, \"_error\", {\n          get: () => error\n        }));\n      }\n      if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {\n        // Freeze the UI by throwing a never resolved promise\n        throw neverSettledPromise;\n      }\n      if (status === AwaitRenderStatus.error && !errorElement) {\n        // No errorElement, throw to the nearest route-level error boundary\n        throw promise._error;\n      }\n      if (status === AwaitRenderStatus.error) {\n        // Render via our errorElement\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: errorElement\n        });\n      }\n      if (status === AwaitRenderStatus.success) {\n        // Render children with resolved value\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: children\n        });\n      }\n\n      // Throw to the suspense boundary\n      throw promise;\n    }\n  }\n\n  /**\n   * @private\n   * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n   */\n  function ResolveAwait(_ref8) {\n    let {\n      children\n    } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, toRender);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // UTILS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Creates a route config from a React \"children\" object, which is usually\n   * either a `<Route>` element or an array of them. Used internally by\n   * `<Routes>` to create a route config from its children.\n   *\n   * @see https://reactrouter.com/v6/utils/create-routes-from-children\n   */\n  function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n      parentPath = [];\n    }\n    let routes = [];\n    React__namespace.Children.forEach(children, (element, index) => {\n      if (! /*#__PURE__*/React__namespace.isValidElement(element)) {\n        // Ignore non-elements. This allows people to more easily inline\n        // conditionals in their route config.\n        return;\n      }\n      let treePath = [...parentPath, index];\n      if (element.type === React__namespace.Fragment) {\n        // Transparently support React.Fragment and its children.\n        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n        return;\n      }\n      !(element.type === Route) ? router.UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\")  : void 0;\n      !(!element.props.index || !element.props.children) ? router.UNSAFE_invariant(false, \"An index route cannot have child routes.\")  : void 0;\n      let route = {\n        id: element.props.id || treePath.join(\"-\"),\n        caseSensitive: element.props.caseSensitive,\n        element: element.props.element,\n        Component: element.props.Component,\n        index: element.props.index,\n        path: element.props.path,\n        loader: element.props.loader,\n        action: element.props.action,\n        errorElement: element.props.errorElement,\n        ErrorBoundary: element.props.ErrorBoundary,\n        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n        shouldRevalidate: element.props.shouldRevalidate,\n        handle: element.props.handle,\n        lazy: element.props.lazy\n      };\n      if (element.props.children) {\n        route.children = createRoutesFromChildren(element.props.children, treePath);\n      }\n      routes.push(route);\n    });\n    return routes;\n  }\n\n  /**\n   * Renders the result of `matchRoutes()` into a React element.\n   */\n  function renderMatches(matches) {\n    return _renderMatches(matches);\n  }\n\n  function mapRouteProperties(route) {\n    let updates = {\n      // Note: this check also occurs in createRoutesFromChildren so update\n      // there if you change this -- please and thank you!\n      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n      {\n        if (route.element) {\n          router.UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        element: /*#__PURE__*/React__namespace.createElement(route.Component),\n        Component: undefined\n      });\n    }\n    if (route.HydrateFallback) {\n      {\n        if (route.hydrateFallbackElement) {\n          router.UNSAFE_warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        hydrateFallbackElement: /*#__PURE__*/React__namespace.createElement(route.HydrateFallback),\n        HydrateFallback: undefined\n      });\n    }\n    if (route.ErrorBoundary) {\n      {\n        if (route.errorElement) {\n          router.UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        errorElement: /*#__PURE__*/React__namespace.createElement(route.ErrorBoundary),\n        ErrorBoundary: undefined\n      });\n    }\n    return updates;\n  }\n  function createMemoryRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createMemoryHistory({\n        initialEntries: opts == null ? void 0 : opts.initialEntries,\n        initialIndex: opts == null ? void 0 : opts.initialIndex\n      }),\n      hydrationData: opts == null ? void 0 : opts.hydrationData,\n      routes,\n      mapRouteProperties,\n      dataStrategy: opts == null ? void 0 : opts.dataStrategy,\n      patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation\n    }).initialize();\n  }\n\n  Object.defineProperty(exports, 'AbortedDeferredError', {\n    enumerable: true,\n    get: function () { return router.AbortedDeferredError; }\n  });\n  Object.defineProperty(exports, 'NavigationType', {\n    enumerable: true,\n    get: function () { return router.Action; }\n  });\n  Object.defineProperty(exports, 'createPath', {\n    enumerable: true,\n    get: function () { return router.createPath; }\n  });\n  Object.defineProperty(exports, 'defer', {\n    enumerable: true,\n    get: function () { return router.defer; }\n  });\n  Object.defineProperty(exports, 'generatePath', {\n    enumerable: true,\n    get: function () { return router.generatePath; }\n  });\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\n    enumerable: true,\n    get: function () { return router.isRouteErrorResponse; }\n  });\n  Object.defineProperty(exports, 'json', {\n    enumerable: true,\n    get: function () { return router.json; }\n  });\n  Object.defineProperty(exports, 'matchPath', {\n    enumerable: true,\n    get: function () { return router.matchPath; }\n  });\n  Object.defineProperty(exports, 'matchRoutes', {\n    enumerable: true,\n    get: function () { return router.matchRoutes; }\n  });\n  Object.defineProperty(exports, 'parsePath', {\n    enumerable: true,\n    get: function () { return router.parsePath; }\n  });\n  Object.defineProperty(exports, 'redirect', {\n    enumerable: true,\n    get: function () { return router.redirect; }\n  });\n  Object.defineProperty(exports, 'redirectDocument', {\n    enumerable: true,\n    get: function () { return router.redirectDocument; }\n  });\n  Object.defineProperty(exports, 'replace', {\n    enumerable: true,\n    get: function () { return router.replace; }\n  });\n  Object.defineProperty(exports, 'resolvePath', {\n    enumerable: true,\n    get: function () { return router.resolvePath; }\n  });\n  exports.Await = Await;\n  exports.MemoryRouter = MemoryRouter;\n  exports.Navigate = Navigate;\n  exports.Outlet = Outlet;\n  exports.Route = Route;\n  exports.Router = Router;\n  exports.RouterProvider = RouterProvider;\n  exports.Routes = Routes;\n  exports.UNSAFE_DataRouterContext = DataRouterContext;\n  exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\n  exports.UNSAFE_LocationContext = LocationContext;\n  exports.UNSAFE_NavigationContext = NavigationContext;\n  exports.UNSAFE_RouteContext = RouteContext;\n  exports.UNSAFE_logV6DeprecationWarnings = logV6DeprecationWarnings;\n  exports.UNSAFE_mapRouteProperties = mapRouteProperties;\n  exports.UNSAFE_useRouteId = useRouteId;\n  exports.UNSAFE_useRoutesImpl = useRoutesImpl;\n  exports.createMemoryRouter = createMemoryRouter;\n  exports.createRoutesFromChildren = createRoutesFromChildren;\n  exports.createRoutesFromElements = createRoutesFromChildren;\n  exports.renderMatches = renderMatches;\n  exports.useActionData = useActionData;\n  exports.useAsyncError = useAsyncError;\n  exports.useAsyncValue = useAsyncValue;\n  exports.useBlocker = useBlocker;\n  exports.useHref = useHref;\n  exports.useInRouterContext = useInRouterContext;\n  exports.useLoaderData = useLoaderData;\n  exports.useLocation = useLocation;\n  exports.useMatch = useMatch;\n  exports.useMatches = useMatches;\n  exports.useNavigate = useNavigate;\n  exports.useNavigation = useNavigation;\n  exports.useNavigationType = useNavigationType;\n  exports.useOutlet = useOutlet;\n  exports.useOutletContext = useOutletContext;\n  exports.useParams = useParams;\n  exports.useResolvedPath = useResolvedPath;\n  exports.useRevalidator = useRevalidator;\n  exports.useRouteError = useRouteError;\n  exports.useRouteLoaderData = useRouteLoaderData;\n  exports.useRoutes = useRoutes;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-router.development.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$remix_run$router$dist$router_cjs","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["json","NavigationType","backgroundColor","preventScrollReset","Route","useResolvedPath","navigator","handle","matchRoutes","static","useInRouterContext","initialEntries","hydrateFallbackElement","fromRouteId","useOutlet","useAsyncError","MemoryRouter","resolve","encodeLocation","index","defer","generatePath","useParams","params","useLoaderData","useRevalidator","redirectDocument","ReactRouter","useRoutes","UNSAFE_DataRouterContext","redirect","UNSAFE_useRouteId","fontStyle","hash","displayName","pathname","navigationType","key","children","component","__esModule","_data","Routes","path","padding","useNavigation","routeContext","useMatch","Router","UNSAFE_RouteContext","matchPath","useOutletContext","useLocation","error","shouldRevalidate","id","outlet","UNSAFE_logV6DeprecationWarnings","useAsyncValue","push","caseSensitive","createMemoryRouter","basename","currentLocation","isDataRoute","useHref","initialIndex","useNavigationType","RouterProvider","element","loader","createRoutesFromChildren","patchRoutesOnNavigation","Outlet","replace","style","createHref","UNSAFE_useRoutesImpl","value","pathnameBase","location","enumerable","go","_deepestRenderedBoundaryId","Await","useBlocker","errorElement","hydrationData","action","current","useRouteLoaderData","dataStrategy","renderMatches","ErrorBoundary","useActionData","matches","parsePath","history","useRouteError","useNavigate","match","state","router","Component","hasErrorBoundary","UNSAFE_LocationContext","lazy","useMatches","revalidation","createRoutesFromElements","relative","UNSAFE_mapRouteProperties","_tracked","v7_prependBasename","resolvePath","UNSAFE_DataRouterStateContext","AbortedDeferredError","future","v7_relativeSplatPath","_error","historyAction","revalidate","search","get","mapRouteProperties","nextLocation","isRouteErrorResponse","routes","Navigate","v5Compat","HydrateFallback","createPath","UNSAFE_NavigationContext"]],"~:compiled-at",1740921907202,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_router$dist$umd$react_router_development.js\",\n\"lineCount\":560,\n\"mappings\":\"AAAAA,cAAA,CAAA,kEAAA,GAAuF,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAW9H,WAAS,CAACH,MAAD,EAASI,OAAT,CAAkB;AACP,YAAnB,KAAA,MAAOD,QAAP,IAAiD,WAAjD,KAA+B,MAAOD,OAAtC,GAA+DE,OAAA,CAAQD,OAAR,EAAiBF,OAAA,CAAQ,iCAAR,CAAjB,EAAmCA,OAAA,CAAQ,uDAAR,CAAnC,CAA/D,GACkB,UAAlB,KAAA,MAAOI,OAAP,IAAgCA,MAAOC,CAAAA,GAAvC,GAA6CD,MAAA,CAAO,CAAC,SAAD,EAAY,OAAZ,EAAqB,mBAArB,CAAP,EAAkDD,OAAlD,CAA7C,IACCJ,MAAA,GAA+B,WAAtB,KAAA,MAAOO,WAAP,GAAoCA,UAApC,GAAiDP,MAAjD,IAA2DQ,IAApE,EAA0EJ,OAAA,CAAQJ,MAAOS,CAAAA,WAAf,GAA6B,EAA7B,EAAiCT,MAAOU,CAAAA,KAAxC,EAA+CV,MAAOW,CAAAA,WAAtD,CAD3E,CADA;AAD0B,GAA3B,CAAD,CAIG,IAJH,EAIU,QAAS,CAACR,OAAD,EAAUO,KAAV,EAAiBE,MAAjB,CAAyB;AAsB1CC,YAASA,SAAQ,EAAG;AAClBA,cAAA,GAAWC,MAAOC,CAAAA,MAAP,GAAgBD,MAAOC,CAAAA,MAAOC,CAAAA,IAAd,EAAhB,GAAuC,QAAS,CAACC,MAAD,CAAS;AAClE,aAAK,IAAIC,IAAI,CAAb,EAAgBA,CAAhB,GAAoBC,SAAUC,CAAAA,MAA9B,EAAsCF,CAAA,EAAtC,CAA2C;AACzC,cAAIG,SAASF,SAAA,CAAUD,CAAV,CAAb,EACSI,GADT;AACA,eAASA,GAAT,GAAgBD,OAAhB;AACMP,kBAAOS,CAAAA,SAAUC,CAAAA,cAAeC,CAAAA,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,KACEL,MAAA,CAAOK,GAAP,CADF,GACgBD,MAAA,CAAOC,GAAP,CADhB;AADF;AAFyC;AAQ3C,eAAOL,MAAP;AATkE,OAApE;AAWA,aAAOJ,QAASa,CAAAA,KAAT,CAAe,IAAf,EAAqBP,SAArB,CAAP;AAZkB;AA0GpBQ,YAASA,mBAAkB,EAAG;AAC5B,aAAuD,IAAvD,IAAOC,gBAAiBC,CAAAA,UAAjB,CAA4BC,eAA5B,CAAP;AAD4B;AAc9BC,YAASA,YAAW,EAAG;AACpBJ,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,8EAFwB,CAAxB;AAGA,aAAOJ,gBAAiBC,CAAAA,UAAjB,CAA4BC,eAA5B,CAA6CG,CAAAA,QAApD;AAJqB;AAyCvBC,YAASA,0BAAyB,CAACC,EAAD,CAAK;AACtBP,sBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CAA+CC,CAAAA,MAC9D,IAIET,gBAAiBU,CAAAA,eAAjB,CAAiCH,EAAjC,CAJF;AAFqC;AAgBvCI,YAASA,YAAW,EAAG;AACrB,UAAI,CACFC,WADE,CAAA,GAEAZ,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAFJ;AAKA,aAAOD,WAAA,GAAcE,iBAAA,EAAd,GAAoCC,mBAAA,EAA3C;AANqB;AAQvBA,YAASA,oBAAmB,EAAG;AAC5BhB,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,8EAFwB,CAAxB;AAGA,UAAIY,oBAAoBhB,gBAAiBC,CAAAA,UAAjB,CAA4BgB,iBAA5B,CAAxB,EACI,CACFC,QADE,EAEFC,MAFE,EAGFC,SAHE,CAAA,GAIApB,gBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CALJ,EAMI,CACFa,OADE,CAAA,GAEArB,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CARJ,EASI,CACF,SAAUS,gBADR,CAAA,GAEAnB,WAAA,EAXJ,EAYIoB,qBAAqBC,IAAKC,CAAAA,SAAL,CAAezC,MAAO0C,CAAAA,0BAAP,CAAkCL,OAAlC,EAA2CF,MAAOQ,CAAAA,oBAAlD,CAAf,CAZzB,EAaIC,YAAY5B,gBAAiB6B,CAAAA,MAAjB,CAAwB,CAAA,CAAxB,CAbhB;AAcAvB,+BAAA,CAA0B,EAAA,IAAM;AAC9BsB,iBAAUE,CAAAA,OAAV,GAAoB,CAAA,CAApB;AAD8B,OAAhC,CAAA;AA6BA,aA1Be9B,gBAAiB+B,CAAAA,WAAjBC,CAA6B,QAAS,CAACC,EAAD,EAAKC,OAAL,CAAc;AACjD,YAAK,EAArB,KAAIA,OAAJ,KACEA,OADF,GACY,EADZ;AAGAlD,cAAOmD,CAAAA,cAAP,CAAsBP,SAAUE,CAAAA,OAAhC,EApD0BM,+FAoD1B,CAAA;AAIKR,iBAAUE,CAAAA,OAAf,KACkB,QAAlB,KAAI,MAAOG,GAAX,GACEb,SAAUiB,CAAAA,EAAV,CAAaJ,EAAb,CADF,IAIIK,EAWJ,GAXWtD,MAAOuD,CAAAA,SAAP,CAAiBN,EAAjB,EAAqBT,IAAKgB,CAAAA,KAAL,CAAWjB,kBAAX,CAArB,EAAqDD,gBAArD,EAA4F,MAA5F,KAAuEY,OAAQO,CAAAA,QAA/E,CAWX,EAHyB,IAGzB,IAHIzB,iBAGJ,IAH8C,GAG9C,KAHiCE,QAGjC,KAFEoB,EAAKI,CAAAA,QAEP,GAFoC,GAAlB,KAAAJ,EAAKI,CAAAA,QAAL,GAAwBxB,QAAxB,GAAmClC,MAAO2D,CAAAA,SAAP,CAAiB,CAACzB,QAAD,EAAWoB,EAAKI,CAAAA,QAAhB,CAAjB,CAErD,GAAA,CAAGR,OAAQU,CAAAA,OAAV,GAAoBxB,SAAUwB,CAAAA,OAA9B,GAAwCxB,SAAUyB,CAAAA,IAAnD,EAAyDP,EAAzD,EAA+DJ,OAAQY,CAAAA,KAAvE,EAA8EZ,OAA9E,CAfA,CADA;AARiE,OAApDF,EAyBZ,CAACd,QAAD,EAAWE,SAAX,EAAsBG,kBAAtB,EAA0CD,gBAA1C,EAA4DN,iBAA5D,CAzBYgB,CA0Bf;AA/C6B;AAkE/Be,YAASA,UAAS,CAACC,OAAD,CAAU;AAC1B,UAAIC,SAASjD,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAA0CoC,CAAAA,MAAvD;AACA,aAAIA,MAAJ,GACsBjD,gBAAiBkD,CAAAA,aAAjB,CAA+BC,aAAcC,CAAAA,QAA7C,EAAuD,CACzEC,MAAOL,OADkE,CAAvD,EAEjBC,MAFiB,CADtB,GAKOA,MALP;AAF0B;AA6B5BK,YAASA,gBAAe,CAACrB,EAAD,EAAKsB,MAAL,CAAa;AACnC,UAAI,CACFd,QADE,CAAA,GAEW,IAAK,EAAhB,KAAAc,MAAA,GAAoB,EAApB,GAAyBA,MAF7B;AAGA,OAAI,CACF,OAAApC,MADE,CAAJ,GAEInB,gBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CAFJ;AAGA,UAAI,CACFa,OADE,CAAA,GAEArB,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAFJ,EAGI,CACF,SAAUS,gBADR,CAAA,GAEAnB,WAAA,EALJ,EAMIoB,qBAAqBC,IAAKC,CAAAA,SAAL,CAAezC,MAAO0C,CAAAA,0BAAP,CAAkCL,OAAlC,EAA2CF,MAAOQ,CAAAA,oBAAlD,CAAf,CANzB;AAOA,aAAO3B,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAMxE,MAAOuD,CAAAA,SAAP,CAAiBN,EAAjB,EAAqBT,IAAKgB,CAAAA,KAAL,CAAWjB,kBAAX,CAArB,EAAqDD,gBAArD,EAAoF,MAApF,KAAuEmB,QAAvE,CAA/B,EAA4H,CAACR,EAAD,EAAKV,kBAAL,EAAyBD,gBAAzB,EAA2CmB,QAA3C,CAA5H,CAAP;AAdmC;AAyBrCgB,YAASA,UAAS,CAACC,MAAD,EAASC,WAAT,CAAsB;AACtC,aAAOC,aAAA,CAAcF,MAAd,EAAsBC,WAAtB,CAAP;AADsC;AAKxCC,YAASA,cAAa,CAACF,MAAD,EAASC,WAAT,EAAsBE,eAAtB,EAAuC1C,MAAvC,CAA+C;AAClEpB,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,4EAFwB,CAAxB;AAGA,UAAI,CACFgB,SADE,EAEF,OAAQ0C,QAFN,CAAA,GAGA9D,gBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CAHJ,EAII,CACF,QAASuD,aADP,CAAA,GAEA/D,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CANJ;AAOA,UAAImD,aAAaD,aAAA,CAAcA,aAAcvE,CAAAA,MAA5B,GAAqC,CAArC,CAAjB;AACA,UAAIyE,eAAeD,UAAA,GAAaA,UAAWE,CAAAA,MAAxB,GAAiC,EAApD;AACA,UAAIC,iBAAiBH,UAAA,GAAaA,UAAWtB,CAAAA,QAAxB,GAAmC,GAAxD;AACA,UAAI0B,qBAAqBJ,UAAA,GAAaA,UAAWK,CAAAA,YAAxB,GAAuC,GAAhE;AAuBE,UAAIC,cAtBFC,UAsBED,GAtBYN,UAsBZM,IAtB0BN,UAAWQ,CAAAA,KAsBrCF,KAA4BC,UAAYjC,CAAAA,IAAxCgC,IAAgD,EAApD;AACAG,iBAAA,CAAYN,cAAZ,EAA4B,CAACI,UAA7B,IAA4CD,UAAWI,CAAAA,QAAX,CAAoB,GAApB,CAA5C,EAAsE,uEAAtE,IAAiJP,cAAjJ,GAAkK,8BAAlK,GAA+LG,UAA/L,GAA4M,4NAA5M,KAA2bA,UAA3b,GAAwc,8BAAxc,MAAyf,GAAf,KAAAA,UAAA;AAAqB,SAArB,GAA2BA,UAA3B,GAAwC,IAAlhB,IAA0hB,QAA1hB,EAAA;AAEEK,oBAAAA,GAAsBxE,WAAA,EAAtBwE;AACJ,UAAItE,QAAJ;AACIsD,iBAAJ,IAEMiB,cAEJ,GAF+C,QAAvB,KAAA,MAAOjB,YAAP,GAAkC3E,MAAO6F,CAAAA,SAAP,CAAiBlB,WAAjB,CAAlC,GAAkEA,WAE1F,EADyB,GACzB,KADES,kBACF,KADyF,IAAxD,KAACU,QAAD,GAAyBF,cAAkBlC,CAAAA,QAA3C,IAA+D,CAA/D,GAAwEoC,QAAsBC,CAAAA,UAAtB,CAAiCX,kBAAjC,CACzG,KADkKpF,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,4OAA/B;OAAoRgE,kBAApR,GAAyS,kBAAzS,KAAuUQ,cAAkBlC,CAAAA,QAAzV,GAAoW,qCAApW,EAClK,EAAArC,QAAA,GAAWuE,cAJb,IAMEvE,QANF,GAMasE,cANb;AASIK,gBAAAA,GADAtC,cACAsC,GADW3E,QAASqC,CAAAA,QACpBsC,IADgC,GAChCA;AACuB,SAA3B,KAAIZ,kBAAJ,KAeMa,UAEJ,GAFqBb,kBAAmBxB,CAAAA,OAAnB,CAA2B,KAA3B,EAAkC,EAAlC,CAAsCsC,CAAAA,KAAtC,CAA4C,GAA5C,CAErB,EAAAF,UAAA,GAAoB,GAApB,GADetC,cAASE,CAAAA,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAA4BsC,CAAAA,KAA5BC,CAAkC,GAAlCA,CACoBC,CAAAA,KAAT,CAAeH,UAAezF,CAAAA,MAA9B,CAAsC6F,CAAAA,IAAtC,CAA2C,GAA3C,CAjB5B;AAmBIhE,YAAAA,GAAU,CAACyC,QAAD,IAAaD,eAAb,IAAgCA,eAAgBxC,CAAAA,OAAhD,IAA4F,CAA5F,GAA2DwC,eAAgBxC,CAAAA,OAAQ7B,CAAAA,MAAnF,GAAgGqE,eAAgBxC,CAAAA,OAAhH,GAA0HrC,MAAOsG,CAAAA,WAAP,CAAmB5B,MAAnB,EAA2B,CACjKhB,SAAUsC,UADuJ,CAA3B,CAApI3D;AAIFrC,YAAOmD,CAAAA,cAAP,CAAsBoC,UAAtB,IAAgD,IAAhD,IAAqClD,MAArC,EAAsD,8BAAtD,GAAwFhB,QAASqC,CAAAA,QAAjG,GAA4GrC,QAASkF,CAAAA,MAArH,GAA8HlF,QAASmF,CAAAA,IAAvI,GAA8I,IAA9I,CAAA;AACAxG,YAAOmD,CAAAA,cAAP,CAAiC,IAAjC,IAAsBd,MAAtB,IAAuFoE,IAAAA,EAAvF,KAAyCpE,MAAA,CAAQA,MAAQ7B,CAAAA,MAAhB,GAAyB,CAAzB,CAA4BgF,CAAAA,KAAMkB,CAAAA,OAA3E,IAAoJD,IAAAA,EAApJ,KAAoGpE,MAAA,CAAQA,MAAQ7B,CAAAA,MAAhB,GAAyB,CAAzB,CAA4BgF,CAAAA,KAAMmB,CAAAA,SAAtI,IAA4MF,IAAAA,EAA5M,KAAiKpE,MAAA,CAAQA,MAAQ7B,CAAAA,MAAhB,GAAyB,CAAzB,CAA4BgF,CAAAA,KAAMoB,CAAAA,IAAnM,EAAuN,kCAAvN,GAA6PvF,QAASqC,CAAAA,QAAtQ,GAAiRrC,QAASkF,CAAAA,MAA1R,GAAmSlF,QAASmF,CAAAA,IAA5S,GAAmT,mJAAnT,CAAA;AAEEK,qBAAAA,GAAkBC,cAAA,CAAezE,MAAf,IAA0BA,MAAQ0E,CAAAA,GAAR,CAAYC,KAAA,IAAS9G,MAAOC,CAAAA,MAAP,CAAc,EAAd,EAAkB6G,KAAlB,EAAyB,CAC5F9B,OAAQhF,MAAOC,CAAAA,MAAP,CAAc,EAAd,EAAkB8E,YAAlB,EAAgC+B,KAAM9B,CAAAA,MAAtC,CADoF,EAE5FxB,SAAU1D,MAAO2D,CAAAA,SAAP,CAAiB,CAACyB,kBAAD,EAE3BhD,SAAU6E,CAAAA,cAAV,GAA2B7E,SAAU6E,CAAAA,cAAV,CAAyBD,KAAMtD,CAAAA,QAA/B,CAAyCA,CAAAA,QAApE,GAA+EsD,KAAMtD,CAAAA,QAF1D,CAAjB,CAFkF,EAK5F2B,aAAqC,GAAvB,KAAA2B,KAAM3B,CAAAA,YAAN,GAA6BD,kBAA7B,GAAkDpF,MAAO2D,CAAAA,SAAP,CAAiB,CAACyB,kBAAD,EAEjFhD,SAAU6E,CAAAA,cAAV,GAA2B7E,SAAU6E,CAAAA,cAAV,CAAyBD,KAAM3B,CAAAA,YAA/B,CAA6C3B,CAAAA,QAAxE,GAAmFsD,KAAM3B,CAAAA,YAFR,CAAjB,CAL4B,CAAzB,CAArB,CAA1B;AAQjBN,mBARiB,EAQFF,eARE,EAQe1C,MARf,CAAlB0E;AAaJ,aAAIlC,WAAJ,IAAmBkC,eAAnB,GACsB7F,gBAAiBkD,CAAAA,aAAjB,CAA+BhD,eAAgBkD,CAAAA,QAA/C,EAAyD,CAC3EC,MAAO,CACLhD,SAAUpB,QAAA,CAAS,CACjByD,SAAU,GADO,EAEjB6C,OAAQ,EAFS,EAGjBC,KAAM,EAHW,EAIjB1C,MAAO,IAJU,EAKjBpD,IAAK,SALY,CAAT,EAMPW,QANO,CADL,EAQL6F,eAAgBlH,MAAOmH,CAAAA,MAAOC,CAAAA,GARzB,CADoE,CAAzD,EAWjBP,eAXiB,CADtB,GAcOA,eAdP;AA3FmE;AA+LrEQ,YAASA,cAAa,CAACC,IAAD,CAAO;AAC3B,UAAI,CACFC,YADE,EAEFP,KAFE,EAGFQ,QAHE,CAAA,GAIAF,IAJJ;AASA,OAJItF,IAIJ,GAJwBhB,gBAAiBC,CAAAA,UAAjB,CAA4BgB,iBAA5B,CAIxB,KAAyBD,IAAkBP,CAAAA,MAA3C,IAAqDO,IAAkByF,CAAAA,aAAvE,KAAyFT,KAAMxB,CAAAA,KAAMkC,CAAAA,YAArG,IAAqHV,KAAMxB,CAAAA,KAAMmC,CAAAA,aAAjI,MACE3F,IAAkByF,CAAAA,aAAcG,CAAAA,0BADlC,GAC+DZ,KAAMxB,CAAAA,KAAMqC,CAAAA,EAD3E;AAGA,aAAoB7G,gBAAiBkD,CAAAA,aAAjB,CAA+BrC,YAAauC,CAAAA,QAA5C,EAAsD,CACxEC,MAAOkD,YADiE,CAAtD,EAEjBC,QAFiB,CAApB;AAb2B;AAiB7BV,YAASA,eAAc,CAACzE,OAAD,EAAU0C,aAAV,EAAyBF,eAAzB,EAA0C1C,MAA1C,CAAkD;AACvE,UAAI2F,gBAAJ;AACsB,UAAK,EAA3B,KAAI/C,aAAJ,KACEA,aADF,GACkB,EADlB;AAGwB,UAAK,EAA7B,KAAIF,eAAJ,KACEA,eADF,GACoB,IADpB;AAGe,UAAK,EAApB,KAAI1C,MAAJ,KACEA,MADF,GACW,IADX;AAGA,UAAe,IAAf,IAAIE,OAAJ,CAAqB;AACnB,YAAI0F,OAAJ;AACA,YAAI,CAAClD,eAAL;AACE,iBAAO,IAAP;AADF;AAGA,YAAIA,eAAgBmD,CAAAA,MAApB;AAGE3F,iBAAA,GAAUwC,eAAgBxC,CAAAA,OAA1B;AAHF,cAIO,KAA0B,IAA1B,KAAK0F,OAAL,GAAe5F,MAAf,KAAkC4F,OAAQE,CAAAA,mBAA1C,IAA0F,CAA1F,KAAiElD,aAAcvE,CAAAA,MAA/E,IAA+F,CAACqE,eAAgBqD,CAAAA,WAAhH,IAAgK,CAAhK,GAA+HrD,eAAgBxC,CAAAA,OAAQ7B,CAAAA,MAAvJ;AAOL6B,iBAAA,GAAUwC,eAAgBxC,CAAAA,OAA1B;AAPK;AASL,iBAAO,IAAP;AATK;AATY;AAqBrB,UAAIwE,kBAAkBxE,OAAtB,EAGI2F,SAAiD,IAAxC,KAACF,gBAAD,GAAoBjD,eAApB,IAA+C,IAAK,EAApD,GAAwDiD,gBAAiBE,CAAAA,MAHtF;AAIc,UAAd,IAAIA,MAAJ,KACMG,OAEJ,GAFiBtB,eAAgBuB,CAAAA,SAAhB,CAA0BC,CAAA,IAAKA,CAAE7C,CAAAA,KAAMqC,CAAAA,EAAb,IAAsEpB,IAAAA,EAAtE,MAA8B,IAAV,IAAAuB,MAAA,GAAiB,IAAK,EAAtB,GAA0BA,MAAA,CAAOK,CAAE7C,CAAAA,KAAMqC,CAAAA,EAAf,CAA9C,CAA1B,CAEjB,EADgB,CAChB,IADEM,OACF,IADqBnI,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,2DAA/B,GAA6FlB,MAAOoI,CAAAA,IAAP,CAAYN,MAAZ,CAAoB3B,CAAAA,IAApB,CAAyB,GAAzB,CAA7F,CACrB,EAAAQ,eAAA,GAAkBA,eAAgBT,CAAAA,KAAhB,CAAsB,CAAtB,EAAyBmC,IAAKC,CAAAA,GAAL,CAAS3B,eAAgBrG,CAAAA,MAAzB,EAAiC2H,OAAjC,GAA8C,CAA9C,CAAzB,CAHpB;AAQA,UAAIM,iBAAiB,CAAA,CAArB,EACIC,gBAAgB,CAAC,CADrB;AAEA,UAAI7D,eAAJ,IAAuB1C,MAAvB,IAAiCA,MAAO8F,CAAAA,mBAAxC;AACE,aAAS3H,MAAT,GAAa,CAAb,EAAgBA,MAAhB,GAAoBuG,eAAgBrG,CAAAA,MAApC,EAA4CF,MAAA,EAA5C,CAAiD;AAC3C0G,iBAAAA,GAAQH,eAAA,CAAgBvG,MAAhB,CAAR0G;AAEJ,cAAIA,OAAMxB,CAAAA,KAAMmD,CAAAA,eAAhB,IAAmC3B,OAAMxB,CAAAA,KAAMoD,CAAAA,sBAA/C;AACEF,yBAAA,GAAgBpI,MAAhB;AADF;AAGA,cAAI0G,OAAMxB,CAAAA,KAAMqC,CAAAA,EAAhB,CAAoB;AAClB,gBAAI,CACFgB,UADE,EAEFb,MAFE,CAAA,GAGAnD,eAHJ;AAIIiE,4BAAAA,GAAmB9B,OAAMxB,CAAAA,KAAMuD,CAAAA,MAA/BD,IAAwErC,IAAAA,EAAxEqC,KAAyCD,UAAA,CAAW7B,OAAMxB,CAAAA,KAAMqC,CAAAA,EAAvB,CAAzCiB,KAAsF,CAACd,MAAvFc,IAA4HrC,IAAAA,EAA5HqC,KAAiGd,MAAA,CAAOhB,OAAMxB,CAAAA,KAAMqC,CAAAA,EAAnB,CAAjGiB;AACJ,gBAAI9B,OAAMxB,CAAAA,KAAMoB,CAAAA,IAAhB,IAAwBkC,gBAAxB,CAA0C;AAIxCL,4BAAA,GAAiB,CAAA,CAAjB;AAEE5B,6BAAA,GADmB,CAArB,IAAI6B,aAAJ,GACoB7B,eAAgBT,CAAAA,KAAhB,CAAsB,CAAtB,EAAyBsC,aAAzB,GAAyC,CAAzC,CADpB,GAGoB,CAAC7B,eAAA,CAAgB,CAAhB,CAAD,CAFlB;AAIF;AAVwC;AANxB;AAN2B;AADnD;AA4BA,aAAOA,eAAgBmC,CAAAA,WAAhB,CAA4B,CAAC/E,MAAD,EAAS+C,KAAT,EAAgBiC,KAAhB,CAAA,IAA0B;AAE3D,YAAIC,KAAJ,EACIC,8BAA8B,CAAA,CADlC,EAEIzB,eAAe,IAFnB,EAGIkB,yBAAyB,IAH7B;AAII/D,uBAAJ,KACEqE,KAEA,GAFQlB,MAAA,IAAUhB,KAAMxB,CAAAA,KAAMqC,CAAAA,EAAtB,GAA2BG,MAAA,CAAOhB,KAAMxB,CAAAA,KAAMqC,CAAAA,EAAnB,CAA3B,GAAoDpB,IAAAA,EAE5D,EADAiB,YACA,GADeV,KAAMxB,CAAAA,KAAMkC,CAAAA,YAC3B,IAD2C0B,mBAC3C,EAAIX,cAAJ,KACsB,CAApB,GAAIC,aAAJ,IAAmC,CAAnC,KAAyBO,KAAzB,IACExD,WAAA,CAAY,gBAAZ,EAA8B,CAAA,CAA9B,EAAqC,0EAArC,CAEA,EADA0D,2BACA,GAD8B,CAAA,CAC9B,EAAAP,sBAAA,GAAyB,IAH3B,IAIWF,aAJX,KAI6BO,KAJ7B,KAKEE,2BACA,GAD8B,CAAA,CAC9B,EAAAP,sBAAA,GAAyB5B,KAAMxB,CAAAA,KAAMoD,CAAAA,sBAArC;AAA+D,YANjE,CADF,CAHF;AAcA,YAAIvG,UAAU0C,aAAcsE,CAAAA,MAAd,CAAqBxC,eAAgBT,CAAAA,KAAhB,CAAsB,CAAtB,EAAyB6C,KAAzB,GAAiC,CAAjC,CAArB,CAAd,EACIK,cAAc,EAAAA,IAAM;AACtB,cAAI9B,QAAJ;AAEEA,kBAAA,GADE0B,KAAJ,GACaxB,YADb,GAEWyB,2BAAJ,GACMP,sBADN,GAEI5B,KAAMxB,CAAAA,KAAMmB,CAAAA,SAAhB,GAOmB3F,gBAAiBkD,CAAAA,aAAjB,CAA+B8C,KAAMxB,CAAAA,KAAMmB,CAAAA,SAA3C,EAAsD,IAAtD,CAPnB,GAQIK,KAAMxB,CAAAA,KAAMkB,CAAAA,OAAhB,GACMM,KAAMxB,CAAAA,KAAMkB,CAAAA,OADlB,GAGMzC,MAdX;AAgBF,iBAAoBjD,gBAAiBkD,CAAAA,aAAjB,CAA+BmD,aAA/B,EAA8C,CACzDL,KADyD,EAEhEO,aAAc,CACZtD,MADY,EAEZ5B,OAFY,EAGZT,YAAgC,IAAhCA,IAAaiD,eAHD,CAFkD,EAOtD2C,QAPsD,CAA9C,CAApB;AAnBsB,SADxB;AAiCA,eAAO3C,eAAA,KAAoBmC,KAAMxB,CAAAA,KAAMmC,CAAAA,aAAhC,IAAiDX,KAAMxB,CAAAA,KAAMkC,CAAAA,YAA7D,IAAuF,CAAvF,KAA6EuB,KAA7E,IAAyGjI,gBAAiBkD,CAAAA,aAAjB,CAA+BqF,mBAA/B,EAAoD,CAClKlI,SAAUwD,eAAgBxD,CAAAA,QADwI,EAElKmI,aAAc3E,eAAgB2E,CAAAA,YAFoI,EAGlKC,UAAW/B,YAHuJ,EAI3JwB,KAJ2J,EAKlK1B,SAAU8B,WAAA,EALwJ,EAMlK/B,aAAc,CACZtD,OAAQ,IADI,EAEZ5B,OAFY,EAGZT,YAAa,CAAA,CAHD,CANoJ,CAApD,CAAzG,GAWF0H,WAAA,EAXL;AArD2D,OAAtD,EAiEJ,IAjEI,CAAP;AA1EuE;AAgKzEI,YAASA,0BAAyB,CAACC,QAAD,CAAW;AAC3C,aAAOA,QAAP,GAAkB,+FAAlB;AAD2C;AAG7CC,YAASA,qBAAoB,CAACD,QAAD,CAAW;AACtC,UAAIE,MAAM7I,gBAAiBC,CAAAA,UAAjB,CAA4BgB,iBAA5B,CAAV;AACC4H,SAAD,IAAO7J,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+BsI,yBAAA,CAA0BC,QAA1B,CAA/B,CAAP;AACA,aAAOE,GAAP;AAHsC;AAKxCC,YAASA,mBAAkB,CAACH,QAAD,CAAW;AACpC,UAAI7F,QAAQ9C,gBAAiBC,CAAAA,UAAjB,CAA4B8I,sBAA5B,CAAZ;AACCjG,WAAD,IAAS9D,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+BsI,yBAAA,CAA0BC,QAA1B,CAA/B,CAAT;AACA,aAAO7F,KAAP;AAHoC;AAYtCkG,YAASA,kBAAiB,CAACL,QAAD,CAAW;AANnC,UAAInE,QAAQxE,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAAZ;AACC2D,WAAD,IAASxF,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+BsI,yBAAA,CAMZC,QANY,CAA/B,CAAT;AAOIM,WAAAA,GANGzE,KAMenD,CAAAA,OAAN,CANTmD,KAM6BnD,CAAAA,OAAQ7B,CAAAA,MAA5B,GAAqC,CAArC,CAAZyJ;AACHA,WAAUzE,CAAAA,KAAMqC,CAAAA,EAAjB,IAAsB7H,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+BuI,QAA/B,GAA0C,wDAA1C,CAAtB;AACA,aAAOM,KAAUzE,CAAAA,KAAMqC,CAAAA,EAAvB;AAJmC;AAmFrCqC,YAASA,cAAa,EAAG;AACvB,UAAIC,aAAJ;AACA,UAAIjB,QAAQlI,gBAAiBC,CAAAA,UAAjB,CAA4BmJ,iBAA5B,CAAZ,EACItG,QAAQgG,kBAAA,CAAmBO,mBAAoBC,CAAAA,aAAvC,CADZ,EAEIC,UAAUP,iBAAA,CAAkBK,mBAAoBC,CAAAA,aAAtC,CAFd;AAMA,aAAc7D,IAAAA,EAAd,KAAIyC,KAAJ,GACSA,KADT,GAKyC,IAAlC,KAACiB,aAAD,GAAiBrG,KAAMkE,CAAAA,MAAvB,IAAyC,IAAK,EAA9C,GAAkDmC,aAAA,CAAcI,OAAd,CALzD;AARuB;AAmBzBC,YAASA,cAAa,EAAG;AACvB,UAAInG,QAAQrD,gBAAiBC,CAAAA,UAAjB,CAA4BwJ,YAA5B,CAAZ;AACA,aAAgB,IAAT,IAAApG,KAAA,GAAgB,IAAK,EAArB,GAAyBA,KAAMqG,CAAAA,KAAtC;AAFuB;AAiFzB5I,YAASA,kBAAiB,EAAG;AAC3B,UAAI,CACF,OAAQ6I,QADN,CAAA,GAEAf,oBAAA,CAAqBgB,cAAeC,CAAAA,iBAApC,CAFJ,EAGIhD,KAAKmC,iBAAA,CAAkBK,mBAAoBQ,CAAAA,iBAAtC,CAHT,EAIIjI,YAAY5B,gBAAiB6B,CAAAA,MAAjB,CAAwB,CAAA,CAAxB,CAJhB;AAKAvB,+BAAA,CAA0B,EAAA,IAAM;AAC9BsB,iBAAUE,CAAAA,OAAV,GAAoB,CAAA,CAApB;AAD8B,OAAhC,CAAA;AAoBA,aAjBe9B,gBAAiB+B,CAAAA,WAAjBC,CAA6B,QAAS,CAACC,EAAD,EAAKC,OAAL,CAAc;AACjD,YAAK,EAArB,KAAIA,OAAJ,KACEA,OADF,GACY,EADZ;AAGAlD,cAAOmD,CAAAA,cAAP,CAAsBP,SAAUE,CAAAA,OAAhC,EAhuB0BM,+FAguB1B,CAAA;AAIKR,iBAAUE,CAAAA,OAAf,KACkB,QAAlB,KAAI,MAAOG,GAAX,GACE0H,QAAS3H,CAAAA,QAAT,CAAkBC,EAAlB,CADF,GAGE0H,QAAS3H,CAAAA,QAAT,CAAkBC,EAAlB,EAAsBhD,QAAA,CAAS,CAC7B6K,YAAajD,EADgB,CAAT,EAEnB3E,OAFmB,CAAtB,CAJF;AARiE,OAApDF,EAgBZ,CAAC2H,QAAD,EAAW9C,EAAX,CAhBY7E,CAiBf;AA1B2B;AA6B7ByC,YAASA,YAAW,CAAC/E,GAAD,EAAMqK,IAAN,EAAYC,OAAZ,CAAqB;AAClCD,UAAL,IAAcE,eAAA,CAAgBvK,GAAhB,CAAd,KACEuK,eAAA,CAAgBvK,GAAhB,CACA,GADuB,CAAA,CACvB,EAAAV,MAAOmD,CAAAA,cAAP,CAAsB,CAAA,CAAtB,EAA6B6H,OAA7B,CAFF;AADuC;AAezCE,YAASA,yBAAwB,CAACC,YAAD,EAAeC,YAAf,CAA6B;AACc3E,UAAAA,EAA1E,MAAqB,IAAhB,IAAA0E,YAAA,GAAuB,IAAK,EAA5B,GAAgCA,YAAaE,CAAAA,kBAAlD,KACEC,cAAA,CAAe,oBAAf,EAAqC,iFAArC,EAAwH,gEAAxH,CADF;AAG4E7E,UAAAA,EAA5E,MAAqB,IAAhB,IAAA0E,YAAA,GAAuB,IAAK,EAA5B,GAAgCA,YAAaxI,CAAAA,oBAAlD,KAA2FyI,YAA3F,IAA4GA,YAAazI,CAAAA,oBAAzH,IACE2I,cAAA,CAAe,sBAAf,EAAuC,iEAAvC,EAA0G,kEAA1G,CADF;AAGIF,kBAAJ,KACyC3E,IAAAA,EASvC,KATI2E,YAAaG,CAAAA,iBASjB,IARED,cAAA,CAAe,mBAAf,EAAoC,wDAApC,EAA8F,+DAA9F,CAQF,EAN4C7E,IAAAA,EAM5C,KANI2E,YAAaI,CAAAA,sBAMjB,IALEF,cAAA,CAAe,wBAAf,EAAyC,sEAAzC,EAAiH,oEAAjH,CAKF,EAHyC7E,IAAAA,EAGzC,KAHI2E,YAAanD,CAAAA,mBAGjB;AAFEqD,oBAAA,CAAe,qBAAf,EAAsC,uDAAtC,EAA+F,iEAA/F,CAEF,EAAoD7E,IAAAA,EAApD,KAAI2E,YAAaK,CAAAA,8BAAjB,IACEH,cAAA,CAAe,gCAAf,EAAiD,8EAAjD,EAAiI,4EAAjI,CAXJ;AAP4D;AA6H9DI,YAASA,WAAU,CAACC,KAAD,CAAQ;AACzB,UAAI,CACFjH,MADE,EAEFvC,MAFE,EAGF2B,KAHE,CAAA,GAIA6H,KAJJ;AAKA,aAAO/G,aAAA,CAAcF,MAAd,EAAsB+B,IAAAA,EAAtB,EAAiC3C,KAAjC,EAAwC3B,MAAxC,CAAP;AANyB;AA2G3ByJ,YAASA,MAAK,CAACC,MAAD,CAAS;AACrB7L,YAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,8JAA/B,CAAA;AADqB;AAYvB0K,YAASA,OAAM,CAACC,KAAD,CAAQ;AACrB,UAAI,CACF,SAAUC,YAAA,GAAe,GADvB,EAEFxE,QAAA,GAAW,IAFT,EAGF,SAAUyE,YAHR,EAIF/E,cAAA,GAAiBlH,MAAOmH,CAAAA,MAAOC,CAAAA,GAJ7B,EAKFhF,SALE,EAMF,OAAQ8J,UAAA,GAAa,CAAA,CANnB,EAOF/J,MAPE,CAAA,GAQA4J,KARJ;AASEhL,wBAAA,EAAF,IAAyBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,oHAA/B,CAAzB;AAIA,UAAIc,WAAW8J,YAAapI,CAAAA,OAAb,CAAqB,MAArB,EAA6B,GAA7B,CAAf;AACIuI,WAAAA,GAAoBnL,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAO,EACtDtC,QADsD,EAEtDE,SAFsD,EAGtDX,OAAQyK,UAH8C,EAItD/J,OAAQlC,QAAA,CAAS,CACf0C,qBAAsB,CAAA,CADP,CAAT,EAELR,MAFK,CAJ8C,EAAhC,EAOpB,CAACD,QAAD,EAAWC,MAAX,EAAmBC,SAAnB,EAA8B8J,UAA9B,CAPoB,CAApBC;AAQwB,cAA5B,KAAI,MAAOF,aAAX,KACEA,YADF,GACiBjM,MAAO6F,CAAAA,SAAP,CAAiBoG,YAAjB,CADjB;AAGA,UAAI,CACFvI,QAAA,GAAW,GADT,EAEF6C,MAAA,GAAS,EAFP,EAGFC,IAAA,GAAO,EAHL,EAIF1C,KAAA,GAAQ,IAJN,EAKFpD,GAAA,GAAM,SALJ,CAAA,GAMAuL,YANJ,EAOIG,kBAAkBpL,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAM;AACnD,YAAI6H,mBAAmBrM,MAAOsM,CAAAA,aAAP,CAAqB5I,QAArB,EAA+BxB,QAA/B,CAAvB;AACA,eAAwB,IAAxB,IAAImK,gBAAJ,GACS,IADT,GAGO,CACLhL,SAAU,CACRqC,SAAU2I,gBADF,EAER9F,MAFQ,EAGRC,IAHQ,EAIR1C,KAJQ,EAKRpD,GALQ,CADL,EAQLwG,cARK,CAHP;AAFmD,OAA/B,EAenB,CAAChF,QAAD,EAAWwB,QAAX,EAAqB6C,MAArB,EAA6BC,IAA7B,EAAmC1C,KAAnC,EAA0CpD,GAA1C,EAA+CwG,cAA/C,CAfmB,CAPtB;AAuBAlH,YAAOmD,CAAAA,cAAP,CAAyC,IAAzC,IAAsBiJ,eAAtB,EAA+C,0BAA/C,GAAuElK,QAAvE,GAAkF,qCAAlF,IAAyH,GAAzH,GAAgIwB,QAAhI,GAA2I6C,MAA3I,GAAoJC,IAApJ,GAA2J,8FAA3J,EAAA;AACA,aAAuB,IAAvB,IAAI4F,eAAJ,GACS,IADT,GAGoBpL,gBAAiBkD,CAAAA,aAAjB,CAA+B1C,iBAAkB4C,CAAAA,QAAjD,EAA2D,CAC7EC,MAAO8H,KADsE,CAA3D,EAEJnL,gBAAiBkD,CAAAA,aAAjB,CAA+BhD,eAAgBkD,CAAAA,QAA/C,EAAyD,CAC7DoD,QAD6D,EAEvEnD,MAAO+H,eAFgE,CAAzD,CAFI,CAHpB;AAlDqB;AA2LvBG,YAASA,aAAY,CAACC,KAAD,CAAQ;AAC3B,OAAI,CACF,SAAAhF,KADE,CAAJ,GAEIgF,KAFJ;AAGA,UAAIC,OAAOjC,aAAA,EAAX;AACIkC,WAAAA,GAA+B,UAApB,KAAA,MAAOlF,MAAP,GAAiCA,KAAA,CAASiF,IAAT,CAAjC,GAAkDjF,KAA7DkF;AACJ,aAAoB1L,gBAAiBkD,CAAAA,aAAjB,CAA+BlD,gBAAiB2L,CAAAA,QAAhD,EAA0D,IAA1D,EAAgED,KAAhE,CAApB;AAN2B;AAoB7BE,YAASA,yBAAwB,CAACpF,QAAD,EAAWlC,UAAX,CAAuB;AACnC,UAAK,EAAxB,KAAIA,UAAJ,KACEA,UADF,GACe,EADf;AAGA,UAAIZ,SAAS,EAAb;AACA1D,sBAAiB6L,CAAAA,QAASC,CAAAA,OAA1B,CAAkCtF,QAAlC,EAA4C,CAACd,OAAD,EAAUuC,KAAV,CAAA,IAAoB;AAC9D,YAAmBjI,gBAAiB+L,CAAAA,cAAjB,CAAgCrG,OAAhC,CAAnB;AAMA,cADIsG,KACA,GADW,CAAC,GAAG1H,UAAJ,EAAgB2D,KAAhB,CACX,EAAAvC,OAAQuG,CAAAA,IAAR,KAAiBjM,gBAAiB2L,CAAAA,QAAtC;AAEEjI,kBAAOb,CAAAA,IAAK/C,CAAAA,KAAZ,CAAkB4D,MAAlB,EAA0BkI,wBAAA,CAAyBlG,OAAQwG,CAAAA,KAAM1F,CAAAA,QAAvC,EAAiDwF,KAAjD,CAA1B,CAAA;AAFF,gBAAA;AAKEtG,mBAAQuG,CAAAA,IAAV,KAAmBrB,KAAnB,IAA4B5L,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,GAA/B,IAA8D,QAAxB,KAAA,MAAOsF,QAAQuG,CAAAA,IAAf,GAAmCvG,OAAQuG,CAAAA,IAA3C,GAAkDvG,OAAQuG,CAAAA,IAAKE,CAAAA,IAArG,IAA6G,gIAA7G,CAA5B;AACGzG,mBAAQwG,CAAAA,KAAMjE,CAAAA,KAAjB,IAA2BvC,OAAQwG,CAAAA,KAAM1F,CAAAA,QAAzC,IAAqDxH,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAA+B,0CAA/B,CAArD;AACA,gBAAIoE,QAAQ,CACVqC,GAAInB,OAAQwG,CAAAA,KAAMrF,CAAAA,EAAlBA,IAAwBmF,KAAS3G,CAAAA,IAAT,CAAc,GAAd,CADd,EAEV+G,cAAe1G,OAAQwG,CAAAA,KAAME,CAAAA,aAFnB,EAGV1G,QAASA,OAAQwG,CAAAA,KAAMxG,CAAAA,OAHb,EAIVC,UAAWD,OAAQwG,CAAAA,KAAMvG,CAAAA,SAJf,EAKVsC,MAAOvC,OAAQwG,CAAAA,KAAMjE,CAAAA,KALX,EAMV3F,KAAMoD,OAAQwG,CAAAA,KAAM5J,CAAAA,IANV,EAOVyF,OAAQrC,OAAQwG,CAAAA,KAAMnE,CAAAA,MAPZ,EAQVsE,OAAQ3G,OAAQwG,CAAAA,KAAMG,CAAAA,MARZ,EASV3F,aAAchB,OAAQwG,CAAAA,KAAMxF,CAAAA,YATlB,EAUVC,cAAejB,OAAQwG,CAAAA,KAAMvF,CAAAA,aAVnB,EAWV2F,iBAAiD,IAAjDA,IAAkB5G,OAAQwG,CAAAA,KAAMvF,CAAAA,aAAhC2F,IAAuF,IAAvFA,IAAyD5G,OAAQwG,CAAAA,KAAMxF,CAAAA,YAX7D,EAYV6F,iBAAkB7G,OAAQwG,CAAAA,KAAMK,CAAAA,gBAZtB;AAaVC,mBAAQ9G,OAAQwG,CAAAA,KAAMM,CAAAA,MAbZ,EAcV5G,KAAMF,OAAQwG,CAAAA,KAAMtG,CAAAA,IAdV,CAAZ;AAgBIF,mBAAQwG,CAAAA,KAAM1F,CAAAA,QAAlB,KACEhC,KAAMgC,CAAAA,QADR,GACmBoF,wBAAA,CAAyBlG,OAAQwG,CAAAA,KAAM1F,CAAAA,QAAvC,EAAiDwF,KAAjD,CADnB;AAGAtI,kBAAOb,CAAAA,IAAP,CAAY2B,KAAZ,CAAA;AA1BA;AANA;AAD8D,OAAhE,CAAA;AAmCA,aAAOd,MAAP;AAxCsD;AAkDxD+I,YAASA,mBAAkB,CAACjI,KAAD,CAAQ;AACjC,UAAIkI,UAAU,CAGZJ,iBAAyC,IAAzCA,IAAkB9H,KAAMmC,CAAAA,aAAxB2F,IAAuE,IAAvEA,IAAiD9H,KAAMkC,CAAAA,YAH3C,CAAd;AAKIlC,WAAMmB,CAAAA,SAAV,KAEQnB,KAAMkB,CAAAA,OAIZ,IAHI1G,MAAOmD,CAAAA,cAAP,CAAsB,CAAA,CAAtB,EAA6B,iGAA7B,CAGJ,EAAAjD,MAAOC,CAAAA,MAAP,CAAcuN,OAAd,EAAuB,CACrBhH,QAAsB1F,gBAAiBkD,CAAAA,aAAjB,CAA+BsB,KAAMmB,CAAAA,SAArC,CADD,EAErBA,UAAWF,IAAAA,EAFU,CAAvB,CANF;AAWIjB,WAAMmD,CAAAA,eAAV,KAEQnD,KAAMoD,CAAAA,sBAIZ,IAHI5I,MAAOmD,CAAAA,cAAP,CAAsB,CAAA,CAAtB,EAA6B,4HAA7B,CAGJ,EAAAjD,MAAOC,CAAAA,MAAP,CAAcuN,OAAd,EAAuB,CACrB9E,uBAAqC5H,gBAAiBkD,CAAAA,aAAjB,CAA+BsB,KAAMmD,CAAAA,eAArC,CADhB,EAErBA,gBAAiBlC,IAAAA,EAFI,CAAvB,CANF;AAWIjB,WAAMmC,CAAAA,aAAV,KAEQnC,KAAMkC,CAAAA,YAIZ,IAHI1H,MAAOmD,CAAAA,cAAP,CAAsB,CAAA,CAAtB,EAA6B,8GAA7B,CAGJ,EAAAjD,MAAOC,CAAAA,MAAP,CAAcuN,OAAd,EAAuB,CACrBhG,aAA2B1G,gBAAiBkD,CAAAA,aAAjB,CAA+BsB,KAAMmC,CAAAA,aAArC,CADN,EAErBA,cAAelB,IAAAA,EAFM,CAAvB,CANF;AAWA,aAAOiH,OAAP;AAvCiC;AAp5CnC,QAAI1M,mBAlBJ2M,QAA0B,CAACC,CAAD,CAAI;AAC5B,UAAIA,CAAJ,IAASA,CAAEC,CAAAA,UAAX;AAAuB,eAAOD,CAAP;AAAvB;AACA,UAAIE,IAAI5N,MAAO6N,CAAAA,MAAP,CAAc,IAAd,CAAR;AACIH,OAAJ,IACE1N,MAAOoI,CAAAA,IAAP,CAAYsF,CAAZ,CAAed,CAAAA,OAAf,CAAuB,QAAS,CAACkB,CAAD,CAAI;AAClC,YAAU,SAAV,KAAIA,CAAJ,CAAqB;AACnB,cAAIC,IAAI/N,MAAOgO,CAAAA,wBAAP,CAAgCN,CAAhC,EAAmCI,CAAnC,CAAR;AACA9N,gBAAOiO,CAAAA,cAAP,CAAsBL,CAAtB,EAAyBE,CAAzB,EAA4BC,CAAEG,CAAAA,GAAF,GAAQH,CAAR,GAAY,CACtCI,WAAY,CAAA,CAD0B,EAEtCD,IAAKA,QAAS,EAAG;AAAE,mBAAOR,CAAA,CAAEI,CAAF,CAAP;AAAF,WAFqB,CAAxC,CAAA;AAFmB;AADa,OAApC,CADF;AAWAF,OAAA,CAAE,SAAF,CAAA,GAAeF,CAAf;AACA,aAAO1N,MAAOoO,CAAAA,MAAP,CAAcR,CAAd,CAAP;AAf4B,KAkBM,CAAkBhO,KAAlB,CAApC;AAmBA,UAAMmC,oBAAiCjB,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAAvC;AAEEtM,qBAAkBuM,CAAAA,WAAlB,GAAgC,YAAhC;AAEF,UAAMzE,yBAAsC/I,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAA5C;AAEExE,0BAAuByE,CAAAA,WAAvB,GAAqC,iBAArC;AAEF,UAAM/D,eAA4BzJ,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAAlC;AAEE9D,gBAAa+D,CAAAA,WAAb,GAA2B,OAA3B;AAaF,UAAMhN,oBAAiCR,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAAvC;AAEE/M,qBAAkBgN,CAAAA,WAAlB,GAAgC,YAAhC;AAEF,UAAMtN,kBAA+BF,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAArC;AAEErN,mBAAgBsN,CAAAA,WAAhB,GAA8B,UAA9B;AAEF,UAAM3M,eAA4Bb,gBAAiBuN,CAAAA,aAAjB,CAA+B,CAC/DtK,OAAQ,IADuD,EAE/D5B,QAAS,EAFsD,EAG/DT,YAAa,CAAA,CAHkD,CAA/B,CAAlC;AAMEC,gBAAa2M,CAAAA,WAAb,GAA2B,OAA3B;AAEF,UAAMpE,oBAAiCpJ,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAAvC;AAEEnE,qBAAkBoE,CAAAA,WAAlB,GAAgC,YAAhC;AAgLF,UAAMrK,gBAA6BnD,gBAAiBuN,CAAAA,aAAjB,CAA+B,IAA/B,CAAnC,EAqNMnF,sBAAmCpI,gBAAiBkD,CAAAA,aAAjB,CA9BzCuK,QAA8B,EAAG;AAC/B,UAAIvF,QAAQgB,aAAA,EAAZ;AACA,UAAIc,UAAUhL,MAAO0O,CAAAA,oBAAP,CAA4BxF,KAA5B,CAAA,GAAqCA,KAAMyF,CAAAA,MAA3C,GAAoD,GAApD,GAA0DzF,KAAM0F,CAAAA,UAAhE,GAA6E1F,KAAA,YAAiB2F,KAAjB,GAAyB3F,KAAM8B,CAAAA,OAA/B,GAAyCxI,IAAKC,CAAAA,SAAL,CAAeyG,KAAf,CAApI,EACI4F,QAAQ5F,KAAA,YAAiB2F,KAAjB,GAAyB3F,KAAM4F,CAAAA,KAA/B,GAAuC,IADnD,EAGIC,YAAY,CACdC,QAAS,QADK,EAEdC,gBAHcC,wBACA,CAHhB,EAOIC,aAAa,CACfH,QAAS,SADM,EAEfC,gBAPcC,wBAKC,CAPjB;AAaEE,aAAQlG,CAAAA,KAAR,CAAc,sDAAd,EAAsEA,KAAtE,CAAA;AACAmG,WAAA,GAAuBrO,gBAAiBkD,CAAAA,aAAjB,CAA+BlD,gBAAiB2L,CAAAA,QAAhD,EAA0D,IAA1D,EAA6E3L,gBAAiBkD,CAAAA,aAAjB,CAA+B,GAA/B,EAAoC,IAApC,EAA0C,yCAA1C,CAA7E,EAAgLlD,gBAAiBkD,CAAAA,aAAjB,CAA+B,GAA/B,EAAoC,IAApC,EAA0C,8FAA1C,EAAuJlD,gBAAiBkD,CAAAA,aAAjB,CAA+B,MAA/B,EAAuC,CACnYoL,MAAOH,UAD4X,CAAvC,EAE3V,eAF2V,CAAvJ,EAElL,KAFkL,EAE3K,GAF2K,EAEzJnO,gBAAiBkD,CAAAA,aAAjB,CAA+B,MAA/B,EAAuC,CACnFoL,MAAOH,UAD4E,CAAvC,EAE3C,cAF2C,CAFyJ,EAInL,sBAJmL,CAAhL,CAAvB;AAMF,aAAoBnO,gBAAiBkD,CAAAA,aAAjB,CAA+BlD,gBAAiB2L,CAAAA,QAAhD,EAA0D,IAA1D,EAA6E3L,gBAAiBkD,CAAAA,aAAjB,CAA+B,IAA/B,EAAqC,IAArC,EAA2C,+BAA3C,CAA7E,EAAuKlD,gBAAiBkD,CAAAA,aAAjB,CAA+B,IAA/B,EAAqC,CAC9NoL,MAAO,CACLC,UAAW,QADN,CADuN,CAArC,EAIxLvE,OAJwL,CAAvK,EAIP8D,KAAA,GAAqB9N,gBAAiBkD,CAAAA,aAAjB,CAA+B,KAA/B,EAAsC,CACtEoL,MAAOP,SAD+D,CAAtC,EAE/BD,KAF+B,CAArB,GAED,IANQ,EAMFO,KANE,CAApB;AAtB+B,KA8BQ,EAAsD,IAAtD,CArNzC;AAsNA,SAAM9F,oBAAN,QAAkCvI,iBAAiB2F,CAAAA,SAAnD;AACE6I,iBAAW,CAACtC,KAAD,CAAQ;AACjB,aAAA,CAAMA,KAAN,CAAA;AACA,YAAKpJ,CAAAA,KAAL,GAAa,CACXzC,SAAU6L,KAAM7L,CAAAA,QADL,EAEXmI,aAAc0D,KAAM1D,CAAAA,YAFT,EAGXN,MAAOgE,KAAMhE,CAAAA,KAHF,CAAb;AAFiB;AAQZuG,qCAAwB,CAACvG,KAAD,CAAQ;AACrC,eAAO,CACEA,KADF,CAAP;AADqC;AAKhCwG,qCAAwB,CAACxC,KAAD,EAAQpJ,KAAR,CAAe;AAS5C,eAAIA,KAAMzC,CAAAA,QAAV,KAAuB6L,KAAM7L,CAAAA,QAA7B,IAAgE,MAAhE,KAAyCyC,KAAM0F,CAAAA,YAA/C,IAAiG,MAAjG,KAA0E0D,KAAM1D,CAAAA,YAAhF,GACS,CACLN,MAAOgE,KAAMhE,CAAAA,KADR,EAEL7H,SAAU6L,KAAM7L,CAAAA,QAFX,EAGLmI,aAAc0D,KAAM1D,CAAAA,YAHf,CADT,GAYO,CACLN,MAAuBzC,IAAAA,EAAhB,KAAAyG,KAAMhE,CAAAA,KAAN,GAA4BgE,KAAMhE,CAAAA,KAAlC,GAA0CpF,KAAMoF,CAAAA,KADlD,EAEL7H,SAAUyC,KAAMzC,CAAAA,QAFX,EAGLmI,aAAc0D,KAAM1D,CAAAA,YAApBA,IAAoC1F,KAAM0F,CAAAA,YAHrC,CAZP;AAT4C;AA2B9CmG,uBAAiB,CAACzG,KAAD,EAAQ0G,SAAR,CAAmB;AAClCR,eAAQlG,CAAAA,KAAR,CAAc,uDAAd,EAAuEA,KAAvE,EAA8E0G,SAA9E,CAAA;AADkC;AAGpCC,YAAM,EAAG;AACP,eAA4BpJ,IAAAA,EAArB,KAAA,IAAK3C,CAAAA,KAAMoF,CAAAA,KAAX,GAA8ClI,gBAAiBkD,CAAAA,aAAjB,CAA+BrC,YAAauC,CAAAA,QAA5C,EAAsD,CACzGC,MAAO,IAAK6I,CAAAA,KAAM3F,CAAAA,YADuF,CAAtD,EAErCvG,gBAAiBkD,CAAAA,aAAjB,CAA+BkG,iBAAkBhG,CAAAA,QAAjD,EAA2D,CACzEC,MAAO,IAAKP,CAAAA,KAAMoF,CAAAA,KADuD,EAEzE1B,SAAU,IAAK0F,CAAAA,KAAMzD,CAAAA,SAFoD,CAA3D,CAFqC,CAA9C,GAKD,IAAKyD,CAAAA,KAAM1F,CAAAA,QALjB;AADO;AA5CX;AAmNA,QAAIoD,iBAA8B,QAAS,CAACA,cAAD,CAAiB;AAC1DA,oBAAA,CAAA,UAAA,GAA+B,YAA/B;AACAA,oBAAA,CAAA,cAAA,GAAmC,gBAAnC;AACAA,oBAAA,CAAA,iBAAA,GAAsC,aAAtC;AACA,aAAOA,cAAP;AAJ0D,KAA1B,CAKhCA,cALgC,IAKd,EALc,CAAlC,EAMIP,sBAAmC,QAAS,CAACA,mBAAD,CAAsB;AACpEA,yBAAA,CAAA,UAAA,GAAoC,YAApC;AACAA,yBAAA,CAAA,aAAA,GAAuC,eAAvC;AACAA,yBAAA,CAAA,aAAA,GAAuC,eAAvC;AACAA,yBAAA,CAAA,aAAA,GAAuC,eAAvC;AACAA,yBAAA,CAAA,aAAA,GAAuC,eAAvC;AACAA,yBAAA,CAAA,kBAAA,GAA4C,oBAA5C;AACAA,yBAAA,CAAA,UAAA,GAAoC,YAApC;AACAA,yBAAA,CAAA,cAAA,GAAwC,gBAAxC;AACAA,yBAAA,CAAA,iBAAA,GAA2C,aAA3C;AACAA,yBAAA,CAAA,UAAA,GAAoC,YAApC;AACA,aAAOA,mBAAP;AAXoE,KAA/B,CAYrCA,mBAZqC,IAYd,EAZc,CANvC;AAyJA,QAAIyF,YAAY,CAAhB;AAiGA,UAAM7E,kBAAkB,EAAxB,EAQM8E,gBAAgB,EARtB,EAeMzE,iBAAiB,CAAC0E,IAAD,EAAOC,GAAP,EAAYC,IAAZ,CAAA5E,IAAqB;AAAe,UAAA,GAAA,uCAAA,GAAoD2E,GAApD,GAA0D,qBAA1D,IAAwFD,IAAxF,GAA+F,2DAA/F,KAAoKE,IAApK,GAA2K,GAA3K;AALpDH,mBAAA,CAAc/E,IAAd,CAAL,KACE+E,aAAA,CAAc/E,IAAd,CACA,GADyB,CAAA,CACzB,EAAAoE,OAAQe,CAAAA,IAAR,CAAanF,IAAb,CAFF;AAK0C,KAf5C,EA6DMoF,sBAAsBpP,gBAAA,CAAA,eA7D5B;AA4VA,QAAIqP,oBAAiC,QAAS,CAACA,iBAAD,CAAoB;AAChEA,uBAAA,CAAkBA,iBAAA,CAAA,OAAlB,GAAiD,CAAjD,CAAA,GAAsD,SAAtD;AACAA,uBAAA,CAAkBA,iBAAA,CAAA,OAAlB,GAAiD,CAAjD,CAAA,GAAsD,SAAtD;AACAA,uBAAA,CAAkBA,iBAAA,CAAA,KAAlB,GAA+C,CAA/C,CAAA,GAAoD,OAApD;AACA,aAAOA,iBAAP;AAJgE,KAA7B,CAKnCA,iBALmC,IAKd,EALc,CAArC;AAMA,UAAMC,sBAAsB,IAAIC,OAAJ,CAAY,EAAA,IAAM;KAAlB,CAA5B;AACA,SAAMC,mBAAN,QAAiCxP,iBAAiB2F,CAAAA,SAAlD;AACE6I,iBAAW,CAACtC,KAAD,CAAQ;AACjB,aAAA,CAAMA,KAAN,CAAA;AACA,YAAKpJ,CAAAA,KAAL,GAAa,CACXoF,MAAO,IADI,CAAb;AAFiB;AAMZuG,qCAAwB,CAACvG,KAAD,CAAQ;AACrC,eAAO,CACLA,KADK,CAAP;AADqC;AAKvCyG,uBAAiB,CAACzG,KAAD,EAAQ0G,SAAR,CAAmB;AAClCR,eAAQlG,CAAAA,KAAR,CAAc,wDAAd,EAAkEA,KAAlE,EAAyE0G,SAAzE,CAAA;AADkC;AAGpCC,YAAM,EAAG;AACP,YAAI,CACFrI,QADE,EAEFE,YAFE,EAGF+I,OAHE,CAAA,GAIA,IAAKvD,CAAAA,KAJT,EAKIwD,UAAU,IALd,EAMI/B,SAAS0B,iBAAkBM,CAAAA,OAN/B;AAOA,YAAMF,OAAN,YAAyBF,OAAzB;AAUO,cAAI,IAAKzM,CAAAA,KAAMoF,CAAAA,KAAf,CAAsB;AAE3ByF,kBAAA,GAAS0B,iBAAkBnH,CAAAA,KAA3B;AACA,gBAAI0H,cAAc,IAAK9M,CAAAA,KAAMoF,CAAAA,KAA7B;AACAwH,mBAAA,GAAUH,OAAQM,CAAAA,MAAR,EAAiBC,CAAAA,KAAjB,CAAuB,EAAA,IAAM;aAA7B,CAAV;AACA5Q,kBAAOiO,CAAAA,cAAP,CAAsBuC,OAAtB,EAA+B,UAA/B,EAA2C,CACzCtC,IAAK,EAAAA,IAAM,CAAA,CAD8B,CAA3C,CAAA;AAGAlO,kBAAOiO,CAAAA,cAAP,CAAsBuC,OAAtB,EAA+B,QAA/B,EAAyC,CACvCtC,IAAK,EAAAA,IAAMwC,WAD4B,CAAzC,CAAA;AAR2B,WAAtB;AAWIH,mBAAQM,CAAAA,QAAZ,IAELL,OACA,GADUD,OACV,EAAA9B,MAAA,GAAS,QAAA,IAAY+B,OAAZ,GAAsBL,iBAAkBnH,CAAAA,KAAxC,GAAgD,OAAA,IAAWwH,OAAX,GAAqBL,iBAAkBW,CAAAA,OAAvC,GAAiDX,iBAAkBM,CAAAA,OAHvH,KAMLhC,MAIA,GAJS0B,iBAAkBM,CAAAA,OAI3B,EAHAzQ,MAAOiO,CAAAA,cAAP,CAAsBsC,OAAtB,EAA+B,UAA/B,EAA2C,CACzCrC,IAAK,EAAAA,IAAM,CAAA,CAD8B,CAA3C,CAGA,EAAAsC,OAAA,GAAUD,OAAQQ,CAAAA,IAAR,CAAaxE,IAAA,IAAQvM,MAAOiO,CAAAA,cAAP,CAAsBsC,OAAtB,EAA+B,OAA/B,EAAwC,CACrErC,IAAK,EAAAA,IAAM3B,IAD0D,CAAxC,CAArB,EAENvD,KAAA,IAAShJ,MAAOiO,CAAAA,cAAP,CAAsBsC,OAAtB,EAA+B,QAA/B,EAAyC,CACpDrC,IAAK,EAAAA,IAAMlF,KADyC,CAAzC,CAFH,CAVL,CAAA;AAXA;AAVP;AAEEyF,gBAKA,GALS0B,iBAAkBW,CAAAA,OAK3B,EAJAN,OAIA,GAJUH,OAAQE,CAAAA,OAAR,EAIV,EAHAvQ,MAAOiO,CAAAA,cAAP,CAAsBuC,OAAtB,EAA+B,UAA/B,EAA2C,CACzCtC,IAAK,EAAAA,IAAM,CAAA,CAD8B,CAA3C,CAGA,EAAAlO,MAAOiO,CAAAA,cAAP,CAAsBuC,OAAtB,EAA+B,OAA/B,EAAwC,CACtCtC,IAAK,EAAAA,IAAMqC,OAD2B,CAAxC,CAAA;AAPF;AAqCA,YAAI9B,MAAJ,KAAe0B,iBAAkBnH,CAAAA,KAAjC,IAA0CwH,OAAQQ,CAAAA,MAAlD,YAAoElR,MAAOmR,CAAAA,oBAA3E;AAEE,gBAAMb,mBAAN;AAFF;AAIA,YAAI3B,MAAJ,KAAe0B,iBAAkBnH,CAAAA,KAAjC,IAA0C,CAACxB,YAA3C;AAEE,gBAAMgJ,OAAQQ,CAAAA,MAAd;AAFF;AAIA,YAAIvC,MAAJ,KAAe0B,iBAAkBnH,CAAAA,KAAjC;AAEE,iBAAoBlI,gBAAiBkD,CAAAA,aAAjB,CAA+BuG,YAAarG,CAAAA,QAA5C,EAAsD,CACxEC,MAAOqM,OADiE,EAExElJ,SAAUE,YAF8D,CAAtD,CAApB;AAFF;AAOA,YAAIiH,MAAJ,KAAe0B,iBAAkBW,CAAAA,OAAjC;AAEE,iBAAoBhQ,gBAAiBkD,CAAAA,aAAjB,CAA+BuG,YAAarG,CAAAA,QAA5C,EAAsD,CACxEC,MAAOqM,OADiE,EAE9DlJ,QAF8D,CAAtD,CAApB;AAFF;AASA,cAAMkJ,OAAN;AArEO;AAfX;AA6NAxQ,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,sBAA/B,EAAuD,CACrD8O,WAAY,CAAA,CADyC,EAErDD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOmR,CAAAA,oBAAd;AAAF,KAFoC,CAAvD,CAAA;AAIAjR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,gBAA/B,EAAiD,CAC/C8O,WAAY,CAAA,CADmC,EAE/CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOmH,CAAAA,MAAd;AAAF,KAF8B,CAAjD,CAAA;AAIAjH,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,YAA/B,EAA6C,CAC3C8O,WAAY,CAAA,CAD+B,EAE3CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOoR,CAAAA,UAAd;AAAF,KAF0B,CAA7C,CAAA;AAIAlR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,OAA/B,EAAwC,CACtC8O,WAAY,CAAA,CAD0B,EAEtCD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOqR,CAAAA,KAAd;AAAF,KAFqB,CAAxC,CAAA;AAIAnR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,cAA/B,EAA+C,CAC7C8O,WAAY,CAAA,CADiC,EAE7CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOsR,CAAAA,YAAd;AAAF,KAF4B,CAA/C,CAAA;AAIApR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,sBAA/B,EAAuD,CACrD8O,WAAY,CAAA,CADyC,EAErDD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAO0O,CAAAA,oBAAd;AAAF,KAFoC,CAAvD,CAAA;AAIAxO,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,MAA/B,EAAuC,CACrC8O,WAAY,CAAA,CADyB,EAErCD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOuR,CAAAA,IAAd;AAAF,KAFoB,CAAvC,CAAA;AAIArR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,WAA/B,EAA4C,CAC1C8O,WAAY,CAAA,CAD8B,EAE1CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOwR,CAAAA,SAAd;AAAF,KAFyB,CAA5C,CAAA;AAIAtR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,aAA/B,EAA8C,CAC5C8O,WAAY,CAAA,CADgC,EAE5CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOsG,CAAAA,WAAd;AAAF,KAF2B,CAA9C,CAAA;AAIApG,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,WAA/B,EAA4C,CAC1C8O,WAAY,CAAA,CAD8B,EAE1CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAO6F,CAAAA,SAAd;AAAF,KAFyB,CAA5C,CAAA;AAIA3F,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,UAA/B,EAA2C,CACzC8O,WAAY,CAAA,CAD6B,EAEzCD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAOyR,CAAAA,QAAd;AAAF,KAFwB,CAA3C,CAAA;AAIAvR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,kBAA/B,EAAmD,CACjD8O,WAAY,CAAA,CADqC,EAEjDD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAO0R,CAAAA,gBAAd;AAAF,KAFgC,CAAnD,CAAA;AAIAxR,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,SAA/B,EAA0C,CACxC8O,WAAY,CAAA,CAD4B,EAExCD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAO4D,CAAAA,OAAd;AAAF,KAFuB,CAA1C,CAAA;AAIA1D,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,aAA/B,EAA8C,CAC5C8O,WAAY,CAAA,CADgC,EAE5CD,IAAKA,QAAS,EAAG;AAAE,aAAOpO,MAAO2R,CAAAA,WAAd;AAAF,KAF2B,CAA9C,CAAA;AAIApS,WAAQqS,CAAAA,KAAR,GAvSAA,QAAc,CAACC,KAAD,CAAQ;AACpB,UAAI,CACFrK,QADE,EAEFE,YAFE,EAGF+I,OAHE,CAAA,GAIAoB,KAJJ;AAKA,aAAoB7Q,gBAAiBkD,CAAAA,aAAjB,CAA+BsM,kBAA/B,EAAmD,CAC5DC,OAD4D,EAEvD/I,YAFuD,CAAnD,EAGJ1G,gBAAiBkD,CAAAA,aAAjB,CAA+BqI,YAA/B,EAA6C,IAA7C,EAAmD/E,QAAnD,CAHI,CAApB;AANoB,KAuStB;AACAjI,WAAQuS,CAAAA,YAAR,GA/dAA,QAAqB,CAACC,KAAD,CAAQ;AAC3B,UAAI,CACF7P,QADE,EAEFsF,QAFE,EAGFwK,cAHE,EAIFC,YAJE,EAKF9P,MALE,CAAA,GAMA4P,KANJ;AAOIG,WAAAA,GAAalR,gBAAiB6B,CAAAA,MAAjB,EAAbqP;AACsB,UAA1B,IAAIA,KAAWpP,CAAAA,OAAf,KACEoP,KAAWpP,CAAAA,OADb,GACuB9C,MAAOmS,CAAAA,mBAAP,CAA2B,CAC9CH,cAD8C,EAE9CC,YAF8C,EAG9CG,SAAU,CAAA,CAHoC,CAA3B,CADvB;AAOA,UAAIC,UAAUH,KAAWpP,CAAAA,OAAzB,EACI,CAACgB,KAAD,EAAQwO,YAAR,CAAA,GAAwBtR,gBAAiBuR,CAAAA,QAAjB,CAA0B,CACpDlF,OAAQgF,OAAQhF,CAAAA,MADoC,EAEpDhM,SAAUgR,OAAQhR,CAAAA,QAFkC,CAA1B,CAD5B,EAKI,CACFgK,kBADE,CAAA,GAEAlJ,MAFA,IAEU,EAPd,EAQIqQ,WAAWxR,gBAAiB+B,CAAAA,WAAjB,CAA6B0P,QAAA,IAAY;AACtDpH,0BAAA,IAAsB+E,mBAAtB,GAA4CA,mBAAA,CAAoB,EAAA,IAAMkC,YAAA,CAAaG,QAAb,CAA1B,CAA5C,GAAgGH,YAAA,CAAaG,QAAb,CAAhG;AADsD,OAAzC,EAEZ,CAACH,YAAD,EAAejH,kBAAf,CAFY,CARf;AAWArK,sBAAiBU,CAAAA,eAAjB,CAAiC,EAAA,IAAM2Q,OAAQK,CAAAA,MAAR,CAAeF,QAAf,CAAvC,EAAiE,CAACH,OAAD,EAAUG,QAAV,CAAjE,CAAA;AACAxR,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAMzH,wBAAA,CAAyB/I,MAAzB,CAAjC,EAAmE,CAACA,MAAD,CAAnE,CAAA;AACA,aAAoBnB,gBAAiBkD,CAAAA,aAAjB,CAA+B4H,MAA/B,EAAuC,CAC/C5J,QAD+C,EAE/CsF,QAF+C,EAGzDnG,SAAUyC,KAAMzC,CAAAA,QAHyC,EAIzD6F,eAAgBpD,KAAMuJ,CAAAA,MAJmC,EAKzDjL,UAAWiQ,OAL8C,EAMjDlQ,MANiD,CAAvC,CAApB;AA7B2B,KA+d7B;AACA5C,WAAQqT,CAAAA,QAAR,GAjbAA,QAAiB,CAACC,KAAD,CAAQ;AACvB,UAAI,CACF5P,EADE,EAEFW,OAFE,EAGFE,KAHE,EAIFL,QAJE,CAAA,GAKAoP,KALJ;AAMC9R,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,iFAFwB,CAAxB;AAGA,UAAI,CACFe,MADE,EAEF,OAAQ2C,QAFN,CAAA,GAGA9D,gBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CAHJ;AAIAxB,YAAOmD,CAAAA,cAAP,CAAsB,CAAC2B,QAAvB,EAAiC,yOAAjC,CAAA;AACA,OAAI,CACF,QAAAzC,KADE,CAAJ,GAEIrB,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAFJ;AAGA,UAAI,CACF,SAAUS,gBADR,CAAA,GAEAnB,WAAA,EAFJ,EAGI6B,WAAWrB,WAAA,EAHf;AAOI2B,WAAAA,GAAOtD,MAAOuD,CAAAA,SAAP,CAAiBN,EAAjB,EAAqBjD,MAAO0C,CAAAA,0BAAP,CAAkCL,KAAlC,EAA2CF,MAAOQ,CAAAA,oBAAlD,CAArB,EAA8FL,gBAA9F,EAA6H,MAA7H,KAAgHmB,QAAhH,CAAPH;AACJ,UAAIwP,WAAWtQ,IAAKC,CAAAA,SAAL,CAAea,KAAf,CAAf;AACAtC,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAM3P,QAAA,CAASR,IAAKgB,CAAAA,KAAL,CAAWsP,QAAX,CAAT,EAA+B,CAC9DlP,OAD8D,EAE9DE,KAF8D,EAG9DL,QAH8D,CAA/B,CAAjC,EAII,CAACT,QAAD,EAAW8P,QAAX,EAAqBrP,QAArB,EAA+BG,OAA/B,EAAwCE,KAAxC,CAJJ,CAAA;AAKA,aAAO,IAAP;AAhCuB,KAibzB;AACAvE,WAAQwT,CAAAA,MAAR,GA3YAA,QAAe,CAAC7F,KAAD,CAAQ;AACrB,aAAOnJ,SAAA,CAAUmJ,KAAMlJ,CAAAA,OAAhB,CAAP;AADqB,KA2YvB;AACAzE,WAAQqM,CAAAA,KAAR,GAAgBA,KAAhB;AACArM,WAAQuM,CAAAA,MAAR,GAAiBA,MAAjB;AACAvM,WAAQyT,CAAAA,cAAR,GA5jBAA,QAAuB,CAAC1L,IAAD,CAAO;AAC5B,UAAI,CACF2L,eADE,EAEF,OAAQtI,QAFN,EAGFxI,MAHE,CAAA,GAIAmF,IAJJ,EAKI,CAACxD,KAAD,EAAQwO,YAAR,CAAA,GAAwBtR,gBAAiBuR,CAAAA,QAAjB,CAA0B5H,QAAS7G,CAAAA,KAAnC,CAL5B,EAMI,CACFuH,kBADE,CAAA,GAEAlJ,MAFA,IAEU,EARd,EASIqQ,WAAWxR,gBAAiB+B,CAAAA,WAAjB,CAA6B0P,QAAA,IAAY;AAClDpH,0BAAJ,IAA0B+E,mBAA1B,GACEA,mBAAA,CAAoB,EAAA,IAAMkC,YAAA,CAAaG,QAAb,CAA1B,CADF,GAGEH,YAAA,CAAaG,QAAb,CAHF;AADsD,OAAzC,EAMZ,CAACH,YAAD,EAAejH,kBAAf,CANY,CATf;AAmBArK,sBAAiBU,CAAAA,eAAjB,CAAiC,EAAA,IAAMiJ,QAASuI,CAAAA,SAAT,CAAmBV,QAAnB,CAAvC,EAAqE,CAAC7H,QAAD,EAAW6H,QAAX,CAArE,CAAA;AACAxR,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAM;AAC/B3S,cAAOmD,CAAAA,cAAP,CAAyC,IAAzC,IAAsB8P,eAAtB,IAAiD,CAACtI,QAASxI,CAAAA,MAAO8F,CAAAA,mBAAlE,EAAuF,oIAAvF,CAAA;AAD+B,OAAjC,EAIG,EAJH,CAAA;AAKA,UAAI7F,YAAYpB,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAChC,EACL2O,WAAYxI,QAASwI,CAAAA,UADhB,EAELlM,eAAgB0D,QAAS1D,CAAAA,cAFpB,EAGL5D,GAAIyK,CAAAzK,IAAKsH,QAAS3H,CAAAA,QAAT,CAAkB8K,CAAlB,CAHJ,EAILjK,KAAM,CAACZ,EAAD,EAAKa,KAAL,EAAYsP,IAAZ,CAAAvP,IAAqB8G,QAAS3H,CAAAA,QAAT,CAAkBC,EAAlB,EAAsB,CAC/Ca,KAD+C,EAE/CuP,mBAA4B,IAAR,IAAAD,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKC,CAAAA,kBAFF,CAAtB,CAJtB,EAQLzP,QAAS,CAACX,EAAD,EAAKa,KAAL,EAAYsP,IAAZ,CAAAxP,IAAqB+G,QAAS3H,CAAAA,QAAT,CAAkBC,EAAlB,EAAsB,CAClDW,QAAS,CAAA,CADyC,EAElDE,KAFkD,EAGlDuP,mBAA4B,IAAR,IAAAD,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKC,CAAAA,kBAHC,CAAtB,CARzB,EADO,EAeb,CAAC1I,QAAD,CAfa,CAAhB,EAgBIzI,WAAWyI,QAASzI,CAAAA,QAApBA,IAAgC,GAhBpC;AAiBIF,UAAAA,GAAoBhB,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAO,EACtDxE,OAAQ2K,QAD8C,EAEtDvI,SAFsD,EAGtDX,OAAQ,CAAA,CAH8C,EAItDS,QAJsD,EAAhC,EAKpB,CAACyI,QAAD,EAAWvI,SAAX,EAAsBF,QAAtB,CALoB,CAApBF;AAMJhB,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAMzH,wBAAA,CAAyB/I,MAAzB,EAAiCwI,QAASxI,CAAAA,MAA1C,CAAjC,EAAoF,CAACwI,QAAD,EAAWxI,MAAX,CAApF,CAAA;AAQA,aAAoBnB,gBAAiBkD,CAAAA,aAAjB,CAA+BlD,gBAAiB2L,CAAAA,QAAhD,EAA0D,IAA1D,EAA6E3L,gBAAiBkD,CAAAA,aAAjB,CAA+BjC,iBAAkBmC,CAAAA,QAAjD,EAA2D,CAC1JC,MAAOrC,IADmJ,CAA3D,EAEjFhB,gBAAiBkD,CAAAA,aAAjB,CAA+B6F,sBAAuB3F,CAAAA,QAAtD,EAAgE,CAC9EC,MAAOP,KADuE,CAAhE,EAEA9C,gBAAiBkD,CAAAA,aAAjB,CAA+B4H,MAA/B,EAAuC,CAC3C5J,QAD2C,EAErDb,SAAUyC,KAAMzC,CAAAA,QAFqC,EAGrD6F,eAAgBpD,KAAMwP,CAAAA,aAH+B,EAI1ClR,SAJ0C,EAKrDD,OAAQ,CACNQ,qBAAsBgI,QAASxI,CAAAA,MAAOQ,CAAAA,oBADhC,CAL6C,CAAvC,EAQbmB,KAAMoE,CAAAA,WAAN,IAAqByC,QAASxI,CAAAA,MAAO8F,CAAAA,mBAArC,GAAwEjH,gBAAiBkD,CAAAA,aAAjB,CAA+BwH,UAA/B;AAA2C,OACpHhH,OAAQiG,QAASjG,CAAAA,MADmG,EAEpHvC,OAAQwI,QAASxI,CAAAA,MAFmG,EAG7G2B,KAH6G,CAA3C,CAAxE,GAIEmP,eAZW,CAFA,CAFiF,CAA7E,EAgBK,IAhBL,CAApB;AAzD4B,KA4jB9B;AACA1T,WAAQgU,CAAAA,MAAR,GAzTAA,QAAe,CAACC,KAAD,CAAQ;AACrB,UAAI,CACFhM,QADE,EAEFnG,QAFE,CAAA,GAGAmS,KAHJ;AAIA,aAAO/O,SAAA,CAAUmI,wBAAA,CAAyBpF,QAAzB,CAAV,EAA8CnG,QAA9C,CAAP;AALqB,KAyTvB;AACA9B,WAAQkU,CAAAA,wBAAR,GAAmCxR,iBAAnC;AACA1C,WAAQmU,CAAAA,6BAAR,GAAwC3J,sBAAxC;AACAxK,WAAQoU,CAAAA,sBAAR,GAAiCzS,eAAjC;AACA3B,WAAQqU,CAAAA,wBAAR,GAAmCpS,iBAAnC;AACAjC,WAAQsU,CAAAA,mBAAR,GAA8BhS,YAA9B;AACAtC,WAAQuU,CAAAA,+BAAR,GAA0C5I,wBAA1C;AACA3L,WAAQwU,CAAAA,yBAAR,GAAoCtG,kBAApC;AACAlO,WAAQyU,CAAAA,iBAAR,GAh1BAC,QAAmB,EAAG;AACpB,aAAOjK,iBAAA,CAAkBK,mBAAoB6J,CAAAA,UAAtC,CAAP;AADoB,KAg1BtB;AACA3U,WAAQ4U,CAAAA,oBAAR,GAA+BvP,aAA/B;AACArF,WAAQ6U,CAAAA,kBAAR,GA3FAA,QAA2B,CAAC1P,MAAD,EAAS0O,IAAT,CAAe;AACxC,aAAOpT,MAAOqU,CAAAA,YAAP,CAAoB,CACzBnS,SAAkB,IAAR,IAAAkR,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKlR,CAAAA,QADd,EAEzBC,OAAQlC,QAAA,CAAS,EAAT,EAAqB,IAAR,IAAAmT,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKjR,CAAAA,MAA1C,EAAkD,CACxDmS,mBAAoB,CAAA,CADoC,CAAlD,CAFiB,EAKzBjC,QAASrS,MAAOmS,CAAAA,mBAAP,CAA2B,CAClCH,eAAwB,IAAR,IAAAoB,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKpB,CAAAA,cADX,EAElCC,aAAsB,IAAR,IAAAmB,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKnB,CAAAA,YAFT,CAA3B,CALgB,EASzBsC,cAAuB,IAAR,IAAAnB,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKmB,CAAAA,aATnB,EAUzB7P,MAVyB,EAWzB+I,kBAXyB,EAYzB+G,aAAsB,IAAR,IAAApB,IAAA,GAAe,IAAK,EAApB,GAAwBA,IAAKoB,CAAAA,YAZlB,EAazBC,wBAAiC,IAAR,IAAArB,IAAA,GAAe,IAAK,EAApB;AAAwBA,UAAKqB,CAAAA,uBAb7B,CAApB,CAcJC,CAAAA,UAdI,EAAP;AADwC,KA2F1C;AACAnV,WAAQqN,CAAAA,wBAAR,GAAmCA,wBAAnC;AACArN,WAAQoV,CAAAA,wBAAR,GAAmC/H,wBAAnC;AACArN,WAAQqV,CAAAA,aAAR,GA3IAA,QAAsB,CAACvS,OAAD,CAAU;AAC9B,aAAOyE,cAAA,CAAezE,OAAf,CAAP;AAD8B,KA2IhC;AACA9C,WAAQsV,CAAAA,aAAR,GAxxBAA,QAAsB,EAAG;AACvB,UAAI/Q,QAAQgG,kBAAA,CAAmBO,mBAAoByK,CAAAA,aAAvC,CAAZ,EACIvK,UAAUP,iBAAA,CAAkBK,mBAAoB0K,CAAAA,aAAtC,CADd;AAEA,aAAOjR,KAAMkR,CAAAA,UAAN,GAAmBlR,KAAMkR,CAAAA,UAAN,CAAiBzK,OAAjB,CAAnB,GAA+C9D,IAAAA,EAAtD;AAHuB,KAwxBzB;AACAlH,WAAQ0V,CAAAA,aAAR,GAnvBAA,QAAsB,EAAG;AACvB,UAAI5Q,QAAQrD,gBAAiBC,CAAAA,UAAjB,CAA4BwJ,YAA5B,CAAZ;AACA,aAAgB,IAAT,IAAApG,KAAA,GAAgB,IAAK,EAArB,GAAyBA,KAAM6M,CAAAA,MAAtC;AAFuB,KAmvBzB;AACA3R,WAAQiL,CAAAA,aAAR,GAAwBA,aAAxB;AACAjL,WAAQ2V,CAAAA,UAAR,GAzuBAA,QAAmB,CAACC,WAAD,CAAc;AAC/B,UAAI,CACF,OAAQxK,QADN,EAEFzI,QAFE,CAAA,GAGA0H,oBAAA,CAAqBgB,cAAewK,CAAAA,UAApC,CAHJ,EAIItR,QAAQgG,kBAAA,CAAmBO,mBAAoB+K,CAAAA,UAAvC,CAJZ,EAKI,CAACC,UAAD,EAAaC,aAAb,CAAA,GAA8BtU,gBAAiBuR,CAAAA,QAAjB,CAA0B,EAA1B,CALlC,EAMIgD,kBAAkBvU,gBAAiB+B,CAAAA,WAAjB,CAA6ByS,GAAA,IAAO;AACxD,YAA2B,UAA3B,KAAI,MAAOL,YAAX;AACE,iBAAO,CAAC,CAACA,WAAT;AADF;AAGA,YAAiB,GAAjB,KAAIjT,QAAJ;AACE,iBAAOiT,WAAA,CAAYK,GAAZ,CAAP;AADF;AAOA,YAAI,CACFC,eADE,EAEFC,YAFE,EAGFpC,aAHE,CAAA,GAIAkC,GAJJ;AAKA,eAAOL,WAAA,CAAY,CACjBM,gBAAiBxV,QAAA,CAAS,EAAT,EAAawV,eAAb,EAA8B,CAC7C/R,SAAU1D,MAAOsM,CAAAA,aAAP,CAAqBmJ,eAAgB/R,CAAAA,QAArC,EAA+CxB,QAA/C,CAAVwB,IAAsE+R,eAAgB/R,CAAAA,QADzC,CAA9B,CADA,EAIjBgS,aAAczV,QAAA,CAAS,EAAT,EAAayV,YAAb,EAA2B,CACvChS,SAAU1D,MAAOsM,CAAAA,aAAP,CAAqBoJ,YAAahS,CAAAA,QAAlC,EAA4CxB,QAA5C,CAAVwB,IAAmEgS,YAAahS,CAAAA,QADzC,CAA3B,CAJG,EAOjB4P,aAPiB,CAAZ,CAAP;AAhBwD,OAApC,EAyBnB,CAACpR,QAAD,EAAWiT,WAAX,CAzBmB,CANtB;AAmCAnU,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAM;AAC/B,YAAIjS,MAAMiV,MAAA,CAAO,EAAE7F,SAAT,CAAV;AACAwF,qBAAA,CAAc5U,GAAd,CAAA;AACA,eAAO,EAAA,IAAMiK,QAASiL,CAAAA,aAAT,CAAuBlV,GAAvB,CAAb;AAH+B,OAAjC,EAIG,CAACiK,QAAD,CAJH,CAAA;AAUA3J,sBAAiB2R,CAAAA,SAAjB,CAA2B,EAAA,IAAM;AACZ,UAAnB,KAAI0C,UAAJ,IACE1K,QAASkL,CAAAA,UAAT,CAAoBR,UAApB,EAAgCE,eAAhC,CADF;AAD+B,OAAjC,EAIG,CAAC5K,QAAD,EAAW0K,UAAX,EAAuBE,eAAvB,CAJH,CAAA;AAQA,aAAOF,UAAA,IAAcvR,KAAMgS,CAAAA,QAASC,CAAAA,GAAf,CAAmBV,UAAnB,CAAd,GAA+CvR,KAAMgS,CAAAA,QAAS1H,CAAAA,GAAf,CAAmBiH,UAAnB,CAA/C,GAAgFrV,MAAOgW,CAAAA,YAA9F;AAtD+B,KAyuBjC;AACAzW,WAAQ0W,CAAAA,OAAR,GA39CAA,QAAgB,CAAChT,EAAD,EAAKiT,KAAL,CAAY;AAC1B,OAAI,CACF,SAAAzS,KADE,CAAJ,GAEc,IAAK,EAAf,KAAAyS,KAAA,GAAmB,EAAnB,GAAwBA,KAF5B;AAGCnV,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,0EAFwB,CAAxB;AAGA,UAAI,CACFc,QADE,EAEFE,SAFE,CAAA,GAGApB,gBAAiBC,CAAAA,UAAjB,CAA4BO,iBAA5B,CAHJ,EAII,CACFgF,IADE,EAEF9C,QAFE,EAGF6C,MAHE,CAAA,GAIAjC,eAAA,CAAgBrB,EAAhB,EAAoB,CACtBQ,SAAAA,KADsB,CAApB,CARJ;AAWI0S,QAAAA,GAAiBzS,QAAjByS;AAMa,SAAjB,KAAIjU,QAAJ,KACEiU,EADF,GACgC,GAAb,KAAAzS,QAAA,GAAmBxB,QAAnB,GAA8BlC,MAAO2D,CAAAA,SAAP,CAAiB,CAACzB,QAAD,EAAWwB,QAAX,CAAjB,CADjD;AAGA,aAAOtB,SAAU+Q,CAAAA,UAAV,CAAqB,CAC1BzP,SAAUyS,EADgB,EAE1B5P,MAF0B,EAG1BC,IAH0B,CAArB,CAAP;AA3B0B,KA29C5B;AACAjH,WAAQwB,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAxB,WAAQ6W,CAAAA,aAAR,GAnzBAA,QAAsB,EAAG;AACvB,UAAItS,QAAQgG,kBAAA,CAAmBO,mBAAoB0K,CAAAA,aAAvC,CAAZ,EACIxK,UAAUP,iBAAA,CAAkBK,mBAAoB0K,CAAAA,aAAtC,CADd;AAEA,UAAIjR,KAAMkE,CAAAA,MAAV,IAA6C,IAA7C,IAAoBlE,KAAMkE,CAAAA,MAAN,CAAauC,OAAb,CAApB;AACE6E,eAAQlG,CAAAA,KAAR,CAAc,0DAAd,GAA2EqB,OAA3E,GAAqF,GAArF,CAAA;AADF;AAIA,eAAOzG,KAAM+E,CAAAA,UAAN,CAAiB0B,OAAjB,CAAP;AAJA;AAHuB,KAmzBzB;AACAhL,WAAQ4B,CAAAA,WAAR,GAAsBA,WAAtB;AACA5B,WAAQ8W,CAAAA,QAAR,GAl5CAA,QAAiB,CAACC,OAAD,CAAU;AACxBvV,wBAAA,EAAD,IAAwBf,MAAOoB,CAAAA,gBAAP,CAAwB,CAAA,CAAxB,EAExB,2EAFwB,CAAxB;AAGA,UAAI,CACFsC,QADE,CAAA,GAEAvC,WAAA,EAFJ;AAGA,aAAOH,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAMxE,MAAOwR,CAAAA,SAAP,CAAiB8E,OAAjB,EAA0BtW,MAAOuW,CAAAA,iBAAP,CAAyB7S,QAAzB,CAA1B,CAA/B,EAA8F,CAACA,QAAD,EAAW4S,OAAX,CAA9F,CAAP;AAPyB,KAk5C3B;AACA/W,WAAQiX,CAAAA,UAAR,GAj0BAA,QAAmB,EAAG;AACpB,UAAI,CACFnU,OADE,EAEFwG,UAFE,CAAA,GAGAiB,kBAAA,CAAmBO,mBAAoBoM,CAAAA,UAAvC,CAHJ;AAIA,aAAOzV,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAMnC,OAAQ0E,CAAAA,GAAR,CAAYsB,CAAA,IAAKrI,MAAO0W,CAAAA,iCAAP,CAAyCrO,CAAzC,EAA4CQ,UAA5C,CAAjB,CAA/B,EAA0G,CAACxG,OAAD,EAAUwG,UAAV,CAA1G,CAAP;AALoB,KAi0BtB;AACAtJ,WAAQoC,CAAAA,WAAR,GAAsBA,WAAtB;AACApC,WAAQoX,CAAAA,aAAR,GAz1BAA,QAAsB,EAAG;AAEvB,aADY7M,kBAAAhG,CAAmBuG,mBAAoBuM,CAAAA,aAAvC9S,CACC+S,CAAAA,UAAb;AAFuB,KAy1BzB;AACAtX,WAAQuX,CAAAA,iBAAR,GAj6CAA,QAA0B,EAAG;AAC3B,aAAO9V,gBAAiBC,CAAAA,UAAjB,CAA4BC,eAA5B,CAA6CgG,CAAAA,cAApD;AAD2B,KAi6C7B;AACA3H,WAAQwE,CAAAA,SAAR,GAAoBA,SAApB;AACAxE,WAAQwX,CAAAA,gBAAR,GAvzCAA,QAAyB,EAAG;AAC1B,aAAO/V,gBAAiBC,CAAAA,UAAjB,CAA4BkD,aAA5B,CAAP;AAD0B,KAuzC5B;AACA5E,WAAQyX,CAAAA,SAAR,GA9xCAA,QAAkB,EAAG;AACnB,UAAI,CACF3U,OADE,CAAA,GAEArB,gBAAiBC,CAAAA,UAAjB,CAA4BY,YAA5B,CAFJ;AAIA,aAAO,CADHmD,OACG,GADU3C,OAAA,CAAQA,OAAQ7B,CAAAA,MAAhB,GAAyB,CAAzB,CACV,IAAawE,OAAWE,CAAAA,MAAxB,GAAiC,EAAxC;AALmB,KA8xCrB;AACA3F,WAAQ+E,CAAAA,eAAR,GAA0BA,eAA1B;AACA/E,WAAQ0X,CAAAA,cAAR,GAt1BAA,QAAuB,EAAG;AACxB,UAAIjV,oBAAoB4H,oBAAA,CAAqBgB,cAAesM,CAAAA,cAApC,CAAxB,EACIpT,QAAQgG,kBAAA,CAAmBO,mBAAoB6M,CAAAA,cAAvC,CADZ;AAEA,aAAOlW,gBAAiBwD,CAAAA,OAAjB,CAAyB,EAAA,IAAO,EACrC2S,WAAYnV,iBAAkBhC,CAAAA,MAAOmX,CAAAA,UADA,EAErCrT,MAAOA,KAAM0F,CAAAA,YAFwB,EAAhC,EAGH,CAACxH,iBAAkBhC,CAAAA,MAAOmX,CAAAA,UAA1B,EAAsCrT,KAAM0F,CAAAA,YAA5C,CAHG,CAAP;AAHwB,KAs1B1B;AACAjK,WAAQ2K,CAAAA,aAAR,GAAwBA,aAAxB;AACA3K,WAAQ6X,CAAAA,kBAAR,GAnzBAA,QAA2B,CAAC7M,OAAD,CAAU;AAEnC,aADYT,kBAAAhG,CAAmBuG,mBAAoBgN,CAAAA,kBAAvCvT,CACC+E,CAAAA,UAAN,CAAiB0B,OAAjB,CAAP;AAFmC,KAmzBrC;AACAhL,WAAQkF,CAAAA,SAAR,GAAoBA,SAApB;AAEAvE,UAAOiO,CAAAA,cAAP,CAAsB5O,OAAtB,EAA+B,YAA/B,EAA6C,CAAE8E,MAAO,CAAA,CAAT,CAA7C,CAAA;AAtkD0C,GAJ5C,CAAA;AAX+H,CAA/H;;\",\n\"sources\":[\"node_modules/react-router/dist/umd/react-router.development.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_router$dist$umd$react_router_development\\\"] = function(global,require,module,exports) {\\n/**\\n * React Router v6.30.0\\n *\\n * Copyright (c) Remix Software Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE.md file in the root directory of this source tree.\\n *\\n * @license MIT\\n */\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@remix-run/router')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'react', '@remix-run/router'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouter = {}, global.React, global.RemixRouter));\\n})(this, (function (exports, React, router) { 'use strict';\\n\\n  function _interopNamespace(e) {\\n    if (e && e.__esModule) return e;\\n    var n = Object.create(null);\\n    if (e) {\\n      Object.keys(e).forEach(function (k) {\\n        if (k !== 'default') {\\n          var d = Object.getOwnPropertyDescriptor(e, k);\\n          Object.defineProperty(n, k, d.get ? d : {\\n            enumerable: true,\\n            get: function () { return e[k]; }\\n          });\\n        }\\n      });\\n    }\\n    n[\\\"default\\\"] = e;\\n    return Object.freeze(n);\\n  }\\n\\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\\n\\n  function _extends() {\\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\\n      for (var i = 1; i < arguments.length; i++) {\\n        var source = arguments[i];\\n        for (var key in source) {\\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\\n            target[key] = source[key];\\n          }\\n        }\\n      }\\n      return target;\\n    };\\n    return _extends.apply(this, arguments);\\n  }\\n\\n  // Create react-specific types from the agnostic types in @remix-run/router to\\n  // export from react-router\\n  const DataRouterContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    DataRouterContext.displayName = \\\"DataRouter\\\";\\n  }\\n  const DataRouterStateContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    DataRouterStateContext.displayName = \\\"DataRouterState\\\";\\n  }\\n  const AwaitContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    AwaitContext.displayName = \\\"Await\\\";\\n  }\\n\\n  /**\\n   * A Navigator is a \\\"location changer\\\"; it's how you get to different locations.\\n   *\\n   * Every history instance conforms to the Navigator interface, but the\\n   * distinction is useful primarily when it comes to the low-level `<Router>` API\\n   * where both the location and a navigator must be provided separately in order\\n   * to avoid \\\"tearing\\\" that may occur in a suspense-enabled app if the action\\n   * and/or location were to be read directly from the history instance.\\n   */\\n\\n  const NavigationContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    NavigationContext.displayName = \\\"Navigation\\\";\\n  }\\n  const LocationContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    LocationContext.displayName = \\\"Location\\\";\\n  }\\n  const RouteContext = /*#__PURE__*/React__namespace.createContext({\\n    outlet: null,\\n    matches: [],\\n    isDataRoute: false\\n  });\\n  {\\n    RouteContext.displayName = \\\"Route\\\";\\n  }\\n  const RouteErrorContext = /*#__PURE__*/React__namespace.createContext(null);\\n  {\\n    RouteErrorContext.displayName = \\\"RouteError\\\";\\n  }\\n\\n  /**\\n   * Returns the full href for the given \\\"to\\\" value. This is useful for building\\n   * custom links that are also accessible and preserve right-click behavior.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-href\\n   */\\n  function useHref(to, _temp) {\\n    let {\\n      relative\\n    } = _temp === void 0 ? {} : _temp;\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useHref() may be used only in the context of a <Router> component.\\\")  : void 0;\\n    let {\\n      basename,\\n      navigator\\n    } = React__namespace.useContext(NavigationContext);\\n    let {\\n      hash,\\n      pathname,\\n      search\\n    } = useResolvedPath(to, {\\n      relative\\n    });\\n    let joinedPathname = pathname;\\n\\n    // If we're operating within a basename, prepend it to the pathname prior\\n    // to creating the href.  If this is a root navigation, then just use the raw\\n    // basename which allows the basename to have full control over the presence\\n    // of a trailing slash on root links\\n    if (basename !== \\\"/\\\") {\\n      joinedPathname = pathname === \\\"/\\\" ? basename : router.joinPaths([basename, pathname]);\\n    }\\n    return navigator.createHref({\\n      pathname: joinedPathname,\\n      search,\\n      hash\\n    });\\n  }\\n\\n  /**\\n   * Returns true if this component is a descendant of a `<Router>`.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-in-router-context\\n   */\\n  function useInRouterContext() {\\n    return React__namespace.useContext(LocationContext) != null;\\n  }\\n\\n  /**\\n   * Returns the current location object, which represents the current URL in web\\n   * browsers.\\n   *\\n   * Note: If you're using this it may mean you're doing some of your own\\n   * \\\"routing\\\" in your app, and we'd like to know what your use case is. We may\\n   * be able to provide something higher-level to better suit your needs.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-location\\n   */\\n  function useLocation() {\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useLocation() may be used only in the context of a <Router> component.\\\")  : void 0;\\n    return React__namespace.useContext(LocationContext).location;\\n  }\\n\\n  /**\\n   * Returns the current navigation action which describes how the router came to\\n   * the current location, either by a pop, push, or replace on the history stack.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-navigation-type\\n   */\\n  function useNavigationType() {\\n    return React__namespace.useContext(LocationContext).navigationType;\\n  }\\n\\n  /**\\n   * Returns a PathMatch object if the given pattern matches the current URL.\\n   * This is useful for components that need to know \\\"active\\\" state, e.g.\\n   * `<NavLink>`.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-match\\n   */\\n  function useMatch(pattern) {\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useMatch() may be used only in the context of a <Router> component.\\\")  : void 0;\\n    let {\\n      pathname\\n    } = useLocation();\\n    return React__namespace.useMemo(() => router.matchPath(pattern, router.UNSAFE_decodePath(pathname)), [pathname, pattern]);\\n  }\\n\\n  /**\\n   * The interface for the navigate() function returned from useNavigate().\\n   */\\n\\n  const navigateEffectWarning = \\\"You should call navigate() in a React.useEffect(), not when \\\" + \\\"your component is first rendered.\\\";\\n\\n  // Mute warnings for calls to useNavigate in SSR environments\\n  function useIsomorphicLayoutEffect(cb) {\\n    let isStatic = React__namespace.useContext(NavigationContext).static;\\n    if (!isStatic) {\\n      // We should be able to get rid of this once react 18.3 is released\\n      // See: https://github.com/facebook/react/pull/26395\\n      // eslint-disable-next-line react-hooks/rules-of-hooks\\n      React__namespace.useLayoutEffect(cb);\\n    }\\n  }\\n\\n  /**\\n   * Returns an imperative method for changing the location. Used by `<Link>`s, but\\n   * may also be used by other elements to change the location.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-navigate\\n   */\\n  function useNavigate() {\\n    let {\\n      isDataRoute\\n    } = React__namespace.useContext(RouteContext);\\n    // Conditional usage is OK here because the usage of a data router is static\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\\n  }\\n  function useNavigateUnstable() {\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useNavigate() may be used only in the context of a <Router> component.\\\")  : void 0;\\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\\n    let {\\n      basename,\\n      future,\\n      navigator\\n    } = React__namespace.useContext(NavigationContext);\\n    let {\\n      matches\\n    } = React__namespace.useContext(RouteContext);\\n    let {\\n      pathname: locationPathname\\n    } = useLocation();\\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\\n    let activeRef = React__namespace.useRef(false);\\n    useIsomorphicLayoutEffect(() => {\\n      activeRef.current = true;\\n    });\\n    let navigate = React__namespace.useCallback(function (to, options) {\\n      if (options === void 0) {\\n        options = {};\\n      }\\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\\n\\n      // Short circuit here since if this happens on first render the navigate\\n      // is useless because we haven't wired up our history listener yet\\n      if (!activeRef.current) return;\\n      if (typeof to === \\\"number\\\") {\\n        navigator.go(to);\\n        return;\\n      }\\n      let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \\\"path\\\");\\n\\n      // If we're operating within a basename, prepend it to the pathname prior\\n      // to handing off to history (but only if we're not in a data router,\\n      // otherwise it'll prepend the basename inside of the router).\\n      // If this is a root navigation, then we navigate to the raw basename\\n      // which allows the basename to have full control over the presence of a\\n      // trailing slash on root links\\n      if (dataRouterContext == null && basename !== \\\"/\\\") {\\n        path.pathname = path.pathname === \\\"/\\\" ? basename : router.joinPaths([basename, path.pathname]);\\n      }\\n      (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\\n    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\\n    return navigate;\\n  }\\n  const OutletContext = /*#__PURE__*/React__namespace.createContext(null);\\n\\n  /**\\n   * Returns the context (if provided) for the child route at this level of the route\\n   * hierarchy.\\n   * @see https://reactrouter.com/v6/hooks/use-outlet-context\\n   */\\n  function useOutletContext() {\\n    return React__namespace.useContext(OutletContext);\\n  }\\n\\n  /**\\n   * Returns the element for the child route at this level of the route\\n   * hierarchy. Used internally by `<Outlet>` to render child routes.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-outlet\\n   */\\n  function useOutlet(context) {\\n    let outlet = React__namespace.useContext(RouteContext).outlet;\\n    if (outlet) {\\n      return /*#__PURE__*/React__namespace.createElement(OutletContext.Provider, {\\n        value: context\\n      }, outlet);\\n    }\\n    return outlet;\\n  }\\n\\n  /**\\n   * Returns an object of key/value pairs of the dynamic params from the current\\n   * URL that were matched by the route path.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-params\\n   */\\n  function useParams() {\\n    let {\\n      matches\\n    } = React__namespace.useContext(RouteContext);\\n    let routeMatch = matches[matches.length - 1];\\n    return routeMatch ? routeMatch.params : {};\\n  }\\n\\n  /**\\n   * Resolves the pathname of the given `to` value against the current location.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-resolved-path\\n   */\\n  function useResolvedPath(to, _temp2) {\\n    let {\\n      relative\\n    } = _temp2 === void 0 ? {} : _temp2;\\n    let {\\n      future\\n    } = React__namespace.useContext(NavigationContext);\\n    let {\\n      matches\\n    } = React__namespace.useContext(RouteContext);\\n    let {\\n      pathname: locationPathname\\n    } = useLocation();\\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\\n    return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \\\"path\\\"), [to, routePathnamesJson, locationPathname, relative]);\\n  }\\n\\n  /**\\n   * Returns the element of the route that matched the current location, prepared\\n   * with the correct context to render the remainder of the route tree. Route\\n   * elements in the tree must render an `<Outlet>` to render their child route's\\n   * element.\\n   *\\n   * @see https://reactrouter.com/v6/hooks/use-routes\\n   */\\n  function useRoutes(routes, locationArg) {\\n    return useRoutesImpl(routes, locationArg);\\n  }\\n\\n  // Internal implementation with accept optional param for RouterProvider usage\\n  function useRoutesImpl(routes, locationArg, dataRouterState, future) {\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useRoutes() may be used only in the context of a <Router> component.\\\")  : void 0;\\n    let {\\n      navigator,\\n      static: isStatic\\n    } = React__namespace.useContext(NavigationContext);\\n    let {\\n      matches: parentMatches\\n    } = React__namespace.useContext(RouteContext);\\n    let routeMatch = parentMatches[parentMatches.length - 1];\\n    let parentParams = routeMatch ? routeMatch.params : {};\\n    let parentPathname = routeMatch ? routeMatch.pathname : \\\"/\\\";\\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \\\"/\\\";\\n    let parentRoute = routeMatch && routeMatch.route;\\n    {\\n      // You won't get a warning about 2 different <Routes> under a <Route>\\n      // without a trailing *, but this is a best-effort warning anyway since we\\n      // cannot even give the warning unless they land at the parent route.\\n      //\\n      // Example:\\n      //\\n      // <Routes>\\n      //   {/* This route path MUST end with /* because otherwise\\n      //       it will never match /blog/post/123 */}\\n      //   <Route path=\\\"blog\\\" element={<Blog />} />\\n      //   <Route path=\\\"blog/feed\\\" element={<BlogFeed />} />\\n      // </Routes>\\n      //\\n      // function Blog() {\\n      //   return (\\n      //     <Routes>\\n      //       <Route path=\\\"post/:id\\\" element={<Post />} />\\n      //     </Routes>\\n      //   );\\n      // }\\n      let parentPath = parentRoute && parentRoute.path || \\\"\\\";\\n      warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\\\"*\\\"), \\\"You rendered descendant <Routes> (or called `useRoutes()`) at \\\" + (\\\"\\\\\\\"\\\" + parentPathname + \\\"\\\\\\\" (under <Route path=\\\\\\\"\\\" + parentPath + \\\"\\\\\\\">) but the \\\") + \\\"parent route path has no trailing \\\\\\\"*\\\\\\\". This means if you navigate \\\" + \\\"deeper, the parent won't match anymore and therefore the child \\\" + \\\"routes will never render.\\\\n\\\\n\\\" + (\\\"Please change the parent <Route path=\\\\\\\"\\\" + parentPath + \\\"\\\\\\\"> to <Route \\\") + (\\\"path=\\\\\\\"\\\" + (parentPath === \\\"/\\\" ? \\\"*\\\" : parentPath + \\\"/*\\\") + \\\"\\\\\\\">.\\\"));\\n    }\\n    let locationFromContext = useLocation();\\n    let location;\\n    if (locationArg) {\\n      var _parsedLocationArg$pa;\\n      let parsedLocationArg = typeof locationArg === \\\"string\\\" ? router.parsePath(locationArg) : locationArg;\\n      !(parentPathnameBase === \\\"/\\\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? router.UNSAFE_invariant(false, \\\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \\\" + \\\"the location pathname must begin with the portion of the URL pathname that was \\\" + (\\\"matched by all parent routes. The current pathname base is \\\\\\\"\\\" + parentPathnameBase + \\\"\\\\\\\" \\\") + (\\\"but pathname \\\\\\\"\\\" + parsedLocationArg.pathname + \\\"\\\\\\\" was given in the `location` prop.\\\"))  : void 0;\\n      location = parsedLocationArg;\\n    } else {\\n      location = locationFromContext;\\n    }\\n    let pathname = location.pathname || \\\"/\\\";\\n    let remainingPathname = pathname;\\n    if (parentPathnameBase !== \\\"/\\\") {\\n      // Determine the remaining pathname by removing the # of URL segments the\\n      // parentPathnameBase has, instead of removing based on character count.\\n      // This is because we can't guarantee that incoming/outgoing encodings/\\n      // decodings will match exactly.\\n      // We decode paths before matching on a per-segment basis with\\n      // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\\n      // match what `window.location.pathname` would reflect.  Those don't 100%\\n      // align when it comes to encoded URI characters such as % and &.\\n      //\\n      // So we may end up with:\\n      //   pathname:           \\\"/descendant/a%25b/match\\\"\\n      //   parentPathnameBase: \\\"/descendant/a%b\\\"\\n      //\\n      // And the direct substring removal approach won't work :/\\n      let parentSegments = parentPathnameBase.replace(/^\\\\//, \\\"\\\").split(\\\"/\\\");\\n      let segments = pathname.replace(/^\\\\//, \\\"\\\").split(\\\"/\\\");\\n      remainingPathname = \\\"/\\\" + segments.slice(parentSegments.length).join(\\\"/\\\");\\n    }\\n    let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : router.matchRoutes(routes, {\\n      pathname: remainingPathname\\n    });\\n    {\\n      router.UNSAFE_warning(parentRoute || matches != null, \\\"No routes matched location \\\\\\\"\\\" + location.pathname + location.search + location.hash + \\\"\\\\\\\" \\\") ;\\n      router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \\\"Matched leaf route at location \\\\\\\"\\\" + location.pathname + location.search + location.hash + \\\"\\\\\\\" \\\" + \\\"does not have an element or Component. This means it will render an <Outlet /> with a \\\" + \\\"null value by default resulting in an \\\\\\\"empty\\\\\\\" page.\\\") ;\\n    }\\n    let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\\n      params: Object.assign({}, parentParams, match.params),\\n      pathname: router.joinPaths([parentPathnameBase,\\n      // Re-encode pathnames that were decoded inside matchRoutes\\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\\n      pathnameBase: match.pathnameBase === \\\"/\\\" ? parentPathnameBase : router.joinPaths([parentPathnameBase,\\n      // Re-encode pathnames that were decoded inside matchRoutes\\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\\n    })), parentMatches, dataRouterState, future);\\n\\n    // When a user passes in a `locationArg`, the associated routes need to\\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\\n    // to use the scoped location instead of the global location.\\n    if (locationArg && renderedMatches) {\\n      return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\\n        value: {\\n          location: _extends({\\n            pathname: \\\"/\\\",\\n            search: \\\"\\\",\\n            hash: \\\"\\\",\\n            state: null,\\n            key: \\\"default\\\"\\n          }, location),\\n          navigationType: router.Action.Pop\\n        }\\n      }, renderedMatches);\\n    }\\n    return renderedMatches;\\n  }\\n  function DefaultErrorComponent() {\\n    let error = useRouteError();\\n    let message = router.isRouteErrorResponse(error) ? error.status + \\\" \\\" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\\n    let stack = error instanceof Error ? error.stack : null;\\n    let lightgrey = \\\"rgba(200,200,200, 0.5)\\\";\\n    let preStyles = {\\n      padding: \\\"0.5rem\\\",\\n      backgroundColor: lightgrey\\n    };\\n    let codeStyles = {\\n      padding: \\\"2px 4px\\\",\\n      backgroundColor: lightgrey\\n    };\\n    let devInfo = null;\\n    {\\n      console.error(\\\"Error handled by React Router default ErrorBoundary:\\\", error);\\n      devInfo = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\\\"p\\\", null, \\\"\\\\uD83D\\\\uDCBF Hey developer \\\\uD83D\\\\uDC4B\\\"), /*#__PURE__*/React__namespace.createElement(\\\"p\\\", null, \\\"You can provide a way better UX than this when your app throws errors by providing your own \\\", /*#__PURE__*/React__namespace.createElement(\\\"code\\\", {\\n        style: codeStyles\\n      }, \\\"ErrorBoundary\\\"), \\\" or\\\", \\\" \\\", /*#__PURE__*/React__namespace.createElement(\\\"code\\\", {\\n        style: codeStyles\\n      }, \\\"errorElement\\\"), \\\" prop on your route.\\\"));\\n    }\\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\\\"h2\\\", null, \\\"Unexpected Application Error!\\\"), /*#__PURE__*/React__namespace.createElement(\\\"h3\\\", {\\n      style: {\\n        fontStyle: \\\"italic\\\"\\n      }\\n    }, message), stack ? /*#__PURE__*/React__namespace.createElement(\\\"pre\\\", {\\n      style: preStyles\\n    }, stack) : null, devInfo);\\n  }\\n  const defaultErrorElement = /*#__PURE__*/React__namespace.createElement(DefaultErrorComponent, null);\\n  class RenderErrorBoundary extends React__namespace.Component {\\n    constructor(props) {\\n      super(props);\\n      this.state = {\\n        location: props.location,\\n        revalidation: props.revalidation,\\n        error: props.error\\n      };\\n    }\\n    static getDerivedStateFromError(error) {\\n      return {\\n        error: error\\n      };\\n    }\\n    static getDerivedStateFromProps(props, state) {\\n      // When we get into an error state, the user will likely click \\\"back\\\" to the\\n      // previous page that didn't have an error. Because this wraps the entire\\n      // application, that will have no effect--the error page continues to display.\\n      // This gives us a mechanism to recover from the error when the location changes.\\n      //\\n      // Whether we're in an error state or not, we update the location in state\\n      // so that when we are in an error state, it gets reset when a new location\\n      // comes in and the user recovers from the error.\\n      if (state.location !== props.location || state.revalidation !== \\\"idle\\\" && props.revalidation === \\\"idle\\\") {\\n        return {\\n          error: props.error,\\n          location: props.location,\\n          revalidation: props.revalidation\\n        };\\n      }\\n\\n      // If we're not changing locations, preserve the location but still surface\\n      // any new errors that may come through. We retain the existing error, we do\\n      // this because the error provided from the app state may be cleared without\\n      // the location changing.\\n      return {\\n        error: props.error !== undefined ? props.error : state.error,\\n        location: state.location,\\n        revalidation: props.revalidation || state.revalidation\\n      };\\n    }\\n    componentDidCatch(error, errorInfo) {\\n      console.error(\\\"React Router caught the following error during render\\\", error, errorInfo);\\n    }\\n    render() {\\n      return this.state.error !== undefined ? /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\\n        value: this.props.routeContext\\n      }, /*#__PURE__*/React__namespace.createElement(RouteErrorContext.Provider, {\\n        value: this.state.error,\\n        children: this.props.component\\n      })) : this.props.children;\\n    }\\n  }\\n  function RenderedRoute(_ref) {\\n    let {\\n      routeContext,\\n      match,\\n      children\\n    } = _ref;\\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\\n\\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\\n    // in a DataStaticRouter\\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\\n      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\\n    }\\n    return /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\\n      value: routeContext\\n    }, children);\\n  }\\n  function _renderMatches(matches, parentMatches, dataRouterState, future) {\\n    var _dataRouterState;\\n    if (parentMatches === void 0) {\\n      parentMatches = [];\\n    }\\n    if (dataRouterState === void 0) {\\n      dataRouterState = null;\\n    }\\n    if (future === void 0) {\\n      future = null;\\n    }\\n    if (matches == null) {\\n      var _future;\\n      if (!dataRouterState) {\\n        return null;\\n      }\\n      if (dataRouterState.errors) {\\n        // Don't bail if we have data router errors so we can render them in the\\n        // boundary.  Use the pre-matched (or shimmed) matches\\n        matches = dataRouterState.matches;\\n      } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\\n        // Don't bail if we're initializing with partial hydration and we have\\n        // router matches.  That means we're actively running `patchRoutesOnNavigation`\\n        // so we should render down the partial matches to the appropriate\\n        // `HydrateFallback`.  We only do this if `parentMatches` is empty so it\\n        // only impacts the root matches for `RouterProvider` and no descendant\\n        // `<Routes>`\\n        matches = dataRouterState.matches;\\n      } else {\\n        return null;\\n      }\\n    }\\n    let renderedMatches = matches;\\n\\n    // If we have data errors, trim matches to the highest error boundary\\n    let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;\\n    if (errors != null) {\\n      let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);\\n      !(errorIndex >= 0) ? router.UNSAFE_invariant(false, \\\"Could not find a matching route for errors on route IDs: \\\" + Object.keys(errors).join(\\\",\\\"))  : void 0;\\n      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\\n    }\\n\\n    // If we're in a partial hydration mode, detect if we need to render down to\\n    // a given HydrateFallback while we load the rest of the hydration data\\n    let renderFallback = false;\\n    let fallbackIndex = -1;\\n    if (dataRouterState && future && future.v7_partialHydration) {\\n      for (let i = 0; i < renderedMatches.length; i++) {\\n        let match = renderedMatches[i];\\n        // Track the deepest fallback up until the first route without data\\n        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\\n          fallbackIndex = i;\\n        }\\n        if (match.route.id) {\\n          let {\\n            loaderData,\\n            errors\\n          } = dataRouterState;\\n          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\\n          if (match.route.lazy || needsToRunLoader) {\\n            // We found the first route that's not ready to render (waiting on\\n            // lazy, or has a loader that hasn't run yet).  Flag that we need to\\n            // render a fallback and render up until the appropriate fallback\\n            renderFallback = true;\\n            if (fallbackIndex >= 0) {\\n              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\\n            } else {\\n              renderedMatches = [renderedMatches[0]];\\n            }\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return renderedMatches.reduceRight((outlet, match, index) => {\\n      // Only data routers handle errors/fallbacks\\n      let error;\\n      let shouldRenderHydrateFallback = false;\\n      let errorElement = null;\\n      let hydrateFallbackElement = null;\\n      if (dataRouterState) {\\n        error = errors && match.route.id ? errors[match.route.id] : undefined;\\n        errorElement = match.route.errorElement || defaultErrorElement;\\n        if (renderFallback) {\\n          if (fallbackIndex < 0 && index === 0) {\\n            warningOnce(\\\"route-fallback\\\", false, \\\"No `HydrateFallback` element provided to render during initial hydration\\\");\\n            shouldRenderHydrateFallback = true;\\n            hydrateFallbackElement = null;\\n          } else if (fallbackIndex === index) {\\n            shouldRenderHydrateFallback = true;\\n            hydrateFallbackElement = match.route.hydrateFallbackElement || null;\\n          }\\n        }\\n      }\\n      let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\\n      let getChildren = () => {\\n        let children;\\n        if (error) {\\n          children = errorElement;\\n        } else if (shouldRenderHydrateFallback) {\\n          children = hydrateFallbackElement;\\n        } else if (match.route.Component) {\\n          // Note: This is a de-optimized path since React won't re-use the\\n          // ReactElement since it's identity changes with each new\\n          // React.createElement call.  We keep this so folks can use\\n          // `<Route Component={...}>` in `<Routes>` but generally `Component`\\n          // usage is only advised in `RouterProvider` when we can convert it to\\n          // `element` ahead of time.\\n          children = /*#__PURE__*/React__namespace.createElement(match.route.Component, null);\\n        } else if (match.route.element) {\\n          children = match.route.element;\\n        } else {\\n          children = outlet;\\n        }\\n        return /*#__PURE__*/React__namespace.createElement(RenderedRoute, {\\n          match: match,\\n          routeContext: {\\n            outlet,\\n            matches,\\n            isDataRoute: dataRouterState != null\\n          },\\n          children: children\\n        });\\n      };\\n      // Only wrap in an error boundary within data router usages when we have an\\n      // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\\n      // an ancestor ErrorBoundary/errorElement\\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React__namespace.createElement(RenderErrorBoundary, {\\n        location: dataRouterState.location,\\n        revalidation: dataRouterState.revalidation,\\n        component: errorElement,\\n        error: error,\\n        children: getChildren(),\\n        routeContext: {\\n          outlet: null,\\n          matches,\\n          isDataRoute: true\\n        }\\n      }) : getChildren();\\n    }, null);\\n  }\\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\\n    DataRouterHook[\\\"UseBlocker\\\"] = \\\"useBlocker\\\";\\n    DataRouterHook[\\\"UseRevalidator\\\"] = \\\"useRevalidator\\\";\\n    DataRouterHook[\\\"UseNavigateStable\\\"] = \\\"useNavigate\\\";\\n    return DataRouterHook;\\n  }(DataRouterHook || {});\\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\\n    DataRouterStateHook[\\\"UseBlocker\\\"] = \\\"useBlocker\\\";\\n    DataRouterStateHook[\\\"UseLoaderData\\\"] = \\\"useLoaderData\\\";\\n    DataRouterStateHook[\\\"UseActionData\\\"] = \\\"useActionData\\\";\\n    DataRouterStateHook[\\\"UseRouteError\\\"] = \\\"useRouteError\\\";\\n    DataRouterStateHook[\\\"UseNavigation\\\"] = \\\"useNavigation\\\";\\n    DataRouterStateHook[\\\"UseRouteLoaderData\\\"] = \\\"useRouteLoaderData\\\";\\n    DataRouterStateHook[\\\"UseMatches\\\"] = \\\"useMatches\\\";\\n    DataRouterStateHook[\\\"UseRevalidator\\\"] = \\\"useRevalidator\\\";\\n    DataRouterStateHook[\\\"UseNavigateStable\\\"] = \\\"useNavigate\\\";\\n    DataRouterStateHook[\\\"UseRouteId\\\"] = \\\"useRouteId\\\";\\n    return DataRouterStateHook;\\n  }(DataRouterStateHook || {});\\n  function getDataRouterConsoleError(hookName) {\\n    return hookName + \\\" must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.\\\";\\n  }\\n  function useDataRouterContext(hookName) {\\n    let ctx = React__namespace.useContext(DataRouterContext);\\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\\n    return ctx;\\n  }\\n  function useDataRouterState(hookName) {\\n    let state = React__namespace.useContext(DataRouterStateContext);\\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\\n    return state;\\n  }\\n  function useRouteContext(hookName) {\\n    let route = React__namespace.useContext(RouteContext);\\n    !route ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\\n    return route;\\n  }\\n\\n  // Internal version with hookName-aware debugging\\n  function useCurrentRouteId(hookName) {\\n    let route = useRouteContext(hookName);\\n    let thisRoute = route.matches[route.matches.length - 1];\\n    !thisRoute.route.id ? router.UNSAFE_invariant(false, hookName + \\\" can only be used on routes that contain a unique \\\\\\\"id\\\\\\\"\\\")  : void 0;\\n    return thisRoute.route.id;\\n  }\\n\\n  /**\\n   * Returns the ID for the nearest contextual route\\n   */\\n  function useRouteId() {\\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\\n  }\\n\\n  /**\\n   * Returns the current navigation, defaulting to an \\\"idle\\\" navigation when\\n   * no navigation is in progress\\n   */\\n  function useNavigation() {\\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\\n    return state.navigation;\\n  }\\n\\n  /**\\n   * Returns a revalidate function for manually triggering revalidation, as well\\n   * as the current state of any manual revalidations\\n   */\\n  function useRevalidator() {\\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\\n    return React__namespace.useMemo(() => ({\\n      revalidate: dataRouterContext.router.revalidate,\\n      state: state.revalidation\\n    }), [dataRouterContext.router.revalidate, state.revalidation]);\\n  }\\n\\n  /**\\n   * Returns the active route matches, useful for accessing loaderData for\\n   * parent/child routes or the route \\\"handle\\\" property\\n   */\\n  function useMatches() {\\n    let {\\n      matches,\\n      loaderData\\n    } = useDataRouterState(DataRouterStateHook.UseMatches);\\n    return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\\n  }\\n\\n  /**\\n   * Returns the loader data for the nearest ancestor Route loader\\n   */\\n  function useLoaderData() {\\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\\n    if (state.errors && state.errors[routeId] != null) {\\n      console.error(\\\"You cannot `useLoaderData` in an errorElement (routeId: \\\" + routeId + \\\")\\\");\\n      return undefined;\\n    }\\n    return state.loaderData[routeId];\\n  }\\n\\n  /**\\n   * Returns the loaderData for the given routeId\\n   */\\n  function useRouteLoaderData(routeId) {\\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\\n    return state.loaderData[routeId];\\n  }\\n\\n  /**\\n   * Returns the action data for the nearest ancestor Route action\\n   */\\n  function useActionData() {\\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\\n    return state.actionData ? state.actionData[routeId] : undefined;\\n  }\\n\\n  /**\\n   * Returns the nearest ancestor Route error, which could be a loader/action\\n   * error or a render error.  This is intended to be called from your\\n   * ErrorBoundary/errorElement to display a proper error message.\\n   */\\n  function useRouteError() {\\n    var _state$errors;\\n    let error = React__namespace.useContext(RouteErrorContext);\\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\\n\\n    // If this was a render error, we put it in a RouteError context inside\\n    // of RenderErrorBoundary\\n    if (error !== undefined) {\\n      return error;\\n    }\\n\\n    // Otherwise look for errors from our data router state\\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\\n  }\\n\\n  /**\\n   * Returns the happy-path data from the nearest ancestor `<Await />` value\\n   */\\n  function useAsyncValue() {\\n    let value = React__namespace.useContext(AwaitContext);\\n    return value == null ? void 0 : value._data;\\n  }\\n\\n  /**\\n   * Returns the error from the nearest ancestor `<Await />` value\\n   */\\n  function useAsyncError() {\\n    let value = React__namespace.useContext(AwaitContext);\\n    return value == null ? void 0 : value._error;\\n  }\\n  let blockerId = 0;\\n\\n  /**\\n   * Allow the application to block navigations within the SPA and present the\\n   * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\\n   * using half-filled form data.  This does not handle hard-reloads or\\n   * cross-origin navigations.\\n   */\\n  function useBlocker(shouldBlock) {\\n    let {\\n      router: router$1,\\n      basename\\n    } = useDataRouterContext(DataRouterHook.UseBlocker);\\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\\n    let [blockerKey, setBlockerKey] = React__namespace.useState(\\\"\\\");\\n    let blockerFunction = React__namespace.useCallback(arg => {\\n      if (typeof shouldBlock !== \\\"function\\\") {\\n        return !!shouldBlock;\\n      }\\n      if (basename === \\\"/\\\") {\\n        return shouldBlock(arg);\\n      }\\n\\n      // If they provided us a function and we've got an active basename, strip\\n      // it from the locations we expose to the user to match the behavior of\\n      // useLocation\\n      let {\\n        currentLocation,\\n        nextLocation,\\n        historyAction\\n      } = arg;\\n      return shouldBlock({\\n        currentLocation: _extends({}, currentLocation, {\\n          pathname: router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\\n        }),\\n        nextLocation: _extends({}, nextLocation, {\\n          pathname: router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\\n        }),\\n        historyAction\\n      });\\n    }, [basename, shouldBlock]);\\n\\n    // This effect is in charge of blocker key assignment and deletion (which is\\n    // tightly coupled to the key)\\n    React__namespace.useEffect(() => {\\n      let key = String(++blockerId);\\n      setBlockerKey(key);\\n      return () => router$1.deleteBlocker(key);\\n    }, [router$1]);\\n\\n    // This effect handles assigning the blockerFunction.  This is to handle\\n    // unstable blocker function identities, and happens only after the prior\\n    // effect so we don't get an orphaned blockerFunction in the router with a\\n    // key of \\\"\\\".  Until then we just have the IDLE_BLOCKER.\\n    React__namespace.useEffect(() => {\\n      if (blockerKey !== \\\"\\\") {\\n        router$1.getBlocker(blockerKey, blockerFunction);\\n      }\\n    }, [router$1, blockerKey, blockerFunction]);\\n\\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\\n    // is memoized so this ensures we update on blocker state updates\\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;\\n  }\\n\\n  /**\\n   * Stable version of useNavigate that is used when we are in the context of\\n   * a RouterProvider.\\n   */\\n  function useNavigateStable() {\\n    let {\\n      router: router$1\\n    } = useDataRouterContext(DataRouterHook.UseNavigateStable);\\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\\n    let activeRef = React__namespace.useRef(false);\\n    useIsomorphicLayoutEffect(() => {\\n      activeRef.current = true;\\n    });\\n    let navigate = React__namespace.useCallback(function (to, options) {\\n      if (options === void 0) {\\n        options = {};\\n      }\\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\\n\\n      // Short circuit here since if this happens on first render the navigate\\n      // is useless because we haven't wired up our router subscriber yet\\n      if (!activeRef.current) return;\\n      if (typeof to === \\\"number\\\") {\\n        router$1.navigate(to);\\n      } else {\\n        router$1.navigate(to, _extends({\\n          fromRouteId: id\\n        }, options));\\n      }\\n    }, [router$1, id]);\\n    return navigate;\\n  }\\n  const alreadyWarned$1 = {};\\n  function warningOnce(key, cond, message) {\\n    if (!cond && !alreadyWarned$1[key]) {\\n      alreadyWarned$1[key] = true;\\n      router.UNSAFE_warning(false, message) ;\\n    }\\n  }\\n\\n  const alreadyWarned = {};\\n  function warnOnce(key, message) {\\n    if (!alreadyWarned[message]) {\\n      alreadyWarned[message] = true;\\n      console.warn(message);\\n    }\\n  }\\n  const logDeprecation = (flag, msg, link) => warnOnce(flag, \\\"\\\\u26A0\\\\uFE0F React Router Future Flag Warning: \\\" + msg + \\\". \\\" + (\\\"You can use the `\\\" + flag + \\\"` future flag to opt-in early. \\\") + (\\\"For more information, see \\\" + link + \\\".\\\"));\\n  function logV6DeprecationWarnings(renderFuture, routerFuture) {\\n    if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === undefined) {\\n      logDeprecation(\\\"v7_startTransition\\\", \\\"React Router will begin wrapping state updates in `React.startTransition` in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_starttransition\\\");\\n    }\\n    if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === undefined && (!routerFuture || !routerFuture.v7_relativeSplatPath)) {\\n      logDeprecation(\\\"v7_relativeSplatPath\\\", \\\"Relative route resolution within Splat routes is changing in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath\\\");\\n    }\\n    if (routerFuture) {\\n      if (routerFuture.v7_fetcherPersist === undefined) {\\n        logDeprecation(\\\"v7_fetcherPersist\\\", \\\"The persistence behavior of fetchers is changing in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist\\\");\\n      }\\n      if (routerFuture.v7_normalizeFormMethod === undefined) {\\n        logDeprecation(\\\"v7_normalizeFormMethod\\\", \\\"Casing of `formMethod` fields is being normalized to uppercase in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod\\\");\\n      }\\n      if (routerFuture.v7_partialHydration === undefined) {\\n        logDeprecation(\\\"v7_partialHydration\\\", \\\"`RouterProvider` hydration behavior is changing in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_partialhydration\\\");\\n      }\\n      if (routerFuture.v7_skipActionErrorRevalidation === undefined) {\\n        logDeprecation(\\\"v7_skipActionErrorRevalidation\\\", \\\"The revalidation behavior after 4xx/5xx `action` responses is changing in v7\\\", \\\"https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation\\\");\\n      }\\n    }\\n  }\\n\\n  /**\\n    Webpack + React 17 fails to compile on any of the following because webpack\\n    complains that `startTransition` doesn't exist in `React`:\\n    * import { startTransition } from \\\"react\\\"\\n    * import * as React from from \\\"react\\\";\\n      \\\"startTransition\\\" in React ? React.startTransition(() => setState()) : setState()\\n    * import * as React from from \\\"react\\\";\\n      \\\"startTransition\\\" in React ? React[\\\"startTransition\\\"](() => setState()) : setState()\\n\\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\\n    * import * as React from from \\\"react\\\";\\n      const START_TRANSITION = \\\"startTransition\\\";\\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\\n\\n    However, that introduces webpack/terser minification issues in production builds\\n    in React 18 where minification/obfuscation ends up removing the call of\\n    React.startTransition entirely from the first half of the ternary.  Grabbing\\n    this exported reference once up front resolves that issue.\\n\\n    See https://github.com/remix-run/react-router/issues/10579\\n  */\\n  const START_TRANSITION = \\\"startTransition\\\";\\n  const startTransitionImpl = React__namespace[START_TRANSITION];\\n\\n  /**\\n   * Given a Remix Router instance, render the appropriate UI\\n   */\\n  function RouterProvider(_ref) {\\n    let {\\n      fallbackElement,\\n      router: router$1,\\n      future\\n    } = _ref;\\n    let [state, setStateImpl] = React__namespace.useState(router$1.state);\\n    let {\\n      v7_startTransition\\n    } = future || {};\\n    let setState = React__namespace.useCallback(newState => {\\n      if (v7_startTransition && startTransitionImpl) {\\n        startTransitionImpl(() => setStateImpl(newState));\\n      } else {\\n        setStateImpl(newState);\\n      }\\n    }, [setStateImpl, v7_startTransition]);\\n\\n    // Need to use a layout effect here so we are subscribed early enough to\\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\\n    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);\\n    React__namespace.useEffect(() => {\\n      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, \\\"`<RouterProvider fallbackElement>` is deprecated when using \\\" + \\\"`v7_partialHydration`, use a `HydrateFallback` component instead\\\") ;\\n      // Only log this once on initial mount\\n      // eslint-disable-next-line react-hooks/exhaustive-deps\\n    }, []);\\n    let navigator = React__namespace.useMemo(() => {\\n      return {\\n        createHref: router$1.createHref,\\n        encodeLocation: router$1.encodeLocation,\\n        go: n => router$1.navigate(n),\\n        push: (to, state, opts) => router$1.navigate(to, {\\n          state,\\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\\n        }),\\n        replace: (to, state, opts) => router$1.navigate(to, {\\n          replace: true,\\n          state,\\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\\n        })\\n      };\\n    }, [router$1]);\\n    let basename = router$1.basename || \\\"/\\\";\\n    let dataRouterContext = React__namespace.useMemo(() => ({\\n      router: router$1,\\n      navigator,\\n      static: false,\\n      basename\\n    }), [router$1, navigator, basename]);\\n    React__namespace.useEffect(() => logV6DeprecationWarnings(future, router$1.future), [router$1, future]);\\n\\n    // The fragment and {null} here are important!  We need them to keep React 18's\\n    // useId happy when we are server-rendering since we may have a <script> here\\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\\n    // useId relies on the component tree structure to generate deterministic id's\\n    // so we need to ensure it remains the same on the client even though\\n    // we don't need the <script> tag\\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(DataRouterContext.Provider, {\\n      value: dataRouterContext\\n    }, /*#__PURE__*/React__namespace.createElement(DataRouterStateContext.Provider, {\\n      value: state\\n    }, /*#__PURE__*/React__namespace.createElement(Router, {\\n      basename: basename,\\n      location: state.location,\\n      navigationType: state.historyAction,\\n      navigator: navigator,\\n      future: {\\n        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath\\n      }\\n    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\\n      routes: router$1.routes,\\n      future: router$1.future,\\n      state: state\\n    }) : fallbackElement))), null);\\n  }\\n  function DataRoutes(_ref2) {\\n    let {\\n      routes,\\n      future,\\n      state\\n    } = _ref2;\\n    return useRoutesImpl(routes, undefined, state, future);\\n  }\\n  /**\\n   * A `<Router>` that stores all entries in memory.\\n   *\\n   * @see https://reactrouter.com/v6/router-components/memory-router\\n   */\\n  function MemoryRouter(_ref3) {\\n    let {\\n      basename,\\n      children,\\n      initialEntries,\\n      initialIndex,\\n      future\\n    } = _ref3;\\n    let historyRef = React__namespace.useRef();\\n    if (historyRef.current == null) {\\n      historyRef.current = router.createMemoryHistory({\\n        initialEntries,\\n        initialIndex,\\n        v5Compat: true\\n      });\\n    }\\n    let history = historyRef.current;\\n    let [state, setStateImpl] = React__namespace.useState({\\n      action: history.action,\\n      location: history.location\\n    });\\n    let {\\n      v7_startTransition\\n    } = future || {};\\n    let setState = React__namespace.useCallback(newState => {\\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\\n    }, [setStateImpl, v7_startTransition]);\\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\\n    React__namespace.useEffect(() => logV6DeprecationWarnings(future), [future]);\\n    return /*#__PURE__*/React__namespace.createElement(Router, {\\n      basename: basename,\\n      children: children,\\n      location: state.location,\\n      navigationType: state.action,\\n      navigator: history,\\n      future: future\\n    });\\n  }\\n  /**\\n   * Changes the current location.\\n   *\\n   * Note: This API is mostly useful in React.Component subclasses that are not\\n   * able to use hooks. In functional components, we recommend you use the\\n   * `useNavigate` hook instead.\\n   *\\n   * @see https://reactrouter.com/v6/components/navigate\\n   */\\n  function Navigate(_ref4) {\\n    let {\\n      to,\\n      replace,\\n      state,\\n      relative\\n    } = _ref4;\\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\\n    // the router loaded. We can help them understand how to avoid that.\\n    \\\"<Navigate> may be used only in the context of a <Router> component.\\\")  : void 0;\\n    let {\\n      future,\\n      static: isStatic\\n    } = React__namespace.useContext(NavigationContext);\\n    router.UNSAFE_warning(!isStatic, \\\"<Navigate> must not be used on the initial render in a <StaticRouter>. \\\" + \\\"This is a no-op, but you should modify your code so the <Navigate> is \\\" + \\\"only ever rendered in response to some user interaction or state change.\\\") ;\\n    let {\\n      matches\\n    } = React__namespace.useContext(RouteContext);\\n    let {\\n      pathname: locationPathname\\n    } = useLocation();\\n    let navigate = useNavigate();\\n\\n    // Resolve the path outside of the effect so that when effects run twice in\\n    // StrictMode they navigate to the same place\\n    let path = router.resolveTo(to, router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \\\"path\\\");\\n    let jsonPath = JSON.stringify(path);\\n    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {\\n      replace,\\n      state,\\n      relative\\n    }), [navigate, jsonPath, relative, replace, state]);\\n    return null;\\n  }\\n  /**\\n   * Renders the child route's element, if there is one.\\n   *\\n   * @see https://reactrouter.com/v6/components/outlet\\n   */\\n  function Outlet(props) {\\n    return useOutlet(props.context);\\n  }\\n  /**\\n   * Declares an element that should be rendered at a certain URL path.\\n   *\\n   * @see https://reactrouter.com/v6/components/route\\n   */\\n  function Route(_props) {\\n    router.UNSAFE_invariant(false, \\\"A <Route> is only ever to be used as the child of <Routes> element, \\\" + \\\"never rendered directly. Please wrap your <Route> in a <Routes>.\\\")  ;\\n  }\\n  /**\\n   * Provides location context for the rest of the app.\\n   *\\n   * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\\n   * router that is more specific to your environment such as a `<BrowserRouter>`\\n   * in web browsers or a `<StaticRouter>` for server rendering.\\n   *\\n   * @see https://reactrouter.com/v6/router-components/router\\n   */\\n  function Router(_ref5) {\\n    let {\\n      basename: basenameProp = \\\"/\\\",\\n      children = null,\\n      location: locationProp,\\n      navigationType = router.Action.Pop,\\n      navigator,\\n      static: staticProp = false,\\n      future\\n    } = _ref5;\\n    !!useInRouterContext() ? router.UNSAFE_invariant(false, \\\"You cannot render a <Router> inside another <Router>.\\\" + \\\" You should never have more than one in your app.\\\")  : void 0;\\n\\n    // Preserve trailing slashes on basename, so we can let the user control\\n    // the enforcement of trailing slashes throughout the app\\n    let basename = basenameProp.replace(/^\\\\/*/, \\\"/\\\");\\n    let navigationContext = React__namespace.useMemo(() => ({\\n      basename,\\n      navigator,\\n      static: staticProp,\\n      future: _extends({\\n        v7_relativeSplatPath: false\\n      }, future)\\n    }), [basename, future, navigator, staticProp]);\\n    if (typeof locationProp === \\\"string\\\") {\\n      locationProp = router.parsePath(locationProp);\\n    }\\n    let {\\n      pathname = \\\"/\\\",\\n      search = \\\"\\\",\\n      hash = \\\"\\\",\\n      state = null,\\n      key = \\\"default\\\"\\n    } = locationProp;\\n    let locationContext = React__namespace.useMemo(() => {\\n      let trailingPathname = router.stripBasename(pathname, basename);\\n      if (trailingPathname == null) {\\n        return null;\\n      }\\n      return {\\n        location: {\\n          pathname: trailingPathname,\\n          search,\\n          hash,\\n          state,\\n          key\\n        },\\n        navigationType\\n      };\\n    }, [basename, pathname, search, hash, state, key, navigationType]);\\n    router.UNSAFE_warning(locationContext != null, \\\"<Router basename=\\\\\\\"\\\" + basename + \\\"\\\\\\\"> is not able to match the URL \\\" + (\\\"\\\\\\\"\\\" + pathname + search + hash + \\\"\\\\\\\" because it does not start with the \\\") + \\\"basename, so the <Router> won't render anything.\\\") ;\\n    if (locationContext == null) {\\n      return null;\\n    }\\n    return /*#__PURE__*/React__namespace.createElement(NavigationContext.Provider, {\\n      value: navigationContext\\n    }, /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\\n      children: children,\\n      value: locationContext\\n    }));\\n  }\\n  /**\\n   * A container for a nested tree of `<Route>` elements that renders the branch\\n   * that best matches the current location.\\n   *\\n   * @see https://reactrouter.com/v6/components/routes\\n   */\\n  function Routes(_ref6) {\\n    let {\\n      children,\\n      location\\n    } = _ref6;\\n    return useRoutes(createRoutesFromChildren(children), location);\\n  }\\n  /**\\n   * Component to use for rendering lazily loaded data from returning defer()\\n   * in a loader function\\n   */\\n  function Await(_ref7) {\\n    let {\\n      children,\\n      errorElement,\\n      resolve\\n    } = _ref7;\\n    return /*#__PURE__*/React__namespace.createElement(AwaitErrorBoundary, {\\n      resolve: resolve,\\n      errorElement: errorElement\\n    }, /*#__PURE__*/React__namespace.createElement(ResolveAwait, null, children));\\n  }\\n  var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\\n    AwaitRenderStatus[AwaitRenderStatus[\\\"pending\\\"] = 0] = \\\"pending\\\";\\n    AwaitRenderStatus[AwaitRenderStatus[\\\"success\\\"] = 1] = \\\"success\\\";\\n    AwaitRenderStatus[AwaitRenderStatus[\\\"error\\\"] = 2] = \\\"error\\\";\\n    return AwaitRenderStatus;\\n  }(AwaitRenderStatus || {});\\n  const neverSettledPromise = new Promise(() => {});\\n  class AwaitErrorBoundary extends React__namespace.Component {\\n    constructor(props) {\\n      super(props);\\n      this.state = {\\n        error: null\\n      };\\n    }\\n    static getDerivedStateFromError(error) {\\n      return {\\n        error\\n      };\\n    }\\n    componentDidCatch(error, errorInfo) {\\n      console.error(\\\"<Await> caught the following error during render\\\", error, errorInfo);\\n    }\\n    render() {\\n      let {\\n        children,\\n        errorElement,\\n        resolve\\n      } = this.props;\\n      let promise = null;\\n      let status = AwaitRenderStatus.pending;\\n      if (!(resolve instanceof Promise)) {\\n        // Didn't get a promise - provide as a resolved promise\\n        status = AwaitRenderStatus.success;\\n        promise = Promise.resolve();\\n        Object.defineProperty(promise, \\\"_tracked\\\", {\\n          get: () => true\\n        });\\n        Object.defineProperty(promise, \\\"_data\\\", {\\n          get: () => resolve\\n        });\\n      } else if (this.state.error) {\\n        // Caught a render error, provide it as a rejected promise\\n        status = AwaitRenderStatus.error;\\n        let renderError = this.state.error;\\n        promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\\n        Object.defineProperty(promise, \\\"_tracked\\\", {\\n          get: () => true\\n        });\\n        Object.defineProperty(promise, \\\"_error\\\", {\\n          get: () => renderError\\n        });\\n      } else if (resolve._tracked) {\\n        // Already tracked promise - check contents\\n        promise = resolve;\\n        status = \\\"_error\\\" in promise ? AwaitRenderStatus.error : \\\"_data\\\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\\n      } else {\\n        // Raw (untracked) promise - track it\\n        status = AwaitRenderStatus.pending;\\n        Object.defineProperty(resolve, \\\"_tracked\\\", {\\n          get: () => true\\n        });\\n        promise = resolve.then(data => Object.defineProperty(resolve, \\\"_data\\\", {\\n          get: () => data\\n        }), error => Object.defineProperty(resolve, \\\"_error\\\", {\\n          get: () => error\\n        }));\\n      }\\n      if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {\\n        // Freeze the UI by throwing a never resolved promise\\n        throw neverSettledPromise;\\n      }\\n      if (status === AwaitRenderStatus.error && !errorElement) {\\n        // No errorElement, throw to the nearest route-level error boundary\\n        throw promise._error;\\n      }\\n      if (status === AwaitRenderStatus.error) {\\n        // Render via our errorElement\\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\\n          value: promise,\\n          children: errorElement\\n        });\\n      }\\n      if (status === AwaitRenderStatus.success) {\\n        // Render children with resolved value\\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\\n          value: promise,\\n          children: children\\n        });\\n      }\\n\\n      // Throw to the suspense boundary\\n      throw promise;\\n    }\\n  }\\n\\n  /**\\n   * @private\\n   * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\\n   */\\n  function ResolveAwait(_ref8) {\\n    let {\\n      children\\n    } = _ref8;\\n    let data = useAsyncValue();\\n    let toRender = typeof children === \\\"function\\\" ? children(data) : children;\\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, toRender);\\n  }\\n\\n  ///////////////////////////////////////////////////////////////////////////////\\n  // UTILS\\n  ///////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * Creates a route config from a React \\\"children\\\" object, which is usually\\n   * either a `<Route>` element or an array of them. Used internally by\\n   * `<Routes>` to create a route config from its children.\\n   *\\n   * @see https://reactrouter.com/v6/utils/create-routes-from-children\\n   */\\n  function createRoutesFromChildren(children, parentPath) {\\n    if (parentPath === void 0) {\\n      parentPath = [];\\n    }\\n    let routes = [];\\n    React__namespace.Children.forEach(children, (element, index) => {\\n      if (! /*#__PURE__*/React__namespace.isValidElement(element)) {\\n        // Ignore non-elements. This allows people to more easily inline\\n        // conditionals in their route config.\\n        return;\\n      }\\n      let treePath = [...parentPath, index];\\n      if (element.type === React__namespace.Fragment) {\\n        // Transparently support React.Fragment and its children.\\n        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\\n        return;\\n      }\\n      !(element.type === Route) ? router.UNSAFE_invariant(false, \\\"[\\\" + (typeof element.type === \\\"string\\\" ? element.type : element.type.name) + \\\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\\\")  : void 0;\\n      !(!element.props.index || !element.props.children) ? router.UNSAFE_invariant(false, \\\"An index route cannot have child routes.\\\")  : void 0;\\n      let route = {\\n        id: element.props.id || treePath.join(\\\"-\\\"),\\n        caseSensitive: element.props.caseSensitive,\\n        element: element.props.element,\\n        Component: element.props.Component,\\n        index: element.props.index,\\n        path: element.props.path,\\n        loader: element.props.loader,\\n        action: element.props.action,\\n        errorElement: element.props.errorElement,\\n        ErrorBoundary: element.props.ErrorBoundary,\\n        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\\n        shouldRevalidate: element.props.shouldRevalidate,\\n        handle: element.props.handle,\\n        lazy: element.props.lazy\\n      };\\n      if (element.props.children) {\\n        route.children = createRoutesFromChildren(element.props.children, treePath);\\n      }\\n      routes.push(route);\\n    });\\n    return routes;\\n  }\\n\\n  /**\\n   * Renders the result of `matchRoutes()` into a React element.\\n   */\\n  function renderMatches(matches) {\\n    return _renderMatches(matches);\\n  }\\n\\n  function mapRouteProperties(route) {\\n    let updates = {\\n      // Note: this check also occurs in createRoutesFromChildren so update\\n      // there if you change this -- please and thank you!\\n      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\\n    };\\n    if (route.Component) {\\n      {\\n        if (route.element) {\\n          router.UNSAFE_warning(false, \\\"You should not include both `Component` and `element` on your route - \\\" + \\\"`Component` will be used.\\\") ;\\n        }\\n      }\\n      Object.assign(updates, {\\n        element: /*#__PURE__*/React__namespace.createElement(route.Component),\\n        Component: undefined\\n      });\\n    }\\n    if (route.HydrateFallback) {\\n      {\\n        if (route.hydrateFallbackElement) {\\n          router.UNSAFE_warning(false, \\\"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \\\" + \\\"`HydrateFallback` will be used.\\\") ;\\n        }\\n      }\\n      Object.assign(updates, {\\n        hydrateFallbackElement: /*#__PURE__*/React__namespace.createElement(route.HydrateFallback),\\n        HydrateFallback: undefined\\n      });\\n    }\\n    if (route.ErrorBoundary) {\\n      {\\n        if (route.errorElement) {\\n          router.UNSAFE_warning(false, \\\"You should not include both `ErrorBoundary` and `errorElement` on your route - \\\" + \\\"`ErrorBoundary` will be used.\\\") ;\\n        }\\n      }\\n      Object.assign(updates, {\\n        errorElement: /*#__PURE__*/React__namespace.createElement(route.ErrorBoundary),\\n        ErrorBoundary: undefined\\n      });\\n    }\\n    return updates;\\n  }\\n  function createMemoryRouter(routes, opts) {\\n    return router.createRouter({\\n      basename: opts == null ? void 0 : opts.basename,\\n      future: _extends({}, opts == null ? void 0 : opts.future, {\\n        v7_prependBasename: true\\n      }),\\n      history: router.createMemoryHistory({\\n        initialEntries: opts == null ? void 0 : opts.initialEntries,\\n        initialIndex: opts == null ? void 0 : opts.initialIndex\\n      }),\\n      hydrationData: opts == null ? void 0 : opts.hydrationData,\\n      routes,\\n      mapRouteProperties,\\n      dataStrategy: opts == null ? void 0 : opts.dataStrategy,\\n      patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation\\n    }).initialize();\\n  }\\n\\n  Object.defineProperty(exports, 'AbortedDeferredError', {\\n    enumerable: true,\\n    get: function () { return router.AbortedDeferredError; }\\n  });\\n  Object.defineProperty(exports, 'NavigationType', {\\n    enumerable: true,\\n    get: function () { return router.Action; }\\n  });\\n  Object.defineProperty(exports, 'createPath', {\\n    enumerable: true,\\n    get: function () { return router.createPath; }\\n  });\\n  Object.defineProperty(exports, 'defer', {\\n    enumerable: true,\\n    get: function () { return router.defer; }\\n  });\\n  Object.defineProperty(exports, 'generatePath', {\\n    enumerable: true,\\n    get: function () { return router.generatePath; }\\n  });\\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\\n    enumerable: true,\\n    get: function () { return router.isRouteErrorResponse; }\\n  });\\n  Object.defineProperty(exports, 'json', {\\n    enumerable: true,\\n    get: function () { return router.json; }\\n  });\\n  Object.defineProperty(exports, 'matchPath', {\\n    enumerable: true,\\n    get: function () { return router.matchPath; }\\n  });\\n  Object.defineProperty(exports, 'matchRoutes', {\\n    enumerable: true,\\n    get: function () { return router.matchRoutes; }\\n  });\\n  Object.defineProperty(exports, 'parsePath', {\\n    enumerable: true,\\n    get: function () { return router.parsePath; }\\n  });\\n  Object.defineProperty(exports, 'redirect', {\\n    enumerable: true,\\n    get: function () { return router.redirect; }\\n  });\\n  Object.defineProperty(exports, 'redirectDocument', {\\n    enumerable: true,\\n    get: function () { return router.redirectDocument; }\\n  });\\n  Object.defineProperty(exports, 'replace', {\\n    enumerable: true,\\n    get: function () { return router.replace; }\\n  });\\n  Object.defineProperty(exports, 'resolvePath', {\\n    enumerable: true,\\n    get: function () { return router.resolvePath; }\\n  });\\n  exports.Await = Await;\\n  exports.MemoryRouter = MemoryRouter;\\n  exports.Navigate = Navigate;\\n  exports.Outlet = Outlet;\\n  exports.Route = Route;\\n  exports.Router = Router;\\n  exports.RouterProvider = RouterProvider;\\n  exports.Routes = Routes;\\n  exports.UNSAFE_DataRouterContext = DataRouterContext;\\n  exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\\n  exports.UNSAFE_LocationContext = LocationContext;\\n  exports.UNSAFE_NavigationContext = NavigationContext;\\n  exports.UNSAFE_RouteContext = RouteContext;\\n  exports.UNSAFE_logV6DeprecationWarnings = logV6DeprecationWarnings;\\n  exports.UNSAFE_mapRouteProperties = mapRouteProperties;\\n  exports.UNSAFE_useRouteId = useRouteId;\\n  exports.UNSAFE_useRoutesImpl = useRoutesImpl;\\n  exports.createMemoryRouter = createMemoryRouter;\\n  exports.createRoutesFromChildren = createRoutesFromChildren;\\n  exports.createRoutesFromElements = createRoutesFromChildren;\\n  exports.renderMatches = renderMatches;\\n  exports.useActionData = useActionData;\\n  exports.useAsyncError = useAsyncError;\\n  exports.useAsyncValue = useAsyncValue;\\n  exports.useBlocker = useBlocker;\\n  exports.useHref = useHref;\\n  exports.useInRouterContext = useInRouterContext;\\n  exports.useLoaderData = useLoaderData;\\n  exports.useLocation = useLocation;\\n  exports.useMatch = useMatch;\\n  exports.useMatches = useMatches;\\n  exports.useNavigate = useNavigate;\\n  exports.useNavigation = useNavigation;\\n  exports.useNavigationType = useNavigationType;\\n  exports.useOutlet = useOutlet;\\n  exports.useOutletContext = useOutletContext;\\n  exports.useParams = useParams;\\n  exports.useResolvedPath = useResolvedPath;\\n  exports.useRevalidator = useRevalidator;\\n  exports.useRouteError = useRouteError;\\n  exports.useRouteLoaderData = useRouteLoaderData;\\n  exports.useRoutes = useRoutes;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n}));\\n//# sourceMappingURL=react-router.development.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"ReactRouter\",\"React\",\"RemixRouter\",\"router\",\"_extends\",\"Object\",\"assign\",\"bind\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"apply\",\"useInRouterContext\",\"React__namespace\",\"useContext\",\"LocationContext\",\"useLocation\",\"UNSAFE_invariant\",\"location\",\"useIsomorphicLayoutEffect\",\"cb\",\"NavigationContext\",\"static\",\"useLayoutEffect\",\"useNavigate\",\"isDataRoute\",\"RouteContext\",\"useNavigateStable\",\"useNavigateUnstable\",\"dataRouterContext\",\"DataRouterContext\",\"basename\",\"future\",\"navigator\",\"matches\",\"locationPathname\",\"routePathnamesJson\",\"JSON\",\"stringify\",\"UNSAFE_getResolveToMatches\",\"v7_relativeSplatPath\",\"activeRef\",\"useRef\",\"current\",\"useCallback\",\"navigate\",\"to\",\"options\",\"UNSAFE_warning\",\"navigateEffectWarning\",\"go\",\"path\",\"resolveTo\",\"parse\",\"relative\",\"pathname\",\"joinPaths\",\"replace\",\"push\",\"state\",\"useOutlet\",\"context\",\"outlet\",\"createElement\",\"OutletContext\",\"Provider\",\"value\",\"useResolvedPath\",\"_temp2\",\"useMemo\",\"useRoutes\",\"routes\",\"locationArg\",\"useRoutesImpl\",\"dataRouterState\",\"isStatic\",\"parentMatches\",\"routeMatch\",\"parentParams\",\"params\",\"parentPathname\",\"parentPathnameBase\",\"pathnameBase\",\"parentPath\",\"parentRoute\",\"route\",\"warningOnce\",\"endsWith\",\"locationFromContext\",\"parsedLocationArg\",\"parsePath\",\"_parsedLocationArg$pa\",\"startsWith\",\"remainingPathname\",\"parentSegments\",\"split\",\"segments\",\"slice\",\"join\",\"matchRoutes\",\"search\",\"hash\",\"undefined\",\"element\",\"Component\",\"lazy\",\"renderedMatches\",\"_renderMatches\",\"map\",\"match\",\"encodeLocation\",\"navigationType\",\"Action\",\"Pop\",\"RenderedRoute\",\"_ref\",\"routeContext\",\"children\",\"staticContext\",\"errorElement\",\"ErrorBoundary\",\"_deepestRenderedBoundaryId\",\"id\",\"_dataRouterState\",\"_future\",\"errors\",\"v7_partialHydration\",\"initialized\",\"errorIndex\",\"findIndex\",\"m\",\"keys\",\"Math\",\"min\",\"renderFallback\",\"fallbackIndex\",\"HydrateFallback\",\"hydrateFallbackElement\",\"loaderData\",\"needsToRunLoader\",\"loader\",\"reduceRight\",\"index\",\"error\",\"shouldRenderHydrateFallback\",\"defaultErrorElement\",\"concat\",\"getChildren\",\"RenderErrorBoundary\",\"revalidation\",\"component\",\"getDataRouterConsoleError\",\"hookName\",\"useDataRouterContext\",\"ctx\",\"useDataRouterState\",\"DataRouterStateContext\",\"useCurrentRouteId\",\"thisRoute\",\"useRouteError\",\"_state$errors\",\"RouteErrorContext\",\"DataRouterStateHook\",\"UseRouteError\",\"routeId\",\"useAsyncValue\",\"AwaitContext\",\"_data\",\"router$1\",\"DataRouterHook\",\"UseNavigateStable\",\"fromRouteId\",\"cond\",\"message\",\"alreadyWarned$1\",\"logV6DeprecationWarnings\",\"renderFuture\",\"routerFuture\",\"v7_startTransition\",\"logDeprecation\",\"v7_fetcherPersist\",\"v7_normalizeFormMethod\",\"v7_skipActionErrorRevalidation\",\"DataRoutes\",\"_ref2\",\"Route\",\"_props\",\"Router\",\"_ref5\",\"basenameProp\",\"locationProp\",\"staticProp\",\"navigationContext\",\"locationContext\",\"trailingPathname\",\"stripBasename\",\"ResolveAwait\",\"_ref8\",\"data\",\"toRender\",\"Fragment\",\"createRoutesFromChildren\",\"Children\",\"forEach\",\"isValidElement\",\"treePath\",\"type\",\"props\",\"name\",\"caseSensitive\",\"action\",\"hasErrorBoundary\",\"shouldRevalidate\",\"handle\",\"mapRouteProperties\",\"updates\",\"_interopNamespace\",\"e\",\"__esModule\",\"n\",\"create\",\"k\",\"d\",\"getOwnPropertyDescriptor\",\"defineProperty\",\"get\",\"enumerable\",\"freeze\",\"createContext\",\"displayName\",\"DefaultErrorComponent\",\"isRouteErrorResponse\",\"status\",\"statusText\",\"Error\",\"stack\",\"preStyles\",\"padding\",\"backgroundColor\",\"lightgrey\",\"codeStyles\",\"console\",\"devInfo\",\"style\",\"fontStyle\",\"constructor\",\"getDerivedStateFromError\",\"getDerivedStateFromProps\",\"componentDidCatch\",\"errorInfo\",\"render\",\"blockerId\",\"alreadyWarned\",\"flag\",\"msg\",\"link\",\"warn\",\"startTransitionImpl\",\"AwaitRenderStatus\",\"neverSettledPromise\",\"Promise\",\"AwaitErrorBoundary\",\"resolve\",\"promise\",\"pending\",\"renderError\",\"reject\",\"catch\",\"_tracked\",\"success\",\"then\",\"_error\",\"AbortedDeferredError\",\"createPath\",\"defer\",\"generatePath\",\"json\",\"matchPath\",\"redirect\",\"redirectDocument\",\"resolvePath\",\"Await\",\"_ref7\",\"MemoryRouter\",\"_ref3\",\"initialEntries\",\"initialIndex\",\"historyRef\",\"createMemoryHistory\",\"v5Compat\",\"history\",\"setStateImpl\",\"useState\",\"setState\",\"newState\",\"listen\",\"useEffect\",\"Navigate\",\"_ref4\",\"jsonPath\",\"Outlet\",\"RouterProvider\",\"fallbackElement\",\"subscribe\",\"createHref\",\"opts\",\"preventScrollReset\",\"historyAction\",\"Routes\",\"_ref6\",\"UNSAFE_DataRouterContext\",\"UNSAFE_DataRouterStateContext\",\"UNSAFE_LocationContext\",\"UNSAFE_NavigationContext\",\"UNSAFE_RouteContext\",\"UNSAFE_logV6DeprecationWarnings\",\"UNSAFE_mapRouteProperties\",\"UNSAFE_useRouteId\",\"useRouteId\",\"UseRouteId\",\"UNSAFE_useRoutesImpl\",\"createMemoryRouter\",\"createRouter\",\"v7_prependBasename\",\"hydrationData\",\"dataStrategy\",\"patchRoutesOnNavigation\",\"initialize\",\"createRoutesFromElements\",\"renderMatches\",\"useActionData\",\"UseActionData\",\"UseLoaderData\",\"actionData\",\"useAsyncError\",\"useBlocker\",\"shouldBlock\",\"UseBlocker\",\"blockerKey\",\"setBlockerKey\",\"blockerFunction\",\"arg\",\"currentLocation\",\"nextLocation\",\"String\",\"deleteBlocker\",\"getBlocker\",\"blockers\",\"has\",\"IDLE_BLOCKER\",\"useHref\",\"_temp\",\"joinedPathname\",\"useLoaderData\",\"useMatch\",\"pattern\",\"UNSAFE_decodePath\",\"useMatches\",\"UseMatches\",\"UNSAFE_convertRouteMatchToUiMatch\",\"useNavigation\",\"UseNavigation\",\"navigation\",\"useNavigationType\",\"useOutletContext\",\"useParams\",\"useRevalidator\",\"UseRevalidator\",\"revalidate\",\"useRouteLoaderData\",\"UseRouteLoaderData\"]\n}\n"]