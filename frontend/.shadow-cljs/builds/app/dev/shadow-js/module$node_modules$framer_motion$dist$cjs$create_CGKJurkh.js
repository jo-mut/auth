["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/framer-motion/dist/cjs/create-CGKJurkh.js"],"~:js","shadow$provide.module$node_modules$framer_motion$dist$cjs$create_CGKJurkh = function(global, require, module, exports) {\n  function isAnimationControls(v) {\n    return null !== v && \"object\" === typeof v && \"function\" === typeof v.start;\n  }\n  function getValueState(visualElement) {\n    const state = [{}, {}];\n    null === visualElement || void 0 === visualElement || visualElement.values.forEach((value, key) => {\n      state[0][key] = value.get();\n      state[1][key] = value.getVelocity();\n    });\n    return state;\n  }\n  function resolveVariantFromProps(props, definition, custom, visualElement) {\n    if (\"function\" === typeof definition) {\n      const [current, velocity] = getValueState(visualElement);\n      definition = definition(void 0 !== custom ? custom : props.custom, current, velocity);\n    }\n    \"string\" === typeof definition && (definition = props.variants && props.variants[definition]);\n    if (\"function\" === typeof definition) {\n      const [current, velocity] = getValueState(visualElement);\n      definition = definition(void 0 !== custom ? custom : props.custom, current, velocity);\n    }\n    return definition;\n  }\n  function resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, void 0 !== custom ? custom : props.custom, visualElement);\n  }\n  function createRenderStep(runNextFrame, stepName) {\n    function triggerCallback(callback) {\n      toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame());\n      numCalls++;\n      callback(latestFrameData);\n    }\n    let thisFrame = new Set(), nextFrame = new Set(), isProcessing = !1, flushNextFrame = !1;\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {delta:0.0, timestamp:0.0, isProcessing:!1}, numCalls = 0;\n    const step = {schedule:(callback, keepAlive = !1, immediate = !1) => {\n      immediate = immediate && isProcessing ? thisFrame : nextFrame;\n      keepAlive && toKeepAlive.add(callback);\n      immediate.has(callback) || immediate.add(callback);\n      return callback;\n    }, cancel:callback => {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    }, process:frameData => {\n      latestFrameData = frameData;\n      isProcessing ? flushNextFrame = !0 : (isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], thisFrame.forEach(triggerCallback), stepName && statsBuffer.value && statsBuffer.value.frameloop[stepName].push(numCalls), numCalls = 0, thisFrame.clear(), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData)));\n    }};\n    return step;\n  }\n  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = !1, useDefaultElapsed = !0;\n    const state = {delta:0.0, timestamp:0.0, isProcessing:!1}, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key) => {\n      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);\n      return acc;\n    }, {}), {read, resolveKeyframes, update, preRender, render, postRender} = steps, processBatch = () => {\n      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();\n      runNextFrame = !1;\n      MotionGlobalConfig.useManualTiming || (state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, 40), 1));\n      state.timestamp = timestamp;\n      state.isProcessing = !0;\n      read.process(state);\n      resolveKeyframes.process(state);\n      update.process(state);\n      preRender.process(state);\n      render.process(state);\n      postRender.process(state);\n      state.isProcessing = !1;\n      runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));\n    };\n    return {schedule:stepsOrder.reduce((acc, key) => {\n      const step = steps[key];\n      acc[key] = (process, keepAlive = !1, immediate = !1) => {\n        runNextFrame || (useDefaultElapsed = runNextFrame = !0, state.isProcessing || scheduleNextBatch(processBatch));\n        return step.schedule(process, keepAlive, immediate);\n      };\n      return acc;\n    }, {}), cancel:process => {\n      for (let i = 0; i < stepsOrder.length; i++) {\n        steps[stepsOrder[i]].cancel(process);\n      }\n    }, state, steps};\n  }\n  function clearTime() {\n    now = void 0;\n  }\n  function addUniqueItem(arr, item) {\n    -1 === arr.indexOf(item) && arr.push(item);\n  }\n  function removeItem(arr, item) {\n    item = arr.indexOf(item);\n    -1 < item && arr.splice(item, 1);\n  }\n  function velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? 1000 / frameDuration * velocity : 0;\n  }\n  function warnOnce(condition, message, element) {\n    condition || warned.has(message) || (console.warn(message), element && console.warn(element), warned.add(message));\n  }\n  function motionValue(init, options) {\n    return new MotionValue(init, options);\n  }\n  function setTarget(visualElement, definition) {\n    definition = resolveVariant(visualElement, definition);\n    let {transitionEnd = {}, transition = {}, ...target} = definition || {};\n    target = {...target, ...transitionEnd};\n    for (const key in target) {\n      definition = target[key];\n      const value = Array.isArray(definition) ? definition[definition.length - 1] || 0 : definition;\n      definition = visualElement;\n      definition.hasValue(key) ? definition.getValue(key).set(value) : definition.addValue(key, motionValue(value));\n    }\n  }\n  function addValueToWillChange(visualElement, key) {\n    if ((visualElement = visualElement.getValue(\"willChange\")) && visualElement.getVelocity && visualElement.add) {\n      return visualElement.add(key);\n    }\n  }\n  function getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n  }\n  function cubicBezier(mX1, mY1, mX2, mY2) {\n    return mX1 === mY1 && mX2 === mY2 ? motionUtils.noop : t => {\n      if (0 !== t && 1 !== t) {\n        var lowerBound = 0, upperBound = 1;\n        let currentX, currentT, i = 0;\n        do {\n          currentT = lowerBound + (upperBound - lowerBound) / 2.0, currentX = (((1.0 - 3.0 * mX2 + 3.0 * mX1) * currentT + (3.0 * mX2 - 6.0 * mX1)) * currentT + 3.0 * mX1) * currentT - t, 0.0 < currentX ? upperBound = currentT : lowerBound = currentT;\n        } while (0.0000001 < Math.abs(currentX) && 12 > ++i);\n        t = currentT;\n        t *= ((1.0 - 3.0 * mY2 + 3.0 * mY1) * t + (3.0 * mY2 - 6.0 * mY1)) * t + 3.0 * mY1;\n      }\n      return t;\n    };\n  }\n  function analyseComplexValue(value) {\n    const values = [], indexes = {color:[], number:[], var:[]}, types = [];\n    let i = 0;\n    value = value.toString().replace(complexRegex, parsedValue => {\n      color.test(parsedValue) ? (indexes.color.push(i), types.push(\"color\"), values.push(color.parse(parsedValue))) : parsedValue.startsWith(\"var(\") ? (indexes.var.push(i), types.push(\"var\"), values.push(parsedValue)) : (indexes.number.push(i), types.push(\"number\"), values.push(parseFloat(parsedValue)));\n      ++i;\n      return \"${}\";\n    }).split(\"${}\");\n    return {values, split:value, indexes, types};\n  }\n  function parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n  }\n  function createTransformer(source) {\n    const {split, types} = analyseComplexValue(source), numSections = split.length;\n    return v => {\n      let output = \"\";\n      for (let i = 0; i < numSections; i++) {\n        if (output += split[i], void 0 !== v[i]) {\n          const type = types[i];\n          output = \"number\" === type ? output + Math.round(100000 * v[i]) / 100000 : \"color\" === type ? output + color.transform(v[i]) : output + v[i];\n        }\n      }\n      return output;\n    };\n  }\n  function applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (\"drop-shadow\" === name) {\n      return v;\n    }\n    const [number] = value.match(floatRegex) || [];\n    if (!number) {\n      return v;\n    }\n    v = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    number !== value && (defaultValue *= 100);\n    return name + \"(\" + defaultValue + v + \")\";\n  }\n  function getAnimatableNone(key, value) {\n    key = defaultValueTypes[key];\n    key !== filter && (key = complex);\n    return key.getAnimatableNone ? key.getAnimatableNone(value) : void 0;\n  }\n  function removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(key => {\n      const value = visualElement.getValue(key);\n      void 0 !== value && (removedTransforms.push([key, value.get()]), value.set(key.startsWith(\"scale\") ? 1 : 0));\n    });\n    return removedTransforms;\n  }\n  function measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n      const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element)), transformsToRestore = new Map();\n      elementsToMeasure.forEach(element => {\n        const removedTransforms = removeNonTranslationalTransform(element);\n        removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());\n      });\n      resolversToMeasure.forEach(resolver => resolver.measureInitialState());\n      elementsToMeasure.forEach(element => {\n        element.render();\n        const restore = transformsToRestore.get(element);\n        restore && restore.forEach(([key, value]) => {\n          var _a;\n          null === (_a = element.getValue(key)) || void 0 === _a || _a.set(value);\n        });\n      });\n      resolversToMeasure.forEach(resolver => resolver.measureEndState());\n      resolversToMeasure.forEach(resolver => {\n        void 0 !== resolver.suspendedScrollY && window.scrollTo(0, resolver.suspendedScrollY);\n      });\n    }\n    isScheduled = anyNeedsMeasurement = !1;\n    toResolve.forEach(resolver => resolver.complete());\n    toResolve.clear();\n  }\n  function readAllKeyframes() {\n    toResolve.forEach(resolver => {\n      resolver.readKeyframes();\n      resolver.needsMeasurement && (anyNeedsMeasurement = !0);\n    });\n  }\n  function getVariableValue(current, element, depth = 1) {\n    motionUtils.invariant(4 >= depth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    if (current = splitCSSVariableRegex.exec(current)) {\n      var [, token1, token2, fallback] = current;\n      current = [`--${null !== token1 && void 0 !== token1 ? token1 : token2}`, fallback];\n    } else {\n      current = [, ];\n    }\n    const [token, fallback$jscomp$0] = current;\n    if (token) {\n      return (current = window.getComputedStyle(element).getPropertyValue(token)) ? (element = current.trim(), /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(element) ? parseFloat(element) : element) : isCSSVariableToken(fallback$jscomp$0) ? getVariableValue(fallback$jscomp$0, element, depth + 1) : fallback$jscomp$0;\n    }\n  }\n  function getFinalKeyframe(keyframes, {repeat, repeatType = \"loop\"}, finalKeyframe) {\n    keyframes = keyframes.filter(isNotNull);\n    return (repeat = repeat && \"loop\" !== repeatType && 1 === repeat % 2 ? 0 : keyframes.length - 1) && void 0 !== finalKeyframe ? finalKeyframe : keyframes[repeat];\n  }\n  function hueToRgb(p, q, t) {\n    0 > t && (t += 1);\n    1 < t && --t;\n    return t < 1 / 6 ? p + 6 * (q - p) * t : .5 > t ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;\n  }\n  function hslaToRgba({hue, saturation, lightness, alpha}) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    if (saturation) {\n      const q = 0.5 > lightness ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p = 2 * lightness - q;\n      lightness = hueToRgb(p, q, hue + 1 / 3);\n      saturation = hueToRgb(p, q, hue);\n      hue = hueToRgb(p, q, hue - 1 / 3);\n    } else {\n      lightness = saturation = hue = lightness;\n    }\n    return {red:Math.round(255 * lightness), green:Math.round(255 * saturation), blue:Math.round(255 * hue), alpha};\n  }\n  function mixImmediate(a, b) {\n    return p => 0 < p ? b : a;\n  }\n  function asRGBA(color) {\n    const type = getColorType(color);\n    motionUtils.warning(!!type, `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    if (!type) {\n      return !1;\n    }\n    color = type.parse(color);\n    type === hsla && (color = hslaToRgba(color));\n    return color;\n  }\n  function mixVisibility(origin, target) {\n    return invisibleValues.has(origin) ? p => 0 >= p ? origin : target : p => 1 <= p ? target : origin;\n  }\n  function mixNumber(a, b) {\n    return p => a + (b - a) * p;\n  }\n  function getMixer(a) {\n    return \"number\" === typeof a ? mixNumber : \"string\" === typeof a ? isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex : Array.isArray(a) ? mixArray : \"object\" === typeof a ? color.test(a) ? mixColor : mixObject : mixImmediate;\n  }\n  function mixArray(a, b) {\n    const output = [...a], numValues = output.length, blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return p => {\n      for (let i = 0; i < numValues; i++) {\n        output[i] = blendValue[i](p);\n      }\n      return output;\n    };\n  }\n  function mixObject(a, b) {\n    const output = {...a, ...b}, blendValue = {};\n    for (const key in output) {\n      void 0 !== a[key] && void 0 !== b[key] && (blendValue[key] = getMixer(a[key])(a[key], b[key]));\n    }\n    return v => {\n      for (const key in blendValue) {\n        output[key] = blendValue[key](v);\n      }\n      return output;\n    };\n  }\n  function mix(from, to, p) {\n    return \"number\" === typeof from && \"number\" === typeof to && \"number\" === typeof p ? from + (to - from) * p : getMixer(from)(from, to);\n  }\n  function calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - 5, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n  }\n  function findSpring({duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass}) {\n    let envelope;\n    motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));\n    1 > dampingRatio ? (envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      return 0.001 - (exponentialDecay - velocity) / (undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio)) * Math.exp(-(exponentialDecay * duration));\n    }, bounce = undampedFreq => {\n      var delta = undampedFreq * dampingRatio * duration;\n      const d = delta * velocity + velocity, e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      delta = Math.exp(-delta);\n      const g = Math.pow(undampedFreq, 2) * Math.sqrt(1 - dampingRatio * dampingRatio);\n      return (0 < -envelope(undampedFreq) + 0.001 ? -1 : 1) * (d - e) * delta / g;\n    }) : (envelope = undampedFreq => -0.001 + Math.exp(-undampedFreq * duration) * ((undampedFreq - velocity) * duration + 1), bounce = undampedFreq => Math.exp(-undampedFreq * duration) * (velocity - undampedFreq) * duration * duration);\n    bounce = approximateRoot(envelope, bounce, 5 / duration);\n    duration = motionUtils.secondsToMilliseconds(duration);\n    if (isNaN(bounce)) {\n      return {stiffness:springDefaults.stiffness, damping:springDefaults.damping, duration};\n    }\n    bounce = Math.pow(bounce, 2) * mass;\n    return {stiffness:bounce, damping:2 * dampingRatio * Math.sqrt(mass * bounce), duration};\n  }\n  function approximateRoot(envelope, derivative, initialGuess) {\n    for (let i = 1; 12 > i; i++) {\n      initialGuess -= envelope(initialGuess) / derivative(initialGuess);\n    }\n    return initialGuess;\n  }\n  function isSpringType(options, keys) {\n    return keys.some(key => void 0 !== options[key]);\n  }\n  function getSpringOptions(options) {\n    let springOptions = {velocity:springDefaults.velocity, stiffness:springDefaults.stiffness, damping:springDefaults.damping, mass:springDefaults.mass, isResolvedFromDuration:!1, ...options};\n    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n      if (options.visualDuration) {\n        var root = 2 * Math.PI / (1.2 * options.visualDuration);\n        root *= root;\n        options = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(root);\n        springOptions = {...springOptions, mass:springDefaults.mass, stiffness:root, damping:options};\n      } else {\n        options = findSpring(options), springOptions = {...springOptions, ...options, mass:springDefaults.mass, isResolvedFromDuration:!0};\n      }\n    }\n    return springOptions;\n  }\n  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    optionsOrVisualDuration = \"object\" !== typeof optionsOrVisualDuration ? {visualDuration:optionsOrVisualDuration, keyframes:[0, 1], bounce} : optionsOrVisualDuration;\n    let {restSpeed, restDelta} = optionsOrVisualDuration;\n    bounce = optionsOrVisualDuration.keyframes[0];\n    const target = optionsOrVisualDuration.keyframes[optionsOrVisualDuration.keyframes.length - 1], state = {done:!1, value:bounce}, {stiffness, damping, mass, duration, velocity, isResolvedFromDuration} = getSpringOptions({...optionsOrVisualDuration, velocity:-motionUtils.millisecondsToSeconds(optionsOrVisualDuration.velocity || 0)}), initialVelocity = velocity || 0.0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - bounce, undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / \n    mass));\n    optionsOrVisualDuration = 5 > Math.abs(initialDelta);\n    restSpeed || (restSpeed = optionsOrVisualDuration ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);\n    restDelta || (restDelta = optionsOrVisualDuration ? springDefaults.restDelta.granular : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (1 > dampingRatio) {\n      const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n      resolveSpring = t => target - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    } else if (1 === dampingRatio) {\n      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = t => {\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return target - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n    const generator = {calculatedDuration:isResolvedFromDuration ? duration || null : null, next:t => {\n      const current = resolveSpring(t);\n      if (isResolvedFromDuration) {\n        state.done = t >= duration;\n      } else {\n        let currentVelocity = 0.0;\n        1 > dampingRatio && (currentVelocity = 0 === t ? motionUtils.secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current));\n        t = Math.abs(target - current) <= restDelta;\n        state.done = Math.abs(currentVelocity) <= restSpeed && t;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    }, toString:() => {\n      const calculatedDuration = Math.min(motionDom.calcGeneratorDuration(generator), motionDom.maxGeneratorDuration), easing = motionDom.generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n      return calculatedDuration + \"ms \" + easing;\n    }};\n    return generator;\n  }\n  function inertia({keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed}) {\n    keyframes = keyframes[0];\n    const state = {done:!1, value:keyframes};\n    let amplitude = power * velocity;\n    velocity = keyframes + amplitude;\n    const target = void 0 === modifyTarget ? velocity : modifyTarget(velocity);\n    target !== velocity && (amplitude = target - keyframes);\n    const calcLatest = t => target + -amplitude * Math.exp(-t / timeConstant), applyFriction = t => {\n      const latest = target + -amplitude * Math.exp(-t / timeConstant);\n      state.done = Math.abs(-amplitude * Math.exp(-t / timeConstant)) <= restDelta;\n      state.value = state.done ? target : latest;\n    };\n    let timeReachedBoundary, spring$1;\n    const checkCatchBoundary = t => {\n      var v = state.value;\n      if (void 0 !== min && v < min || void 0 !== max && v > max) {\n        timeReachedBoundary = t;\n        v = state.value;\n        var JSCompiler_inline_result = state.value;\n        JSCompiler_inline_result = void 0 === min ? max : void 0 === max ? min : Math.abs(min - JSCompiler_inline_result) < Math.abs(max - JSCompiler_inline_result) ? min : max;\n        spring$1 = spring({keyframes:[v, JSCompiler_inline_result], velocity:calcGeneratorVelocity(calcLatest, t, state.value), damping:bounceDamping, stiffness:bounceStiffness, restDelta, restSpeed});\n      }\n    };\n    checkCatchBoundary(0);\n    return {calculatedDuration:null, next:t => {\n      let hasUpdatedFrame = !1;\n      spring$1 || void 0 !== timeReachedBoundary || (hasUpdatedFrame = !0, applyFriction(t), checkCatchBoundary(t));\n      if (void 0 !== timeReachedBoundary && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      }\n      !hasUpdatedFrame && applyFriction(t);\n      return state;\n    }};\n  }\n  function createMixers(output, ease, customMixer) {\n    const mixers = [];\n    customMixer = customMixer || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n      let mixer = customMixer(output[i], output[i + 1]);\n      ease && (mixer = [Array.isArray(ease) ? ease[i] || motionUtils.noop : ease, mixer].reduce(combineFunctions));\n      mixers.push(mixer);\n    }\n    return mixers;\n  }\n  function interpolate(input, output, {clamp:isClamp = !0, ease, mixer} = {}) {\n    const inputLength = input.length;\n    motionUtils.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    if (1 === inputLength) {\n      return () => output[0];\n    }\n    if (2 === inputLength && output[0] === output[1]) {\n      return () => output[1];\n    }\n    const isZeroDeltaRange = input[0] === input[1];\n    input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());\n    const mixers = createMixers(output, ease, mixer), numMixers = mixers.length, interpolator = v => {\n      if (isZeroDeltaRange && v < input[0]) {\n        return output[0];\n      }\n      let i = 0;\n      if (1 < numMixers) {\n        for (; i < input.length - 2 && !(v < input[i + 1]); i++) {\n        }\n      }\n      v = motionUtils.progress(input[i], input[i + 1], v);\n      return mixers[i](v);\n    };\n    return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n  }\n  function fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n      const offsetProgress = motionUtils.progress(0, remaining, i);\n      offset.push(min + (1 - min) * offsetProgress);\n    }\n  }\n  function defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n  }\n  function convertOffsetToTimes(offset, duration) {\n    return offset.map(o => o * duration);\n  }\n  function defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n  }\n  function keyframes({duration = 300, keyframes:keyframeValues, times, ease = \"easeInOut\"}) {\n    ease = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n    const state = {done:!1, value:keyframeValues[0]};\n    times = convertOffsetToTimes(times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(times, keyframeValues, {ease:Array.isArray(ease) ? ease : defaultEasing(keyframeValues, ease)});\n    return {calculatedDuration:duration, next:t => {\n      state.value = mapTimeToKeyframe(t);\n      state.done = t >= duration;\n      return state;\n    }};\n  }\n  function startWaapiAnimation(element, valueName, keyframes, {delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times} = {}) {\n    valueName = {[valueName]:keyframes};\n    times && (valueName.offset = times);\n    ease = motionDom.mapEasingToNativeEasing(ease, duration);\n    Array.isArray(ease) && (valueName.easing = ease);\n    return element.animate(valueName, {delay, duration, easing:Array.isArray(ease) ? \"linear\" : ease, fill:\"both\", iterations:repeat + 1, direction:\"reverse\" === repeatType ? \"alternate\" : \"normal\"});\n  }\n  function requiresPregeneratedKeyframes(options) {\n    return motionDom.isGenerator(options.type) || \"spring\" === options.type || !motionDom.isWaapiSupportedEasing(options.ease);\n  }\n  function pregenerateKeyframes(keyframes, options) {\n    options = new MainThreadAnimation({...options, keyframes, repeat:0, delay:0, isGenerator:!0});\n    keyframes = {done:!1, value:keyframes[0]};\n    const pregeneratedKeyframes = [];\n    let t = 0;\n    for (; !keyframes.done && 20000 > t;) {\n      keyframes = options.sample(t), pregeneratedKeyframes.push(keyframes.value), t += 10;\n    }\n    return {times:void 0, keyframes:pregeneratedKeyframes, duration:t - 10, ease:\"linear\"};\n  }\n  function isTransitionDefined({when, delay:_delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition}) {\n    return !!Object.keys(transition).length;\n  }\n  function shouldBlockAnimation({protectedKeys, needsAnimating}, key) {\n    protectedKeys = protectedKeys.hasOwnProperty(key) && !0 !== needsAnimating[key];\n    needsAnimating[key] = !1;\n    return protectedKeys;\n  }\n  function animateTarget(visualElement, targetAndTransition, {delay = 0, transitionOverride, type} = {}) {\n    var _a;\n    let {transition = visualElement.getDefaultTransition(), transitionEnd, ...target} = targetAndTransition;\n    transitionOverride && (transition = transitionOverride);\n    targetAndTransition = [];\n    type = type && visualElement.animationState && visualElement.animationState.getState()[type];\n    for (const key in target) {\n      transitionOverride = visualElement.getValue(key, null !== (_a = visualElement.latestValues[key]) && void 0 !== _a ? _a : null);\n      const valueTarget = target[key];\n      if (void 0 === valueTarget || type && shouldBlockAnimation(type, key)) {\n        continue;\n      }\n      const valueTransition = {delay, ...motionDom.getValueTransition(transition || {}, key)};\n      let isHandoff = !1;\n      if (window.MotionHandoffAnimation) {\n        var appearId = getOptimisedAppearId(visualElement);\n        appearId && (appearId = window.MotionHandoffAnimation(appearId, key, frame), null !== appearId && (valueTransition.startTime = appearId, isHandoff = !0));\n      }\n      addValueToWillChange(visualElement, key);\n      transitionOverride.start(animateMotionValue(key, transitionOverride, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? {type:!1} : valueTransition, visualElement, isHandoff));\n      (transitionOverride = transitionOverride.animation) && targetAndTransition.push(transitionOverride);\n    }\n    transitionEnd && Promise.all(targetAndTransition).then(() => {\n      frame.update(() => {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n      });\n    });\n    return targetAndTransition;\n  }\n  function animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, \"exit\" === options.type ? null === (_a = visualElement.presenceContext) || void 0 === _a ? void 0 : _a.custom : void 0);\n    let {transition = visualElement.getDefaultTransition() || {}} = resolved || {};\n    options.transitionOverride && (transition = options.transitionOverride);\n    _a = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {\n      const {delayChildren = 0, staggerChildren, staggerDirection} = transition;\n      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n    } : () => Promise.resolve(), {when} = transition;\n    if (when) {\n      const [first, last] = \"beforeChildren\" === when ? [_a, getChildAnimations] : [getChildAnimations, _a];\n      return first().then(() => last());\n    }\n    return Promise.all([_a(), getChildAnimations(options.delay)]);\n  }\n  function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = 1 === staggerDirection ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n      child.notify(\"AnimationStart\", variant);\n      animations.push(animateVariant(child, variant, {...options, delay:delayChildren + generateStaggerDuration(i)}).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n  }\n  function sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n  }\n  function animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    if (Array.isArray(definition)) {\n      var animation = definition.map(variant => animateVariant(visualElement, variant, options));\n      animation = Promise.all(animation);\n    } else {\n      \"string\" === typeof definition ? animation = animateVariant(visualElement, definition, options) : (animation = \"function\" === typeof definition ? resolveVariant(visualElement, definition, options.custom) : definition, animation = Promise.all(animateTarget(visualElement, animation, options)));\n    }\n    return animation.then(() => {\n      visualElement.notify(\"AnimationComplete\", definition);\n    });\n  }\n  function shallowCompare(next, prev) {\n    if (!Array.isArray(prev)) {\n      return !1;\n    }\n    const prevLength = prev.length;\n    if (prevLength !== next.length) {\n      return !1;\n    }\n    for (let i = 0; i < prevLength; i++) {\n      if (prev[i] !== next[i]) {\n        return !1;\n      }\n    }\n    return !0;\n  }\n  function isVariantLabel(v) {\n    return \"string\" === typeof v || Array.isArray(v);\n  }\n  function getVariantContext(visualElement) {\n    if (visualElement) {\n      if (!visualElement.isControllingVariants) {\n        var context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};\n        void 0 !== visualElement.props.initial && (context.initial = visualElement.props.initial);\n        return context;\n      }\n      context = {};\n      for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i], prop = visualElement.props[name];\n        if (isVariantLabel(prop) || !1 === prop) {\n          context[name] = prop;\n        }\n      }\n      return context;\n    }\n  }\n  function animateList(visualElement) {\n    return animations => Promise.all(animations.map(({animation, options}) => animateVisualElement(visualElement, animation, options)));\n  }\n  function createAnimationState(visualElement) {\n    function animateChanges(changedActiveType) {\n      const {props} = visualElement, context = getVariantContext(visualElement.parent) || {}, animations = [], removedKeys = new Set();\n      let encounteredKeys = {}, removedVariantIndex = Infinity;\n      for (let i = 0; i < numAnimationTypes; i++) {\n        const type = reversePriorityOrder[i], typeState = state[type];\n        var prop = void 0 !== props[type] ? props[type] : context[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;\n        !1 === activeDelta && (removedVariantIndex = i);\n        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n        isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1);\n        typeState.protectedKeys = {...encounteredKeys};\n        if (!typeState.isActive && null === activeDelta || !prop && !typeState.prevProp || isAnimationControls(prop) || \"boolean\" === typeof prop) {\n          continue;\n        }\n        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n        let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i > removedVariantIndex && propIsVariant, handledRemovedValues = !1;\n        propIsVariant = Array.isArray(prop) ? prop : [prop];\n        let resolvedValues = propIsVariant.reduce(buildResolvedTypeValues(type), {});\n        !1 === activeDelta && (resolvedValues = {});\n        ({prevResolvedValues:activeDelta = {}} = typeState);\n        var allKeys = {...activeDelta, ...resolvedValues};\n        const markToAnimate = key => {\n          shouldAnimateType = !0;\n          removedKeys.has(key) && (handledRemovedValues = !0, removedKeys.delete(key));\n          typeState.needsAnimating[key] = !0;\n          if (key = visualElement.getValue(key)) {\n            key.liveStyle = !1;\n          }\n        };\n        for (const key in allKeys) {\n          allKeys = resolvedValues[key];\n          const prev = activeDelta[key];\n          if (encounteredKeys.hasOwnProperty(key)) {\n            continue;\n          }\n          let valueHasChanged = !1;\n          (valueHasChanged = Array.isArray(allKeys) && Array.isArray(prev) ? !shallowCompare(allKeys, prev) : allKeys !== prev) ? void 0 !== allKeys && null !== allKeys ? markToAnimate(key) : removedKeys.add(key) : void 0 !== allKeys && removedKeys.has(key) ? markToAnimate(key) : typeState.protectedKeys[key] = !0;\n        }\n        typeState.prevProp = prop;\n        typeState.prevResolvedValues = resolvedValues;\n        typeState.isActive && (encounteredKeys = {...encounteredKeys, ...resolvedValues});\n        isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1);\n        prop = !(isInherited && variantDidChange) || handledRemovedValues;\n        shouldAnimateType && prop && animations.push(...propIsVariant.map(animation => ({animation, options:{type}})));\n      }\n      if (removedKeys.size) {\n        const fallbackAnimation = {};\n        \"boolean\" !== typeof props.initial && (changedActiveType = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial)) && changedActiveType.transition && (fallbackAnimation.transition = changedActiveType.transition);\n        removedKeys.forEach(key => {\n          const fallbackTarget = visualElement.getBaseTarget(key), motionValue = visualElement.getValue(key);\n          motionValue && (motionValue.liveStyle = !0);\n          fallbackAnimation[key] = null !== fallbackTarget && void 0 !== fallbackTarget ? fallbackTarget : null;\n        });\n        animations.push({animation:fallbackAnimation});\n      }\n      changedActiveType = !!animations.length;\n      !isInitialRender || !1 !== props.initial && props.initial !== props.animate || visualElement.manuallyAnimateOnMount || (changedActiveType = !1);\n      isInitialRender = !1;\n      return changedActiveType ? animate(animations) : Promise.resolve();\n    }\n    let animate = animateList(visualElement), state = createState(), isInitialRender = !0;\n    const buildResolvedTypeValues = type => (acc, definition) => {\n      var _a;\n      if (definition = resolveVariant(visualElement, definition, \"exit\" === type ? null === (_a = visualElement.presenceContext) || void 0 === _a ? void 0 : _a.custom : void 0)) {\n        const {transition, transitionEnd, ...target} = definition;\n        acc = {...acc, ...target, ...transitionEnd};\n      }\n      return acc;\n    };\n    return {animateChanges, setActive:function(type, isActive) {\n      var _a;\n      if (state[type].isActive === isActive) {\n        return Promise.resolve();\n      }\n      null === (_a = visualElement.variantChildren) || void 0 === _a || _a.forEach(child => {\n        var _a;\n        return null === (_a = child.animationState) || void 0 === _a ? void 0 : _a.setActive(type, isActive);\n      });\n      state[type].isActive = isActive;\n      _a = animateChanges(type);\n      for (const key in state) {\n        state[key].protectedKeys = {};\n      }\n      return _a;\n    }, setAnimateFunction:function(makeAnimator) {\n      animate = makeAnimator(visualElement);\n    }, getState:() => state, reset:() => {\n      state = createState();\n      isInitialRender = !0;\n    }};\n  }\n  function checkVariantsDidChange(prev, next) {\n    return \"string\" === typeof next ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;\n  }\n  function createTypeState(isActive = !1) {\n    return {isActive, protectedKeys:{}, needsAnimating:{}, prevResolvedValues:{}};\n  }\n  function createState() {\n    return {animate:createTypeState(!0), whileInView:createTypeState(), whileHover:createTypeState(), whileTap:createTypeState(), whileDrag:createTypeState(), whileFocus:createTypeState(), exit:createTypeState()};\n  }\n  function calcLength(axis) {\n    return axis.max - axis.min;\n  }\n  function calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;\n    if (.9999 <= delta.scale && 1.0001 >= delta.scale || isNaN(delta.scale)) {\n      delta.scale = 1.0;\n    }\n    if (-.01 <= delta.translate && .01 >= delta.translate || isNaN(delta.translate)) {\n      delta.translate = 0.0;\n    }\n  }\n  function calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);\n  }\n  function calcRelativePosition(target$jscomp$0, layout$jscomp$0, parent) {\n    var target = target$jscomp$0.x, layout = layout$jscomp$0.x;\n    target.min = layout.min - parent.x.min;\n    target.max = target.min + calcLength(layout);\n    target$jscomp$0 = target$jscomp$0.y;\n    layout$jscomp$0 = layout$jscomp$0.y;\n    target$jscomp$0.min = layout$jscomp$0.min - parent.y.min;\n    target$jscomp$0.max = target$jscomp$0.min + calcLength(layout$jscomp$0);\n  }\n  function isValidMotionProp(key) {\n    return key.startsWith(\"while\") || key.startsWith(\"drag\") && \"draggable\" !== key || key.startsWith(\"layout\") || key.startsWith(\"onTap\") || key.startsWith(\"onPan\") || key.startsWith(\"onLayout\") || validMotionProps.has(key);\n  }\n  function loadExternalIsValidProp(isValidProp) {\n    isValidProp && (shouldForward = key => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key));\n  }\n  function filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n      if (\"values\" !== key || \"object\" !== typeof props.values) {\n        if (shouldForward(key) || !0 === forwardMotionProps && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props.draggable && key.startsWith(\"onDrag\")) {\n          filteredProps[key] = props[key];\n        }\n      }\n    }\n    return filteredProps;\n  }\n  function isControllingVariants(props) {\n    return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));\n  }\n  function isVariantNode(props) {\n    return !(!isControllingVariants(props) && !props.variants);\n  }\n  function useConstant(init) {\n    const ref = React.useRef(null);\n    null === ref.current && (ref.current = init());\n    return ref.current;\n  }\n  function resolveMotionValue(value) {\n    return (value = value && value.getVelocity ? value.get() : value) && \"object\" === typeof value && value.mix && value.toValue ? value.toValue() : value;\n  }\n  function makeState({scrapeMotionValuesFromProps, createRenderState, onUpdate}, props, context, presenceContext) {\n    const state = {latestValues:makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps), renderState:createRenderState()};\n    onUpdate && (state.onMount = instance => onUpdate({props, current:instance, ...state}), state.onUpdate = visualElement => onUpdate(visualElement));\n    return state;\n  }\n  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    scrapeMotionValues = scrapeMotionValues(props, {});\n    for (var key in scrapeMotionValues) {\n      values[key] = resolveMotionValue(scrapeMotionValues[key]);\n    }\n    let {initial, animate} = props;\n    key = isControllingVariants(props);\n    scrapeMotionValues = isVariantNode(props);\n    context && scrapeMotionValues && !key && !1 !== props.inherit && (void 0 === initial && (initial = context.initial), void 0 === animate && (animate = context.animate));\n    if ((presenceContext = (context = (context = presenceContext ? !1 === presenceContext.initial : !1) || !1 === initial) ? animate : initial) && \"boolean\" !== typeof presenceContext && !isAnimationControls(presenceContext)) {\n      for (presenceContext = Array.isArray(presenceContext) ? presenceContext : [presenceContext], key = 0; key < presenceContext.length; key++) {\n        if (scrapeMotionValues = resolveVariantFromProps(props, presenceContext[key])) {\n          const {transitionEnd, transition, ...target} = scrapeMotionValues;\n          for (const key in target) {\n            scrapeMotionValues = target[key], Array.isArray(scrapeMotionValues) && (scrapeMotionValues = scrapeMotionValues[context ? scrapeMotionValues.length - 1 : 0]), null !== scrapeMotionValues && (values[key] = scrapeMotionValues);\n          }\n          for (const key in transitionEnd) {\n            values[key] = transitionEnd[key];\n          }\n        }\n      }\n    }\n    return values;\n  }\n  function addDomEvent(target, eventName, handler, options = {passive:!0}) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n  }\n  function extractEventInfo(event) {\n    return {point:{x:event.pageX, y:event.pageY}};\n  }\n  function addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n  }\n  function usePresence(subscribe = !0) {\n    var context = React.useContext(PresenceContext);\n    if (null === context) {\n      return [!0, null];\n    }\n    const {isPresent, onExitComplete, register} = context, id = React.useId();\n    React.useEffect(() => {\n      if (subscribe) {\n        return register(id);\n      }\n    }, [subscribe]);\n    context = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [!1, context] : [!0];\n  }\n  function animateSingleValue(value, keyframes, options) {\n    value = value && value.getVelocity ? value : motionValue(value);\n    value.start(animateMotionValue(\"\", value, keyframes, options));\n    return value.animation;\n  }\n  function isSVGElement(element) {\n    return element instanceof SVGElement && \"svg\" !== element.tagName;\n  }\n  function initPrefersReducedMotion() {\n    hasReducedMotionListener.current = !0;\n    if (isBrowser) {\n      if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        motionMediaQuery.addListener(() => prefersReducedMotion.current = motionMediaQuery.matches);\n        prefersReducedMotion.current = motionMediaQuery.matches;\n      } else {\n        prefersReducedMotion.current = !1;\n      }\n    }\n  }\n  function buildTransform(latestValues, transform, transformTemplate) {\n    let transformString = \"\", transformIsDefault = !0;\n    for (let i = 0; i < numTransforms; i++) {\n      const key = transformPropOrder[i];\n      var value = latestValues[key];\n      if (void 0 === value) {\n        continue;\n      }\n      let valueIsDefault;\n      valueIsDefault = \"number\" === typeof value ? value === (key.startsWith(\"scale\") ? 1 : 0) : 0 === parseFloat(value);\n      if (!valueIsDefault || transformTemplate) {\n        value = getValueAsType(value, numberValueTypes[key]), valueIsDefault || (transformIsDefault = !1, transformString += `${translateAlias[key] || key}(${value}) `), transformTemplate && (transform[key] = value);\n      }\n    }\n    transformString = transformString.trim();\n    transformTemplate ? transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString) : transformIsDefault && (transformString = \"none\");\n    return transformString;\n  }\n  function buildHTMLStyles(state, latestValues, transformTemplate) {\n    const {style, vars, transformOrigin} = state;\n    let hasTransform = !1, hasTransformOrigin = !1;\n    for (const key in latestValues) {\n      var value = latestValues[key];\n      transformProps.has(key) ? hasTransform = !0 : isCSSVariableName(key) ? vars[key] = value : (value = getValueAsType(value, numberValueTypes[key]), key.startsWith(\"origin\") ? (hasTransformOrigin = !0, transformOrigin[key] = value) : style[key] = value);\n    }\n    latestValues.transform || (hasTransform || transformTemplate ? style.transform = buildTransform(latestValues, state.transform, transformTemplate) : style.transform && (style.transform = \"none\"));\n    if (hasTransformOrigin) {\n      const {originX = \"50%\", originY = \"50%\", originZ = 0} = transformOrigin;\n      style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n  }\n  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = !0) {\n    attrs.pathLength = 1;\n    useDashCase = useDashCase ? dashKeys : camelKeys;\n    attrs[useDashCase.offset] = px.transform(-offset);\n    length = px.transform(length);\n    spacing = px.transform(spacing);\n    attrs[useDashCase.array] = `${length} ${spacing}`;\n  }\n  function buildSVGAttrs(state, {attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, ...latest}, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    if (isSVGTag) {\n      state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);\n    } else {\n      state.attrs = state.style;\n      state.style = {};\n      var {attrs, style, dimensions} = state;\n      attrs.transform && (dimensions && (style.transform = attrs.transform), delete attrs.transform);\n      dimensions && (void 0 !== originX || void 0 !== originY || style.transform) && (state = void 0 !== originY ? originY : 0.5, originX = void 0 !== originX ? originX : 0.5, originX = \"string\" === typeof originX ? originX : px.transform(dimensions.x + dimensions.width * originX), state = \"string\" === typeof state ? state : px.transform(dimensions.y + dimensions.height * state), style.transformOrigin = `${originX} ${state}`);\n      void 0 !== attrX && (attrs.x = attrX);\n      void 0 !== attrY && (attrs.y = attrY);\n      void 0 !== attrScale && (attrs.scale = attrScale);\n      void 0 !== pathLength && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);\n    }\n  }\n  function updateSVGDimensions(instance, renderState) {\n    try {\n      renderState.dimensions = \"function\" === typeof instance.getBBox ? instance.getBBox() : instance.getBoundingClientRect();\n    } catch (e) {\n      renderState.dimensions = {x:0, y:0, width:0, height:0};\n    }\n  }\n  function renderHTML(element, {style, vars}, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    for (const key in vars) {\n      element.style.setProperty(key, vars[key]);\n    }\n  }\n  function renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, void 0, projection);\n    for (const key in renderState.attrs) {\n      element.setAttribute(camelCaseAttributes.has(key) ? key : camelToDash(key), renderState.attrs[key]);\n    }\n  }\n  function addScaleCorrector(correctors) {\n    for (const key in correctors) {\n      scaleCorrectors[key] = correctors[key], isCSSVariableName(key) && (scaleCorrectors[key].isCSSVariable = !0);\n    }\n  }\n  function isForcedMotionValue(key, {layout, layoutId}) {\n    return transformProps.has(key) || key.startsWith(\"origin\") || (layout || void 0 !== layoutId) && (!!scaleCorrectors[key] || \"opacity\" === key);\n  }\n  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {\n    var _a;\n    const {style} = props, newValues = {};\n    for (const key in style) {\n      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || void 0 !== (null === (_a = null === visualElement || void 0 === visualElement ? void 0 : visualElement.getValue(key)) || void 0 === _a ? void 0 : _a.liveStyle)) {\n        newValues[key] = style[key];\n      }\n    }\n    return newValues;\n  }\n  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    visualElement = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n        const targetKey = -1 !== transformPropOrder.indexOf(key) ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1) : key;\n        visualElement[targetKey] = props[key];\n      }\n    }\n    return visualElement;\n  }\n  function convertBoundingBoxToBox({top, left, right, bottom}) {\n    return {x:{min:left, max:right}, y:{min:top, max:bottom}};\n  }\n  function convertBoxToBoundingBox({x, y}) {\n    return {top:y.min, right:x.max, bottom:y.max, left:x.min};\n  }\n  function transformBoxPoints(point, transformPoint) {\n    if (!transformPoint) {\n      return point;\n    }\n    const topLeft = transformPoint({x:point.left, y:point.top});\n    point = transformPoint({x:point.right, y:point.bottom});\n    return {top:topLeft.y, left:topLeft.x, bottom:point.y, right:point.x};\n  }\n  function hasScale({scale, scaleX, scaleY}) {\n    return !(void 0 === scale || 1 === scale) || !(void 0 === scaleX || 1 === scaleX) || !(void 0 === scaleY || 1 === scaleY);\n  }\n  function hasTransform(values) {\n    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;\n  }\n  function has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n  }\n  function is2DTranslate(value) {\n    return value && \"0%\" !== value;\n  }\n  function applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    void 0 !== boxScale && (point = originPoint + boxScale * (point - originPoint));\n    return originPoint + scale * (point - originPoint) + translate;\n  }\n  function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n  }\n  function applyBoxDelta(box, {x, y}) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n  }\n  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {\n    const treeLength = treePath.length;\n    if (treeLength) {\n      treeScale.x = treeScale.y = 1;\n      for (let i = 0; i < treeLength; i++) {\n        var node = treePath[i];\n        var delta = node.projectionDelta;\n        const {visualElement} = node.options;\n        visualElement && visualElement.props.style && \"contents\" === visualElement.props.style.display || (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(box, {x:-node.scroll.offset.x, y:-node.scroll.offset.y}), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node.latestValues) && transformBox(box, node.latestValues));\n      }\n      1.0000000000001 > treeScale.x && 0.999999999999 < treeScale.x && (treeScale.x = 1.0);\n      1.0000000000001 > treeScale.y && 0.999999999999 < treeScale.y && (treeScale.y = 1.0);\n    }\n  }\n  function translateAxis(axis, distance) {\n    axis.min += distance;\n    axis.max += distance;\n  }\n  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    axisOrigin = mixNumber$1(axis.min, axis.max, axisOrigin);\n    applyAxisDelta(axis, axisTranslate, axisScale, axisOrigin, boxScale);\n  }\n  function transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n  }\n  function delay(callback, timeout) {\n    const start = time.now(), checkElapsed = ({timestamp}) => {\n      timestamp -= start;\n      timestamp >= timeout && (cancelFrame(checkElapsed), callback(timestamp - timeout));\n    };\n    frame.read(checkElapsed, !0);\n    return () => cancelFrame(checkElapsed);\n  }\n  function distance2D(a, b) {\n    return Math.sqrt(Math.abs(a.x - b.x) ** 2 + Math.abs(a.y - b.y) ** 2);\n  }\n  function compress(min, max, easing) {\n    return p => p < min ? 0 : p > max ? 1 : easing(motionUtils.progress(min, max, p));\n  }\n  function copyBoxInto(box, originBox) {\n    var axis = box.x, originAxis = originBox.x;\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n    box = box.y;\n    originBox = originBox.y;\n    box.min = originBox.min;\n    box.max = originBox.max;\n  }\n  function copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n  }\n  function removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point = originPoint + 1 / scale * (point - translate - originPoint);\n    void 0 !== boxScale && (point = originPoint + 1 / boxScale * (point - originPoint));\n    return point;\n  }\n  function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min);\n    \"number\" === typeof translate && (origin = mixNumber$1(originAxis.min, originAxis.max, origin), axis === originAxis && (origin -= translate), axis.min = removePointDelta(axis.min, translate, scale, origin, boxScale), axis.max = removePointDelta(axis.max, translate, scale, origin, boxScale));\n  }\n  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n  }\n  function removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);\n  }\n  function isAxisDeltaZero(delta) {\n    return 0 === delta.translate && 1 === delta.scale;\n  }\n  function axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n  }\n  function axisEqualsRounded(a, b) {\n    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);\n  }\n  function aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n  }\n  function axisDeltaEquals(a, b) {\n    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;\n  }\n  function eachAxis(callback) {\n    return [callback(\"x\"), callback(\"y\")];\n  }\n  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const {latestValues} = visualElement;\n    latestValues[key] && (values[key] = latestValues[key], visualElement.setStaticValue(key, 0), sharedAnimationValues && (sharedAnimationValues[key] = 0));\n  }\n  function cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = !0;\n    if (projectionNode.root !== projectionNode) {\n      var {visualElement} = projectionNode.options;\n      if (visualElement) {\n        visualElement = getOptimisedAppearId(visualElement);\n        if (window.MotionHasOptimisedAnimation(visualElement, \"transform\")) {\n          const {layout, layoutId} = projectionNode.options;\n          window.MotionCancelOptimisedAnimation(visualElement, \"transform\", frame, !(layout || layoutId));\n        }\n        ({parent:projectionNode} = projectionNode);\n        projectionNode && !projectionNode.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(projectionNode);\n      }\n    }\n  }\n  function createProjectionNode$1({attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform}) {\n    return class {\n      constructor(latestValues = {}, parent = null === defaultParent || void 0 === defaultParent ? void 0 : defaultParent()) {\n        this.id = id++;\n        this.animationId = 0;\n        this.children = new Set();\n        this.options = {};\n        this.hasCheckedOptimisedAppear = this.shouldResetTransform = this.needsReset = this.isSVG = this.isUpdating = this.updateBlockedByResize = this.updateManuallyBlocked = this.isTransformDirty = this.isSharedProjectionDirty = this.isProjectionDirty = this.isLayoutDirty = this.isAnimationBlocked = this.isTreeAnimating = !1;\n        this.treeScale = {x:1, y:1};\n        this.eventHandlers = new Map();\n        this.updateScheduled = this.hasTreeAnimated = !1;\n        this.scheduleUpdate = () => this.update();\n        this.projectionUpdateScheduled = !1;\n        this.checkUpdateFailed = () => {\n          this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());\n        };\n        this.updateProjection = () => {\n          this.projectionUpdateScheduled = !1;\n          this.nodes.forEach(propagateDirtyNodes);\n          this.nodes.forEach(resolveTargetDelta);\n          this.nodes.forEach(calcProjection);\n          this.nodes.forEach(cleanDirtyNodes);\n        };\n        this.resolvedRelativeTargetAt = 0.0;\n        this.hasProjected = !1;\n        this.isVisible = !0;\n        this.animationProgress = 0;\n        this.sharedNodes = new Map();\n        this.latestValues = latestValues;\n        this.root = parent ? parent.root || parent : this;\n        this.path = parent ? [...parent.path, parent] : [];\n        this.depth = (this.parent = parent) ? parent.depth + 1 : 0;\n        for (latestValues = 0; latestValues < this.path.length; latestValues++) {\n          this.path[latestValues].shouldResetTransform = !0;\n        }\n        this.root === this && (this.nodes = new FlatTree());\n      }\n      addEventListener(name, handler) {\n        this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager());\n        return this.eventHandlers.get(name).add(handler);\n      }\n      notifyListeners(name, ...args) {\n        (name = this.eventHandlers.get(name)) && name.notify(...args);\n      }\n      hasListeners(name) {\n        return this.eventHandlers.has(name);\n      }\n      mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n        if (!this.instance) {\n          this.isSVG = isSVGElement(instance);\n          this.instance = instance;\n          var {layoutId, layout, visualElement} = this.options;\n          visualElement && !visualElement.current && visualElement.mount(instance);\n          this.root.nodes.add(this);\n          this.parent && this.parent.children.add(this);\n          isLayoutDirty && (layout || layoutId) && (this.isLayoutDirty = !0);\n          if (attachResizeListener) {\n            let cancelDelay;\n            const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;\n            attachResizeListener(instance, () => {\n              this.root.updateBlockedByResize = !0;\n              cancelDelay && cancelDelay();\n              cancelDelay = delay(resizeUnblockUpdate, 250);\n              globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));\n            });\n          }\n          layoutId && this.root.registerSharedNode(layoutId, this);\n          !1 !== this.options.animate && visualElement && (layoutId || layout) && this.addEventListener(\"didUpdate\", ({delta, hasLayoutChanged, hasRelativeLayoutChanged, layout:newLayout}) => {\n            if (this.isTreeAnimationBlocked()) {\n              this.relativeTarget = this.target = void 0;\n            } else {\n              var layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, {onLayoutAnimationStart, onLayoutAnimationComplete} = visualElement.getProps(), JSCompiler_temp;\n              (JSCompiler_temp = !this.targetLayout) || (JSCompiler_temp = this.targetLayout, JSCompiler_temp = !(axisEqualsRounded(JSCompiler_temp.x, newLayout.x) && axisEqualsRounded(JSCompiler_temp.y, newLayout.y)));\n              hasRelativeLayoutChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n              if (this.options.layoutRoot || this.resumeFrom || hasRelativeLayoutChanged || hasLayoutChanged && (JSCompiler_temp || !this.currentAnimation)) {\n                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);\n                this.setAnimationOrigin(delta, hasRelativeLayoutChanged);\n                delta = {...motionDom.getValueTransition(layoutTransition, \"layout\"), onPlay:onLayoutAnimationStart, onComplete:onLayoutAnimationComplete};\n                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {\n                  delta.delay = 0, delta.type = !1;\n                }\n                this.startAnimation(delta);\n              } else {\n                if (hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete) {\n                  this.options.onExitComplete();\n                }\n              }\n              this.targetLayout = newLayout;\n            }\n          });\n        }\n      }\n      unmount() {\n        this.options.layoutId && this.willUpdate();\n        this.root.nodes.remove(this);\n        const stack = this.getStack();\n        stack && stack.remove(this);\n        this.parent && this.parent.children.delete(this);\n        this.instance = void 0;\n        cancelFrame(this.updateProjection);\n      }\n      blockUpdate() {\n        this.updateManuallyBlocked = !0;\n      }\n      unblockUpdate() {\n        this.updateManuallyBlocked = !1;\n      }\n      isUpdateBlocked() {\n        return this.updateManuallyBlocked || this.updateBlockedByResize;\n      }\n      isTreeAnimationBlocked() {\n        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;\n      }\n      startUpdate() {\n        this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);\n      }\n      getTransformTemplate() {\n        const {visualElement} = this.options;\n        return visualElement && visualElement.getProps().transformTemplate;\n      }\n      willUpdate(shouldNotifyListeners = !0) {\n        this.root.hasTreeAnimated = !0;\n        if (this.root.isUpdateBlocked()) {\n          this.options.onExitComplete && this.options.onExitComplete();\n        } else {\n          if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), !this.isLayoutDirty) {\n            this.isLayoutDirty = !0;\n            for (var i = 0; i < this.path.length; i++) {\n              const node = this.path[i];\n              node.shouldResetTransform = !0;\n              node.updateScroll(\"snapshot\");\n              node.options.layoutRoot && node.willUpdate(!1);\n            }\n            var {layoutId, layout} = this.options;\n            if (void 0 !== layoutId || layout) {\n              this.prevTransformTemplateValue = (i = this.getTransformTemplate()) ? i(this.latestValues, \"\") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n            }\n          }\n        }\n      }\n      update() {\n        this.updateScheduled = !1;\n        if (this.isUpdateBlocked()) {\n          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);\n        } else {\n          this.isUpdating || this.nodes.forEach(clearIsLayoutDirty);\n          this.isUpdating = !1;\n          this.nodes.forEach(resetTransformStyle);\n          this.nodes.forEach(updateLayout);\n          this.nodes.forEach(notifyLayoutUpdate);\n          this.clearAllSnapshots();\n          var now = time.now();\n          frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n          frameData.timestamp = now;\n          frameData.isProcessing = !0;\n          frameSteps.update.process(frameData);\n          frameSteps.preRender.process(frameData);\n          frameSteps.render.process(frameData);\n          frameData.isProcessing = !1;\n        }\n      }\n      didUpdate() {\n        this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));\n      }\n      clearAllSnapshots() {\n        this.nodes.forEach(clearSnapshot);\n        this.sharedNodes.forEach(removeLeadSnapshots);\n      }\n      scheduleUpdateProjection() {\n        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));\n      }\n      scheduleCheckAfterUnmount() {\n        frame.postRender(() => {\n          this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();\n        });\n      }\n      updateSnapshot() {\n        !this.snapshot && this.instance && (!(this.snapshot = this.measure()) || calcLength(this.snapshot.measuredBox.x) || calcLength(this.snapshot.measuredBox.y) || (this.snapshot = void 0));\n      }\n      updateLayout() {\n        if (this.instance && (this.updateScroll(), this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty)) {\n          if (this.resumeFrom && !this.resumeFrom.instance) {\n            for (var i = 0; i < this.path.length; i++) {\n              this.path[i].updateScroll();\n            }\n          }\n          i = this.layout;\n          this.layout = this.measure(!1);\n          this.layoutCorrected = createBox();\n          this.isLayoutDirty = !1;\n          this.projectionDelta = void 0;\n          this.notifyListeners(\"measure\", this.layout.layoutBox);\n          var {visualElement} = this.options;\n          visualElement && visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, i ? i.layoutBox : void 0);\n        }\n      }\n      updateScroll(phase = \"measure\") {\n        var needsMeasurement = !(!this.options.layoutScroll || !this.instance);\n        this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1);\n        needsMeasurement && (needsMeasurement = checkIsScrollRoot(this.instance), this.scroll = {animationId:this.root.animationId, phase, isRoot:needsMeasurement, offset:measureScroll(this.instance), wasRoot:this.scroll ? this.scroll.isRoot : needsMeasurement});\n      }\n      resetTransform() {\n        if (resetTransform) {\n          var isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, JSCompiler_temp;\n          if (JSCompiler_temp = this.projectionDelta) {\n            JSCompiler_temp = this.projectionDelta, JSCompiler_temp = !(isAxisDeltaZero(JSCompiler_temp.x) && isAxisDeltaZero(JSCompiler_temp.y));\n          }\n          var transformTemplate = this.getTransformTemplate();\n          transformTemplate = transformTemplate ? transformTemplate(this.latestValues, \"\") : void 0;\n          var transformTemplateHasChanged = transformTemplate !== this.prevTransformTemplateValue;\n          isResetRequested && (JSCompiler_temp || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplate), this.shouldResetTransform = !1, this.scheduleRender());\n        }\n      }\n      measure(removeTransform = !0) {\n        const pageBox = this.measurePageBox();\n        let layoutBox = this.removeElementScroll(pageBox);\n        removeTransform && (layoutBox = this.removeTransform(layoutBox));\n        removeTransform = layoutBox;\n        roundAxis(removeTransform.x);\n        roundAxis(removeTransform.y);\n        return {animationId:this.root.animationId, measuredBox:pageBox, layoutBox, latestValues:{}, source:this.id};\n      }\n      measurePageBox() {\n        var _a, {visualElement} = this.options;\n        if (!visualElement) {\n          return createBox();\n        }\n        visualElement = visualElement.measureViewportBox();\n        (null === (_a = this.scroll) || void 0 === _a ? 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot) || ({scroll:_a} = this.root, _a && (translateAxis(visualElement.x, _a.offset.x), translateAxis(visualElement.y, _a.offset.y)));\n        return visualElement;\n      }\n      removeElementScroll(box) {\n        var _a;\n        const boxWithoutScroll = createBox();\n        copyBoxInto(boxWithoutScroll, box);\n        if (null === (_a = this.scroll) || void 0 === _a ? 0 : _a.wasRoot) {\n          return boxWithoutScroll;\n        }\n        for (_a = 0; _a < this.path.length; _a++) {\n          const node = this.path[_a], {scroll, options} = node;\n          node !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));\n        }\n        return boxWithoutScroll;\n      }\n      applyTransform(box, transformOnly = !1) {\n        const withTransforms = createBox();\n        copyBoxInto(withTransforms, box);\n        for (box = 0; box < this.path.length; box++) {\n          const node = this.path[box];\n          !transformOnly && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(withTransforms, {x:-node.scroll.offset.x, y:-node.scroll.offset.y});\n          hasTransform(node.latestValues) && transformBox(withTransforms, node.latestValues);\n        }\n        hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues);\n        return withTransforms;\n      }\n      removeTransform(box) {\n        const boxWithoutTransform = createBox();\n        copyBoxInto(boxWithoutTransform, box);\n        for (box = 0; box < this.path.length; box++) {\n          const node = this.path[box];\n          if (!node.instance) {\n            continue;\n          }\n          if (!hasTransform(node.latestValues)) {\n            continue;\n          }\n          hasScale(node.latestValues) && node.updateSnapshot();\n          const sourceBox = createBox(), nodeBox = node.measurePageBox();\n          copyBoxInto(sourceBox, nodeBox);\n          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);\n        }\n        hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues);\n        return boxWithoutTransform;\n      }\n      setTargetDelta(delta) {\n        this.targetDelta = delta;\n        this.root.scheduleUpdateProjection();\n        this.isProjectionDirty = !0;\n      }\n      setOptions(options) {\n        this.options = {...this.options, ...options, crossfade:void 0 !== options.crossfade ? options.crossfade : !0};\n      }\n      clearMeasurements() {\n        this.target = this.targetDelta = this.prevTransformTemplateValue = this.snapshot = this.layout = this.scroll = void 0;\n        this.isLayoutDirty = !1;\n      }\n      forceRelativeParentToResolveTarget() {\n        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);\n      }\n      resolveTargetDelta(forceRecalculation = !1) {\n        var _a, lead = this.getLead();\n        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n        lead = !!this.resumingFrom || this !== lead;\n        if (forceRecalculation || lead && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (_a = this.parent) || void 0 === _a ? 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize) {\n          var {layout, layoutId} = this.options;\n          if (this.layout && (layout || layoutId) && (this.resolvedRelativeTargetAt = frameData.timestamp, this.targetDelta || this.relativeTarget || ((forceRecalculation = this.getClosestProjectingParent()) && forceRecalculation.layout && 1 !== this.animationProgress ? (this.relativeParent = forceRecalculation, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, \n          forceRecalculation.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0), this.relativeTarget || this.targetDelta)) {\n            this.target || (this.target = createBox(), this.targetWithTransforms = createBox());\n            if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {\n              this.forceRelativeParentToResolveTarget();\n              lead = this.target;\n              _a = this.relativeTarget;\n              forceRecalculation = this.relativeParent.target;\n              var target = lead.x, relative = _a.x;\n              target.min = forceRecalculation.x.min + relative.min;\n              target.max = target.min + calcLength(relative);\n              lead = lead.y;\n              _a = _a.y;\n              lead.min = forceRecalculation.y.min + _a.min;\n              lead.max = lead.min + calcLength(_a);\n            } else {\n              this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, (forceRecalculation = this.getClosestProjectingParent()) && !!forceRecalculation.resumingFrom === !!this.resumingFrom && !forceRecalculation.options.layoutScroll && forceRecalculation.target && 1 !== this.animationProgress ? (this.relativeParent = forceRecalculation, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, \n            this.target, forceRecalculation.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0);\n          }\n        }\n      }\n      getClosestProjectingParent() {\n        if (this.parent && !hasScale(this.parent.latestValues) && !has2DTranslate(this.parent.latestValues)) {\n          return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();\n        }\n      }\n      isProjecting() {\n        return !(!(this.relativeTarget || this.targetDelta || this.options.layoutRoot) || !this.layout);\n      }\n      calcProjection() {\n        var _a, lead = this.getLead();\n        const isShared = !!this.resumingFrom || this !== lead;\n        var canSkip = !0;\n        if (this.isProjectionDirty || (null === (_a = this.parent) || void 0 === _a ? 0 : _a.isProjectionDirty)) {\n          canSkip = !1;\n        }\n        isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1);\n        this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1);\n        if (!canSkip) {\n          var {layout, layoutId} = this.options;\n          this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);\n          this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0);\n          this.layout && (layout || layoutId) && (copyBoxInto(this.layoutCorrected, this.layout.layoutBox), _a = this.treeScale.x, canSkip = this.treeScale.y, applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), !lead.layout || lead.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox()), {target:lead} = lead, lead ? (this.projectionDelta && this.prevProjectionDelta ? (copyAxisDeltaInto(this.prevProjectionDelta.x, \n          this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), calcBoxDelta(this.projectionDelta, this.layoutCorrected, lead, this.latestValues), this.treeScale.x === _a && this.treeScale.y === canSkip && axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) && axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners(\"projectionUpdate\", \n          lead))) : this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()));\n        }\n      }\n      hide() {\n        this.isVisible = !1;\n      }\n      show() {\n        this.isVisible = !0;\n      }\n      scheduleRender(notifyAll = !0) {\n        var _a;\n        null === (_a = this.options.visualElement) || void 0 === _a || _a.scheduleRender();\n        notifyAll && (notifyAll = this.getStack()) && notifyAll.scheduleRender();\n        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);\n      }\n      createProjectionDeltas() {\n        this.prevProjectionDelta = {x:createAxisDelta(), y:createAxisDelta()};\n        this.projectionDelta = {x:createAxisDelta(), y:createAxisDelta()};\n        this.projectionDeltaWithTransform = {x:createAxisDelta(), y:createAxisDelta()};\n      }\n      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {\n        const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = {...this.latestValues}, targetDelta = {x:createAxisDelta(), y:createAxisDelta()};\n        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0);\n        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n        const relativeLayout = createBox(), isSharedLayoutAnimation = (snapshot ? snapshot.source : void 0) !== (this.layout ? this.layout.source : void 0);\n        hasOnlyRelativeTargetChanged = this.getStack();\n        const isOnlyMember = !hasOnlyRelativeTargetChanged || 1 >= hasOnlyRelativeTargetChanged.members.length, shouldCrossfadeOpacity = !(!isSharedLayoutAnimation || isOnlyMember || !0 !== this.options.crossfade || this.path.some(hasOpacityCrossfade));\n        this.animationProgress = 0;\n        let prevRelativeTarget;\n        this.mixTargetDelta = latest => {\n          latest /= 1000;\n          mixAxisDelta(targetDelta.x, delta.x, latest);\n          mixAxisDelta(targetDelta.y, delta.y, latest);\n          this.setTargetDelta(targetDelta);\n          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {\n            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n            var output = this.relativeTarget, from = this.relativeTargetOrigin, output$jscomp$0 = output.x, from$jscomp$0 = from.x, to = relativeLayout.x;\n            output$jscomp$0.min = mixNumber$1(from$jscomp$0.min, to.min, latest);\n            output$jscomp$0.max = mixNumber$1(from$jscomp$0.max, to.max, latest);\n            output = output.y;\n            from = from.y;\n            output$jscomp$0 = relativeLayout.y;\n            output.min = mixNumber$1(from.min, output$jscomp$0.min, latest);\n            output.max = mixNumber$1(from.max, output$jscomp$0.max, latest);\n            if (from = prevRelativeTarget) {\n              from = this.relativeTarget, output = prevRelativeTarget, from = axisEquals(from.x, output.x) && axisEquals(from.y, output.y);\n            }\n            from && (this.isProjectionDirty = !1);\n            prevRelativeTarget || (prevRelativeTarget = createBox());\n            copyBoxInto(prevRelativeTarget, this.relativeTarget);\n          }\n          if (isSharedLayoutAnimation) {\n            this.animationValues = mixedValues;\n            from = this.latestValues;\n            shouldCrossfadeOpacity ? (mixedValues.opacity = mixNumber$1(0, void 0 !== from.opacity ? from.opacity : 1, easeCrossfadeIn(latest)), mixedValues.opacityExit = mixNumber$1(void 0 !== snapshotLatestValues.opacity ? snapshotLatestValues.opacity : 1, 0, easeCrossfadeOut(latest))) : isOnlyMember && (mixedValues.opacity = mixNumber$1(void 0 !== snapshotLatestValues.opacity ? snapshotLatestValues.opacity : 1, void 0 !== from.opacity ? from.opacity : 1, latest));\n            for (output = 0; output < numBorders; output++) {\n              if (output$jscomp$0 = `border${borders[output]}Radius`, from$jscomp$0 = void 0 !== snapshotLatestValues[output$jscomp$0] ? snapshotLatestValues[output$jscomp$0] : snapshotLatestValues.borderRadius, to = void 0 !== from[output$jscomp$0] ? from[output$jscomp$0] : from.borderRadius, void 0 !== from$jscomp$0 || void 0 !== to) {\n                if (from$jscomp$0 || (from$jscomp$0 = 0), to || (to = 0), 0 === from$jscomp$0 || 0 === to || (\"number\" === typeof from$jscomp$0 || px.test(from$jscomp$0)) === (\"number\" === typeof to || px.test(to))) {\n                  if (mixedValues[output$jscomp$0] = Math.max(mixNumber$1(asNumber(from$jscomp$0), asNumber(to), latest), 0), percent.test(to) || percent.test(from$jscomp$0)) {\n                    mixedValues[output$jscomp$0] += \"%\";\n                  }\n                } else {\n                  mixedValues[output$jscomp$0] = to;\n                }\n              }\n            }\n            if (snapshotLatestValues.rotate || from.rotate) {\n              mixedValues.rotate = mixNumber$1(snapshotLatestValues.rotate || 0, from.rotate || 0, latest);\n            }\n          }\n          this.root.scheduleUpdateProjection();\n          this.scheduleRender();\n          this.animationProgress = latest;\n        };\n        this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n      }\n      startAnimation(options) {\n        this.notifyListeners(\"animationStart\");\n        this.currentAnimation && this.currentAnimation.stop();\n        this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop();\n        this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0);\n        this.pendingAnimation = frame.update(() => {\n          globalProjectionState.hasAnimatedSinceResize = !0;\n          this.currentAnimation = animateSingleValue(0, 1000, {...options, onUpdate:latest => {\n            this.mixTargetDelta(latest);\n            options.onUpdate && options.onUpdate(latest);\n          }, onStop:() => {\n          }, onComplete:() => {\n            options.onComplete && options.onComplete();\n            this.completeAnimation();\n          }});\n          this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation);\n          this.pendingAnimation = void 0;\n        });\n      }\n      completeAnimation() {\n        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);\n        const stack = this.getStack();\n        stack && stack.exitAnimationComplete();\n        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n        this.notifyListeners(\"animationComplete\");\n      }\n      finishAnimation() {\n        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1000), this.currentAnimation.stop());\n        this.completeAnimation();\n      }\n      applyTransformsToTarget() {\n        const lead = this.getLead();\n        let {targetWithTransforms, target, layout, latestValues} = lead;\n        if (targetWithTransforms && target && layout) {\n          if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n            target = this.target || createBox();\n            var xLength = calcLength(this.layout.layoutBox.x);\n            target.x.min = lead.target.x.min;\n            target.x.max = target.x.min + xLength;\n            xLength = calcLength(this.layout.layoutBox.y);\n            target.y.min = lead.target.y.min;\n            target.y.max = target.y.min + xLength;\n          }\n          copyBoxInto(targetWithTransforms, target);\n          transformBox(targetWithTransforms, latestValues);\n          calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n      }\n      registerSharedNode(layoutId, node) {\n        this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack());\n        this.sharedNodes.get(layoutId).add(node);\n        layoutId = node.options.initialPromotionConfig;\n        node.promote({transition:layoutId ? layoutId.transition : void 0, preserveFollowOpacity:layoutId && layoutId.shouldPreserveFollowOpacity ? layoutId.shouldPreserveFollowOpacity(node) : void 0});\n      }\n      isLead() {\n        const stack = this.getStack();\n        return stack ? stack.lead === this : !0;\n      }\n      getLead() {\n        var _a;\n        const {layoutId} = this.options;\n        return layoutId ? (null === (_a = this.getStack()) || void 0 === _a ? void 0 : _a.lead) || this : this;\n      }\n      getPrevLead() {\n        var _a;\n        const {layoutId} = this.options;\n        return layoutId ? null === (_a = this.getStack()) || void 0 === _a ? void 0 : _a.prevLead : void 0;\n      }\n      getStack() {\n        const {layoutId} = this.options;\n        if (layoutId) {\n          return this.root.sharedNodes.get(layoutId);\n        }\n      }\n      promote({needsReset, transition, preserveFollowOpacity} = {}) {\n        const stack = this.getStack();\n        stack && stack.promote(this, preserveFollowOpacity);\n        needsReset && (this.projectionDelta = void 0, this.needsReset = !0);\n        transition && this.setOptions({transition});\n      }\n      relegate() {\n        const stack = this.getStack();\n        return stack ? stack.relegate(this) : !1;\n      }\n      resetSkewAndRotation() {\n        const {visualElement} = this.options;\n        if (visualElement) {\n          var hasDistortingTransform = !1, {latestValues} = visualElement;\n          if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {\n            hasDistortingTransform = !0;\n          }\n          if (hasDistortingTransform) {\n            hasDistortingTransform = {};\n            latestValues.z && resetDistortingTransform(\"z\", visualElement, hasDistortingTransform, this.animationValues);\n            for (latestValues = 0; latestValues < transformAxes.length; latestValues++) {\n              resetDistortingTransform(`rotate${transformAxes[latestValues]}`, visualElement, hasDistortingTransform, this.animationValues), resetDistortingTransform(`skew${transformAxes[latestValues]}`, visualElement, hasDistortingTransform, this.animationValues);\n            }\n            visualElement.render();\n            for (const key in hasDistortingTransform) {\n              visualElement.setStaticValue(key, hasDistortingTransform[key]), this.animationValues && (this.animationValues[key] = hasDistortingTransform[key]);\n            }\n            visualElement.scheduleRender();\n          }\n        }\n      }\n      getProjectionStyles(styleProp) {\n        var _a, _b;\n        if (this.instance && !this.isSVG) {\n          if (!this.isVisible) {\n            return hiddenVisibility;\n          }\n          var styles = {visibility:\"\"}, transformTemplate = this.getTransformTemplate();\n          if (this.needsReset) {\n            return this.needsReset = !1, styles.opacity = \"\", styles.pointerEvents = resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || \"\", styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\", styles;\n          }\n          var lead = this.getLead();\n          if (!this.projectionDelta || !this.layout || !lead.target) {\n            return styles = {}, this.options.layoutId && (styles.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, styles.pointerEvents = resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || \"\"), this.hasProjected && !hasTransform(this.latestValues) && (styles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\", this.hasProjected = !1), styles;\n          }\n          var valuesToRender = lead.animationValues || lead.latestValues;\n          this.applyTransformsToTarget();\n          var delta = this.projectionDeltaWithTransform, treeScale = this.treeScale, transform = \"\", xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = (null === valuesToRender || void 0 === valuesToRender ? void 0 : valuesToRender.z) || 0;\n          if (xTranslate || yTranslate || zTranslate) {\n            transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n          }\n          if (1 !== treeScale.x || 1 !== treeScale.y) {\n            transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n          }\n          if (valuesToRender) {\n            const {transformPerspective, rotate, rotateX, rotateY, skewX, skewY} = valuesToRender;\n            transformPerspective && (transform = `perspective(${transformPerspective}px) ${transform}`);\n            rotate && (transform += `rotate(${rotate}deg) `);\n            rotateX && (transform += `rotateX(${rotateX}deg) `);\n            rotateY && (transform += `rotateY(${rotateY}deg) `);\n            skewX && (transform += `skewX(${skewX}deg) `);\n            skewY && (transform += `skewY(${skewY}deg) `);\n          }\n          xTranslate = delta.x.scale * treeScale.x;\n          delta = delta.y.scale * treeScale.y;\n          if (1 !== xTranslate || 1 !== delta) {\n            transform += `scale(${xTranslate}, ${delta})`;\n          }\n          styles.transform = transform || \"none\";\n          transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));\n          var {x, y} = this.projectionDelta;\n          styles.transformOrigin = `${100 * x.origin}% ${100 * y.origin}% 0`;\n          styles.opacity = lead.animationValues ? lead === this ? null !== (_b = null !== (_a = valuesToRender.opacity) && void 0 !== _a ? _a : this.latestValues.opacity) && void 0 !== _b ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : lead === this ? void 0 !== valuesToRender.opacity ? valuesToRender.opacity : \"\" : void 0 !== valuesToRender.opacityExit ? valuesToRender.opacityExit : 0;\n          for (const key in scaleCorrectors) {\n            if (void 0 === valuesToRender[key]) {\n              continue;\n            }\n            const {correct, applyTo, isCSSVariable} = scaleCorrectors[key];\n            transformTemplate = \"none\" === styles.transform ? valuesToRender[key] : correct(valuesToRender[key], lead);\n            if (applyTo) {\n              for (_a = applyTo.length, _b = 0; _b < _a; _b++) {\n                styles[applyTo[_b]] = transformTemplate;\n              }\n            } else {\n              isCSSVariable ? this.options.visualElement.renderState.vars[key] = transformTemplate : styles[key] = transformTemplate;\n            }\n          }\n          this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || \"\" : \"none\");\n          return styles;\n        }\n      }\n      clearSnapshot() {\n        this.resumeFrom = this.snapshot = void 0;\n      }\n      resetTree() {\n        this.root.nodes.forEach(node => {\n          var _a;\n          return null === (_a = node.currentAnimation) || void 0 === _a ? void 0 : _a.stop();\n        });\n        this.root.nodes.forEach(clearMeasurements);\n        this.root.sharedNodes.clear();\n      }\n    };\n  }\n  function updateLayout(node) {\n    node.updateLayout();\n  }\n  function notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = (null === (_a = node.resumeFrom) || void 0 === _a ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n      const {layoutBox:layout, measuredBox:measuredLayout} = node.layout;\n      ({animationType:_a} = node.options);\n      const isShared = snapshot.source !== node.layout.source;\n      \"size\" === _a ? eachAxis(axis => {\n        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      }) : shouldAnimatePositionOnly(_a, snapshot.layoutBox, layout) && eachAxis(axis => {\n        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n        node.relativeTarget && !node.currentAnimation && (node.isProjectionDirty = !0, node.relativeTarget[axis].max = node.relativeTarget[axis].min + length);\n      });\n      _a = {x:createAxisDelta(), y:createAxisDelta()};\n      calcBoxDelta(_a, layout, snapshot.layoutBox);\n      const visualDelta = {x:createAxisDelta(), y:createAxisDelta()};\n      isShared ? calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n      const hasLayoutChanged = !(isAxisDeltaZero(_a.x) && isAxisDeltaZero(_a.y));\n      let hasRelativeLayoutChanged = !1;\n      if (!node.resumeFrom) {\n        const relativeParent = node.getClosestProjectingParent();\n        if (relativeParent && !relativeParent.resumeFrom) {\n          const {snapshot:parentSnapshot, layout:parentLayout} = relativeParent;\n          if (parentSnapshot && parentLayout) {\n            const relativeSnapshot = createBox();\n            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n            const relativeLayout = createBox();\n            calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n            axisEqualsRounded(relativeSnapshot.x, relativeLayout.x) && axisEqualsRounded(relativeSnapshot.y, relativeLayout.y) || (hasRelativeLayoutChanged = !0);\n            relativeParent.options.layoutRoot && (node.relativeTarget = relativeLayout, node.relativeTargetOrigin = relativeSnapshot, node.relativeParent = relativeParent);\n          }\n        }\n      }\n      node.notifyListeners(\"didUpdate\", {layout, snapshot, delta:visualDelta, layoutDelta:_a, hasLayoutChanged, hasRelativeLayoutChanged});\n    } else {\n      node.isLead() && ({onExitComplete:_a} = node.options, _a && _a());\n    }\n    node.options.transition = void 0;\n  }\n  function propagateDirtyNodes(node) {\n    node.parent && (node.isProjecting() || (node.isProjectionDirty = node.parent.isProjectionDirty), node.isSharedProjectionDirty || (node.isSharedProjectionDirty = !!(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty)), node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty));\n  }\n  function cleanDirtyNodes(node) {\n    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = !1;\n  }\n  function clearSnapshot(node) {\n    node.clearSnapshot();\n  }\n  function clearMeasurements(node) {\n    node.clearMeasurements();\n  }\n  function clearIsLayoutDirty(node) {\n    node.isLayoutDirty = !1;\n  }\n  function resetTransformStyle(node) {\n    const {visualElement} = node.options;\n    visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify(\"BeforeLayoutMeasure\");\n    node.resetTransform();\n  }\n  function finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = void 0;\n    node.isProjectionDirty = !0;\n  }\n  function resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n  }\n  function calcProjection(node) {\n    node.calcProjection();\n  }\n  function resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n  }\n  function removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n  }\n  function mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber$1(delta.translate, 0, p);\n    output.scale = mixNumber$1(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n  }\n  function hasOpacityCrossfade(node) {\n    return node.animationValues && void 0 !== node.animationValues.opacityExit;\n  }\n  function roundAxis(axis) {\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n  }\n  function shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    var JSCompiler_temp;\n    if (!(JSCompiler_temp = \"position\" === animationType)) {\n      if (animationType = \"preserve-aspect\" === animationType) {\n        snapshot = aspectRatio(snapshot), layout = aspectRatio(layout), animationType = !(.2 >= Math.abs(snapshot - layout));\n      }\n      JSCompiler_temp = animationType;\n    }\n    return JSCompiler_temp;\n  }\n  function checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && (null === (_a = node.scroll) || void 0 === _a ? void 0 : _a.wasRoot);\n  }\n  function pixelsToPercent(pixels, axis) {\n    return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;\n  }\n  function loadFeatures(features) {\n    for (const key in features) {\n      featureDefinitions[key] = {...featureDefinitions[key], ...features[key]};\n    }\n  }\n  function isRefObject(ref) {\n    return ref && \"object\" === typeof ref && Object.prototype.hasOwnProperty.call(ref, \"current\");\n  }\n  function transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? {point:transformPagePoint(info.point)} : info;\n  }\n  function subtractPoint(a, b) {\n    return {x:a.x - b.x, y:a.y - b.y};\n  }\n  function getPanInfo({point}, history) {\n    return {point, delta:subtractPoint(point, history[history.length - 1]), offset:subtractPoint(point, history[0]), velocity:getVelocity(history, 0.1)};\n  }\n  function getVelocity(history, timeDelta) {\n    if (2 > history.length) {\n      return {x:0, y:0};\n    }\n    let i = history.length - 1;\n    var timestampedPoint = null;\n    const lastPoint = history[history.length - 1];\n    for (; 0 <= i;) {\n      timestampedPoint = history[i];\n      if (lastPoint.timestamp - timestampedPoint.timestamp > motionUtils.secondsToMilliseconds(timeDelta)) {\n        break;\n      }\n      i--;\n    }\n    if (!timestampedPoint) {\n      return {x:0, y:0};\n    }\n    history = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (0 === history) {\n      return {x:0, y:0};\n    }\n    timestampedPoint = {x:(lastPoint.x - timestampedPoint.x) / history, y:(lastPoint.y - timestampedPoint.y) / history};\n    Infinity === timestampedPoint.x && (timestampedPoint.x = 0);\n    Infinity === timestampedPoint.y && (timestampedPoint.y = 0);\n    return timestampedPoint;\n  }\n  function applyConstraints(point, {min, max}, elastic) {\n    void 0 !== min && point < min ? point = elastic ? min + (point - min) * elastic.min : Math.max(point, min) : void 0 !== max && point > max && (point = elastic ? max + (point - max) * elastic.max : Math.min(point, max));\n    return point;\n  }\n  function calcRelativeAxisConstraints(axis, min, max) {\n    return {min:void 0 !== min ? axis.min + min : void 0, max:void 0 !== max ? axis.max + max - (axis.max - axis.min) : void 0};\n  }\n  function calcRelativeConstraints(layoutBox, {top, left, bottom, right}) {\n    return {x:calcRelativeAxisConstraints(layoutBox.x, left, right), y:calcRelativeAxisConstraints(layoutBox.y, top, bottom)};\n  }\n  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min, max = constraintsAxis.max - layoutAxis.max;\n    constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min, max] = [max, min]);\n    return {min, max};\n  }\n  function resolveDragElastic(dragElastic = 0.35) {\n    !1 === dragElastic ? dragElastic = 0 : !0 === dragElastic && (dragElastic = 0.35);\n    var JSCompiler_inline_result = dragElastic;\n    JSCompiler_inline_result = {min:resolvePointElastic(JSCompiler_inline_result, \"left\"), max:resolvePointElastic(JSCompiler_inline_result, \"right\")};\n    dragElastic = {min:resolvePointElastic(dragElastic, \"top\"), max:resolvePointElastic(dragElastic, \"bottom\")};\n    return {x:JSCompiler_inline_result, y:dragElastic};\n  }\n  function resolvePointElastic(dragElastic, label) {\n    return \"number\" === typeof dragElastic ? dragElastic : dragElastic[label] || 0;\n  }\n  function shouldDrag(direction, drag, currentDirection) {\n    return (!0 === drag || drag === direction) && (null === currentDirection || currentDirection === direction);\n  }\n  function getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    Math.abs(offset.y) > lockThreshold ? direction = \"y\" : Math.abs(offset.x) > lockThreshold && (direction = \"x\");\n    return direction;\n  }\n  function MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence(), layoutGroup = React.useContext(LayoutGroupContext);\n    return jsxRuntime.jsx(MeasureLayoutWithContext, {...props, layoutGroup, switchLayoutGroup:React.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove});\n  }\n  function handleHoverEvent(node, event, lifecycle) {\n    const {props} = node;\n    node.animationState && props.whileHover && node.animationState.setActive(\"whileHover\", \"Start\" === lifecycle);\n    const callback = props[\"onHover\" + lifecycle];\n    callback && frame.postRender(() => callback(event, extractEventInfo(event)));\n  }\n  function handlePressEvent(node, event, lifecycle) {\n    const {props} = node;\n    if (!(node.current instanceof HTMLButtonElement && node.current.disabled)) {\n      node.animationState && props.whileTap && node.animationState.setActive(\"whileTap\", \"Start\" === lifecycle);\n      var callback = props[\"onTap\" + (\"End\" === lifecycle ? \"\" : lifecycle)];\n      callback && frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n  }\n  function initIntersectionObserver({root, ...options}) {\n    var lookupRoot = root || document;\n    observers.has(lookupRoot) || observers.set(lookupRoot, {});\n    lookupRoot = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    lookupRoot[key] || (lookupRoot[key] = new IntersectionObserver(fireAllObserverCallbacks, {root, ...options}));\n    return lookupRoot[key];\n  }\n  function observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n      observerCallbacks.delete(element);\n      rootInteresectionObserver.unobserve(element);\n    };\n  }\n  function hasViewportOptionChanged({viewport = {}}, {viewport:prevViewport = {}} = {}) {\n    return name => viewport[name] !== prevViewport[name];\n  }\n  function getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n      const {initial, animate} = props;\n      return {initial:!1 === initial || isVariantLabel(initial) ? initial : void 0, animate:isVariantLabel(animate) ? animate : void 0};\n    }\n    return !1 !== props.inherit ? context : {};\n  }\n  function useCreateMotionContext(props) {\n    const {initial, animate} = getCurrentTreeVariants(props, React.useContext(MotionContext));\n    return React.useMemo(() => ({initial, animate}), [Array.isArray(initial) ? initial.join(\" \") : initial, Array.isArray(animate) ? animate.join(\" \") : animate]);\n  }\n  function useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(instance => {\n      instance && visualState.onMount && visualState.onMount(instance);\n      visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount());\n      externalRef && (\"function\" === typeof externalRef ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));\n    }, [visualElement]);\n  }\n  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const {visualElement:parent} = React.useContext(MotionContext), lazyContext = React.useContext(LazyContext), presenceContext = React.useContext(PresenceContext), reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion, visualElementRef = React.useRef(null);\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component, {visualState, parent, props, presenceContext, blockInitialAnimation:presenceContext ? !1 === presenceContext.initial : !1, reducedMotionConfig}));\n    const visualElement = visualElementRef.current;\n    Component = React.useContext(SwitchLayoutGroupContext);\n    !visualElement || visualElement.projection || !ProjectionNodeConstructor || \"html\" !== visualElement.type && \"svg\" !== visualElement.type || createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, Component);\n    const isMounted = React.useRef(!1);\n    React.useInsertionEffect(() => {\n      visualElement && isMounted.current && visualElement.update(props, presenceContext);\n    });\n    const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = React.useRef(!!optimisedAppearId && !(null === (_a = window.MotionHandoffIsComplete) || void 0 === _a ? 0 : _a.call(window, optimisedAppearId)) && (null === (_b = window.MotionHasOptimisedAnimation) || void 0 === _b ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n      visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), microtask.render(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());\n    });\n    React.useEffect(() => {\n      visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {\n        var _a;\n        null === (_a = window.MotionHandoffMarkAsComplete) || void 0 === _a || _a.call(window, optimisedAppearId);\n      }), wantsHandoff.current = !1));\n    });\n    return visualElement;\n  }\n  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const {layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot} = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? void 0 : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({layoutId, layout, alwaysMeasureLayout:!!drag || dragConstraints && isRefObject(dragConstraints), visualElement, animationType:\"string\" === typeof layout ? layout : \"both\", initialPromotionConfig, layoutScroll, layoutRoot});\n  }\n  function getClosestProjectingNode(visualElement) {\n    if (visualElement) {\n      return !1 !== visualElement.options.allowProjection ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n    }\n  }\n  function createRendererMotionComponent({preloadedFeatures, createVisualElement, useRender, useVisualState, Component}) {\n    function MotionComponent(props, externalRef) {\n      const configAndProps = {...React.useContext(MotionConfigContext), ...props, layoutId:useLayoutId(props)}, {isStatic} = configAndProps, context = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);\n      if (!isStatic && isBrowser) {\n        var MeasureLayout = React.useContext(LazyContext).strict;\n        preloadedFeatures && MeasureLayout && (configAndProps.ignoreStrict ? motionUtils.warning(!1, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\") : motionUtils.invariant(!1, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\"));\n        {\n          const {drag, layout} = featureDefinitions;\n          drag || layout ? (MeasureLayout = {...drag, ...layout}, MeasureLayout = {MeasureLayout:(null === drag || void 0 === drag ? 0 : drag.isEnabled(configAndProps)) || (null === layout || void 0 === layout ? 0 : layout.isEnabled(configAndProps)) ? MeasureLayout.MeasureLayout : void 0, ProjectionNode:MeasureLayout.ProjectionNode}) : MeasureLayout = {};\n        }\n        const layoutProjection = MeasureLayout;\n        MeasureLayout = layoutProjection.MeasureLayout;\n        context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n      }\n      return jsxRuntime.jsxs(MotionContext.Provider, {value:context, children:[MeasureLayout && context.visualElement ? jsxRuntime.jsx(MeasureLayout, {visualElement:context.visualElement, ...configAndProps}) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)]});\n    }\n    var _a, _b;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    MotionComponent.displayName = `motion.${\"string\" === typeof Component ? Component : `create(${null !== (_b = null !== (_a = Component.displayName) && void 0 !== _a ? _a : Component.name) && void 0 !== _b ? _b : \"\"})`}`;\n    _a = React.forwardRef(MotionComponent);\n    _a[motionComponentSymbol] = Component;\n    return _a;\n  }\n  function useLayoutId({layoutId}) {\n    const layoutGroupId = React.useContext(LayoutGroupContext).id;\n    return layoutGroupId && void 0 !== layoutId ? layoutGroupId + \"-\" + layoutId : layoutId;\n  }\n  function copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n      isMotionValue(source[key]) || isForcedMotionValue(key, props) || (target[key] = source[key]);\n    }\n  }\n  function useInitialMotionValues({transformTemplate}, visualState) {\n    return React.useMemo(() => {\n      const state = createHtmlRenderState();\n      buildHTMLStyles(state, visualState, transformTemplate);\n      return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n  }\n  function useHTMLProps(props, visualState) {\n    const htmlProps = {}, style = {};\n    copyRawValuesOnly(style, props.style || {}, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    props.drag && !1 !== props.dragListener && (htmlProps.draggable = !1, style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\", style.touchAction = !0 === props.drag ? \"none\" : `pan-${\"x\" === props.drag ? \"y\" : \"x\"}`);\n    void 0 === props.tabIndex && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0);\n    htmlProps.style = style;\n    return htmlProps;\n  }\n  function isSVGComponent(Component) {\n    return \"string\" === typeof Component && !Component.includes(\"-\") && (-1 < lowercaseSVGElements.indexOf(Component) || /[A-Z]/u.test(Component)) ? !0 : !1;\n  }\n  function useSVGProps(props, visualState, _isStatic, Component) {\n    _isStatic = React.useMemo(() => {\n      const state = createSvgRenderState();\n      buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n      return {...state.attrs, style:{...state.style}};\n    }, [visualState]);\n    if (props.style) {\n      const rawStyles = {};\n      copyRawValuesOnly(rawStyles, props.style, props);\n      _isStatic.style = {...rawStyles, ..._isStatic.style};\n    }\n    return _isStatic;\n  }\n  function createUseRender(forwardMotionProps = !1) {\n    return (Component, props, ref, {latestValues}, isStatic) => {\n      latestValues = (isSVGComponent(Component) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component);\n      isStatic = filterProps(props, \"string\" === typeof Component, forwardMotionProps);\n      ref = Component !== React.Fragment ? {...isStatic, ...latestValues, ref} : {};\n      const {children} = props;\n      props = React.useMemo(() => children && children.getVelocity ? children.get() : children, [children]);\n      return React.createElement(Component, {...ref, children:props});\n    };\n  }\n  function createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function(Component, {forwardMotionProps} = {forwardMotionProps:!1}) {\n      Component = {...(isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig), preloadedFeatures, useRender:createUseRender(forwardMotionProps), createVisualElement, Component};\n      return createRendererMotionComponent(Component);\n    };\n  }\n  var motionDom = require(\"module$node_modules$motion_dom$dist$cjs$index\"), motionUtils = require(\"module$node_modules$motion_utils$dist$cjs$index\"), jsxRuntime = require(\"module$node_modules$react$jsx_runtime\"), React = require(\"module$node_modules$react$index\");\n  const LayoutGroupContext = React.createContext({}), MotionGlobalConfig = {skipAnimations:!1, useManualTiming:!1}, stepsOrder = \"read resolveKeyframes update preRender render postRender\".split(\" \"), statsBuffer = {value:null, addProjectionMetrics:null}, {schedule:frame, cancel:cancelFrame, state:frameData, steps:frameSteps} = createRenderBatcher(\"undefined\" !== typeof requestAnimationFrame ? requestAnimationFrame : motionUtils.noop, !0), transformPropOrder = \"transformPerspective x y z translateX translateY translateZ scale scaleX scaleY rotate rotateX rotateY rotateZ skew skewX skewY\".split(\" \"), \n  transformProps = new Set(transformPropOrder), positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", ...transformPropOrder]);\n  let now;\n  const time = {now:() => {\n    void 0 === now && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());\n    return now;\n  }, set:newTime => {\n    now = newTime;\n    queueMicrotask(clearTime);\n  }};\n  class SubscriptionManager {\n    constructor() {\n      this.subscriptions = [];\n    }\n    add(handler) {\n      addUniqueItem(this.subscriptions, handler);\n      return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n      const numSubscriptions = this.subscriptions.length;\n      if (numSubscriptions) {\n        if (1 === numSubscriptions) {\n          this.subscriptions[0](a, b, c);\n        } else {\n          for (let i = 0; i < numSubscriptions; i++) {\n            const handler = this.subscriptions[i];\n            handler && handler(a, b, c);\n          }\n        }\n      }\n    }\n    getSize() {\n      return this.subscriptions.length;\n    }\n    clear() {\n      this.subscriptions.length = 0;\n    }\n  }\n  const warned = new Set(), collectMotionValues = {current:void 0};\n  class MotionValue {\n    constructor(init, options = {}) {\n      this.version = \"12.4.7\";\n      this.canTrackVelocity = null;\n      this.events = {};\n      this.updateAndNotify = (v, render = !0) => {\n        const currentTime = time.now();\n        this.updatedAt !== currentTime && this.setPrevFrameValue();\n        this.prev = this.current;\n        this.setCurrent(v);\n        this.current !== this.prev && this.events.change && this.events.change.notify(this.current);\n        render && this.events.renderRequest && this.events.renderRequest.notify(this.current);\n      };\n      this.hasAnimated = !1;\n      this.setCurrent(init);\n      this.owner = options.owner;\n    }\n    setCurrent(current) {\n      this.current = current;\n      this.updatedAt = time.now();\n      null === this.canTrackVelocity && void 0 !== current && (this.canTrackVelocity = !isNaN(parseFloat(this.current)));\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n      this.prevFrameValue = prevFrameValue;\n      this.prevUpdatedAt = this.updatedAt;\n    }\n    onChange(subscription) {\n      warnOnce(!1, 'value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).');\n      return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n      this.events[eventName] || (this.events[eventName] = new SubscriptionManager());\n      const unsubscribe = this.events[eventName].add(callback);\n      return \"change\" === eventName ? () => {\n        unsubscribe();\n        frame.read(() => {\n          this.events.change.getSize() || this.stop();\n        });\n      } : unsubscribe;\n    }\n    clearListeners() {\n      for (const eventManagers in this.events) {\n        this.events[eventManagers].clear();\n      }\n    }\n    attach(passiveEffect, stopPassiveEffect) {\n      this.passiveEffect = passiveEffect;\n      this.stopPassiveEffect = stopPassiveEffect;\n    }\n    set(v, render = !0) {\n      render && this.passiveEffect ? this.passiveEffect(v, this.updateAndNotify) : this.updateAndNotify(v, render);\n    }\n    setWithVelocity(prev, current, delta) {\n      this.set(current);\n      this.prev = void 0;\n      this.prevFrameValue = prev;\n      this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    jump(v, endAnimation = !0) {\n      this.updateAndNotify(v);\n      this.prev = v;\n      this.prevUpdatedAt = this.prevFrameValue = void 0;\n      endAnimation && this.stop();\n      this.stopPassiveEffect && this.stopPassiveEffect();\n    }\n    get() {\n      collectMotionValues.current && collectMotionValues.current.push(this);\n      return this.current;\n    }\n    getPrevious() {\n      return this.prev;\n    }\n    getVelocity() {\n      var currentTime = time.now();\n      if (!this.canTrackVelocity || void 0 === this.prevFrameValue || 30 < currentTime - this.updatedAt) {\n        return 0;\n      }\n      currentTime = Math.min(this.updatedAt - this.prevUpdatedAt, 30);\n      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), currentTime);\n    }\n    start(startAnimation) {\n      this.stop();\n      return (new Promise(resolve => {\n        this.hasAnimated = !0;\n        this.animation = startAnimation(resolve);\n        this.events.animationStart && this.events.animationStart.notify();\n      })).then(() => {\n        this.events.animationComplete && this.events.animationComplete.notify();\n        this.clearAnimation();\n      });\n    }\n    stop() {\n      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify());\n      this.clearAnimation();\n    }\n    isAnimating() {\n      return !!this.animation;\n    }\n    clearAnimation() {\n      delete this.animation;\n    }\n    destroy() {\n      this.clearListeners();\n      this.stop();\n      this.stopPassiveEffect && this.stopPassiveEffect();\n    }\n  }\n  const isMotionValue = value => !(!value || !value.getVelocity), camelToDash = str => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase(), optimizedAppearDataAttribute = \"data-\" + camelToDash(\"framerAppearId\"), instantAnimationState = {current:!1}, mirrorEasing = easing => p => 0.5 >= p ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2, reverseEasing = easing => p => 1 - easing(1 - p), backOut = cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), \n  anticipate = p => 1 > (p *= 2) ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))), circIn = p => 1 - Math.sin(Math.acos(p)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), clamp = (min, max, v) => v > max ? max : v < min ? min : v, number = {test:v => \"number\" === typeof v, parse:parseFloat, transform:v => v}, alpha = {...number, transform:v => 1 < v ? 1 : 0 > v ? 0 : v}, scale = {...number, default:1}, floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu, singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu, \n  isColorString = (type, testProp) => v => !!(\"string\" === typeof v && singleColorRegex.test(v) && v.startsWith(type) || testProp && null != v && Object.prototype.hasOwnProperty.call(v, testProp)), splitColor = (aName, bName, cName) => v => {\n    if (\"string\" !== typeof v) {\n      return v;\n    }\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {[aName]:parseFloat(a), [bName]:parseFloat(b), [cName]:parseFloat(c), alpha:void 0 !== alpha ? parseFloat(alpha) : 1};\n  }, rgbUnit = {...number, transform:v => Math.round(255 < v ? 255 : 0 > v ? 0 : v)}, rgba = {test:isColorString(\"rgb\", \"red\"), parse:splitColor(\"red\", \"green\", \"blue\"), transform:({red, green, blue, alpha:alpha$1 = 1}) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + Math.round(100000 * alpha.transform(alpha$1)) / 100000 + \")\"}, hex = {test:isColorString(\"#\"), parse:function(v) {\n    let r, g, b;\n    5 < v.length ? (r = v.substring(1, 3), g = v.substring(3, 5), b = v.substring(5, 7), v = v.substring(7, 9)) : (r = v.substring(1, 2), g = v.substring(2, 3), b = v.substring(3, 4), v = v.substring(4, 5), r += r, g += g, b += b, v += v);\n    return {red:parseInt(r, 16), green:parseInt(g, 16), blue:parseInt(b, 16), alpha:v ? parseInt(v, 16) / 255 : 1};\n  }, transform:rgba.transform}, createUnitType = unit => ({test:v => \"string\" === typeof v && v.endsWith(unit) && 1 === v.split(\" \").length, parse:parseFloat, transform:v => `${v}${unit}`}), degrees = createUnitType(\"deg\"), percent = createUnitType(\"%\"), px = createUnitType(\"px\"), vh = createUnitType(\"vh\"), vw = createUnitType(\"vw\"), progressPercentage = {...percent, parse:v => percent.parse(v) / 100, transform:v => percent.transform(100 * v)}, hsla = {test:isColorString(\"hsl\", \"hue\"), parse:splitColor(\"hue\", \n  \"saturation\", \"lightness\"), transform:({hue, saturation, lightness, alpha:alpha$1 = 1}) => \"hsla(\" + Math.round(hue) + \", \" + percent.transform(Math.round(100000 * saturation) / 100000) + \", \" + percent.transform(Math.round(100000 * lightness) / 100000) + \", \" + Math.round(100000 * alpha.transform(alpha$1)) / 100000 + \")\"}, color = {test:v => rgba.test(v) || hex.test(v) || hsla.test(v), parse:v => rgba.test(v) ? rgba.parse(v) : hsla.test(v) ? hsla.parse(v) : hex.parse(v), transform:v => \"string\" === \n  typeof v ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v)}, colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu, complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu, convertNumbersToZero = v => \"number\" === typeof v ? \n  0 : v, complex = {test:function(v) {\n    var _a, _b;\n    return isNaN(v) && \"string\" === typeof v && 0 < ((null === (_a = v.match(floatRegex)) || void 0 === _a ? void 0 : _a.length) || 0) + ((null === (_b = v.match(colorRegex)) || void 0 === _b ? void 0 : _b.length) || 0);\n  }, parse:parseComplexValue, createTransformer, getAnimatableNone:function(v) {\n    const parsed = parseComplexValue(v);\n    return createTransformer(v)(parsed.map(convertNumbersToZero));\n  }}, maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]), functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu, filter = {...complex, getAnimatableNone:v => {\n    const functions = v.match(functionRegex);\n    return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n  }}, browserNumberValueTypes = {borderWidth:px, borderTopWidth:px, borderRightWidth:px, borderBottomWidth:px, borderLeftWidth:px, borderRadius:px, radius:px, borderTopLeftRadius:px, borderTopRightRadius:px, borderBottomRightRadius:px, borderBottomLeftRadius:px, width:px, maxWidth:px, height:px, maxHeight:px, top:px, right:px, bottom:px, left:px, padding:px, paddingTop:px, paddingRight:px, paddingBottom:px, paddingLeft:px, margin:px, marginTop:px, marginRight:px, marginBottom:px, marginLeft:px, backgroundPositionX:px, \n  backgroundPositionY:px}, int = {...number, transform:Math.round}, numberValueTypes = {...browserNumberValueTypes, rotate:degrees, rotateX:degrees, rotateY:degrees, rotateZ:degrees, scale, scaleX:scale, scaleY:scale, scaleZ:scale, skew:degrees, skewX:degrees, skewY:degrees, distance:px, translateX:px, translateY:px, translateZ:px, x:px, y:px, z:px, perspective:px, transformPerspective:px, opacity:alpha, originX:progressPercentage, originY:progressPercentage, originZ:px, zIndex:int, size:px, fillOpacity:alpha, \n  strokeOpacity:alpha, numOctaves:int}, defaultValueTypes = {...numberValueTypes, color, backgroundColor:color, outlineColor:color, fill:color, stroke:color, borderColor:color, borderTopColor:color, borderRightColor:color, borderBottomColor:color, borderLeftColor:color, filter, WebkitFilter:filter}, invalidTemplates = new Set([\"auto\", \"none\", \"0\"]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, {transform}) => \"none\" !== transform && transform ? (_bbox = transform.match(/^matrix3d\\((.+)\\)$/u)) ? \n  parseFloat(_bbox[1].split(\", \")[pos3]) : (transform = transform.match(/^matrix\\((.+)\\)$/u)) ? parseFloat(transform[1].split(\", \")[pos2]) : 0 : 0, transformKeys = new Set([\"x\", \"y\", \"z\"]), nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key)), positionalValues = {width:({x}, {paddingLeft = \"0\", paddingRight = \"0\"}) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight), height:({y}, {paddingTop = \"0\", paddingBottom = \"0\"}) => y.max - y.min - parseFloat(paddingTop) - \n  parseFloat(paddingBottom), top:(_bbox, {top}) => parseFloat(top), left:(_bbox, {left}) => parseFloat(left), bottom:({y}, {top}) => parseFloat(top) + (y.max - y.min), right:({x}, {left}) => parseFloat(left) + (x.max - x.min), x:getTranslateFromMatrix(4, 13), y:getTranslateFromMatrix(5, 14)};\n  positionalValues.translateX = positionalValues.x;\n  positionalValues.translateY = positionalValues.y;\n  const toResolve = new Set();\n  let isScheduled = !1, anyNeedsMeasurement = !1;\n  class KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = !1) {\n      this.isScheduled = this.needsMeasurement = this.isAsync = this.isComplete = !1;\n      this.unresolvedKeyframes = [...unresolvedKeyframes];\n      this.onComplete = onComplete;\n      this.name = name;\n      this.motionValue = motionValue;\n      this.element = element;\n      this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n      this.isScheduled = !0;\n      this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());\n    }\n    readKeyframes() {\n      const {unresolvedKeyframes, name, element, motionValue} = this;\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        if (null === unresolvedKeyframes[i]) {\n          if (0 === i) {\n            const currentValue = null === motionValue || void 0 === motionValue ? void 0 : motionValue.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (void 0 !== currentValue) {\n              unresolvedKeyframes[0] = currentValue;\n            } else if (element && name) {\n              const valueAsRead = element.readValue(name, finalKeyframe);\n              void 0 !== valueAsRead && null !== valueAsRead && (unresolvedKeyframes[0] = valueAsRead);\n            }\n            void 0 === unresolvedKeyframes[0] && (unresolvedKeyframes[0] = finalKeyframe);\n            motionValue && void 0 === currentValue && motionValue.set(unresolvedKeyframes[0]);\n          } else {\n            unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n          }\n        }\n      }\n    }\n    setFinalKeyframe() {\n    }\n    measureInitialState() {\n    }\n    renderEndStyles() {\n    }\n    measureEndState() {\n    }\n    complete() {\n      this.isComplete = !0;\n      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n      toResolve.delete(this);\n    }\n    cancel() {\n      this.isComplete || (this.isScheduled = !1, toResolve.delete(this));\n    }\n    resume() {\n      this.isComplete || this.scheduleResolve();\n    }\n  }\n  const checkStringStartsWith = token => key => \"string\" === typeof key && key.startsWith(token), isCSSVariableName = checkStringStartsWith(\"--\"), startsAsVariableToken = checkStringStartsWith(\"var(--\"), isCSSVariableToken = value => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split(\"/*\")[0].trim()) : !1, singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu, splitCSSVariableRegex = /^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u, \n  testValueType = v => type => type.test(v), dimensionValueTypes = [number, px, percent, degrees, vw, vh, {test:v => \"auto\" === v, parse:v => v}];\n  class DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n      super(unresolvedKeyframes, onComplete, name, motionValue, element, !0);\n    }\n    readKeyframes() {\n      const {unresolvedKeyframes, element, name} = this;\n      if (element && element.current) {\n        super.readKeyframes();\n        for (var i = 0; i < unresolvedKeyframes.length; i++) {\n          var keyframe = unresolvedKeyframes[i];\n          if (\"string\" === typeof keyframe && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {\n            const resolved = getVariableValue(keyframe, element.current);\n            void 0 !== resolved && (unresolvedKeyframes[i] = resolved);\n            i === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);\n          }\n        }\n        this.resolveNoneKeyframes();\n        if (positionalKeys.has(name) && 2 === unresolvedKeyframes.length) {\n          var [origin, target] = unresolvedKeyframes;\n          i = dimensionValueTypes.find(testValueType(origin));\n          keyframe = dimensionValueTypes.find(testValueType(target));\n          if (i !== keyframe) {\n            if (i !== number && i !== px || keyframe !== number && keyframe !== px) {\n              this.needsMeasurement = !0;\n            } else {\n              for (i = 0; i < unresolvedKeyframes.length; i++) {\n                keyframe = unresolvedKeyframes[i], \"string\" === typeof keyframe && (unresolvedKeyframes[i] = parseFloat(keyframe));\n              }\n            }\n          }\n        }\n      }\n    }\n    resolveNoneKeyframes() {\n      const {unresolvedKeyframes, name} = this, noneKeyframeIndexes = [];\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        var JSCompiler_inline_result = unresolvedKeyframes[i];\n        JSCompiler_inline_result = \"number\" === typeof JSCompiler_inline_result ? 0 === JSCompiler_inline_result : null !== JSCompiler_inline_result ? \"none\" === JSCompiler_inline_result || \"0\" === JSCompiler_inline_result || /^0[^.\\s]+$/u.test(JSCompiler_inline_result) : !0;\n        JSCompiler_inline_result && noneKeyframeIndexes.push(i);\n      }\n      if (noneKeyframeIndexes.length) {\n        i = 0;\n        for (JSCompiler_inline_result = void 0; i < unresolvedKeyframes.length && !JSCompiler_inline_result;) {\n          const keyframe = unresolvedKeyframes[i];\n          \"string\" === typeof keyframe && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (JSCompiler_inline_result = unresolvedKeyframes[i]);\n          i++;\n        }\n        if (JSCompiler_inline_result && name) {\n          for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, JSCompiler_inline_result);\n          }\n        }\n      }\n    }\n    measureInitialState() {\n      const {element, unresolvedKeyframes, name} = this;\n      if (element && element.current) {\n        \"height\" === name && (this.suspendedScrollY = window.pageYOffset);\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        void 0 !== measureKeyframe && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);\n      }\n    }\n    measureEndState() {\n      var _a;\n      const {element, name, unresolvedKeyframes} = this;\n      if (element && element.current) {\n        var value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, !1);\n        value = unresolvedKeyframes.length - 1;\n        var finalKeyframe = unresolvedKeyframes[value];\n        unresolvedKeyframes[value] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        null !== finalKeyframe && void 0 === this.finalKeyframe && (this.finalKeyframe = finalKeyframe);\n        (null === (_a = this.removedTransforms) || void 0 === _a ? 0 : _a.length) && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n          element.getValue(unsetTransformName).set(unsetTransformValue);\n        });\n        this.resolveNoneKeyframes();\n      }\n    }\n  }\n  const isAnimatable = (value, name) => \"zIndex\" === name ? !1 : \"number\" === typeof value || Array.isArray(value) || \"string\" === typeof value && (complex.test(value) || \"0\" === value) && !value.startsWith(\"url(\") ? !0 : !1, isNotNull = value => null !== value;\n  class BaseAnimation {\n    constructor({autoplay = !0, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options}) {\n      this.hasAttemptedResolve = this.isStopped = !1;\n      this.createdAt = time.now();\n      this.options = {autoplay, delay, type, repeat, repeatDelay, repeatType, ...options};\n      this.updateFinishedPromise();\n    }\n    calcStartTime() {\n      return this.resolvedAt ? 40 < this.resolvedAt - this.createdAt ? this.resolvedAt : this.createdAt : this.createdAt;\n    }\n    get resolved() {\n      this._resolved || this.hasAttemptedResolve || (readAllKeyframes(), measureAllKeyframes());\n      return this._resolved;\n    }\n    onKeyframesResolved(keyframes, finalKeyframe) {\n      this.resolvedAt = time.now();\n      this.hasAttemptedResolve = !0;\n      const {name, type, velocity, delay, onComplete, onUpdate, isGenerator} = this.options;\n      var JSCompiler_temp;\n      if (JSCompiler_temp = !isGenerator) {\n        {\n          const originKeyframe = keyframes[0];\n          if (null === originKeyframe) {\n            JSCompiler_temp = !1;\n          } else {\n            if (\"display\" === name || \"visibility\" === name) {\n              JSCompiler_temp = !0;\n            } else {\n              JSCompiler_temp = keyframes[keyframes.length - 1];\n              var isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(JSCompiler_temp, name);\n              motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${JSCompiler_temp}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${JSCompiler_temp} via the \\`style\\` property.`);\n              if (isOriginAnimatable && isTargetAnimatable) {\n                b: {\n                  if (JSCompiler_temp = keyframes[0], 1 === keyframes.length) {\n                    JSCompiler_temp = !0;\n                  } else {\n                    for (isOriginAnimatable = 0; isOriginAnimatable < keyframes.length; isOriginAnimatable++) {\n                      if (keyframes[isOriginAnimatable] !== JSCompiler_temp) {\n                        JSCompiler_temp = !0;\n                        break b;\n                      }\n                    }\n                    JSCompiler_temp = void 0;\n                  }\n                }\n                JSCompiler_temp = JSCompiler_temp || (\"spring\" === type || motionDom.isGenerator(type)) && velocity;\n              } else {\n                JSCompiler_temp = !1;\n              }\n            }\n          }\n        }\n        JSCompiler_temp = !JSCompiler_temp;\n      }\n      if (JSCompiler_temp) {\n        if (instantAnimationState.current || !delay) {\n          onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n          onComplete && onComplete();\n          this.resolveFinishedPromise();\n          return;\n        }\n        this.options.duration = 0;\n      }\n      JSCompiler_temp = this.initPlayback(keyframes, finalKeyframe);\n      !1 !== JSCompiler_temp && (this._resolved = {keyframes, finalKeyframe, ...JSCompiler_temp}, this.onPostResolved());\n    }\n    onPostResolved() {\n    }\n    then(resolve, reject) {\n      return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n      this.options.type = \"keyframes\";\n      this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n      this.currentFinishedPromise = new Promise(resolve => {\n        this.resolveFinishedPromise = resolve;\n      });\n    }\n  }\n  const mixNumber$1 = (from, to, progress) => from + (to - from) * progress, mixLinearColor = (from, to, v) => {\n    from *= from;\n    to = v * (to * to - from) + from;\n    return 0 > to ? 0 : Math.sqrt(to);\n  }, colorTypes = [hex, rgba, hsla], getColorType = v => colorTypes.find(type => type.test(v)), mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n      return mixImmediate(from, to);\n    }\n    const blended = {...fromRGBA};\n    return v => {\n      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);\n      return rgba.transform(blended);\n    };\n  }, combineFunctions = (a, b) => v => b(a(v)), invisibleValues = new Set([\"none\", \"hidden\"]), mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);\n    if (originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length) {\n      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n        return mixVisibility(origin, target);\n      }\n      origin = mixArray;\n      var _a;\n      target = [];\n      const pointers = {color:0, var:0, number:0};\n      for (let i = 0; i < targetStats.values.length; i++) {\n        const type = targetStats.types[i], originValue = null !== (_a = originStats.values[originStats.indexes[type][pointers[type]]]) && void 0 !== _a ? _a : 0;\n        target[i] = originValue;\n        pointers[type]++;\n      }\n      return [origin(target, targetStats.values), template].reduce(combineFunctions);\n    }\n    motionUtils.warning(!0, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }, springDefaults = {stiffness:100, damping:10, mass:1.0, velocity:0.0, duration:800, bounce:0.3, visualDuration:0.3, restSpeed:{granular:0.01, default:2}, restDelta:{granular:0.005, default:0.5}, minDuration:0.01, maxDuration:10.0, minDamping:0.05, maxDamping:1}, durationKeys = [\"duration\", \"bounce\"], physicsKeys = [\"stiffness\", \"damping\", \"mass\"], easeIn = cubicBezier(0.42, 0, 1, 1), easeOut = cubicBezier(0, 0, 0.58, 1), easeInOut = cubicBezier(0.42, 0, 0.58, 1), isEasingArray = ease => Array.isArray(ease) && \n  \"number\" !== typeof ease[0], easingLookup = {linear:motionUtils.noop, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate}, easingDefinitionToFunction = definition => {\n    if (motionDom.isBezierDefinition(definition)) {\n      motionUtils.invariant(4 === definition.length, \"Cubic bezier arrays must contain four numerical values.\");\n      const [x1, y1, x2, y2] = definition;\n      return cubicBezier(x1, y1, x2, y2);\n    }\n    return \"string\" === typeof definition ? (motionUtils.invariant(void 0 !== easingLookup[definition], `Invalid easing type '${definition}'`), easingLookup[definition]) : definition;\n  }, frameloopDriver = update => {\n    const passTimestamp = ({timestamp}) => update(timestamp);\n    return {start:() => frame.update(passTimestamp, !0), stop:() => cancelFrame(passTimestamp), now:() => frameData.isProcessing ? frameData.timestamp : time.now()};\n  }, generators = {decay:inertia, inertia, tween:keyframes, keyframes, spring}, percentToProgress = percent => percent / 100;\n  class MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n      super(options);\n      this.cancelTime = this.holdTime = null;\n      this.currentTime = 0;\n      this.playbackSpeed = 1;\n      this.pendingPlayState = \"running\";\n      this.startTime = null;\n      this.state = \"idle\";\n      this.stop = () => {\n        this.resolver.cancel();\n        this.isStopped = !0;\n        if (\"idle\" !== this.state) {\n          this.teardown();\n          var {onStop} = this.options;\n          onStop && onStop();\n        }\n      };\n      const {name, motionValue, element, keyframes} = this.options;\n      this.resolver = new ((null === element || void 0 === element ? void 0 : element.KeyframeResolver) || KeyframeResolver)(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n      this.resolver.scheduleResolve();\n    }\n    flatten() {\n      super.flatten();\n      this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n    }\n    initPlayback(keyframes$1) {\n      const {type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0} = this.options;\n      var generatorFactory = motionDom.isGenerator(type) ? type : generators[type] || keyframes;\n      let mapPercentToKeyframes, mirroredGenerator;\n      generatorFactory !== keyframes && motionUtils.invariant(2 >= keyframes$1.length, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n      generatorFactory !== keyframes && \"number\" !== typeof keyframes$1[0] && (mapPercentToKeyframes = [percentToProgress, mix(keyframes$1[0], keyframes$1[1])].reduce(combineFunctions), keyframes$1 = [0, 100]);\n      const generator = generatorFactory({...this.options, keyframes:keyframes$1});\n      \"mirror\" === repeatType && (mirroredGenerator = generatorFactory({...this.options, keyframes:[...keyframes$1].reverse(), velocity:-velocity}));\n      null === generator.calculatedDuration && (generator.calculatedDuration = motionDom.calcGeneratorDuration(generator));\n      ({calculatedDuration:keyframes$1} = generator);\n      generatorFactory = keyframes$1 + repeatDelay;\n      return {generator, mirroredGenerator, mapPercentToKeyframes, calculatedDuration:keyframes$1, resolvedDuration:generatorFactory, totalDuration:generatorFactory * (repeat + 1) - repeatDelay};\n    }\n    onPostResolved() {\n      const {autoplay = !0} = this.options;\n      this.play();\n      \"paused\" !== this.pendingPlayState && autoplay ? this.state = this.pendingPlayState : this.pause();\n    }\n    tick(timestamp, sample = !1) {\n      var {resolved} = this;\n      if (!resolved) {\n        return {keyframes:timestamp} = this.options, {done:!0, value:timestamp[timestamp.length - 1]};\n      }\n      const {finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration} = resolved;\n      if (null === this.startTime) {\n        return generator.next(0);\n      }\n      const {delay, repeat, repeatType, repeatDelay, onUpdate} = this.options;\n      0 < this.speed ? this.startTime = Math.min(this.startTime, timestamp) : 0 > this.speed && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime));\n      this.currentTime = sample ? timestamp : null !== this.holdTime ? this.holdTime : Math.round(timestamp - this.startTime) * this.speed;\n      sample = this.currentTime - delay * (0 <= this.speed ? 1 : -1);\n      timestamp = 0 <= this.speed ? 0 > sample : sample > totalDuration;\n      this.currentTime = Math.max(sample, 0);\n      \"finished\" === this.state && null === this.holdTime && (this.currentTime = totalDuration);\n      resolved = this.currentTime;\n      sample = generator;\n      if (repeat) {\n        resolved = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n        let currentIteration = Math.floor(resolved), iterationProgress = resolved % 1.0;\n        !iterationProgress && 1 <= resolved && (iterationProgress = 1);\n        1 === iterationProgress && currentIteration--;\n        currentIteration = Math.min(currentIteration, repeat + 1);\n        currentIteration % 2 && (\"reverse\" === repeatType ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : \"mirror\" === repeatType && (sample = mirroredGenerator));\n        resolved = (1 < iterationProgress ? 1 : 0 > iterationProgress ? 0 : iterationProgress) * resolvedDuration;\n      }\n      sample = timestamp ? {done:!1, value:keyframes[0]} : sample.next(resolved);\n      mapPercentToKeyframes && (sample.value = mapPercentToKeyframes(sample.value));\n      ({done:resolved} = sample);\n      timestamp || null === calculatedDuration || (resolved = 0 <= this.speed ? this.currentTime >= totalDuration : 0 >= this.currentTime);\n      (timestamp = null === this.holdTime && (\"finished\" === this.state || \"running\" === this.state && resolved)) && void 0 !== finalKeyframe && (sample.value = getFinalKeyframe(keyframes, this.options, finalKeyframe));\n      onUpdate && onUpdate(sample.value);\n      timestamp && this.finish();\n      return sample;\n    }\n    get duration() {\n      const {resolved} = this;\n      return resolved ? motionUtils.millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n      return motionUtils.millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n      this.currentTime = newTime = motionUtils.secondsToMilliseconds(newTime);\n      null !== this.holdTime || 0 === this.speed ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.speed);\n    }\n    get speed() {\n      return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n      const hasChanged = this.playbackSpeed !== newSpeed;\n      this.playbackSpeed = newSpeed;\n      hasChanged && (this.time = motionUtils.millisecondsToSeconds(this.currentTime));\n    }\n    play() {\n      this.resolver.isScheduled || this.resolver.resume();\n      if (!this._resolved) {\n        this.pendingPlayState = \"running\";\n      } else {\n        if (!this.isStopped) {\n          var {driver = frameloopDriver, onPlay, startTime} = this.options;\n          this.driver || (this.driver = driver(timestamp => this.tick(timestamp)));\n          onPlay && onPlay();\n          var now = this.driver.now();\n          null !== this.holdTime ? this.startTime = now - this.holdTime : this.startTime ? \"finished\" === this.state && (this.startTime = now) : this.startTime = null !== startTime && void 0 !== startTime ? startTime : this.calcStartTime();\n          \"finished\" === this.state && this.updateFinishedPromise();\n          this.cancelTime = this.startTime;\n          this.holdTime = null;\n          this.state = \"running\";\n          this.driver.start();\n        }\n      }\n    }\n    pause() {\n      var _a;\n      this._resolved ? (this.state = \"paused\", this.holdTime = null !== (_a = this.currentTime) && void 0 !== _a ? _a : 0) : this.pendingPlayState = \"paused\";\n    }\n    complete() {\n      \"running\" !== this.state && this.play();\n      this.pendingPlayState = this.state = \"finished\";\n      this.holdTime = null;\n    }\n    finish() {\n      this.teardown();\n      this.state = \"finished\";\n      const {onComplete} = this.options;\n      onComplete && onComplete();\n    }\n    cancel() {\n      null !== this.cancelTime && this.tick(this.cancelTime);\n      this.teardown();\n      this.updateFinishedPromise();\n    }\n    teardown() {\n      this.state = \"idle\";\n      this.stopDriver();\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      this.startTime = this.cancelTime = null;\n      this.resolver.cancel();\n    }\n    stopDriver() {\n      this.driver && (this.driver.stop(), this.driver = void 0);\n    }\n    sample(time) {\n      this.startTime = 0;\n      return this.tick(time, !0);\n    }\n  }\n  const acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\"]), supportsWaapi = motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\")), unsupportedEasingFunctions = {anticipate, backInOut, circInOut};\n  class AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n      super(options);\n      const {name, motionValue, element, keyframes} = this.options;\n      this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n      this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n      let {duration = 300, times, ease, type, motionValue, name, startTime} = this.options;\n      if (!motionValue.owner || !motionValue.owner.current) {\n        return !1;\n      }\n      \"string\" === typeof ease && motionDom.supportsLinearEasing() && ease in unsupportedEasingFunctions && (ease = unsupportedEasingFunctions[ease]);\n      if (requiresPregeneratedKeyframes(this.options)) {\n        const {onComplete, onUpdate, motionValue, element, ...options} = this.options;\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes;\n        1 === keyframes.length && (keyframes[1] = keyframes[0]);\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n      pregeneratedAnimation = startWaapiAnimation(motionValue.owner.current, name, keyframes, {...this.options, duration, times, ease});\n      pregeneratedAnimation.startTime = null !== startTime && void 0 !== startTime ? startTime : this.calcStartTime();\n      this.pendingTimeline ? (motionDom.attachTimeline(pregeneratedAnimation, this.pendingTimeline), this.pendingTimeline = void 0) : pregeneratedAnimation.onfinish = () => {\n        const {onComplete} = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n      return {animation:pregeneratedAnimation, duration, times, type, ease, keyframes};\n    }\n    get duration() {\n      var {resolved} = this;\n      if (!resolved) {\n        return 0;\n      }\n      ({duration:resolved} = resolved);\n      return motionUtils.millisecondsToSeconds(resolved);\n    }\n    get time() {\n      var {resolved} = this;\n      if (!resolved) {\n        return 0;\n      }\n      ({animation:resolved} = resolved);\n      return motionUtils.millisecondsToSeconds(resolved.currentTime || 0);\n    }\n    set time(newTime) {\n      var {resolved} = this;\n      resolved && ({animation:resolved} = resolved, resolved.currentTime = motionUtils.secondsToMilliseconds(newTime));\n    }\n    get speed() {\n      var {resolved} = this;\n      if (!resolved) {\n        return 1;\n      }\n      ({animation:resolved} = resolved);\n      return resolved.playbackRate;\n    }\n    set speed(newSpeed) {\n      var {resolved} = this;\n      resolved && ({animation:resolved} = resolved, resolved.playbackRate = newSpeed);\n    }\n    get state() {\n      var {resolved} = this;\n      if (!resolved) {\n        return \"idle\";\n      }\n      ({animation:resolved} = resolved);\n      return resolved.playState;\n    }\n    get startTime() {\n      var {resolved} = this;\n      if (!resolved) {\n        return null;\n      }\n      ({animation:resolved} = resolved);\n      return resolved.startTime;\n    }\n    attachTimeline(timeline) {\n      if (this._resolved) {\n        var {resolved} = this;\n        if (!resolved) {\n          return motionUtils.noop;\n        }\n        ({animation:resolved} = resolved);\n        motionDom.attachTimeline(resolved, timeline);\n      } else {\n        this.pendingTimeline = timeline;\n      }\n      return motionUtils.noop;\n    }\n    play() {\n      if (!this.isStopped) {\n        var {resolved} = this;\n        resolved && ({animation:resolved} = resolved, \"finished\" === resolved.playState && this.updateFinishedPromise(), resolved.play());\n      }\n    }\n    pause() {\n      var {resolved} = this;\n      resolved && ({animation:resolved} = resolved, resolved.pause());\n    }\n    stop() {\n      this.resolver.cancel();\n      this.isStopped = !0;\n      if (\"idle\" !== this.state) {\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        var {resolved} = this;\n        if (resolved) {\n          var {animation, keyframes, duration, type, ease, times} = resolved;\n          if (\"idle\" !== animation.playState && \"finished\" !== animation.playState) {\n            if (this.time) {\n              const {motionValue, onUpdate, onComplete, element, ...options} = this.options;\n              resolved = new MainThreadAnimation({...options, keyframes, duration, type, ease, times, isGenerator:!0});\n              const sampleTime = motionUtils.secondsToMilliseconds(this.time);\n              motionValue.setWithVelocity(resolved.sample(sampleTime - 10).value, resolved.sample(sampleTime).value, 10);\n            }\n            ({onStop:resolved} = this.options);\n            resolved && resolved();\n            this.cancel();\n          }\n        }\n      }\n    }\n    complete() {\n      const {resolved} = this;\n      resolved && resolved.animation.finish();\n    }\n    cancel() {\n      const {resolved} = this;\n      resolved && resolved.animation.cancel();\n    }\n    static supports(options) {\n      const {motionValue, name, repeatDelay, repeatType, damping, type} = options;\n      if (!(motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement)) {\n        return !1;\n      }\n      const {onUpdate, transformTemplate} = motionValue.owner.getProps();\n      return supportsWaapi() && name && acceleratedValues.has(name) && !onUpdate && !transformTemplate && !repeatDelay && \"mirror\" !== repeatType && 0 !== damping && \"inertia\" !== type;\n    }\n  }\n  const underDampedSpring = {type:\"spring\", stiffness:500, damping:25, restSpeed:10}, keyframesTransition = {type:\"keyframes\", duration:0.8}, ease = {type:\"keyframes\", ease:[0.25, 0.1, 0.35, 1], duration:0.3}, getDefaultTransition = (valueKey, {keyframes}) => 2 < keyframes.length ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith(\"scale\") ? {type:\"spring\", stiffness:550, damping:0 === keyframes[1] ? 2 * Math.sqrt(550) : 30, restSpeed:10} : underDampedSpring : ease, animateMotionValue = \n  (name, value, target, transition = {}, element, isHandoff) => onComplete => {\n    const valueTransition = motionDom.getValueTransition(transition, name) || {};\n    var delay = valueTransition.delay || transition.delay || 0;\n    let {elapsed = 0} = transition;\n    elapsed -= motionUtils.secondsToMilliseconds(delay);\n    let options = {keyframes:Array.isArray(target) ? target : [null, target], ease:\"easeOut\", velocity:value.getVelocity(), ...valueTransition, delay:-elapsed, onUpdate:v => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    }, onComplete:() => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n    }, name, motionValue:value, element:isHandoff ? void 0 : element};\n    isTransitionDefined(valueTransition) || (options = {...options, ...getDefaultTransition(name, options)});\n    options.duration && (options.duration = motionUtils.secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay));\n    void 0 !== options.from && (options.keyframes[0] = options.from);\n    delay = !1;\n    if (!1 === options.type || 0 === options.duration && !options.repeatDelay) {\n      options.duration = 0, 0 === options.delay && (delay = !0);\n    }\n    if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n      delay = !0, options.duration = 0, options.delay = 0;\n    }\n    if (delay && !isHandoff && void 0 !== value.get()) {\n      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n      if (void 0 !== finalKeyframe) {\n        return frame.update(() => {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        }), new motionDom.GroupPlaybackControls([]);\n      }\n    }\n    return !isHandoff && AcceleratedAnimation.supports(options) ? new AcceleratedAnimation(options) : new MainThreadAnimation(options);\n  }, variantPriorityOrder = \"animate whileInView whileFocus whileHover whileTap whileDrag exit\".split(\" \"), variantProps = [\"initial\", ...variantPriorityOrder], numVariantProps = variantProps.length, reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;\n  class Feature {\n    constructor(node) {\n      this.isMounted = !1;\n      this.node = node;\n    }\n    update() {\n    }\n  }\n  class AnimationFeature extends Feature {\n    constructor(node) {\n      super(node);\n      node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n      const {animate} = this.node.getProps();\n      isAnimationControls(animate) && (this.unmountControls = animate.subscribe(this.node));\n    }\n    mount() {\n      this.updateAnimationControlsSubscription();\n    }\n    update() {\n      const {animate} = this.node.getProps(), {animate:prevAnimate} = this.node.prevProps || {};\n      animate !== prevAnimate && this.updateAnimationControlsSubscription();\n    }\n    unmount() {\n      var _a;\n      this.node.animationState.reset();\n      null === (_a = this.unmountControls) || void 0 === _a || _a.call(this);\n    }\n  }\n  let id$1 = 0;\n  class ExitAnimationFeature extends Feature {\n    constructor() {\n      super(...arguments);\n      this.id = id$1++;\n    }\n    update() {\n      if (this.node.presenceContext) {\n        var {isPresent, onExitComplete} = this.node.presenceContext, {isPresent:prevIsPresent} = this.node.prevPresenceContext || {};\n        this.node.animationState && isPresent !== prevIsPresent && (prevIsPresent = this.node.animationState.setActive(\"exit\", !isPresent), onExitComplete && !isPresent && prevIsPresent.then(() => {\n          onExitComplete(this.id);\n        }));\n      }\n    }\n    mount() {\n      const {register, onExitComplete} = this.node.presenceContext || {};\n      onExitComplete && onExitComplete(this.id);\n      register && (this.unmount = register(this.id));\n    }\n    unmount() {\n    }\n  }\n  const animations = {animation:{Feature:AnimationFeature}, exit:{Feature:ExitAnimationFeature}}, MotionContext = React.createContext({}), createAxisDelta = () => ({translate:0, scale:1, origin:0, originPoint:0}), createBox = () => ({x:{min:0, max:0}, y:{min:0, max:0}}), validMotionProps = new Set(\"animate exit variants initial style values variants transition transformTemplate custom inherit onBeforeLayoutMeasure onAnimationStart onAnimationComplete onUpdate onDragStart onDrag onDragEnd onMeasureDragConstraints onDirectionLock onDragTransitionEnd _dragX _dragY onHoverStart onHoverEnd onViewportEnter onViewportLeave globalTapTarget ignoreStrict viewport\".split(\" \"));\n  let shouldForward = key => !isValidMotionProp(key);\n  try {\n    loadExternalIsValidProp(require(\"module$node_modules$$emotion$is_prop_valid$dist$emotion_is_prop_valid_cjs\").default);\n  } catch (_a) {\n  }\n  const PresenceContext = React.createContext(null), makeUseVisualState = config => (props, isStatic) => {\n    const context = React.useContext(MotionContext), presenceContext = React.useContext(PresenceContext), make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n  }, addPointerInfo = handler => event => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event)), isBrowser = \"undefined\" !== typeof window, useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect, MotionConfigContext = React.createContext({transformPagePoint:p => p, isStatic:!1, reducedMotion:\"never\"}), visualElementStore = new WeakMap(), featureProps = {animation:\"animate variants whileHover whileTap exit whileInView whileFocus whileDrag\".split(\" \"), \n  exit:[\"exit\"], drag:[\"drag\", \"dragControls\"], focus:[\"whileFocus\"], hover:[\"whileHover\", \"onHoverStart\", \"onHoverEnd\"], tap:[\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"], pan:[\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"], inView:[\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"], layout:[\"layout\", \"layoutId\"]}, featureDefinitions = {};\n  for (const key in featureProps) {\n    featureDefinitions[key] = {isEnabled:props => featureProps[key].some(name => !!props[name])};\n  }\n  const prefersReducedMotion = {current:null}, hasReducedMotionListener = {current:!1}, valueTypes = [...dimensionValueTypes, color, complex], propEventHandlers = \"AnimationStart AnimationComplete Update BeforeLayoutMeasure LayoutMeasure LayoutAnimationStart LayoutAnimationComplete\".split(\" \");\n  class VisualElement {\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n      return {};\n    }\n    constructor({parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState}, options = {}) {\n      this.current = null;\n      this.children = new Set();\n      this.isControllingVariants = this.isVariantNode = !1;\n      this.shouldReduceMotion = null;\n      this.values = new Map();\n      this.KeyframeResolver = KeyframeResolver;\n      this.features = {};\n      this.valueSubscriptions = new Map();\n      this.prevMotionValues = {};\n      this.events = {};\n      this.propEventSubscriptions = {};\n      this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n      this.render = () => {\n        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));\n      };\n      this.renderScheduledAt = 0.0;\n      this.scheduleRender = () => {\n        const now = time.now();\n        this.renderScheduledAt < now && (this.renderScheduledAt = now, frame.render(this.render, !1, !0));\n      };\n      const {latestValues, renderState, onUpdate} = visualState;\n      this.onUpdate = onUpdate;\n      this.latestValues = latestValues;\n      this.baseTarget = {...latestValues};\n      this.initialValues = props.initial ? {...latestValues} : {};\n      this.renderState = renderState;\n      this.parent = parent;\n      this.props = props;\n      this.presenceContext = presenceContext;\n      this.depth = parent ? parent.depth + 1 : 0;\n      this.reducedMotionConfig = reducedMotionConfig;\n      this.options = options;\n      this.blockInitialAnimation = !!blockInitialAnimation;\n      this.isControllingVariants = isControllingVariants(props);\n      if (this.isVariantNode = isVariantNode(props)) {\n        this.variantChildren = new Set();\n      }\n      this.manuallyAnimateOnMount = !(!parent || !parent.current);\n      const {willChange, ...initialMotionValues} = this.scrapeMotionValuesFromProps(props, {}, this);\n      for (const key in initialMotionValues) {\n        parent = initialMotionValues[key], void 0 !== latestValues[key] && parent && parent.getVelocity && parent.set(latestValues[key], !1);\n      }\n    }\n    mount(instance) {\n      this.current = instance;\n      visualElementStore.set(instance, this);\n      this.projection && !this.projection.instance && this.projection.mount(instance);\n      this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this));\n      this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n      hasReducedMotionListener.current || initPrefersReducedMotion();\n      this.shouldReduceMotion = \"never\" === this.reducedMotionConfig ? !1 : \"always\" === this.reducedMotionConfig ? !0 : prefersReducedMotion.current;\n      warnOnce(!0 !== this.shouldReduceMotion, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n      this.parent && this.parent.children.add(this);\n      this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n      this.projection && this.projection.unmount();\n      cancelFrame(this.notifyUpdate);\n      cancelFrame(this.render);\n      this.valueSubscriptions.forEach(remove => remove());\n      this.valueSubscriptions.clear();\n      this.removeFromVariantTree && this.removeFromVariantTree();\n      this.parent && this.parent.children.delete(this);\n      for (var key$jscomp$0 in this.events) {\n        this.events[key$jscomp$0].clear();\n      }\n      for (const key in this.features) {\n        if (key$jscomp$0 = this.features[key]) {\n          key$jscomp$0.unmount(), key$jscomp$0.isMounted = !1;\n        }\n      }\n      this.current = null;\n    }\n    bindToMotionValue(key, value) {\n      this.valueSubscriptions.has(key) && this.valueSubscriptions.get(key)();\n      const valueIsTransform = transformProps.has(key);\n      if (valueIsTransform && this.onBindTransform) {\n        this.onBindTransform();\n      }\n      const removeOnChange = value.on(\"change\", latestValue => {\n        this.latestValues[key] = latestValue;\n        this.props.onUpdate && frame.preRender(this.notifyUpdate);\n        valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);\n      }), removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n      let removeSyncCheck;\n      window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key, value));\n      this.valueSubscriptions.set(key, () => {\n        removeOnChange();\n        removeOnRenderRequest();\n        removeSyncCheck && removeSyncCheck();\n        value.owner && value.stop();\n      });\n    }\n    sortNodePosition(other) {\n      return this.current && this.sortInstanceNodePosition && this.type === other.type ? this.sortInstanceNodePosition(this.current, other.current) : 0;\n    }\n    updateFeatures() {\n      let key = \"animation\";\n      for (key in featureDefinitions) {\n        var featureDefinition = featureDefinitions[key];\n        if (!featureDefinition) {\n          continue;\n        }\n        const {isEnabled, Feature:FeatureConstructor} = featureDefinition;\n        !this.features[key] && FeatureConstructor && isEnabled(this.props) && (this.features[key] = new FeatureConstructor(this));\n        this.features[key] && (featureDefinition = this.features[key], featureDefinition.isMounted ? featureDefinition.update() : (featureDefinition.mount(), featureDefinition.isMounted = !0));\n      }\n    }\n    triggerBuild() {\n      this.build(this.renderState, this.latestValues, this.props);\n    }\n    measureViewportBox() {\n      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n    }\n    getStaticValue(key) {\n      return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n      this.latestValues[key] = value;\n    }\n    update(props, presenceContext) {\n      (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender();\n      this.prevProps = this.props;\n      this.props = props;\n      this.prevPresenceContext = this.presenceContext;\n      this.presenceContext = presenceContext;\n      for (presenceContext = 0; presenceContext < propEventHandlers.length; presenceContext++) {\n        var key$jscomp$0 = propEventHandlers[presenceContext];\n        this.propEventSubscriptions[key$jscomp$0] && (this.propEventSubscriptions[key$jscomp$0](), delete this.propEventSubscriptions[key$jscomp$0]);\n        var listener = props[\"on\" + key$jscomp$0];\n        listener && (this.propEventSubscriptions[key$jscomp$0] = this.on(key$jscomp$0, listener));\n      }\n      props = this.scrapeMotionValuesFromProps(props, this.prevProps, this);\n      presenceContext = this.prevMotionValues;\n      for (const key in props) {\n        key$jscomp$0 = props[key], listener = presenceContext[key], key$jscomp$0 && key$jscomp$0.getVelocity ? (this.addValue(key, key$jscomp$0), warnOnce(\"12.4.7\" === key$jscomp$0.version, `Attempting to mix Motion versions ${key$jscomp$0.version} with 12.4.7 may not work as expected.`)) : listener && listener.getVelocity ? this.addValue(key, motionValue(key$jscomp$0, {owner:this})) : listener !== key$jscomp$0 && (this.hasValue(key) ? (listener = this.getValue(key), !0 === listener.liveStyle ? listener.jump(key$jscomp$0) : \n        listener.hasAnimated || listener.set(key$jscomp$0)) : (listener = this.getStaticValue(key), this.addValue(key, motionValue(void 0 !== listener ? listener : key$jscomp$0, {owner:this}))));\n      }\n      for (const key in presenceContext) {\n        void 0 === props[key] && this.removeValue(key);\n      }\n      this.prevMotionValues = props;\n      this.handleChildMotionValue && this.handleChildMotionValue();\n      this.onUpdate && this.onUpdate(this);\n    }\n    getProps() {\n      return this.props;\n    }\n    getVariant(name) {\n      return this.props.variants ? this.props.variants[name] : void 0;\n    }\n    getDefaultTransition() {\n      return this.props.transition;\n    }\n    getTransformPagePoint() {\n      return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;\n    }\n    addVariantChild(child) {\n      const closestVariantNode = this.getClosestVariantNode();\n      if (closestVariantNode) {\n        return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);\n      }\n    }\n    addValue(key, value) {\n      const existingValue = this.values.get(key);\n      value !== existingValue && (existingValue && this.removeValue(key), this.bindToMotionValue(key, value), this.values.set(key, value), this.latestValues[key] = value.get());\n    }\n    removeValue(key) {\n      this.values.delete(key);\n      const unsubscribe = this.valueSubscriptions.get(key);\n      unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key));\n      delete this.latestValues[key];\n      this.removeValueFromRenderState(key, this.renderState);\n    }\n    hasValue(key) {\n      return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n      if (this.props.values && this.props.values[key]) {\n        return this.props.values[key];\n      }\n      let value = this.values.get(key);\n      void 0 === value && void 0 !== defaultValue && (value = motionValue(null === defaultValue ? void 0 : defaultValue, {owner:this}), this.addValue(key, value));\n      return value;\n    }\n    readValue(key, target) {\n      var _a;\n      let value = void 0 === this.latestValues[key] && this.current ? null !== (_a = this.getBaseTargetFromProps(this.props, key)) && void 0 !== _a ? _a : this.readValueFromInstance(this.current, key, this.options) : this.latestValues[key];\n      void 0 !== value && null !== value && (\"string\" === typeof value && (/^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(value) || /^0[^.\\s]+$/u.test(value)) ? value = parseFloat(value) : !valueTypes.find(testValueType(value)) && complex.test(target) && (value = getAnimatableNone(key, target)), this.setBaseTarget(key, value && value.getVelocity ? value.get() : value));\n      return value && value.getVelocity ? value.get() : value;\n    }\n    setBaseTarget(key, value) {\n      this.baseTarget[key] = value;\n    }\n    getBaseTarget(key) {\n      var _a;\n      const {initial} = this.props;\n      let valueFromInitial;\n      if (\"string\" === typeof initial || \"object\" === typeof initial) {\n        const variant = resolveVariantFromProps(this.props, initial, null === (_a = this.presenceContext) || void 0 === _a ? void 0 : _a.custom);\n        variant && (valueFromInitial = variant[key]);\n      }\n      if (initial && void 0 !== valueFromInitial) {\n        return valueFromInitial;\n      }\n      _a = this.getBaseTargetFromProps(this.props, key);\n      return void 0 === _a || _a && _a.getVelocity ? void 0 !== this.initialValues[key] && void 0 === valueFromInitial ? void 0 : this.baseTarget[key] : _a;\n    }\n    on(eventName, callback) {\n      this.events[eventName] || (this.events[eventName] = new SubscriptionManager());\n      return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n      this.events[eventName] && this.events[eventName].notify(...args);\n    }\n  }\n  class DOMVisualElement extends VisualElement {\n    constructor() {\n      super(...arguments);\n      this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n      return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n      return props.style ? props.style[key] : void 0;\n    }\n    removeValueFromRenderState(key, {vars, style}) {\n      delete vars[key];\n      delete style[key];\n    }\n    handleChildMotionValue() {\n      this.childSubscription && (this.childSubscription(), delete this.childSubscription);\n      const {children} = this.props;\n      children && children.getVelocity && (this.childSubscription = children.on(\"change\", latest => {\n        this.current && (this.current.textContent = `${latest}`);\n      }));\n    }\n  }\n  const getValueAsType = (value, type) => type && \"number\" === typeof value ? type.transform(value) : value, translateAlias = {x:\"translateX\", y:\"translateY\", z:\"translateZ\", transformPerspective:\"perspective\"}, numTransforms = transformPropOrder.length, dashKeys = {offset:\"stroke-dashoffset\", array:\"stroke-dasharray\"}, camelKeys = {offset:\"strokeDashoffset\", array:\"strokeDasharray\"}, camelCaseAttributes = new Set(\"baseFrequency diffuseConstant kernelMatrix kernelUnitLength keySplines keyTimes limitingConeAngle markerHeight markerWidth numOctaves targetX targetY surfaceScale specularConstant specularExponent stdDeviation tableValues viewBox gradientTransform pathLength startOffset textLength lengthAdjust\".split(\" \")), \n  isSVGTag = tag => \"string\" === typeof tag && \"svg\" === tag.toLowerCase(), scaleCorrectors = {};\n  class SVGVisualElement extends DOMVisualElement {\n    constructor() {\n      super(...arguments);\n      this.type = \"svg\";\n      this.isSVGTag = !1;\n      this.measureInstanceViewportBox = createBox;\n      this.updateDimensions = () => {\n        this.current && !this.renderState.dimensions && updateSVGDimensions(this.current, this.renderState);\n      };\n    }\n    getBaseTargetFromProps(props, key) {\n      return props[key];\n    }\n    readValueFromInstance(instance, key) {\n      if (transformProps.has(key)) {\n        return (instance = defaultValueTypes[key]) ? instance.default || 0 : 0;\n      }\n      key = camelCaseAttributes.has(key) ? key : camelToDash(key);\n      return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n      return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    onBindTransform() {\n      this.current && !this.renderState.dimensions && frame.postRender(this.updateDimensions);\n    }\n    build(renderState, latestValues, props) {\n      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n      renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n      this.isSVGTag = isSVGTag(instance.tagName);\n      super.mount(instance);\n    }\n  }\n  class HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n      super(...arguments);\n      this.type = \"html\";\n      this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n      if (transformProps.has(key)) {\n        return (key = defaultValueTypes[key]) ? key.default || 0 : 0;\n      }\n      instance = window.getComputedStyle(instance);\n      key = (isCSSVariableName(key) ? instance.getPropertyValue(key) : instance[key]) || 0;\n      return \"string\" === typeof key ? key.trim() : key;\n    }\n    measureInstanceViewportBox(instance, {transformPagePoint}) {\n      return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPagePoint));\n    }\n    build(renderState, latestValues, props) {\n      buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    }\n  }\n  const {schedule:microtask} = createRenderBatcher(queueMicrotask, !1), compareByDepth = (a, b) => a.depth - b.depth;\n  class FlatTree {\n    constructor() {\n      this.children = [];\n      this.isDirty = !1;\n    }\n    add(child) {\n      addUniqueItem(this.children, child);\n      this.isDirty = !0;\n    }\n    remove(child) {\n      removeItem(this.children, child);\n      this.isDirty = !0;\n    }\n    forEach(callback) {\n      this.isDirty && this.children.sort(compareByDepth);\n      this.isDirty = !1;\n      this.children.forEach(callback);\n    }\n  }\n  const borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"], numBorders = borders.length, asNumber = value => \"string\" === typeof value ? parseFloat(value) : value, easeCrossfadeIn = compress(0, 0.5, circOut), easeCrossfadeOut = compress(0.5, 0.95, motionUtils.noop), xKeys = [\"x\", \"scaleX\", \"originX\"], yKeys = [\"y\", \"scaleY\", \"originY\"];\n  class NodeStack {\n    constructor() {\n      this.members = [];\n    }\n    add(node) {\n      addUniqueItem(this.members, node);\n      node.scheduleRender();\n    }\n    remove(node) {\n      removeItem(this.members, node);\n      node === this.prevLead && (this.prevLead = void 0);\n      node === this.lead && (node = this.members[this.members.length - 1]) && this.promote(node);\n    }\n    relegate(node) {\n      var indexOfNode = this.members.findIndex(member => node === member);\n      if (0 === indexOfNode) {\n        return !1;\n      }\n      let prevLead;\n      for (; 0 <= indexOfNode; indexOfNode--) {\n        const member = this.members[indexOfNode];\n        if (!1 !== member.isPresent) {\n          prevLead = member;\n          break;\n        }\n      }\n      return prevLead ? (this.promote(prevLead), !0) : !1;\n    }\n    promote(node, preserveFollowOpacity) {\n      const prevLead = this.lead;\n      node !== prevLead && (this.prevLead = prevLead, this.lead = node, node.show(), prevLead && (prevLead.instance && prevLead.scheduleRender(), node.scheduleRender(), node.resumeFrom = prevLead, preserveFollowOpacity && (node.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node.snapshot = prevLead.snapshot, node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node.root && node.root.isUpdating && (node.isLayoutDirty = !0), {crossfade:node} = node.options, !1 === \n      node && prevLead.hide()));\n    }\n    exitAnimationComplete() {\n      this.members.forEach(node => {\n        const {options, resumingFrom} = node;\n        options.onExitComplete && options.onExitComplete();\n        resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();\n      });\n    }\n    scheduleRender() {\n      this.members.forEach(node => {\n        node.instance && node.scheduleRender(!1);\n      });\n    }\n    removeLeadSnapshot() {\n      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);\n    }\n  }\n  const globalProjectionState = {hasAnimatedSinceResize:!0, hasEverUpdated:!1}, transformAxes = [\"\", \"X\", \"Y\", \"Z\"], hiddenVisibility = {visibility:\"hidden\"};\n  let id = 0;\n  const defaultLayoutTransition = {duration:0.45, ease:[0.4, 0, 0.1, 1]}, userAgentContains = string => \"undefined\" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\") ? Math.round : motionUtils.noop, DocumentProjectionNode = createProjectionNode$1({attachResizeListener:(ref, notify) => addDomEvent(ref, \"resize\", notify), measureScroll:() => ({x:document.documentElement.scrollLeft || \n  document.body.scrollLeft, y:document.documentElement.scrollTop || document.body.scrollTop}), checkIsScrollRoot:() => !0}), rootProjectionNode = {current:void 0}, HTMLProjectionNode = createProjectionNode$1({measureScroll:instance => ({x:instance.scrollLeft, y:instance.scrollTop}), defaultParent:() => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode({});\n      documentNode.mount(window);\n      documentNode.setOptions({layoutScroll:!0});\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  }, resetTransform:(instance, value) => {\n    instance.style.transform = void 0 !== value ? value : \"none\";\n  }, checkIsScrollRoot:instance => \"fixed\" === window.getComputedStyle(instance).position}), correctBorderRadius = {correct:(latest, node) => {\n    if (!node.target) {\n      return latest;\n    }\n    if (\"string\" === typeof latest) {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    latest = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${latest}%`;\n  }}, LazyContext = React.createContext({strict:!1});\n  class PanSession {\n    constructor(event, handlers, {transformPagePoint, dragSnapToOrigin = !1} = {}) {\n      this.lastMoveEventInfo = this.lastMoveEvent = this.startEvent = null;\n      this.handlers = {};\n      this.updatePoint = () => {\n        if (this.lastMoveEvent && this.lastMoveEventInfo) {\n          var info = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = null !== this.startEvent, isDistancePastThreshold = 3 <= distance2D(info.offset, {x:0, y:0});\n          if (isPanStarted || isDistancePastThreshold) {\n            ({point:isDistancePastThreshold} = info);\n            var {timestamp} = frameData;\n            this.history.push({...isDistancePastThreshold, timestamp});\n            var {onStart, onMove} = this.handlers;\n            isPanStarted || (onStart && onStart(this.lastMoveEvent, info), this.startEvent = this.lastMoveEvent);\n            onMove && onMove(this.lastMoveEvent, info);\n          }\n        }\n      };\n      this.handlePointerMove = (event, info) => {\n        if (event.target instanceof Element && event.target.hasPointerCapture && void 0 !== event.pointerId) {\n          try {\n            if (!event.target.hasPointerCapture(event.pointerId)) {\n              return;\n            }\n          } catch (e) {\n          }\n        }\n        this.lastMoveEvent = event;\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n        frame.update(this.updatePoint, !0);\n      };\n      this.handlePointerUp = (event, info) => {\n        motionDom.capturePointer(event, \"release\");\n        this.end();\n        const {onEnd, onSessionEnd, resumeAnimation} = this.handlers;\n        this.dragSnapToOrigin && resumeAnimation && resumeAnimation();\n        this.lastMoveEvent && this.lastMoveEventInfo && (info = getPanInfo(\"pointercancel\" === event.type || \"lostpointercapture\" === event.type ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history), this.startEvent && onEnd && onEnd(event, info), onSessionEnd && onSessionEnd(event, info));\n      };\n      if (motionDom.isPrimaryPointer(event)) {\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        transformPagePoint = extractEventInfo(event);\n        transformPagePoint = transformPoint(transformPagePoint, this.transformPagePoint);\n        ({point:dragSnapToOrigin} = transformPagePoint);\n        var {timestamp} = frameData;\n        this.history = [{...dragSnapToOrigin, timestamp}];\n        ({onSessionStart:handlers} = handlers);\n        handlers && handlers(event, getPanInfo(transformPagePoint, this.history));\n        motionDom.capturePointer(event, \"set\");\n        this.removeListeners = [addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", this.handlePointerUp)].reduce(combineFunctions);\n      }\n    }\n    updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n    end() {\n      this.removeListeners && this.removeListeners();\n      cancelFrame(this.updatePoint);\n    }\n  }\n  const elementDragControls = new WeakMap();\n  class VisualElementDragControls {\n    constructor(visualElement) {\n      this.openDragLock = null;\n      this.isDragging = !1;\n      this.currentDirection = null;\n      this.originPoint = {x:0, y:0};\n      this.hasMutatedConstraints = this.constraints = !1;\n      this.elastic = createBox();\n      this.visualElement = visualElement;\n    }\n    start(originEvent, {snapToCursor = !1} = {}) {\n      var {presenceContext} = this.visualElement;\n      presenceContext && !1 === presenceContext.isPresent || ({dragSnapToOrigin:presenceContext} = this.getProps(), this.panSession = new PanSession(originEvent, {onSessionStart:event => {\n        const {dragSnapToOrigin} = this.getProps();\n        dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n        snapToCursor && this.snapToCursor(extractEventInfo(event).point);\n      }, onStart:(event, info) => {\n        const {drag, dragPropagation, onDragStart} = this.getProps();\n        if (drag && !dragPropagation && (this.openDragLock && this.openDragLock(), this.openDragLock = motionDom.setDragLock(drag), !this.openDragLock)) {\n          return;\n        }\n        this.isDragging = !0;\n        this.currentDirection = null;\n        this.resolveConstraints();\n        this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0);\n        eachAxis(axis => {\n          let current = this.getAxisMotionValue(axis).get() || 0;\n          if (percent.test(current)) {\n            var {projection} = this.visualElement;\n            projection && projection.layout && (projection = projection.layout.layoutBox[axis]) && (current = calcLength(projection) * (parseFloat(current) / 100));\n          }\n          this.originPoint[axis] = current;\n        });\n        onDragStart && frame.postRender(() => onDragStart(event, info));\n        addValueToWillChange(this.visualElement, \"transform\");\n        const {animationState} = this.visualElement;\n        animationState && animationState.setActive(\"whileDrag\", !0);\n      }, onMove:(event, info) => {\n        const {dragPropagation, dragDirectionLock, onDirectionLock, onDrag} = this.getProps();\n        if (dragPropagation || this.openDragLock) {\n          var {offset} = info;\n          dragDirectionLock && null === this.currentDirection ? (this.currentDirection = getCurrentDirection(offset), null !== this.currentDirection && onDirectionLock && onDirectionLock(this.currentDirection)) : (this.updateAxis(\"x\", info.point, offset), this.updateAxis(\"y\", info.point, offset), this.visualElement.render(), onDrag && onDrag(event, info));\n        }\n      }, onSessionEnd:(event, info) => this.stop(event, info), resumeAnimation:() => eachAxis(axis => {\n        var _a;\n        return \"paused\" === this.getAnimationState(axis) && (null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.play());\n      })}, {transformPagePoint:this.visualElement.getTransformPagePoint(), dragSnapToOrigin:presenceContext}));\n    }\n    stop(event, info) {\n      var isDragging = this.isDragging;\n      this.cancel();\n      if (isDragging) {\n        ({velocity:isDragging} = info);\n        this.startAnimation(isDragging);\n        var {onDragEnd} = this.getProps();\n        onDragEnd && frame.postRender(() => onDragEnd(event, info));\n      }\n    }\n    cancel() {\n      this.isDragging = !1;\n      const {projection, animationState} = this.visualElement;\n      projection && (projection.isAnimationBlocked = !1);\n      this.panSession && this.panSession.end();\n      this.panSession = void 0;\n      const {dragPropagation} = this.getProps();\n      !dragPropagation && this.openDragLock && (this.openDragLock(), this.openDragLock = null);\n      animationState && animationState.setActive(\"whileDrag\", !1);\n    }\n    updateAxis(axis, _point, offset) {\n      ({drag:_point} = this.getProps());\n      offset && shouldDrag(axis, _point, this.currentDirection) && (_point = this.getAxisMotionValue(axis), offset = this.originPoint[axis] + offset[axis], this.constraints && this.constraints[axis] && (offset = applyConstraints(offset, this.constraints[axis], this.elastic[axis])), _point.set(offset));\n    }\n    resolveConstraints() {\n      var _a;\n      const {dragConstraints, dragElastic} = this.getProps(), layout$jscomp$0 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (_a = this.visualElement.projection) || void 0 === _a ? void 0 : _a.layout;\n      _a = this.constraints;\n      dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = dragConstraints && layout$jscomp$0 ? calcRelativeConstraints(layout$jscomp$0.layoutBox, dragConstraints) : !1;\n      this.elastic = resolveDragElastic(dragElastic);\n      _a !== this.constraints && layout$jscomp$0 && this.constraints && !this.hasMutatedConstraints && eachAxis(axis => {\n        if (!1 !== this.constraints && this.getAxisMotionValue(axis)) {\n          var JSCompiler_temp_const = this.constraints, layout = layout$jscomp$0.layoutBox[axis], constraints = this.constraints[axis];\n          const relativeConstraints = {};\n          void 0 !== constraints.min && (relativeConstraints.min = constraints.min - layout.min);\n          void 0 !== constraints.max && (relativeConstraints.max = constraints.max - layout.min);\n          JSCompiler_temp_const[axis] = relativeConstraints;\n        }\n      });\n    }\n    resolveRefConstraints() {\n      const {dragConstraints:constraints, onMeasureDragConstraints} = this.getProps();\n      if (!constraints || !isRefObject(constraints)) {\n        return !1;\n      }\n      var constraintsElement = constraints.current;\n      motionUtils.invariant(null !== constraintsElement, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n      var {projection} = this.visualElement;\n      if (!projection || !projection.layout) {\n        return !1;\n      }\n      var rootProjectionNode = projection.root, transformPagePoint = this.visualElement.getTransformPagePoint();\n      constraintsElement = convertBoundingBoxToBox(transformBoxPoints(constraintsElement.getBoundingClientRect(), transformPagePoint));\n      ({scroll:rootProjectionNode} = rootProjectionNode);\n      rootProjectionNode && (translateAxis(constraintsElement.x, rootProjectionNode.offset.x), translateAxis(constraintsElement.y, rootProjectionNode.offset.y));\n      projection = projection.layout.layoutBox;\n      projection = {x:calcViewportAxisConstraints(projection.x, constraintsElement.x), y:calcViewportAxisConstraints(projection.y, constraintsElement.y)};\n      onMeasureDragConstraints && (rootProjectionNode = onMeasureDragConstraints(convertBoxToBoundingBox(projection)), this.hasMutatedConstraints = !!rootProjectionNode, rootProjectionNode && (projection = convertBoundingBoxToBox(rootProjectionNode)));\n      return projection;\n    }\n    startAnimation(velocity) {\n      const {drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd} = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis(axis => {\n        if (shouldDrag(axis, drag, this.currentDirection)) {\n          var transition = constraints && constraints[axis] || {};\n          dragSnapToOrigin && (transition = {min:0, max:0});\n          return this.startAxisValueAnimation(axis, {type:\"inertia\", velocity:dragMomentum ? velocity[axis] : 0, bounceStiffness:dragElastic ? 200 : 1000000, bounceDamping:dragElastic ? 40 : 10000000, timeConstant:750, restDelta:1, restSpeed:10, ...dragTransition, ...transition});\n        }\n      });\n      return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n      const axisValue = this.getAxisMotionValue(axis);\n      addValueToWillChange(this.visualElement, axis);\n      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));\n    }\n    stopAnimation() {\n      eachAxis(axis => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n      eachAxis(axis => {\n        var _a;\n        return null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.pause();\n      });\n    }\n    getAnimationState(axis) {\n      var _a;\n      return null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.state;\n    }\n    getAxisMotionValue(axis) {\n      var dragKey = `_drag${axis.toUpperCase()}`;\n      const props = this.visualElement.getProps();\n      return (dragKey = props[dragKey]) ? dragKey : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);\n    }\n    snapToCursor(point) {\n      eachAxis(axis => {\n        var {drag} = this.getProps();\n        if (shouldDrag(axis, drag, this.currentDirection)) {\n          ({projection:drag} = this.visualElement);\n          var axisValue = this.getAxisMotionValue(axis);\n          if (drag && drag.layout) {\n            const {min, max} = drag.layout.layoutBox[axis];\n            axisValue.set(point[axis] - (min + 0.5 * (max - min)));\n          }\n        }\n      });\n    }\n    scalePositionWithinConstraints() {\n      if (this.visualElement.current) {\n        var {drag, dragConstraints} = this.getProps(), {projection} = this.visualElement;\n        if (isRefObject(dragConstraints) && projection && this.constraints) {\n          this.stopAnimation();\n          var boxProgress = {x:0, y:0};\n          eachAxis(axis => {\n            var axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && !1 !== this.constraints) {\n              axisValue = axisValue.get();\n              axisValue = {min:axisValue, max:axisValue};\n              var target = this.constraints[axis];\n              let origin = 0.5;\n              const sourceLength = calcLength(axisValue), targetLength = calcLength(target);\n              targetLength > sourceLength ? origin = motionUtils.progress(target.min, target.max - sourceLength, axisValue.min) : sourceLength > targetLength && (origin = motionUtils.progress(axisValue.min, axisValue.max - targetLength, target.min));\n              boxProgress[axis] = 1 < origin ? 1 : 0 > origin ? 0 : origin;\n            }\n          });\n          var {transformTemplate} = this.visualElement.getProps();\n          this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          projection.root && projection.root.updateScroll();\n          projection.updateLayout();\n          this.resolveConstraints();\n          eachAxis(axis => {\n            if (shouldDrag(axis, drag, null)) {\n              var axisValue = this.getAxisMotionValue(axis), {min, max} = this.constraints[axis];\n              axisValue.set(min + (max - min) * boxProgress[axis]);\n            }\n          });\n        }\n      }\n    }\n    addListeners() {\n      if (this.visualElement.current) {\n        elementDragControls.set(this.visualElement, this);\n        var stopPointerListener = addPointerEvent(this.visualElement.current, \"pointerdown\", event => {\n          const {drag, dragListener = !0} = this.getProps();\n          drag && dragListener && this.start(event);\n        }), measureDragConstraints = () => {\n          const {dragConstraints} = this.getProps();\n          isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());\n        }, {projection} = this.visualElement, stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout());\n        frame.read(measureDragConstraints);\n        var stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({delta, hasLayoutChanged}) => {\n          this.isDragging && hasLayoutChanged && (eachAxis(axis => {\n            const motionValue = this.getAxisMotionValue(axis);\n            motionValue && (this.originPoint[axis] += delta[axis].translate, motionValue.set(motionValue.get() + delta[axis].translate));\n          }), this.visualElement.render());\n        });\n        return () => {\n          stopResizeListener();\n          stopPointerListener();\n          stopMeasureLayoutListener();\n          stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n      }\n    }\n    getProps() {\n      const props = this.visualElement.getProps(), {drag = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = 0.35, dragMomentum = !0} = props;\n      return {...props, drag, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum};\n    }\n  }\n  class DragGesture extends Feature {\n    constructor(node) {\n      super(node);\n      this.removeListeners = this.removeGroupControls = motionUtils.noop;\n      this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n      const {dragControls} = this.node.getProps();\n      dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls));\n      this.removeListeners = this.controls.addListeners() || motionUtils.noop;\n    }\n    unmount() {\n      this.removeGroupControls();\n      this.removeListeners();\n    }\n  }\n  const asyncHandler = handler => (event, info) => {\n    handler && frame.postRender(() => handler(event, info));\n  };\n  class PanGesture extends Feature {\n    constructor() {\n      super(...arguments);\n      this.removePointerDownListener = motionUtils.noop;\n    }\n    onPointerDown(pointerDownEvent) {\n      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {transformPagePoint:this.node.getTransformPagePoint()});\n    }\n    createPanHandlers() {\n      const {onPanSessionStart, onPanStart, onPan, onPanEnd} = this.node.getProps();\n      return {onSessionStart:asyncHandler(onPanSessionStart), onStart:asyncHandler(onPanStart), onMove:onPan, onEnd:(event, info) => {\n        delete this.session;\n        onPanEnd && frame.postRender(() => onPanEnd(event, info));\n      }};\n    }\n    mount() {\n      this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", event => this.onPointerDown(event));\n    }\n    update() {\n      this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n      this.removePointerDownListener();\n      this.session && this.session.end();\n    }\n  }\n  const SwitchLayoutGroupContext = React.createContext({});\n  class MeasureLayoutWithContext extends React.Component {\n    componentDidMount() {\n      const {visualElement, layoutGroup, switchLayoutGroup, layoutId} = this.props, {projection} = visualElement;\n      addScaleCorrector(defaultScaleCorrectors);\n      projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      }), projection.setOptions({...projection.options, onExitComplete:() => this.safeToRemove()}));\n      globalProjectionState.hasEverUpdated = !0;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n      const {layoutDependency, visualElement, drag, isPresent} = this.props, projection = visualElement.projection;\n      if (!projection) {\n        return null;\n      }\n      projection.isPresent = isPresent;\n      drag || prevProps.layoutDependency !== layoutDependency || void 0 === layoutDependency ? projection.willUpdate() : this.safeToRemove();\n      prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {\n        const stack = projection.getStack();\n        stack && stack.members.length || this.safeToRemove();\n      }));\n      return null;\n    }\n    componentDidUpdate() {\n      const {projection} = this.props.visualElement;\n      projection && (projection.root.didUpdate(), microtask.postRender(() => {\n        !projection.currentAnimation && projection.isLead() && this.safeToRemove();\n      }));\n    }\n    componentWillUnmount() {\n      const {visualElement, layoutGroup, switchLayoutGroup:promoteContext} = this.props, {projection} = visualElement;\n      projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));\n    }\n    safeToRemove() {\n      const {safeToRemove} = this.props;\n      safeToRemove && safeToRemove();\n    }\n    render() {\n      return null;\n    }\n  }\n  const defaultScaleCorrectors = {borderRadius:{...correctBorderRadius, applyTo:[\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]}, borderTopLeftRadius:correctBorderRadius, borderTopRightRadius:correctBorderRadius, borderBottomLeftRadius:correctBorderRadius, borderBottomRightRadius:correctBorderRadius, boxShadow:{correct:(latest, {treeScale, projectionDelta}) => {\n    const shadow = complex.parse(latest);\n    if (5 < shadow.length) {\n      return latest;\n    }\n    latest = complex.createTransformer(latest);\n    const offset = \"number\" !== typeof shadow[0] ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x;\n    treeScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= treeScale;\n    treeScale = xScale + 0.5 * (treeScale - xScale);\n    \"number\" === typeof shadow[2 + offset] && (shadow[2 + offset] /= treeScale);\n    \"number\" === typeof shadow[3 + offset] && (shadow[3 + offset] /= treeScale);\n    return latest(shadow);\n  }}}, drag = {pan:{Feature:PanGesture}, drag:{Feature:DragGesture, ProjectionNode:HTMLProjectionNode, MeasureLayout}};\n  class HoverGesture extends Feature {\n    mount() {\n      const {current} = this.node;\n      current && (this.unmount = motionDom.hover(current, (_element, startEvent) => {\n        handleHoverEvent(this.node, startEvent, \"Start\");\n        return endEvent => handleHoverEvent(this.node, endEvent, \"End\");\n      }));\n    }\n    unmount() {\n    }\n  }\n  class FocusGesture extends Feature {\n    constructor() {\n      super(...arguments);\n      this.isActive = !1;\n    }\n    onFocus() {\n      let isFocusVisible = !1;\n      try {\n        isFocusVisible = this.node.current.matches(\":focus-visible\");\n      } catch (e) {\n        isFocusVisible = !0;\n      }\n      isFocusVisible && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !0), this.isActive = !0);\n    }\n    onBlur() {\n      this.isActive && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !1), this.isActive = !1);\n    }\n    mount() {\n      this.unmount = [addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur())].reduce(combineFunctions);\n    }\n    unmount() {\n    }\n  }\n  class PressGesture extends Feature {\n    mount() {\n      const {current} = this.node;\n      current && (this.unmount = motionDom.press(current, (_element, startEvent) => {\n        handlePressEvent(this.node, startEvent, \"Start\");\n        return (endEvent, {success}) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n      }, {useGlobalTarget:this.node.props.globalTapTarget}));\n    }\n    unmount() {\n    }\n  }\n  const observerCallbacks = new WeakMap(), observers = new WeakMap(), fireObserverCallback = entry => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n  }, fireAllObserverCallbacks = entries => {\n    entries.forEach(fireObserverCallback);\n  }, thresholdNames = {some:0, all:1};\n  class InViewFeature extends Feature {\n    constructor() {\n      super(...arguments);\n      this.isInView = this.hasEnteredView = !1;\n    }\n    startObserver() {\n      this.unmount();\n      const {viewport = {}} = this.node.getProps(), {root, margin:rootMargin, amount = \"some\", once} = viewport;\n      return observeIntersection(this.node.current, {root:root ? root.current : void 0, rootMargin, threshold:\"number\" === typeof amount ? amount : thresholdNames[amount]}, entry => {\n        var {isIntersecting} = entry;\n        if (this.isInView !== isIntersecting && (this.isInView = isIntersecting, !once || isIntersecting || !this.hasEnteredView)) {\n          isIntersecting && (this.hasEnteredView = !0);\n          this.node.animationState && this.node.animationState.setActive(\"whileInView\", isIntersecting);\n          var {onViewportEnter, onViewportLeave} = this.node.getProps();\n          (isIntersecting = isIntersecting ? onViewportEnter : onViewportLeave) && isIntersecting(entry);\n        }\n      });\n    }\n    mount() {\n      this.startObserver();\n    }\n    update() {\n      if (\"undefined\" !== typeof IntersectionObserver) {\n        var {props, prevProps} = this.node;\n        [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();\n      }\n    }\n    unmount() {\n    }\n  }\n  const gestureAnimations = {inView:{Feature:InViewFeature}, tap:{Feature:PressGesture}, focus:{Feature:FocusGesture}, hover:{Feature:HoverGesture}}, layout = {layout:{ProjectionNode:HTMLProjectionNode, MeasureLayout}}, motionComponentSymbol = Symbol.for(\"motionComponentSymbol\"), createHtmlRenderState = () => ({style:{}, transform:{}, transformOrigin:{}, vars:{}}), lowercaseSVGElements = \"animate circle defs desc ellipse g image line filter marker mask metadata path pattern polygon polyline rect stop switch symbol svg text tspan use view\".split(\" \"), \n  createSvgRenderState = () => ({...createHtmlRenderState(), attrs:{}}), htmlMotionConfig = {useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1, createRenderState:createHtmlRenderState})}, layoutProps = \"x y width height cx cy r\".split(\" \"), svgMotionConfig = {useVisualState:makeUseVisualState({scrapeMotionValuesFromProps, createRenderState:createSvgRenderState, onUpdate:({props, prevProps, current, renderState, latestValues}) => {\n    if (current) {\n      var hasTransform = !!props.drag;\n      if (!hasTransform) {\n        for (var key$jscomp$0 in latestValues) {\n          if (transformProps.has(key$jscomp$0)) {\n            hasTransform = !0;\n            break;\n          }\n        }\n      }\n      if (hasTransform) {\n        hasTransform = !prevProps;\n        if (prevProps) {\n          for (key$jscomp$0 = 0; key$jscomp$0 < layoutProps.length; key$jscomp$0++) {\n            const key = layoutProps[key$jscomp$0];\n            props[key] !== prevProps[key] && (hasTransform = !0);\n          }\n        }\n        hasTransform && frame.read(() => {\n          updateSVGDimensions(current, renderState);\n          frame.render(() => {\n            buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\n            renderSVG(current, renderState);\n          });\n        });\n      }\n    }\n  }})}, createDomVisualElement = (Component, options) => isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {allowProjection:Component !== React.Fragment}), createMotionComponent = createMotionComponentFactory({...animations, ...gestureAnimations, ...drag, ...layout}, createDomVisualElement);\n  exports.AcceleratedAnimation = AcceleratedAnimation;\n  exports.FlatTree = FlatTree;\n  exports.HTMLVisualElement = HTMLVisualElement;\n  exports.LayoutGroupContext = LayoutGroupContext;\n  exports.LazyContext = LazyContext;\n  exports.MotionConfigContext = MotionConfigContext;\n  exports.MotionContext = MotionContext;\n  exports.MotionGlobalConfig = MotionGlobalConfig;\n  exports.MotionValue = MotionValue;\n  exports.PresenceContext = PresenceContext;\n  exports.SVGVisualElement = SVGVisualElement;\n  exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\n  exports.VisualElement = VisualElement;\n  exports.acceleratedValues = acceleratedValues;\n  exports.addDomEvent = addDomEvent;\n  exports.addPointerEvent = addPointerEvent;\n  exports.addPointerInfo = addPointerInfo;\n  exports.addScaleCorrector = addScaleCorrector;\n  exports.addUniqueItem = addUniqueItem;\n  exports.animateSingleValue = animateSingleValue;\n  exports.animateTarget = animateTarget;\n  exports.animateValue = function(options) {\n    return new MainThreadAnimation(options);\n  };\n  exports.animateVisualElement = animateVisualElement;\n  exports.animations = animations;\n  exports.anticipate = anticipate;\n  exports.backIn = backIn;\n  exports.backInOut = backInOut;\n  exports.backOut = backOut;\n  exports.browserNumberValueTypes = browserNumberValueTypes;\n  exports.buildTransform = buildTransform;\n  exports.calcLength = calcLength;\n  exports.camelToDash = camelToDash;\n  exports.cancelFrame = cancelFrame;\n  exports.circIn = circIn;\n  exports.circInOut = circInOut;\n  exports.circOut = circOut;\n  exports.clamp = clamp;\n  exports.collectMotionValues = collectMotionValues;\n  exports.color = color;\n  exports.complex = complex;\n  exports.createBox = createBox;\n  exports.createDomVisualElement = createDomVisualElement;\n  exports.createMotionComponent = createMotionComponent;\n  exports.createMotionComponentFactory = createMotionComponentFactory;\n  exports.createRendererMotionComponent = createRendererMotionComponent;\n  exports.cubicBezier = cubicBezier;\n  exports.defaultOffset = defaultOffset;\n  exports.delay = delay;\n  exports.distance = (a, b) => Math.abs(a - b);\n  exports.distance2D = distance2D;\n  exports.drag = drag;\n  exports.easeIn = easeIn;\n  exports.easeInOut = easeInOut;\n  exports.easeOut = easeOut;\n  exports.easingDefinitionToFunction = easingDefinitionToFunction;\n  exports.fillOffset = fillOffset;\n  exports.filterProps = filterProps;\n  exports.findSpring = findSpring;\n  exports.frame = frame;\n  exports.frameData = frameData;\n  exports.frameSteps = frameSteps;\n  exports.gestureAnimations = gestureAnimations;\n  exports.getFinalKeyframe = getFinalKeyframe;\n  exports.getOptimisedAppearId = getOptimisedAppearId;\n  exports.hasReducedMotionListener = hasReducedMotionListener;\n  exports.inertia = inertia;\n  exports.initPrefersReducedMotion = initPrefersReducedMotion;\n  exports.instantAnimationState = instantAnimationState;\n  exports.interpolate = interpolate;\n  exports.isBrowser = isBrowser;\n  exports.isEasingArray = isEasingArray;\n  exports.isMotionValue = isMotionValue;\n  exports.isSVGElement = isSVGElement;\n  exports.isValidMotionProp = isValidMotionProp;\n  exports.keyframes = keyframes;\n  exports.layout = layout;\n  exports.loadExternalIsValidProp = loadExternalIsValidProp;\n  exports.loadFeatures = loadFeatures;\n  exports.makeUseVisualState = makeUseVisualState;\n  exports.mirrorEasing = mirrorEasing;\n  exports.mix = mix;\n  exports.mixNumber = mixNumber$1;\n  exports.motionComponentSymbol = motionComponentSymbol;\n  exports.motionValue = motionValue;\n  exports.moveItem = function([...arr], fromIndex, toIndex) {\n    const startIndex = 0 > fromIndex ? arr.length + fromIndex : fromIndex;\n    0 <= startIndex && startIndex < arr.length && (toIndex = 0 > toIndex ? arr.length + toIndex : toIndex, [fromIndex] = arr.splice(fromIndex, 1), arr.splice(toIndex, 0, fromIndex));\n    return arr;\n  };\n  exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\n  exports.optimizedAppearDataId = \"framerAppearId\";\n  exports.pipe = (...transformers) => transformers.reduce(combineFunctions);\n  exports.prefersReducedMotion = prefersReducedMotion;\n  exports.px = px;\n  exports.removeItem = removeItem;\n  exports.resolveMotionValue = resolveMotionValue;\n  exports.reverseEasing = reverseEasing;\n  exports.rootProjectionNode = rootProjectionNode;\n  exports.setTarget = setTarget;\n  exports.spring = spring;\n  exports.startWaapiAnimation = startWaapiAnimation;\n  exports.stepsOrder = stepsOrder;\n  exports.supportsWaapi = supportsWaapi;\n  exports.time = time;\n  exports.transformProps = transformProps;\n  exports.useConstant = useConstant;\n  exports.useIsPresent = function() {\n    var context = React.useContext(PresenceContext);\n    return null === context ? !0 : context.isPresent;\n  };\n  exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\n  exports.usePresence = usePresence;\n  exports.velocityPerSecond = velocityPerSecond;\n  exports.visualElementStore = visualElementStore;\n  exports.warnOnce = warnOnce;\n};\n","~:source","shadow$provide[\"module$node_modules$framer_motion$dist$cjs$create_CGKJurkh\"] = function(global,require,module,exports) {\n'use strict';\n\nvar motionDom = require('motion-dom');\nvar motionUtils = require('motion-utils');\nvar jsxRuntime = require('react/jsx-runtime');\nvar React = require('react');\n\nconst LayoutGroupContext = React.createContext({});\n\nfunction isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nfunction getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\nconst MotionGlobalConfig = {\n    skipAnimations: false,\n    useManualTiming: false,\n};\n\nconst stepsOrder = [\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\n\nconst statsBuffer = {\n    value: null,\n    addProjectionMetrics: null,\n};\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        if (!MotionGlobalConfig.useManualTiming) {\n            state.delta = useDefaultElapsed\n                ? 1000 / 60\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        }\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : motionUtils.noop, true);\n\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    ...transformPropOrder,\n]);\n\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = \"12.4.7\";\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            const currentTime = time.now();\n            /**\n             * If we're updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */\n            if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(parseFloat(this.current) -\n            parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue(\"willChange\");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can't add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n}\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\nconst instantAnimationState = {\n    current: false,\n};\n\n/*\n  Bezier function generator\n  This has been modified from Gatan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return motionUtils.noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\nconst clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nconst floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nfunction isNullish(v) {\n    return v == null;\n}\n\nconst singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\nconst colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone: getAnimatableNone$1,\n};\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\nconst browserNumberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n};\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nconst numberValueTypes = {\n    ...browserNumberValueTypes,\n    ...transformValueTypes,\n    zIndex: int,\n    size: px,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n/**\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\n */\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\nconst checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === \"display\" || name === \"visibility\")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === \"spring\" || motionDom.isGenerator(type)) && velocity));\n}\n\nconst isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber$1 = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nfunction mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nconst invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber$1(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nconst springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = motionUtils.secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -motionUtils.millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? motionUtils.secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(motionDom.calcGeneratorDuration(generator), motionDom.maxGeneratorDuration);\n            const easing = motionDom.generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nconst easingLookup = {\n    linear: motionUtils.noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (motionDom.isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    motionUtils.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = motionUtils.progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = motionUtils.progress(0, remaining, i);\n        offset.push(mixNumber$1(min, 1, offsetProgress));\n    }\n}\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we've already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = motionDom.isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            motionUtils.invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = motionDom.calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? motionUtils.millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return motionUtils.millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = motionUtils.secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = motionUtils.millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = motionDom.mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    const animation = element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n    return animation;\n}\n\nconst supportsWaapi = /*@__PURE__*/ motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (motionDom.isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !motionDom.isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            motionDom.supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            motionDom.attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return motionUtils.millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return motionUtils.millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = motionUtils.secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return motionUtils.noop;\n            const { animation } = resolved;\n            motionDom.attachTimeline(animation, timeline);\n        }\n        return motionUtils.noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = motionUtils.secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = motionDom.getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - motionUtils.secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = motionUtils.secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new motionDom.GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...motionDom.getValueTransition(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\n\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\n                    ? props.initial[0]\n                    : props.initial);\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition;\n                }\n            }\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nclass Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        var _a;\n        this.node.animationState.reset();\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n\nlet id$1 = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id$1++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => {\n                onExitComplete(this.id);\n            });\n        }\n    }\n    mount() {\n        const { register, onExitComplete } = this.node.presenceContext || {};\n        if (onExitComplete) {\n            onExitComplete(this.id);\n        }\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\nconst MotionContext = /* @__PURE__ */ React.createContext({});\n\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\n/**\n * @public\n */\nconst PresenceContext = \n/* @__PURE__ */ React.createContext(null);\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onUpdate) {\n        /**\n         * onMount works without the VisualElement because it could be\n         * called before the VisualElement payload has been hydrated.\n         * (e.g. if someone is using m components <m.circle />)\n         */\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = React.useContext(MotionContext);\n    const presenceContext = React.useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\nconst isBrowser = typeof window !== \"undefined\";\n\nconst useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\n/**\n * @public\n */\nconst MotionConfigContext = React.createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = React.useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = React.useId();\n    React.useEffect(() => {\n        if (subscribe) {\n            return register(id);\n        }\n    }, [subscribe]);\n    const safeToRemove = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\nconst visualElementStore = new WeakMap();\n\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"12.4.7\", `Attempting to mix Motion versions ${nextValue.version} with 12.4.7 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState, onUpdate } = visualState;\n        this.onUpdate = onUpdate;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n        this.onUpdate && this.onUpdate(this);\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        var _a;\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nconst isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nfunction updateSVGDimensions(instance, renderState) {\n    try {\n        renderState.dimensions =\n            typeof instance.getBBox === \"function\"\n                ? instance.getBBox()\n                : instance.getBoundingClientRect();\n    }\n    catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n    }\n}\n\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {\n    var _a;\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n        this.updateDimensions = () => {\n            if (this.current && !this.renderState.dimensions) {\n                updateSVGDimensions(this.current, this.renderState);\n            }\n        };\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    onBindTransform() {\n        if (this.current && !this.renderState.dimensions) {\n            frame.postRender(this.updateDimensions);\n        }\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"html\";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    }\n}\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\n\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\n\nconst compareByDepth = (a, b) => a.depth - b.depth;\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber$1(0, \n        // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, motionUtils.noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(motionUtils.progress(min, max, p));\n    };\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\")\n        return;\n    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nfunction eachAxis(callback) {\n    return [callback(\"x\"), callback(\"y\")];\n}\n\n/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nconst hiddenVisibility = { visibility: \"hidden\" };\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                attachResizeListener(instance, () => {\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const hasTargetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout);\n                    /*\n                     * Note: Disabled to fix relative animations always triggering new\n                     * layout animations. If this causes further issues, we can try\n                     * a different approach to detecting relative target changes.\n                     */\n                    // || hasRelativeLayoutChanged\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n                    if (this.options.layoutRoot ||\n                        this.resumeFrom ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (hasTargetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        const animationOptions = {\n                            ...motionDom.getValueTransition(layoutTransition, \"layout\"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we're running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don't yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll(\"snapshot\");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            this.isUpdating = false;\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n            if (this.snapshot &&\n                !calcLength(this.snapshot.measuredBox.x) &&\n                !calcLength(this.snapshot.measuredBox.y)) {\n                this.snapshot = undefined;\n            }\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = \"measure\") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            var _a;\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            var _a;\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn't up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            var _a;\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don't use transform for this step of processing so we don't\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            var _a;\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can't skip.\n             */\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node's shared projection is dirty then\n             * we can't skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn't have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don't have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            var _a;\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot\n                ? snapshot.latestValues\n                : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners(\"animationStart\");\n            this.currentAnimation && this.currentAnimation.stop();\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n                this.resumingFrom.currentAnimation.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\n                    ...options,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onStop: () => {\n                    },\n                    onComplete: () => {\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we're only animating position, and this element isn't the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        }\n        getPrevLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there's no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don't have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there's no distorting values, we don't need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        getProjectionStyles(styleProp) {\n            var _a, _b;\n            if (!this.instance || this.isSVG)\n                return undefined;\n            if (!this.isVisible) {\n                return hiddenVisibility;\n            }\n            const styles = {\n                visibility: \"\",\n            };\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return styles;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                const emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            const { x, y } = this.projectionDelta;\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : \"\"\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = styles.transform === \"none\"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    // If this is a CSS variable, set it directly on the instance.\n                    // Replacing this function from creating styles to setting them\n                    // would be a good place to remove per frame object creation\n                    if (isCSSVariable) {\n                        this.options.visualElement.renderState.vars[key] = corrected;\n                    }\n                    else {\n                        styles[key] = corrected;\n                    }\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\"\n                        : \"none\";\n            }\n            return styles;\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (animationType === \"size\") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeLayoutChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeLayoutChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeLayoutChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify(\"BeforeLayoutMeasure\");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber$1(delta.translate, 0, p);\n    output.scale = mixNumber$1(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber$1(from.min, to.min, p);\n    output.max = mixNumber$1(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\n    ? Math.round\n    : motionUtils.noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === \"position\" ||\n        (animationType === \"preserve-aspect\" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\n}\n\nconst DocumentProjectionNode = createProjectionNode$1({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode$1({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : \"none\";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\n});\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber$1(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nconst LazyContext = React.createContext({ strict: false });\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\nfunction isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, dragSnapToOrigin = false } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            if (event.target instanceof Element &&\n                event.target.hasPointerCapture &&\n                event.pointerId !== undefined) {\n                try {\n                    if (!event.target.hasPointerCapture(event.pointerId)) {\n                        return;\n                    }\n                }\n                catch (e) { }\n            }\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            motionDom.capturePointer(event, \"release\");\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\" ||\n                event.type === \"lostpointercapture\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!motionDom.isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        motionDom.capturePointer(event, \"set\");\n        this.removeListeners = pipe(addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            motionUtils.secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber$1(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber$1(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = motionUtils.progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = motionUtils.progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nconst elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = motionDom.setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info) => {\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => this.stop(event, info);\n        const resumeAnimation = () => eachAxis((axis) => {\n            var _a;\n            return this.getAnimationState(axis) === \"paused\" &&\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n        });\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        var _a;\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        motionUtils.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\n    }\n    getAnimationState(axis) {\n        var _a;\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = motionUtils.noop;\n        this.removeListeners = motionUtils.noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || motionUtils.noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = motionUtils.noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = React.createContext({});\n\nclass MeasureLayoutWithContext extends React.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = React.useContext(LayoutGroupContext);\n    return (jsxRuntime.jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: React.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onHover\" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = motionDom.hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, \"Start\");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\n        });\n    }\n    unmount() { }\n}\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.current instanceof HTMLButtonElement && node.current.disabled) {\n        return;\n    }\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = motionDom.press(current, (_element, startEvent) => {\n            handlePressEvent(this.node, startEvent, \"Start\");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));\n    return React.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nconst motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = React.useContext(MotionContext);\n    const lazyContext = React.useContext(LazyContext);\n    const presenceContext = React.useContext(PresenceContext);\n    const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = React.useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = React.useRef(false);\n    React.useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = React.useRef(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    React.useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    var _a, _b;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...React.useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsxRuntime.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    MotionComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : \"\"})`}`;\n    const ForwardRefMotionComponent = React.forwardRef(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = React.useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = React.useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? motionUtils.warning(false, strictMessage)\n            : motionUtils.invariant(false, strictMessage);\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nconst createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return React.useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = React.useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\n        const useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        const elementProps = Component !== React.Fragment\n            ? { ...filteredProps, ...visualProps, ref }\n            : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */\n        const { children } = props;\n        const renderedChildren = React.useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n        return React.createElement(Component, {\n            ...elementProps,\n            children: renderedChildren,\n        });\n    };\n    return useRender;\n}\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nconst layoutProps = [\"x\", \"y\", \"width\", \"height\", \"cx\", \"cy\", \"r\"];\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\n            if (!current)\n                return;\n            let hasTransform = !!props.drag;\n            if (!hasTransform) {\n                for (const key in latestValues) {\n                    if (transformProps.has(key)) {\n                        hasTransform = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasTransform)\n                return;\n            let needsMeasure = !prevProps;\n            if (prevProps) {\n                /**\n                 * Check the layout props for changes, if any are found we need to\n                 * measure the element again.\n                 */\n                for (let i = 0; i < layoutProps.length; i++) {\n                    const key = layoutProps[i];\n                    if (props[key] !==\n                        prevProps[key]) {\n                        needsMeasure = true;\n                    }\n                }\n            }\n            if (!needsMeasure)\n                return;\n            frame.read(() => {\n                updateSVGDimensions(current, renderState);\n                frame.render(() => {\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\n                    renderSVG(current, renderState);\n                });\n            });\n        },\n    }),\n};\n\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\n        const baseConfig = isSVGComponent(Component)\n            ? svgMotionConfig\n            : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component,\n        };\n        return createRendererMotionComponent(config);\n    };\n}\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== React.Fragment,\n        });\n};\n\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n}, createDomVisualElement);\n\nexports.AcceleratedAnimation = AcceleratedAnimation;\nexports.FlatTree = FlatTree;\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyContext = LazyContext;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionContext = MotionContext;\nexports.MotionGlobalConfig = MotionGlobalConfig;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\nexports.VisualElement = VisualElement;\nexports.acceleratedValues = acceleratedValues;\nexports.addDomEvent = addDomEvent;\nexports.addPointerEvent = addPointerEvent;\nexports.addPointerInfo = addPointerInfo;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animateSingleValue = animateSingleValue;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.animateVisualElement = animateVisualElement;\nexports.animations = animations;\nexports.anticipate = anticipate;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.browserNumberValueTypes = browserNumberValueTypes;\nexports.buildTransform = buildTransform;\nexports.calcLength = calcLength;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.collectMotionValues = collectMotionValues;\nexports.color = color;\nexports.complex = complex;\nexports.createBox = createBox;\nexports.createDomVisualElement = createDomVisualElement;\nexports.createMotionComponent = createMotionComponent;\nexports.createMotionComponentFactory = createMotionComponentFactory;\nexports.createRendererMotionComponent = createRendererMotionComponent;\nexports.cubicBezier = cubicBezier;\nexports.defaultOffset = defaultOffset;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.drag = drag;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.easingDefinitionToFunction = easingDefinitionToFunction;\nexports.fillOffset = fillOffset;\nexports.filterProps = filterProps;\nexports.findSpring = findSpring;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.frameSteps = frameSteps;\nexports.gestureAnimations = gestureAnimations;\nexports.getFinalKeyframe = getFinalKeyframe;\nexports.getOptimisedAppearId = getOptimisedAppearId;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.inertia = inertia;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isBrowser = isBrowser;\nexports.isEasingArray = isEasingArray;\nexports.isMotionValue = isMotionValue;\nexports.isSVGElement = isSVGElement;\nexports.isValidMotionProp = isValidMotionProp;\nexports.keyframes = keyframes;\nexports.layout = layout;\nexports.loadExternalIsValidProp = loadExternalIsValidProp;\nexports.loadFeatures = loadFeatures;\nexports.makeUseVisualState = makeUseVisualState;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixNumber = mixNumber$1;\nexports.motionComponentSymbol = motionComponentSymbol;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.resolveMotionValue = resolveMotionValue;\nexports.reverseEasing = reverseEasing;\nexports.rootProjectionNode = rootProjectionNode;\nexports.setTarget = setTarget;\nexports.spring = spring;\nexports.startWaapiAnimation = startWaapiAnimation;\nexports.stepsOrder = stepsOrder;\nexports.supportsWaapi = supportsWaapi;\nexports.time = time;\nexports.transformProps = transformProps;\nexports.useConstant = useConstant;\nexports.useIsPresent = useIsPresent;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.usePresence = usePresence;\nexports.velocityPerSecond = velocityPerSecond;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$jsx_runtime","~$module$node_modules$motion_dom$dist$cjs$index","~$module$node_modules$$emotion$is_prop_valid$dist$emotion_is_prop_valid_cjs","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$motion_utils$dist$cjs$index"]],"~:properties",["^5",["dragSnapToOrigin","hasReducedMotionListener","blue","stop","hasAttemptedResolve","resolveMotionValue","originX","stopPassiveEffect","backgroundColor","timeConstant","px","isUpdating","isVariantNode","isStopped","optimizedAppearDataAttribute","z","targetWithTransforms","sharedNodes","isProjectionDirty","frameSteps","repeatType","animateVisualElement","mapPercentToKeyframes","owner","rotateZ","resolver","transformPagePoint","updatedAt","backOut","projectionDelta","buildTransform","isDirty","isActive","easeIn","onSessionStart","marginBottom","measuredOrigin","MotionContext","values","attrs","renderScheduledAt","updateAndNotify","min","easing","visualState","blockInitialAnimation","relativeParent","dragConstraints","width","hasCheckedOptimisedAppear","mirroredGenerator","pathLength","origin","prevProp","right","supportsWaapi","passive","transformProps","dragPropagation","finalKeyframe","LazyContext","defaultParent","next","isDragging","prevTransformTemplateValue","top","relativeTarget","touchAction","removeItem","steps","renderState","prevUpdatedAt","interpolate","cubicBezier","rotateX","stiffness","addDomEvent","WebkitTouchCallout","currentDirection","borderLeftWidth","motionComponentSymbol","cancelFrame","restDelta","driver","circOut","borderBottomColor","offset","updateBlockedByResize","initialPromotionConfig","translate","cancel","correct","layoutCorrected","isComplete","originZ","height","margin","propEventSubscriptions","removePointerDownListener","numOctaves","preserveFollowOpacity","visualElementStore","PresenceContext","scale","layoutScroll","createVisualElement","onUpdate","createTransformer","originY","tabIndex","createdAt","animateSingleValue","totalDuration","rootMargin","updateManuallyBlocked","handlers","members","relativeTargetOrigin","constraints","onStart","optimizedAppearDataId","safeToRemove","useVisualState","animateChanges","createMotionComponent","currentTime","attemptToResolveRelativeTarget","autoplay","stepsOrder","browserNumberValueTypes","reducedMotion","targetLayout","isSVGTag","borderBottomRightRadius","var","ease","inView","isPresent","visualElement","scroll","hasProjected","isStatic","updateDimensions","animateTarget","calculatedDuration","addPointerEvent","suspendedScrollY","isAsync","translateY","isResolvedFromDuration","displayName","resolvedAt","cancelTime","Feature","passiveEffect","pendingTimeline","delta","acceleratedValues","isLayoutDirty","currentFinishedPromise","resumeAnimation","startWaapiAnimation","addPointerInfo","animationValues","playbackSpeed","treeScale","repeat","circIn","textContent","parent","removeListeners","process","prevMotionValues","shouldReduceMotion","whileHover","measureScroll","children","x","isCSSVariable","focus","lead","protectedKeys","resolveFinishedPromise","max","radius","marginTop","path","startEvent","padding","animationProgress","frameData","prevLead","_resolved","liveStyle","isSharedProjectionDirty","mirrorEasing","prevFrameValue","isValidMotionProp","userSelect","inertia","id","latestValues","createRendererMotionComponent","circInOut","baseTarget","openDragLock","timestamp","whileFocus","transform","toString","presenceContext","dragDirectionLock","viewBox","maxHeight","snapshot","reset","root","layoutDelta","skewY","dragMomentum","crossfade","skipAnimations","createRenderState","useIsomorphicLayoutEffect","hasAnimatedSinceResize","types","borderBottomWidth","needsAnimating","distance2D","onExitComplete","pan","updateScheduled","loadFeatures","SVGVisualElement","FlatTree","AcceleratedAnimation","KeyframeResolver","handlePointerMove","borderRightWidth","restSpeed","iterations","alwaysMeasureLayout","gestureAnimations","playbackRate","visibility","valueSubscriptions","updatePoint","originPoint","isInView","whileInView","scaleX","motionValue","times","element","borderWidth","animationId","instantAnimationState","drag","name","onEnd","getState","schedule","layoutRoot","applyTo","animate","stroke","style","opacityExit","mixNumber","warnOnce","checkUpdateFailed","animation","backInOut","useGlobalTarget","needsReset","measuredBox","value","needsMeasurement","prevResolvedValues","dimensions","startTime","backgroundPositionY","camelToDash","isBrowser","elastic","linear","fillOffset","reverseEasing","onPlay","direction","hasEnteredView","childSubscription","initial","onMount","MotionConfigContext","ProjectionNode","targetDelta","resolvedDuration","start","notifyUpdate","prev","useRender","fill","borderBottomLeftRadius","threshold","split","clamp","layout","green","marginLeft","pendingAnimation","borderRadius","minDuration","number","borderLeftColor","whileDrag","VisualElement","distance","pipe","MeasureLayout","current","red","animationState","strokeOpacity","animationType","layoutId","getOptimisedAppearId","updateProjection","filter","bounce","isAnimationBlocked","time","scaleY","eventHandlers","setAnimateFunction","removeFromVariantTree","translateX","transformOrigin","variantChildren","instance","draggable","mixTargetDelta","prevPresenceContext","length","isGenerator","onComplete","events","isEasingArray","borderColor","props","initPrefersReducedMotion","filterProps","nodes","animations","scheduleUpdate","onSessionEnd","switchLayoutGroup","layoutBox","duration","renderInstance","prevProps","delay","forwardMotionProps","history","boxShadow","source","wasRoot","type","layoutGroup","bounceDamping","resumingFrom","render","addProjectionMetrics","projection","attachResizeListener","y","isTransformDirty","addScaleCorrector","makeUseVisualState","minDamping","unresolvedKeyframes","hasMutatedConstraints","animateValue","HTMLVisualElement","outlineColor","state","isVisible","ref","depth","version","zIndex","controls","maxDamping","useConstant","preloadedFeatures","onMove","isProcessing","bounceStiffness","target","scaleZ","perspective","alpha","hasEverUpdated","skewX","defaultOffset","rootProjectionNode","borderTopWidth","unmount","MotionIsMounted","pendingPlayState","parse","exit","Component","easeInOut","decay","resumeFrom","lastMoveEventInfo","tween","hasTreeAnimated","unmountControls","fillOpacity","skew","holdTime","bottom","now","collectMotionValues","set","whileTap","strict","WebkitUserSelect","some","generator","isSVG","isMotionValue","addUniqueItem","keyframes","all","scrapeMotionValuesFromProps","mass","hasLayoutChanged","handlePointerUp","lastMoveEvent","projectionDeltaWithTransform","maxWidth","size","borderRightColor","dragElastic","MotionGlobalConfig","removeGroupControls","easeOut","backgroundPositionX","createMotionComponentFactory","onfinish","session","repeatDelay","spring","mix","setActive","hover","maxDuration","calcLength","usePresence","MotionValue","resolvedRelativeTargetAt","indexes","visualDuration","frame","rotateY","allowProjection","onStop","phase","features","translateZ","damping","loadExternalIsValidProp","SwitchLayoutGroupContext","options","measureInstanceViewportBox","scheduleRender","isMounted","transition","LayoutGroupContext","getFinalKeyframe","paddingLeft","borderTopRightRadius","isSVGElement","createDomVisualElement","complex","borderTopLeftRadius","rotate","prefersReducedMotion","tap","createBox","color","initialValues","reducedMotionConfig","default","useIsPresent","backIn","anticipate","currentAnimation","array","WebkitFilter","findSpring","done","resetTransform","opacity","getAnimatableNone","isRoot","easingDefinitionToFunction","setTarget","point","isControllingVariants","granular","velocityPerSecond","left","manuallyAnimateOnMount","pointerEvents","transformPerspective","hasRelativeLayoutChanged","canTrackVelocity","node","test","preserveOpacity","borderTopColor","shouldResetTransform","isEnabled","velocity","useManualTiming","subscriptions","paddingBottom","projectionUpdateScheduled","paddingRight","moveItem","vars","marginRight","isScheduled","isTreeAnimating","hasAnimated","prevProjectionDelta","checkIsScrollRoot","paddingTop","panSession"]],"~:compiled-at",1740925089132,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$framer_motion$dist$cjs$create_CGKJurkh.js\",\n\"lineCount\":3928,\n\"mappings\":\"AAAAA,cAAA,CAAA,0DAAA,GAA+E,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAUvHC,UAASA,oBAAmB,CAACC,CAAD,CAAI;AAC5B,WAAc,IAAd,KAAQA,CAAR,IACiB,QADjB,KACI,MAAOA,EADX,IAEuB,UAFvB,KAEI,MAAOA,EAAEC,CAAAA,KAFb;AAD4B;AAMhCC,UAASA,cAAa,CAACC,aAAD,CAAgB;AAClC,UAAMC,QAAQ,CAAC,EAAD,EAAK,EAAL,CAAd;AACkB,QAAlB,KAAAD,aAAA,IAA4C,IAAK,EAAjD,KAA0BA,aAA1B,IAA8DA,aAAcE,CAAAA,MAAOC,CAAAA,OAArB,CAA6B,CAACC,KAAD,EAAQC,GAAR,CAAA,IAAgB;AACvGJ,WAAA,CAAM,CAAN,CAAA,CAASI,GAAT,CAAA,GAAgBD,KAAME,CAAAA,GAAN,EAAhB;AACAL,WAAA,CAAM,CAAN,CAAA,CAASI,GAAT,CAAA,GAAgBD,KAAMG,CAAAA,WAAN,EAAhB;AAFuG,KAA7C,CAA9D;AAIA,WAAON,KAAP;AANkC;AAQtCO,UAASA,wBAAuB,CAACC,KAAD,EAAQC,UAAR,EAAoBC,MAApB,EAA4BX,aAA5B,CAA2C;AAIvE,QAA0B,UAA1B,KAAI,MAAOU,WAAX,CAAsC;AAClC,YAAM,CAACE,OAAD,EAAUC,QAAV,CAAA,GAAsBd,aAAA,CAAcC,aAAd,CAA5B;AACAU,gBAAA,GAAaA,UAAA,CAAsBI,IAAAA,EAAX,KAAAH,MAAA,GAAuBA,MAAvB,GAAgCF,KAAME,CAAAA,MAAjD,EAAyDC,OAAzD,EAAkEC,QAAlE,CAAb;AAFkC;AAQZ,YAA1B,KAAI,MAAOH,WAAX,KACIA,UADJ,GACiBD,KAAMM,CAAAA,QADvB,IACmCN,KAAMM,CAAAA,QAAN,CAAeL,UAAf,CADnC;AAQA,QAA0B,UAA1B,KAAI,MAAOA,WAAX,CAAsC;AAClC,YAAM,CAACE,OAAD,EAAUC,QAAV,CAAA,GAAsBd,aAAA,CAAcC,aAAd,CAA5B;AACAU,gBAAA,GAAaA,UAAA,CAAsBI,IAAAA,EAAX,KAAAH,MAAA,GAAuBA,MAAvB,GAAgCF,KAAME,CAAAA,MAAjD,EAAyDC,OAAzD,EAAkEC,QAAlE,CAAb;AAFkC;AAItC,WAAOH,UAAP;AAxBuE;AA2B3EM,UAASA,eAAc,CAAChB,aAAD,EAAgBU,UAAhB,EAA4BC,MAA5B,CAAoC;AACvD,UAAMF,QAAQT,aAAciB,CAAAA,QAAd,EAAd;AACA,WAAOT,uBAAA,CAAwBC,KAAxB,EAA+BC,UAA/B,EAAsDI,IAAAA,EAAX,KAAAH,MAAA,GAAuBA,MAAvB,GAAgCF,KAAME,CAAAA,MAAjF,EAAyFX,aAAzF,CAAP;AAFuD;AAwB3DkB,UAASA,iBAAgB,CAACC,YAAD,EAAeC,QAAf,CAAyB;AAuB9CC,YAASA,gBAAe,CAACC,QAAD,CAAW;AAC3BC,iBAAYC,CAAAA,GAAZ,CAAgBF,QAAhB,CAAJ,KACIG,IAAKC,CAAAA,QAAL,CAAcJ,QAAd,CACA,EAAAH,YAAA,EAFJ;AAIAQ,cAAA,EAAA;AACAL,cAAA,CAASM,eAAT,CAAA;AAN+B;AAlBnC,QAAIC,YAAY,IAAIC,GAAJ,EAAhB,EACIC,YAAY,IAAID,GAAJ,EADhB,EAMIE,eAAe,CAAA,CANnB,EAOIC,iBAAiB,CAAA,CAPrB;AAWA,UAAMV,cAAc,IAAIW,OAAJ,EAApB;AACA,QAAIN,kBAAkB,CAClBO,MAAO,GADW,EAElBC,UAAW,GAFO,EAGlBJ,aAAc,CAAA,CAHI,CAAtB,EAKIL,WAAW,CALf;AAcA,UAAMF,OAAO,CAITC,SAAU,CAACJ,QAAD,EAAWe,SAAA,GAAY,CAAA,CAAvB,EAA8BC,SAAA,GAAY,CAAA,CAA1C,CAAAZ,IAAoD;AAEpDa,eAAAA,GADoBD,SACZ,IADyBN,YACzB,GAAoBH,SAApB,GAAgCE,SAAxCQ;AACFF,eAAJ,IACId,WAAYiB,CAAAA,GAAZ,CAAgBlB,QAAhB,CADJ;AAEKiB,eAAMf,CAAAA,GAAN,CAAUF,QAAV,CAAL,IACIiB,SAAMC,CAAAA,GAAN,CAAUlB,QAAV,CADJ;AAEA,aAAOA,QAAP;AAP0D,KAJrD,EAgBTmB,OAASnB,QAADmB,IAAc;AAClBV,eAAUW,CAAAA,MAAV,CAAiBpB,QAAjB,CAAA;AACAC,iBAAYmB,CAAAA,MAAZ,CAAmBpB,QAAnB,CAAA;AAFkB,KAhBb,EAuBTqB,QAAUC,SAADD,IAAe;AACpBf,qBAAA,GAAkBgB,SAAlB;AAMIZ,kBAAJ,GACIC,cADJ,GACqB,CAAA,CADrB,IAIAD,YAeA,GAfe,CAAA,CAef,EAdA,CAACH,SAAD,EAAYE,SAAZ,CAcA,GAdyB,CAACA,SAAD,EAAYF,SAAZ,CAczB,EAZAA,SAAU1B,CAAAA,OAAV,CAAkBkB,eAAlB,CAYA,EARID,QAQJ,IARgByB,WAAYzC,CAAAA,KAQ5B,IAPIyC,WAAYzC,CAAAA,KAAM0C,CAAAA,SAAlB,CAA4B1B,QAA5B,CAAsC2B,CAAAA,IAAtC,CAA2CpB,QAA3C,CAOJ,EALAA,QAKA,GALW,CAKX,EAFAE,SAAUmB,CAAAA,KAAV,EAEA,EADAhB,YACA,GADe,CAAA,CACf,EAAIC,cAAJ,KACIA,cACA,GADiB,CAAA,CACjB,EAAAR,IAAKkB,CAAAA,OAAL,CAAaC,SAAb,CAFJ,CAnBA,CAAA;AAPoB,KAvBf,CAAb;AAuDA,WAAOnB,IAAP;AAtF8C;AA0FlDwB,UAASA,oBAAmB,CAACC,iBAAD,EAAoBC,cAApB,CAAoC;AAC5D,QAAIhC,eAAe,CAAA,CAAnB,EACIiC,oBAAoB,CAAA,CADxB;AAEA,UAAMnD,QAAQ,CACVkC,MAAO,GADG,EAEVC,UAAW,GAFD,EAGVJ,aAAc,CAAA,CAHJ,CAAd,EAKMqB,mBAAmB,EAAAA,IAAOlC,YAAPkC,GAAsB,CAAA,CAL/C,EAMMC,QAAQC,UAAWC,CAAAA,MAAX,CAAkB,CAACC,GAAD,EAAMpD,GAAN,CAAA,IAAc;AAC1CoD,SAAA,CAAIpD,GAAJ,CAAA,GAAWa,gBAAA,CAAiBmC,gBAAjB,EAAmCF,cAAA,GAAiB9C,GAAjB,GAAuBS,IAAAA,EAA1D,CAAX;AACA,aAAO2C,GAAP;AAF0C,KAAhC,EAGX,EAHW,CANd,EAUM,CAAEC,IAAF,EAAQC,gBAAR,EAA0BC,MAA1B,EAAkCC,SAAlC,EAA6CC,MAA7C,EAAqDC,UAArD,CAAA,GAAoET,KAV1E,EAWMU,eAAe,EAAAA,IAAM;AACvB,YAAM5B,YAAY6B,kBAAmBC,CAAAA,eAAnB,GACZjE,KAAMmC,CAAAA,SADM,GAEZ+B,WAAYC,CAAAA,GAAZ,EAFN;AAGAjD,kBAAA,GAAe,CAAA,CAAf;AACK8C,wBAAmBC,CAAAA,eAAxB,KACIjE,KAAMkC,CAAAA,KADV,GACkBiB,iBAAA,GACR,IADQ,GACD,EADC,GAERiB,IAAKC,CAAAA,GAAL,CAASD,IAAKE,CAAAA,GAAL,CAASnC,SAAT,GAAqBnC,KAAMmC,CAAAA,SAA3B,EAvBRoC,EAuBQ,CAAT,EAA4D,CAA5D,CAHV;AAKAvE,WAAMmC,CAAAA,SAAN,GAAkBA,SAAlB;AACAnC,WAAM+B,CAAAA,YAAN,GAAqB,CAAA,CAArB;AAEA0B,UAAKf,CAAAA,OAAL,CAAa1C,KAAb,CAAA;AACA0D,sBAAiBhB,CAAAA,OAAjB,CAAyB1C,KAAzB,CAAA;AACA2D,YAAOjB,CAAAA,OAAP,CAAe1C,KAAf,CAAA;AACA4D,eAAUlB,CAAAA,OAAV,CAAkB1C,KAAlB,CAAA;AACA6D,YAAOnB,CAAAA,OAAP,CAAe1C,KAAf,CAAA;AACA8D,gBAAWpB,CAAAA,OAAX,CAAmB1C,KAAnB,CAAA;AACAA,WAAM+B,CAAAA,YAAN,GAAqB,CAAA,CAArB;AACIb,kBAAJ,IAAoBgC,cAApB,KACIC,iBACA,GADoB,CAAA,CACpB,EAAAF,iBAAA,CAAkBc,YAAlB,CAFJ;AApBuB,KAX3B;AAyDA,WAAO,CAAEtC,SAdQ6B,UAAWC,CAAAA,MAAX9B,CAAkB,CAAC+B,GAAD,EAAMpD,GAAN,CAAA,IAAc;AAC7C,YAAMoB,OAAO6B,KAAA,CAAMjD,GAAN,CAAb;AACAoD,SAAA,CAAIpD,GAAJ,CAAA,GAAW,CAACsC,OAAD,EAAUN,SAAA,GAAY,CAAA,CAAtB,EAA6BC,SAAA,GAAY,CAAA,CAAzC,CAAA,IAAmD;AACrDnB,oBAAL,KARJiC,iBACA,GAFAjC,YAEA,GAFe,CAAA,CAEf,EAAKlB,KAAM+B,CAAAA,YAAX,IACIkB,iBAAA,CAAkBc,YAAlB,CAMA;AAEA,eAAOvC,IAAKC,CAAAA,QAAL,CAAciB,OAAd,EAAuBN,SAAvB,EAAkCC,SAAlC,CAAP;AAH0D,OAA9D;AAKA,aAAOmB,GAAP;AAP6C,KAAhC/B,EAQd,EARcA,CAcV,EAAYe,OALHE,OAADF,IAAa;AACxB,WAAK,IAAIgC,IAAI,CAAb,EAAgBA,CAAhB,GAAoBlB,UAAWmB,CAAAA,MAA/B,EAAuCD,CAAA,EAAvC;AACInB,aAAA,CAAMC,UAAA,CAAWkB,CAAX,CAAN,CAAqBhC,CAAAA,MAArB,CAA4BE,OAA5B,CAAA;AADJ;AADwB,KAKrB,EAAoB1C,KAApB,EAA2BqD,KAA3B,CAAP;AA5D4D;AAmHhEqB,UAASA,UAAS,EAAG;AACjBP,OAAA,GAAMtD,IAAAA,EAAN;AADiB;AA0BrB8D,UAASA,cAAa,CAACC,GAAD,EAAMC,IAAN,CAAY;AACJ,KAAC,CAA3B,KAAID,GAAIE,CAAAA,OAAJ,CAAYD,IAAZ,CAAJ,IACID,GAAI9B,CAAAA,IAAJ,CAAS+B,IAAT,CADJ;AAD8B;AAIlCE,UAASA,WAAU,CAACH,GAAD,EAAMC,IAAN,CAAY;AACrBG,QAAAA,GAAQJ,GAAIE,CAAAA,OAAJ,CAAYD,IAAZ,CAARG;AACM,KAAC,CAAb,GAAIA,IAAJ,IACIJ,GAAIK,CAAAA,MAAJ,CAAWD,IAAX,EAAkB,CAAlB,CADJ;AAF2B;AA2D/BE,UAASA,kBAAiB,CAACtE,QAAD,EAAWuE,aAAX,CAA0B;AAChD,WAAOA,aAAA,GAA4B,IAA5B,GAAmCA,aAAnC,GAAgBvE,QAAhB,GAAoD,CAA3D;AADgD;AAKpDwE,UAASA,SAAQ,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,OAArB,CAA8B;AACvCF,aAAJ,IAAiBG,MAAOjE,CAAAA,GAAP,CAAW+D,OAAX,CAAjB,KAEAG,OAAQC,CAAAA,IAAR,CAAaJ,OAAb,CAGA,EAFIC,OAEJ,IADIE,OAAQC,CAAAA,IAAR,CAAaH,OAAb,CACJ,EAAAC,MAAOjD,CAAAA,GAAP,CAAW+C,OAAX,CALA;AAD2C;AA6T/CK,UAASA,YAAW,CAACC,IAAD,EAAOC,OAAP,CAAgB;AAChC,WAAO,IAAIC,WAAJ,CAAgBF,IAAhB,EAAsBC,OAAtB,CAAP;AADgC;AAgBpCE,UAASA,UAAS,CAAChG,aAAD,EAAgBU,UAAhB,CAA4B;AACpCuF,cAAAA,GAAWjF,cAAA,CAAehB,aAAf,EAA8BU,UAA9B,CAAXuF;AACN,QAAI,CAAEC,aAAA,GAAgB,EAAlB,EAAsBC,UAAA,GAAa,EAAnC,EAAuC,GAAGC,MAA1C,CAAA,GAAqDH,UAArD,IAAiE,EAArE;AACAG,UAAA,GAAS,CAAE,GAAGA,MAAL,EAAa,GAAGF,aAAhB,CAAT;AACA,SAAK,MAAM7F,GAAX,GAAkB+F,OAAlB,CAA0B;AACqB,gBAAA,GAAAA,MAAA,CAAO/F,GAAP,CAAA;AAA3C,YAAMD,QA5bHiG,KAAMC,CAAAA,OAAN,CAQkBzG,UARlB,CAQA,GAAuBA,UAAA,CAAEA,UAAE6E,CAAAA,MAAJ,GAAa,CAAb,CAAvB,IAA0C,CAA1C,GAA8C7E,UAobjD;AACeG,gBAAAA,GAAAA,aAAAA;AAbfA,gBAAcuG,CAAAA,QAAd,CAa8BlG,GAb9B,CAAJ,GACIL,UAAcwG,CAAAA,QAAd,CAY8BnG,GAZ9B,CAA4BoG,CAAAA,GAA5B,CAYmCrG,KAZnC,CADJ,GAIIJ,UAAc0G,CAAAA,QAAd,CAS8BrG,GAT9B,EAA4BuF,WAAA,CASOxF,KATP,CAA5B,CAJJ;AAW0B;AAJgB;AAgB9CuG,UAASA,qBAAoB,CAAC3G,aAAD,EAAgBK,GAAhB,CAAqB;AAM9C,SALMuG,aAKN,GALmB5G,aAAcwG,CAAAA,QAAd,CAAuB,YAAvB,CAKnB,KAA4BI,aAZwBrG,CAAAA,WAYpD,IAA4BqG,aATiBpE,CAAAA,GAS7C;AACI,aAAOoE,aAAWpE,CAAAA,GAAX,CAAenC,GAAf,CAAP;AADJ;AAN8C;AAmBlDwG,UAASA,qBAAoB,CAAC7G,aAAD,CAAgB;AACzC,WAAOA,aAAcS,CAAAA,KAAd,CAAoBqG,4BAApB,CAAP;AADyC;AA+C7CC,UAASA,YAAW,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX,EAAgBC,GAAhB,CAAqB;AAErC,WAAIH,GAAJ,KAAYC,GAAZ,IAAmBC,GAAnB,KAA2BC,GAA3B,GACWC,WAAYC,CAAAA,IADvB,GAIQC,CAAD,IAAO;AAAA,UAAM,CAAN,KAAAA,CAAA,IAAiB,CAAjB,KAAWA,CAAX,CAAA;AAAyB,YAAA,aAAA,CAAA,EAAA,aAAA,CAAA;AAtBvC,YAAIC,QAAJ,EACIC,QADJ,EAEI/C,IAAI,CAFR;AAGA;AACI+C,kBAEA,GAFWC,UAEX,IAFyBC,UAEzB,GAFsCD,UAEtC,IAFoD,GAEpD,EADAF,QACA,MAX6B,GAW7B,GAXmC,GAWnC,GAgBmCL,GAhBnC,GAX8C,GAW9C,GAgBmCF,GAhBnC,IADsBQ,QACtB,IAX+D,GAW/D,GAgBmCN,GAhBnC,GAX0E,GAW1E,GAgBmCF,GAhBnC,KADsBQ,QACtB,GAX2F,GAW3F,GAgBmCR,GAhBnC,IADsBQ,QACtB,GAgBmCG,CAhBnC,EAAe,GAAf,GAAIJ,QAAJ,GACIG,UADJ,GACiBF,QADjB,GAIIC,UAJJ,GAIiBD,QAJjB;AAHJ,iBANyBI,SAMzB,GASSvD,IAAKwD,CAAAA,GAAL,CAASN,QAAT,CATT,IAL6BO,EAK7B,GAUI,EAAErD,CAVN;AAWA,SAAA,GAAO+C,QAAP;AAQuC,SAAA,MA3BN,GA2BM,GA3BA,GA2BA,GAAAO,GAAA,GA3BW,GA2BX,GAAAC,GAAA,IAAAV,CAAA,IA3B4B,GA2B5B,GAAAS,GAAA,GA3BuC,GA2BvC,GAAAC,GAAA,KAAAV,CAAA,GA3BwD,GA2BxD,GAAAU,GAAA;AAAzB;AAAA,aAAA,CAAA;AAAA,KAJd;AAFqC;AAoOzCC,UAASA,oBAAmB,CAAC7H,KAAD,CAAQ;AAEhC,UAAMF,SAAS,EAAf,EACMgI,UAAU,CACZC,MAAO,EADK,EAEZC,OAAQ,EAFI,EAGZC,IAAK,EAHO,CADhB,EAMMC,QAAQ,EANd;AAOA,QAAI7D,IAAI,CAAR;AAoBM8D,SAAAA,GA5BgBnI,KAAMoI,CAAAA,QAANC,EASUC,CAAAA,OAAdC,CAAsBC,YAAtBD,EAAqCE,WAAD,IAAiB;AAC/DV,WAAMW,CAAAA,IAAN,CAAWD,WAAX,CAAJ,IACIX,OAAQC,CAAAA,KAAMpF,CAAAA,IAAd,CAAmB0B,CAAnB,CAEA,EADA6D,KAAMvF,CAAAA,IAAN,CAnBQgG,OAmBR,CACA,EAAA7I,MAAO6C,CAAAA,IAAP,CAAYoF,KAAMa,CAAAA,KAAN,CAAYH,WAAZ,CAAZ,CAHJ,IAKSA,WAAYI,CAAAA,UAAZ,CApBUC,MAoBV,CAAJ,IACDhB,OAAQG,CAAAA,GAAItF,CAAAA,IAAZ,CAAiB0B,CAAjB,CAEA,EADA6D,KAAMvF,CAAAA,IAAN,CAvBMoG,KAuBN,CACA,EAAAjJ,MAAO6C,CAAAA,IAAP,CAAY8F,WAAZ,CAHC,KAMDX,OAAQE,CAAAA,MAAOrF,CAAAA,IAAf,CAAoB0B,CAApB,CAEA,EADA6D,KAAMvF,CAAAA,IAAN,CA9BSqG,QA8BT,CACA,EAAAlJ,MAAO6C,CAAAA,IAAP,CAAYsG,UAAA,CAAWR,WAAX,CAAZ,CARC,CALL;AAeA,QAAEpE,CAAF;AACA,aA9BY6E,KA8BZ;AAjBmE,KAArDX,CAmBMJ,CAAAA,KAAV,CAhCEe,KAgCF,CAARf;AACN,WAAO,CAAErI,MAAF,EAAUqI,MAAAA,KAAV,EAAiBL,OAAjB,EAA0BI,KAA1B,CAAP;AA9BgC;AAgCpCiB,UAASA,kBAAiB,CAAC1J,CAAD,CAAI;AAC1B,WAAOoI,mBAAA,CAAoBpI,CAApB,CAAuBK,CAAAA,MAA9B;AAD0B;AAG9BsJ,UAASA,kBAAiB,CAACC,MAAD,CAAS;AAC/B,UAAM,CAAElB,KAAF,EAASD,KAAT,CAAA,GAAmBL,mBAAA,CAAoBwB,MAApB,CAAzB,EACMC,cAAcnB,KAAM7D,CAAAA,MAD1B;AAEA,WAAQ7E,CAAD,IAAO;AACV,UAAI8J,SAAS,EAAb;AACA,WAAK,IAAIlF,IAAI,CAAb,EAAgBA,CAAhB,GAAoBiF,WAApB,EAAiCjF,CAAA,EAAjC;AAEI,YADAkF,MACI,IADMpB,KAAA,CAAM9D,CAAN,CACN,EAAS3D,IAAAA,EAAT,KAAAjB,CAAA,CAAE4E,CAAF,CAAJ,CAAwB;AACpB,gBAAMmF,OAAOtB,KAAA,CAAM7D,CAAN,CAAb;AAEIkF,gBAAA,GApDCP,QAmDL,KAAIQ,IAAJ,GACID,MADJ,GA5MQtF,IAAKwF,CAAAA,KAAL,CAAe,MAAf,GA6MehK,CAAAA,CAAE4E,CAAF5E,CA7Mf,CA4MR,GA5MiC,MA4MjC,GAlDIkJ,OAqDC,KAAIa,IAAJ,GACDD,MADC,GACSxB,KAAM2B,CAAAA,SAAN,CAAgBjK,CAAA,CAAE4E,CAAF,CAAhB,CADT,GAIDkF,MAJC,GAIS9J,CAAA,CAAE4E,CAAF,CANV;AAHgB;AAF5B;AAeA,aAAOkF,MAAP;AAjBU,KAAd;AAH+B;AAwCnCI,UAASA,mBAAkB,CAAClK,CAAD,CAAI;AAC3B,UAAM,CAACmK,IAAD,EAAO5J,KAAP,CAAA,GAAgBP,CAAEoK,CAAAA,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,CAAe1B,CAAAA,KAAf,CAAqB,GAArB,CAAtB;AACA,QAAa,aAAb,KAAIyB,IAAJ;AACI,aAAOnK,CAAP;AADJ;AAEA,UAAM,CAACuI,MAAD,CAAA,GAAWhI,KAAM8J,CAAAA,KAAN,CAAYC,UAAZ,CAAX,IAAsC,EAA5C;AACA,QAAI,CAAC/B,MAAL;AACI,aAAOvI,CAAP;AADJ;AAEMuK,KAAAA,GAAOhK,KAAMsI,CAAAA,OAAN,CAAcN,MAAd,EAAsB,EAAtB,CAAPgC;AACN,QAAIC,eAAeC,WAAY9I,CAAAA,GAAZ,CAAgBwI,IAAhB,CAAA,GAAwB,CAAxB,GAA4B,CAA/C;AACI5B,UAAJ,KAAehI,KAAf,KACIiK,YADJ,IACoB,GADpB;AAEA,WAAOL,IAAP,GAAc,GAAd,GAAoBK,YAApB,GAAmCD,CAAnC,GAA0C,GAA1C;AAX2B;AAgI/BG,UAASA,kBAAiB,CAAClK,GAAD,EAAMD,KAAN,CAAa;AAC/BoK,OAAAA,GAH6BC,iBAAA,CAGUpK,GAHV,CAG7BmK;AACAA,OAAJ,KAAyBE,MAAzB,KACIF,GADJ,GACuBG,OADvB;AAGA,WAAOH,GAAiBD,CAAAA,iBAAjB,GACDC,GAAiBD,CAAAA,iBAAjB,CAAmCnK,KAAnC,CADC,GAEDU,IAAAA,EAFN;AALmC;AAyDvC8J,UAASA,gCAA+B,CAAC5K,aAAD,CAAgB;AACpD,UAAM6K,oBAAoB,EAA1B;AACAC,iCAA8B3K,CAAAA,OAA9B,CAAuCE,GAAD,IAAS;AAC3C,YAAMD,QAAQJ,aAAcwG,CAAAA,QAAd,CAAuBnG,GAAvB,CAAd;AACcS,UAAAA,EAAd,KAAIV,KAAJ,KACIyK,iBAAkB9H,CAAAA,IAAlB,CAAuB,CAAC1C,GAAD,EAAMD,KAAME,CAAAA,GAAN,EAAN,CAAvB,CACA,EAAAF,KAAMqG,CAAAA,GAAN,CAAUpG,GAAI4I,CAAAA,UAAJ,CAAe,OAAf,CAAA,GAA0B,CAA1B,GAA8B,CAAxC,CAFJ;AAF2C,KAA/C,CAAA;AAOA,WAAO4B,iBAAP;AAToD;AA8BxDE,UAASA,oBAAmB,EAAG;AAC3B,QAAIC,mBAAJ,CAAyB;AACrB,YAAMC,qBAAqB5E,KAAM6E,CAAAA,IAAN,CAAWC,SAAX,CAAsBT,CAAAA,MAAtB,CAA8BU,QAAD,IAAcA,QAASC,CAAAA,gBAApD,CAA3B,EACMC,oBAAoB,IAAIxJ,GAAJ,CAAQmJ,kBAAmBM,CAAAA,GAAnB,CAAwBH,QAAD,IAAcA,QAAS5F,CAAAA,OAA9C,CAAR,CAD1B,EAEMgG,sBAAsB,IAAIC,GAAJ,EAF5B;AAOAH,uBAAkBnL,CAAAA,OAAlB,CAA2BqF,OAAD,IAAa;AACnC,cAAMqF,oBAAoBD,+BAAA,CAAgCpF,OAAhC,CAA1B;AACKqF,yBAAkBnG,CAAAA,MAAvB,KAEA8G,mBAAoB/E,CAAAA,GAApB,CAAwBjB,OAAxB,EAAiCqF,iBAAjC,CACA,EAAArF,OAAQ1B,CAAAA,MAAR,EAHA;AAFmC,OAAvC,CAAA;AAQAmH,wBAAmB9K,CAAAA,OAAnB,CAA4BiL,QAAD,IAAcA,QAASM,CAAAA,mBAAT,EAAzC,CAAA;AAEAJ,uBAAkBnL,CAAAA,OAAlB,CAA2BqF,OAAD,IAAa;AACnCA,eAAQ1B,CAAAA,MAAR,EAAA;AACA,cAAM6H,UAAUH,mBAAoBlL,CAAAA,GAApB,CAAwBkF,OAAxB,CAAhB;AACImG,eAAJ,IACIA,OAAQxL,CAAAA,OAAR,CAAgB,CAAC,CAACE,GAAD,EAAMD,KAAN,CAAD,CAAA,IAAkB;AAC9B,cAAIwL,EAAJ;AACiC,cAAjC,MAACA,EAAD,GAAMpG,OAAQgB,CAAAA,QAAR,CAAiBnG,GAAjB,CAAN,KAAgD,IAAK,EAArD,KAAyCuL,EAAzC,IAAkEA,EAAGnF,CAAAA,GAAH,CAAOrG,KAAP,CAAlE;AAF8B,SAAlC,CADJ;AAHmC,OAAvC,CAAA;AAWA6K,wBAAmB9K,CAAAA,OAAnB,CAA4BiL,QAAD,IAAcA,QAASS,CAAAA,eAAT,EAAzC,CAAA;AAEAZ,wBAAmB9K,CAAAA,OAAnB,CAA4BiL,QAAD,IAAc;AACHtK,YAAAA,EAAlC,KAAIsK,QAASU,CAAAA,gBAAb,IACIC,MAAOC,CAAAA,QAAP,CAAgB,CAAhB,EAAmBZ,QAASU,CAAAA,gBAA5B,CADJ;AADqC,OAAzC,CAAA;AA/BqB;AAsCzBG,eAAA,GADAjB,mBACA,GADsB,CAAA,CACtB;AACAG,aAAUhL,CAAAA,OAAV,CAAmBiL,QAAD,IAAcA,QAASc,CAAAA,QAAT,EAAhC,CAAA;AACAf,aAAUnI,CAAAA,KAAV,EAAA;AAzC2B;AA2C/BmJ,UAASA,iBAAgB,EAAG;AACxBhB,aAAUhL,CAAAA,OAAV,CAAmBiL,QAAD,IAAc;AAC5BA,cAASgB,CAAAA,aAAT,EAAA;AACIhB,cAASC,CAAAA,gBAAb,KACIL,mBADJ,GAC0B,CAAA,CAD1B;AAF4B,KAAhC,CAAA;AADwB;AAyJ5BqB,UAASA,iBAAgB,CAACzL,OAAD,EAAU4E,OAAV,EAAmB8G,KAAA,GAAQ,CAA3B,CAA8B;AACnDlF,eAAYmF,CAAAA,SAAZ,CAFaC,CAEb,IAAsBF,KAAtB,EAA0C,yDAAwD1L,OAAxD,sDAA1C,CAAA;AAPA,QADMsJ,OACN,GADcuC,qBAAsBC,CAAAA,IAAtB,CAS6B9L,OAT7B,CACd,CAAA;AAEA,UAAM,CAAA,EAAG+L,MAAH,EAAWC,MAAX,EAAmBC,QAAnB,CAAA,GAA+B3C,OAArC;AACA,aAAA,GAAO,CAAE,KAAe,IAAX,KAAAyC,MAAA,IAA8B,IAAK,EAAnC,KAAmBA,MAAnB,GAAuCA,MAAvC,GAAgDC,MAApD,EAAF,EAAgEC,QAAhE,CAAP;AAHA,KAAA;AACI,aAAA,GAAO,CAAA,GAAP;AADJ;AAQA,UAAM,CAACC,KAAD,EAAQD,iBAAR,CAAA,GAAoB,OAA1B;AAEA,QAAKC,KAAL;AAIA,aAAA,CADM7G,OACN,GADiB8F,MAAOgB,CAAAA,gBAAP,CAAwBvH,OAAxB,CAAiCwH,CAAAA,gBAAjC,CAAkDF,KAAlD,CACjB,KACUG,OACC,GADShH,OAASiH,CAAAA,IAAT,EACT,EA9CkB,8BAA+BpE,CAAAA,IAA/B,CA8CAmE,OA9CA,CA8ClB,GAA6B5D,UAAA,CAAW4D,OAAX,CAA7B,GAAmDA,OAF9D,IAIOE,kBAAA,CAAmBN,iBAAnB,CAAA,GACDR,gBAAA,CAAiBQ,iBAAjB,EAA2BrH,OAA3B,EAAoC8G,KAApC,GAA4C,CAA5C,CADC,GAEDO,iBANN;AAJA;AAJmD;AAiOvDO,UAASA,iBAAgB,CAACC,SAAD,EAAY,CAAEC,MAAF,EAAUC,UAAA,GAAa,MAAvB,CAAZ,EAA6CC,aAA7C,CAA4D;AAC3EC,aAAAA,GAAoBJ,SAAU3C,CAAAA,MAAV,CAAiBgD,SAAjB,CAApBD;AAIN,WAAO,CAHDxI,MAGC,GAHOqI,MAAA,IAAyB,MAAzB,KAAUC,UAAV,IAAkD,CAAlD,KAAmCD,MAAnC,GAA4C,CAA5C,GACR,CADQ,GAERG,SAAkB/I,CAAAA,MAFV,GAEmB,CAC1B,KAA4B5D,IAAAA,EAA5B,KAAU0M,aAAV,GAEDA,aAFC,GACDC,SAAA,CAAkBxI,MAAlB,CADN;AALiF;AAmJrF0I,UAASA,SAAQ,CAACC,CAAD,EAAIC,CAAJ,EAAOvG,CAAP,CAAU;AACf,KAAR,GAAIA,CAAJ,KACIA,CADJ,IACS,CADT;AAEQ,KAAR,GAAIA,CAAJ,IACI,EAAAA,CADJ;AAEA,WAAIA,CAAJ,GAAQ,CAAR,GAAY,CAAZ,GACWsG,CADX,GACyB,CADzB,IACgBC,CADhB,GACoBD,CADpB,IAC6BtG,CAD7B,GAEQ,EAAR,GAAIA,CAAJ,GACWuG,CADX,GAEIvG,CAAJ,GAAQ,CAAR,GAAY,CAAZ,GACWsG,CADX,IACgBC,CADhB,GACoBD,CADpB,KAC0B,CAD1B,GAC8B,CAD9B,GACkCtG,CADlC,IACuC,CADvC,GAEOsG,CANP;AALuB;AAa3BE,UAASA,WAAU,CAAC,CAAEC,GAAF,EAAOC,UAAP,EAAmBC,SAAnB,EAA8BC,KAA9B,CAAD,CAAwC;AACvDH,OAAA,IAAO,GAAP;AACAC,cAAA,IAAc,GAAd;AACAC,aAAA,IAAa,GAAb;AAIA,QAAKD,UAAL,CAGK;AACD,YAAMH,IAAgB,GAAZ,GAAAI,SAAA,GACJA,SADI,IACS,CADT,GACaD,UADb,IAEJC,SAFI,GAEQD,UAFR,GAEqBC,SAFrB,GAEiCD,UAF3C,EAGMJ,IAAI,CAAJA,GAAQK,SAARL,GAAoBC,CAH1B;AAIAM,eAAA,GAAMR,QAAA,CAASC,CAAT,EAAYC,CAAZ,EAAeE,GAAf,GAAqB,CAArB,GAAyB,CAAzB,CAAN;AACAK,gBAAA,GAAQT,QAAA,CAASC,CAAT,EAAYC,CAAZ,EAAeE,GAAf,CAAR;AACAM,SAAA,GAAOV,QAAA,CAASC,CAAT,EAAYC,CAAZ,EAAeE,GAAf,GAAqB,CAArB,GAAyB,CAAzB,CAAP;AAPC,KAHL;AACII,eAAA,GAAMC,UAAN,GAAcC,GAAd,GAAqBJ,SAArB;AADJ;AAYA,WAAO,CACHE,IAAK9J,IAAKwF,CAAAA,KAAL,CAAiB,GAAjB,GAAWsE,SAAX,CADF,EAEHC,MAAO/J,IAAKwF,CAAAA,KAAL,CAAmB,GAAnB,GAAWuE,UAAX,CAFJ,EAGHC,KAAMhK,IAAKwF,CAAAA,KAAL,CAAkB,GAAlB,GAAWwE,GAAX,CAHH,EAIHH,KAJG,CAAP;AAnBuD;AA2B3DI,UAASA,aAAY,CAACC,CAAD,EAAIC,CAAJ,CAAO;AACxB,WAAQZ,CAAD,IAAY,CAAJ,GAAAA,CAAA,GAAQY,CAAR,GAAYD,CAA3B;AADwB;AAc5BE,UAASA,OAAM,CAACtG,KAAD,CAAQ;AACnB,UAAMyB,OAAO8E,YAAA,CAAavG,KAAb,CAAb;AACAf,eAAYuH,CAAAA,OAAZ,CAAoB,CAAA,CAAQ/E,IAA5B,EAAoC,IAAGzB,KAAH,sEAApC,CAAA;AACA,QAAI,CAASyB,IAAb;AACI,aAAO,CAAA,CAAP;AADJ;AAEIgF,SAAAA,GAAQhF,IAAKZ,CAAAA,KAAL,CAAWb,KAAX,CAARyG;AACAhF,QAAJ,KAAaiF,IAAb,KAEID,KAFJ,GAEYd,UAAA,CAAWc,KAAX,CAFZ;AAIA,WAAOA,KAAP;AAVmB;AA4CvBE,UAASA,cAAa,CAACC,MAAD,EAAS3I,MAAT,CAAiB;AACnC,WAAI4I,eAAgBxN,CAAAA,GAAhB,CAAoBuN,MAApB,CAAJ,GACYnB,CAAD,IAAa,CAAL,IAAAA,CAAA,GAASmB,MAAT,GAAkB3I,MADrC,GAIYwH,CAAD,IAAa,CAAL,IAAAA,CAAA,GAASxH,MAAT,GAAkB2I,MAJrC;AADmC;AASvCE,UAASA,UAAS,CAACV,CAAD,EAAIC,CAAJ,CAAO;AACrB,WAAQZ,CAAD,IAAmBW,CAAnB,IAAsBC,CAAtB,GAAmBD,CAAnB,IAAyBX,CAAhC;AADqB;AAGzBsB,UAASA,SAAQ,CAACX,CAAD,CAAI;AACjB,WAAiB,QAAjB,KAAI,MAAOA,EAAX,GACWU,SADX,GAGsB,QAAjB,KAAI,MAAOV,EAAX,GACMpB,kBAAA,CAAmBoB,CAAnB,CAAA,GACDD,YADC,GAEDnG,KAAMW,CAAAA,IAAN,CAAWyF,CAAX,CAAA,GACIY,QADJ,GAEIC,UALT,GAOI/I,KAAMC,CAAAA,OAAN,CAAciI,CAAd,CAAJ,GACMc,QADN,GAGiB,QAAjB,KAAI,MAAOd,EAAX,GACMpG,KAAMW,CAAAA,IAAN,CAAWyF,CAAX,CAAA,GAAgBY,QAAhB,GAA2BG,SADjC,GAGEhB,YAhBP;AADiB;AAmBrBe,UAASA,SAAQ,CAACd,CAAD,EAAIC,CAAJ,CAAO;AACpB,UAAM7E,SAAS,CAAC,GAAG4E,CAAJ,CAAf,EACMgB,YAAY5F,MAAOjF,CAAAA,MADzB,EAEM8K,aAAajB,CAAEhD,CAAAA,GAAF,CAAM,CAAC1L,CAAD,EAAI4E,CAAJ,CAAA,IAAUyK,QAAA,CAASrP,CAAT,CAAA,CAAYA,CAAZ,EAAe2O,CAAA,CAAE/J,CAAF,CAAf,CAAhB,CAFnB;AAGA,WAAQmJ,CAAD,IAAO;AACV,WAAK,IAAInJ,IAAI,CAAb,EAAgBA,CAAhB,GAAoB8K,SAApB,EAA+B9K,CAAA,EAA/B;AACIkF,cAAA,CAAOlF,CAAP,CAAA,GAAY+K,UAAA,CAAW/K,CAAX,CAAA,CAAcmJ,CAAd,CAAZ;AADJ;AAGA,aAAOjE,MAAP;AAJU,KAAd;AAJoB;AAWxB2F,UAASA,UAAS,CAACf,CAAD,EAAIC,CAAJ,CAAO;AACrB,UAAM7E,SAAS,CAAE,GAAG4E,CAAL,EAAQ,GAAGC,CAAX,CAAf,EACMgB,aAAa,EADnB;AAEA,SAAK,MAAMnP,GAAX,GAAkBsJ,OAAlB;AACmB7I,UAAAA,EAAf,KAAIyN,CAAA,CAAElO,GAAF,CAAJ,IAAuCS,IAAAA,EAAvC,KAA4B0N,CAAA,CAAEnO,GAAF,CAA5B,KACImP,UAAA,CAAWnP,GAAX,CADJ,GACsB6O,QAAA,CAASX,CAAA,CAAElO,GAAF,CAAT,CAAA,CAAiBkO,CAAA,CAAElO,GAAF,CAAjB,EAAyBmO,CAAA,CAAEnO,GAAF,CAAzB,CADtB;AADJ;AAKA,WAAQR,CAAD,IAAO;AACV,WAAK,MAAMQ,GAAX,GAAkBmP,WAAlB;AACI7F,cAAA,CAAOtJ,GAAP,CAAA,GAAcmP,UAAA,CAAWnP,GAAX,CAAA,CAAgBR,CAAhB,CAAd;AADJ;AAGA,aAAO8J,MAAP;AAJU,KAAd;AARqB;AAkDzB8F,UAASA,IAAG,CAACvE,IAAD,EAAOwE,EAAP,EAAW9B,CAAX,CAAc;AACtB,WAAoB,QAApB,KAAI,MAAO1C,KAAX,IACkB,QADlB,KACI,MAAOwE,GADX,IAEiB,QAFjB,KAEI,MAAO9B,EAFX,GAGuB1C,IAHvB,IAG6BwE,EAH7B,GAGuBxE,IAHvB,IAGiC0C,CAHjC,GAKcsB,QAAAS,CAASzE,IAATyE,CACP,CAAMzE,IAAN,EAAYwE,EAAZ,CANP;AADsB;AAW1BE,UAASA,sBAAqB,CAACC,YAAD,EAAevI,CAAf,EAAkB1G,OAAlB,CAA2B;AACrD,UAAMkP,QAAQzL,IAAKC,CAAAA,GAAL,CAASgD,CAAT,GAFayI,CAEb,EAAqC,CAArC,CAAd;AACA,WAAO5K,iBAAA,CAAkBvE,OAAlB,GAA4BiP,YAAA,CAAaC,KAAb,CAA5B,EAAiDxI,CAAjD,GAAqDwI,KAArD,CAAP;AAFqD;AAgCzDE,UAASA,WAAU,CAAC,CAAEC,QAAA,GAAWC,cAAeD,CAAAA,QAA5B,EAAsCE,MAAA,GAASD,cAAeC,CAAAA,MAA9D,EAAsEtP,QAAA,GAAWqP,cAAerP,CAAAA,QAAhG,EAA0GuP,IAAA,GAAOF,cAAeE,CAAAA,IAAhI,CAAD,CAA0I;AACzJ,QAAIC,QAAJ;AAEAjJ,eAAYuH,CAAAA,OAAZ,CAAoBsB,QAApB,IAAgC7I,WAAYkJ,CAAAA,qBAAZ,CAAkCJ,cAAeK,CAAAA,WAAjD,CAAhC,EAA+F,4CAA/F,CAAA;AACA,QAAIC,eAAe,CAAfA,GAAmBL,MAAvB;AAIAK,gBAAA,GAAeC,KAAA,CAAMP,cAAeQ,CAAAA,UAArB,EAAiCR,cAAeS,CAAAA,UAAhD,EAA4DH,YAA5D,CAAf;AACAP,YAAA,GAAWQ,KAAA,CAAMP,cAAeU,CAAAA,WAArB,EAAkCV,cAAeK,CAAAA,WAAjD,EAA8DnJ,WAAYyJ,CAAAA,qBAAZ,CAAkCZ,QAAlC,CAA9D,CAAX;AACmB,KAAnB,GAAIO,YAAJ,IAIIH,QAQA,GARYS,YAADT,IAAkB;AACzB,YAAMU,mBAAmBD,YAAnBC,GAAkCP,YAAxC;AAKA,aArBIQ,KAqBJ,IAHUD,gBAGV,GAH6BlQ,QAG7B,KAF0BiQ,YAE1B,GAwDczM,IAAK4M,CAAAA,IAAL,CAAU,CAAV,GA1D0BT,YA0D1B,GA1D0BA,YA0D1B,CAxDd,IADUnM,IAAK6M,CAAAA,GAALC,CAAS,EAHLJ,gBAGK,GAHcd,QAGd,CAATkB,CACV;AANyB,KAQ7B,EAAAC,MAAA,GAAcN,YAADM,IAAkB;AAE3B,UAAMjP,QADmB2O,YACnB3O,GADkCqO,YAClCrO,GAA2B8N,QAAjC;AACA,YAAMoB,IAAIlP,KAAJkP,GAAYxQ,QAAZwQ,GAAuBxQ,QAA7B,EACMyQ,IAAIjN,IAAKkN,CAAAA,GAAL,CAASf,YAAT,EAAuB,CAAvB,CAAJc,GAAgCjN,IAAKkN,CAAAA,GAAL,CAAST,YAAT,EAAuB,CAAvB,CAAhCQ,GAA4DrB,QADlE;AAEMuB,WAAAA,GAAInN,IAAK6M,CAAAA,GAAL,CAAS,CAAC/O,KAAV,CAAJqP;AACN,YAAMC,IAAoBpN,IAAKkN,CAAAA,GAALT,CAASA,YAATA,EAAuB,CAAvBA,CAApBW,GAgDQpN,IAAK4M,CAAAA,IAAL,CAAU,CAAV,GAhDuCT,YAgDvC,GAhDuCA,YAgDvC,CAhDd;AAEA,cADmD,CAApCkB,GAAA,CAACrB,QAAA,CAASS,YAAT,CAADY,GA9BXV,KA8BWU,GAAwC,CAAC,CAAzCA,GAA6C,CAC5D,KAAmBL,CAAnB,GAAuBC,CAAvB,IAA4BE,KAA5B,GAAkCC,CAAlC;AAR2B,KAZnC,KA2BIpB,QAKA,GALYS,YAADT,IAGA,CAzCHW,KAsCGX,GACGhM,IAAK6M,CAAAA,GAAL3C,CAAS,CAACuC,YAAVvC,GAAyB0B,QAAzB1B,CADH8B,KAEIS,YAFJT,GAEmBxP,QAFnBwP,IAE+BJ,QAF/BI,GAE0C,CAF1CA,CAKX,EAAAe,MAAA,GAAcN,YAADM,IACC/M,IAAK6M,CAAAA,GAAL3C,CAAS,CAACuC,YAAVvC,GAAyB0B,QAAzB1B,CADD6C,IAEEvQ,QAFFuQ,GAEaN,YAFbM,IAE8BnB,QAF9BmB,GAEyCnB,QAlC1D,CAAA;AAuCMa,UAAAA,GAAea,eAAA,CAAgBtB,QAAhB,EAA0Be,MAA1B,EADA,CACA,GADInB,QACJ,CAAfa;AACNb,YAAA,GAAW7I,WAAYkJ,CAAAA,qBAAZ,CAAkCL,QAAlC,CAAX;AACA,QAAI2B,KAAA,CAAMd,MAAN,CAAJ;AACI,aAAO,CACHe,UAAW3B,cAAe2B,CAAAA,SADvB,EAEHC,QAAS5B,cAAe4B,CAAAA,OAFrB,EAGH7B,QAHG,CAAP;AADJ;AAQU4B,UAAAA,GAAYxN,IAAKkN,CAAAA,GAAL,CAAST,MAAT,EAAuB,CAAvB,CAAZe,GAAwCzB,IAAxCyB;AACN,WAAO,CACHA,UAAAA,MADG,EAEHC,QAAwB,CAAxBA,GAAStB,YAATsB,GAA4BzN,IAAK4M,CAAAA,IAAL,CAAUb,IAAV,GAAiByB,MAAjB,CAFzB,EAGH5B,QAHG,CAAP;AA5DqJ;AAoE7J0B,UAASA,gBAAe,CAACtB,QAAD,EAAWe,UAAX,EAAuBW,YAAvB,CAAqC;AAEzD,SAAK,IAAItN,IAAI,CAAb,EAHmBuN,EAGnB,GAAgBvN,CAAhB,EAAoCA,CAAA,EAApC;AACawN,kBAAT,IAAkB5B,QAAA,CAAS4B,YAAT,CAAlB,GAAqCb,UAAA,CAAWa,YAAX,CAArC;AADJ;AAGA,WAAOA,YAAP;AALyD;AAa7DC,UAASA,aAAY,CAACpM,OAAD,EAAUqM,IAAV,CAAgB;AACjC,WAAOA,IAAKC,CAAAA,IAAL,CAAW/R,GAAD,IAA0BS,IAAAA,EAA1B,KAASgF,OAAA,CAAQzF,GAAR,CAAnB,CAAP;AADiC;AAGrCgS,UAASA,iBAAgB,CAACvM,OAAD,CAAU;AAC/B,QAAIwM,gBAAgB,CAChBzR,SAAUqP,cAAerP,CAAAA,QADT,EAEhBgR,UAAW3B,cAAe2B,CAAAA,SAFV,EAGhBC,QAAS5B,cAAe4B,CAAAA,OAHR,EAIhB1B,KAAMF,cAAeE,CAAAA,IAJL,EAKhBmC,uBAAwB,CAAA,CALR,EAMhB,GAAGzM,OANa,CAApB;AASA,QAAI,CAACoM,YAAA,CAAapM,OAAb,EAAsB0M,WAAtB,CAAL,IACIN,YAAA,CAAapM,OAAb,EAAsB2M,YAAtB,CADJ;AAEI,UAAI3M,OAAQ4M,CAAAA,cAAZ,CAA4B;AAExB,YAAMC,OAAQ,CAARA,GAAYtO,IAAKuO,CAAAA,EAAjBD,IAAyC,GAAzCA,GADiB7M,OAAQ4M,CAAAA,cACzBC,CAAN;AACkBA,YAAZd,IAAmBc,IAAnBd;AACAC,eAAAA,GAAU,CAAVA,GACFrB,KAAA,CAAM,IAAN,EAAY,CAAZ,EAAe,CAAf,IAAoB3K,OAAQqK,CAAAA,MAA5B,IAAsC,CAAtC,EADE2B,GAEFzN,IAAK4M,CAAAA,IAAL,CAAUY,IAAV,CAFEC;AAGNQ,qBAAA,GAAgB,CACZ,GAAGA,aADS,EAEZlC,KAAMF,cAAeE,CAAAA,IAFT,EAGZyB,UAAAA,IAHY,EAIZC,QAAAA,OAJY,CAAhB;AAPwB,OAA5B;AAeUe,eACN,GADgB7C,UAAA,CAAWlK,OAAX,CAChB,EAAAwM,aAAA,GAAgB,CACZ,GAAGA,aADS,EAEZ,GAAGO,OAFS,EAGZzC,KAAMF,cAAeE,CAAAA,IAHT,EAKhB,uBAAuC,CAAA,CALvB,CAAhB;AAhBJ;AAFJ;AA0BA,WAAOkC,aAAP;AApC+B;AAsCnCQ,UAASA,OAAM,CAACC,uBAAA,GAA0B7C,cAAewC,CAAAA,cAA1C,EAA0DvC,MAAA,GAASD,cAAeC,CAAAA,MAAlF,CAA0F;AAC/FrK,2BAAAA,GAA6C,QAAnC,KAAA,MAAOiN,wBAAP,GACV,CACEL,eAAgBK,uBADlB,EAEE1F,UAAW,CAAC,CAAD,EAAI,CAAJ,CAFb,EAGE8C,MAHF,CADU,GAMV4C,uBANAjN;AAON,QAAI,CAAEkN,SAAF,EAAaC,SAAb,CAAA,GAA2BnN,uBAA/B;AACMiJ,UAAAA,GAASjJ,uBAAQuH,CAAAA,SAAR,CAAkB,CAAlB,CAAT0B;AACN,UAAM3I,SAASN,uBAAQuH,CAAAA,SAAR,CAAkBvH,uBAAQuH,CAAAA,SAAU3I,CAAAA,MAApC,GAA6C,CAA7C,CAAf,EAKMzE,QAAQ,CAAEiT,KAAM,CAAA,CAAR,EAAe9S,MAAO2O,MAAtB,CALd,EAMM,CAAE8C,SAAF,EAAaC,OAAb,EAAsB1B,IAAtB,EAA4BH,QAA5B,EAAsCpP,QAAtC,EAAgD0R,sBAAhD,CAAA,GAA4EF,gBAAA,CAAiB,CAC/F,GAAGvM,uBAD4F,EAE/FjF,SAAU,CAACuG,WAAYyJ,CAAAA,qBAAZ,CAAkC/K,uBAAQjF,CAAAA,QAA1C,IAAsD,CAAtD,CAFoF,CAAjB,CANlF,EAUMsS,kBAAkBtS,QAAlBsS,IAA8B,GAVpC,EAWM3C,eAAesB,OAAftB,IAA0B,CAA1BA,GAA8BnM,IAAK4M,CAAAA,IAAL,CAAUY,SAAV,GAAsBzB,IAAtB,CAA9BI,CAXN,EAYM4C,eAAehN,MAAfgN,GAAwBrE,MAZ9B,EAaMsE,sBAAsBjM,WAAYyJ,CAAAA,qBAAZ,CAAkCxM,IAAK4M,CAAAA,IAAL,CAAUY,SAAV;AAAsBzB,QAAtB,CAAlC,CAb5B;AAqBMkD,2BAAAA,GAA2C,CAA3CA,GAAkBjP,IAAKwD,CAAAA,GAAL,CAASuL,YAAT,CAAlBE;AACNN,aAAA,KAAcA,SAAd,GAA0BM,uBAAA,GACpBpD,cAAe8C,CAAAA,SAAUO,CAAAA,QADL,GAEpBrD,cAAe8C,CAAAA,SAAUQ,CAAAA,OAF/B;AAGAP,aAAA,KAAcA,SAAd,GAA0BK,uBAAA,GACpBpD,cAAe+C,CAAAA,SAAUM,CAAAA,QADL,GAEpBrD,cAAe+C,CAAAA,SAAUO,CAAAA,OAF/B;AAGA,QAAIC,aAAJ;AACA,QAAmB,CAAnB,GAAIjD,YAAJ,CAAsB;AAClB,YAAMkD,cAA8BL,mBAA9BK,GAtFYrP,IAAK4M,CAAAA,IAAL,CAAU,CAAV,GAsFuCT,YAtFvC,GAsFuCA,YAtFvC,CAsFlB;AAEAiD,mBAAA,GAAiBnM,CAADmM,IAEJrN,MAFIqN,GACKpP,IAAK6M,CAAAA,GAALb,CAAS,CAACG,YAAVH,GAAyBgD,mBAAzBhD,GAA+C/I,CAA/C+I,CADLoD,KAIDN,eAJCM,GAKAjD,YALAiD,GAKeJ,mBALfI,GAKqCL,YALrCK,IAMAC,WANAD,GAOApP,IAAKsP,CAAAA,GAAL,CAASD,WAAT,GAAuBpM,CAAvB,CAPAmM,GAQAL,YARAK,GAQepP,IAAKuP,CAAAA,GAAL,CAASF,WAAT,GAAuBpM,CAAvB,CARfmM,CAAhB;AAHkB,KAAtB,KAcK,KAAqB,CAArB,KAAIjD,YAAJ;AAEDiD,mBAAA,GAAiBnM,CAADmM,IAAOrN,MAAPqN,GACZpP,IAAK6M,CAAAA,GAAL,CAAS,CAACmC,mBAAV,GAAgC/L,CAAhC,CADYmM,IAEPL,YAFOK,IAGHN,eAHGM,GAGeJ,mBAHfI,GAGqCL,YAHrCK,IAGqDnM,CAHrDmM,CAAhB;AAFC,UAOA;AAED,YAAMI,oBAAoBR,mBAApBQ,GAA0CxP,IAAK4M,CAAAA,IAAL,CAAUT,YAAV,GAAyBA,YAAzB,GAAwC,CAAxC,CAAhD;AACAiD,mBAAA,GAAiBnM,CAADmM,IAAO;AAGnB,cAAMK,WAAWzP,IAAKE,CAAAA,GAAL,CAASsP,iBAAT,GAA6BvM,CAA7B,EAAgC,GAAhC,CAAjB;AACA,eAAQlB,MAAR,GAHiB/B,IAAK6M,CAAAA,GAALb,CAAS,CAACG,YAAVH,GAAyBgD,mBAAzBhD,GAA+C/I,CAA/C+I,CAGjB,KAEU8C,eAFV,GAGY3C,YAHZ,GAG2B6C,mBAH3B,GAGiDD,YAHjD,IAIY/O,IAAK0P,CAAAA,IAAL,CAAUD,QAAV,CAJZ,GAKYD,iBALZ,GAMgBT,YANhB,GAOgB/O,IAAK2P,CAAAA,IAAL,CAAUF,QAAV,CAPhB,IAQQD,iBARR;AAJmB,OAAvB;AAHC;AAkBL,UAAMI,YAAY,CACdC,mBAAoB3B,sBAAA,GAAyBtC,QAAzB,IAAqC,IAArC,GAA4C,IADlD,EAEdkE,KAAO7M,CAAD6M,IAAO;AACT,YAAMvT,UAAU6S,aAAA,CAAcnM,CAAd,CAAhB;AACA,UAAKiL,sBAAL;AAmBItS,aAAMiT,CAAAA,IAAN,GAAa5L,CAAb,IAAkB2I,QAAlB;AAnBJ,YAA6B;AACzB,YAAImE,kBAAkB,GAAtB;AAMmB,SAAnB,GAAI5D,YAAJ,KACI4D,eADJ,GAEc,CAAN,KAAA9M,CAAA,GACMF,WAAYkJ,CAAAA,qBAAZ,CAAkC6C,eAAlC,CADN,GAEMvD,qBAAA,CAAsB6D,aAAtB,EAAqCnM,CAArC,EAAwC1G,OAAxC,CAJd;AAOMyT,SAAAA,GAA+BhQ,IAAKwD,CAAAA,GAAL,CAASzB,MAAT,GAAkBxF,OAAlB,CAA/ByT,IAA6DpB,SAA7DoB;AACNpU,aAAMiT,CAAAA,IAAN,GAFiC7O,IAAKwD,CAAAA,GAAL,CAASuM,eAAT,CAEjC,IAF8DpB,SAE9D,IACgCqB,CADhC;AAfyB;AAqB7BpU,WAAMG,CAAAA,KAAN,GAAcH,KAAMiT,CAAAA,IAAN,GAAa9M,MAAb,GAAsBxF,OAApC;AACA,aAAOX,KAAP;AAxBS,KAFC,EA4BduI,SAAU,EAAAA,IAAM;AACZ,YAAM0L,qBAAqB7P,IAAKE,CAAAA,GAAL,CAAS+P,SAAUC,CAAAA,qBAAV,CAAgCN,SAAhC,CAAT,EAAqDK,SAAUE,CAAAA,oBAA/D,CAA3B,EACMC,SAASH,SAAUI,CAAAA,oBAAV,CAAgCC,QAAD,IAAcV,SAAUE,CAAAA,IAAV/T,CAAe8T,kBAAf9T,GAAoCuU,QAApCvU,CAA8CA,CAAAA,KAA3F,EAAkG8T,kBAAlG,EAAsH,EAAtH,CADf;AAEA,aAAOA,kBAAP,GAA4B,KAA5B,GAAoCO,MAApC;AAHY,KA5BF,CAAlB;AAkCA,WAAOR,SAAP;AAhHqG;AAmHzGW,UAASA,QAAO,CAAC,CAAEvH,SAAF,EAAaxM,QAAA,GAAW,GAAxB,EAA6BgU,KAAA,GAAQ,GAArC,EAA0CC,YAAA,GAAe,GAAzD,EAA8DC,aAAA,GAAgB,EAA9E,EAAkFC,eAAA,GAAkB,GAApG,EAAyGC,YAAzG,EAAuH1Q,GAAvH,EAA4HD,GAA5H,EAAiI2O,SAAA,GAAY,GAA7I,EAAkJD,SAAlJ,CAAD,CAAiK;AACvKjE,aAAAA,GAAS1B,SAAA,CAAU,CAAV,CAAT0B;AACN,UAAM9O,QAAQ,CACViT,KAAM,CAAA,CADI,EAEV9S,MAAO2O,SAFG,CAAd;AAYA,QAAImG,YAAYL,KAAZK,GAAoBrU,QAAxB;AACMsU,YAAAA,GAAQpG,SAARoG,GAAiBD,SAAjBC;AACN,UAAM/O,SAA0BtF,IAAAA,EAAjB,KAAAmU,YAAA,GAA6BE,QAA7B,GAAqCF,YAAA,CAAaE,QAAb,CAApD;AAKI/O,UAAJ,KAAe+O,QAAf,KACID,SADJ,GACgB9O,MADhB,GACyB2I,SADzB;AAGA,UAAMqG,aAAc9N,CAAD8N,IAAOhP,MAAPgP,GADM,CAACF,SACPE,GADmB/Q,IAAK6M,CAAAA,GAAL,CAAS,CACF5J,CADP,GAAcwN,YAAd,CACtC,EACMO,gBAAiB/N,CAAD+N,IAAO;AAEzB,YAAMC,SAHgBlP,MAGhBkP,GAJe,CAACJ,SAIhBI,GAJ4BjR,IAAK6M,CAAAA,GAAL,CAAS,CAIjB5J,CAJQ,GAAcwN,YAAd,CAIlC;AACA7U,WAAMiT,CAAAA,IAAN,GAAa7O,IAAKwD,CAAAA,GAAL,CALQ,CAACqN,SAKT,GALqB7Q,IAAK6M,CAAAA,GAAL,CAAS,CAGnB5J,CAHU,GAAcwN,YAAd,CAKrB,CAAb,IAAgC7B,SAAhC;AACAhT,WAAMG,CAAAA,KAAN,GAAcH,KAAMiT,CAAAA,IAAN,GAAa9M,MAAb,GAAsBkP,MAApC;AAJyB,KAD7B;AAaA,QAAIC,mBAAJ,EACIC,QADJ;AAEA,UAAMC,qBAAsBnO,CAADmO,IAAO;AACLrV,UAAAA,IAANH,KAAMG,CAAAA,KAAAA;AAAzB,UAlCkCU,IAAAA,EAkClC,KAlC0ByD,GAkC1B,IAlC+C1E,CAkC/C,GAlCmD0E,GAkCnD,IAlCoEzD,IAAAA,EAkCpE,KAlC4DwD,GAkC5D,IAlCiFzE,CAkCjF,GAlCqFyE,GAkCrF,CAAA;AAEAiR,2BAAA,GAAsBjO,CAAtB;AAEsBlH,SAAAA,GAANH,KAAMG,CAAAA,KAAAA;AAA6BA,YAAAA,2BAANH,KAAMG,CAAAA,KAAAA;AAnC/C,gCAAA,GADQU,IAAAA,EAAZ,KAAIyD,GAAJ,GACWD,GADX,GAEYxD,IAAAA,EAAZ,KAAIwD,GAAJ,GACWC,GADX,GAEOF,IAAKwD,CAAAA,GAAL,CAAStD,GAAT,GAAe1E,wBAAf,CAAA,GAAoBwE,IAAKwD,CAAAA,GAAL,CAASvD,GAAT,GAAezE,wBAAf,CAApB,GAAwC0E,GAAxC,GAA8CD,GAHjD;AAkCJkR,gBAAA,GAAW1C,MAAA,CAAO,CACdzF,UAAW,CAAOjN,CAAP,EAAc,wBAAd,CADG,EAEdS,SAAU+O,qBAAA,CAAsBwF,UAAtB,EAAkC9N,CAAlC,EAAqCrH,KAAMG,CAAAA,KAA3C,CAFI,EAGd0R,QAASiD,aAHK,EAIdlD,UAAWmD,eAJG,EAKd/B,SALc,EAMdD,SANc,CAAP,CAAX;AAHA;AAD8B,KAAlC;AAaAyC,sBAAA,CAAmB,CAAnB,CAAA;AACA,WAAO,CACHvB,mBAAoB,IADjB,EAEHC,KAAO7M,CAAD6M,IAAO;AAOT,UAAIuB,kBAAkB,CAAA,CAAtB;AACKF,cAAL,IAAyC1U,IAAAA,EAAzC,KAAiByU,mBAAjB,KACIG,eAEA,GAFkB,CAAA,CAElB,EADAL,aAAA,CAAc/N,CAAd,CACA,EAAAmO,kBAAA,CAAmBnO,CAAnB,CAHJ;AASA,UAA4BxG,IAAAA,EAA5B,KAAIyU,mBAAJ,IAAyCjO,CAAzC,IAA8CiO,mBAA9C;AACI,eAAOC,QAASrB,CAAAA,IAAT,CAAc7M,CAAd,GAAkBiO,mBAAlB,CAAP;AADJ;AAII,OAACG,eAAD,IAAoBL,aAAA,CAAc/N,CAAd,CAApB;AACA,aAAOrH,KAAP;AAtBK,KAFV,CAAP;AArD6K;AAuHjL0V,UAASA,aAAY,CAAChM,MAAD,EAASiM,IAAT,EAAeC,WAAf,CAA4B;AAC7C,UAAMC,SAAS,EAAf;AACMC,eAAAA,GAAeF,WAAfE,IAA8BtG,GAA9BsG;AACN,UAAMC,YAAYrM,MAAOjF,CAAAA,MAAnBsR,GAA4B,CAAlC;AACA,SAAK,IAAIvR,IAAI,CAAb,EAAgBA,CAAhB,GAAoBuR,SAApB,EAA+BvR,CAAA,EAA/B,CAAoC;AAChC,UAAIkL,QAAQoG,WAAA,CAAapM,MAAA,CAAOlF,CAAP,CAAb,EAAwBkF,MAAA,CAAOlF,CAAP,GAAW,CAAX,CAAxB,CAAZ;AACImR,UAAJ,KAEIjG,KAFJ,GAEiBsG,CADU5P,KAAMC,CAAAA,OAAN,CAAcsP,IAAd,CAAAK,GAAsBL,IAAA,CAAKnR,CAAL,CAAtBwR,IAAiC7O,WAAYC,CAAAA,IAA7C4O,GAAoDL,IAC9DK,EAAgBtG,KAAhBsG,CA3fsBzS,CAAAA,MAAb,CAAoB0S,gBAApB,CAyf1B;AAIAJ,YAAO/S,CAAAA,IAAP,CAAY4M,KAAZ,CAAA;AANgC;AAQpC,WAAOmG,MAAP;AAZ6C;AAiCjDK,UAASA,YAAW,CAACC,KAAD,EAAQzM,MAAR,EAAgB,CAAE,MAAO0M,OAAA,GAAU,CAAA,CAAnB,EAAyBT,IAAzB,EAA+BjG,KAA/B,CAAA,GAAyC,EAAzD,CAA6D;AAC7E,UAAM2G,cAAcF,KAAM1R,CAAAA,MAA1B;AACA0C,eAAYmF,CAAAA,SAAZ,CAAsB+J,WAAtB,KAAsC3M,MAAOjF,CAAAA,MAA7C,EAAqD,sDAArD,CAAA;AAKA,QAAoB,CAApB,KAAI4R,WAAJ;AACI,aAAO,EAAA,IAAM3M,MAAA,CAAO,CAAP,CAAb;AADJ;AAEA,QAAoB,CAApB,KAAI2M,WAAJ,IAAyB3M,MAAA,CAAO,CAAP,CAAzB,KAAuCA,MAAA,CAAO,CAAP,CAAvC;AACI,aAAO,EAAA,IAAMA,MAAA,CAAO,CAAP,CAAb;AADJ;AAEA,UAAM4M,mBAAmBH,KAAA,CAAM,CAAN,CAAnBG,KAAgCH,KAAA,CAAM,CAAN,CAAtC;AAEIA,SAAA,CAAM,CAAN,CAAJ,GAAeA,KAAA,CAAME,WAAN,GAAoB,CAApB,CAAf,KACIF,KACA,GADQ,CAAC,GAAGA,KAAJ,CAAWI,CAAAA,OAAX,EACR,EAAA7M,MAAA,GAAS,CAAC,GAAGA,MAAJ,CAAY6M,CAAAA,OAAZ,EAFb;AAIA,UAAMV,SAASH,YAAA,CAAahM,MAAb,EAAqBiM,IAArB,EAA2BjG,KAA3B,CAAf,EACMqG,YAAYF,MAAOpR,CAAAA,MADzB,EAEM+R,eAAgB5W,CAAD4W,IAAO;AACxB,UAAIF,gBAAJ,IAAwB1W,CAAxB,GAA4BuW,KAAA,CAAM,CAAN,CAA5B;AACI,eAAOzM,MAAA,CAAO,CAAP,CAAP;AADJ;AAEA,UAAIlF,IAAI,CAAR;AACA,UAAgB,CAAhB,GAAIuR,SAAJ;AACI,aAAA,EAAOvR,CAAP,GAAW2R,KAAM1R,CAAAA,MAAjB,GAA0B,CAA1B,IACQ,EAAA7E,CAAA,GAAIuW,KAAA,CAAM3R,CAAN,GAAU,CAAV,CAAJ,CADR,EAA6BA,CAAA,EAA7B;;AADJ;AAMMiS,OAAAA,GAAkBtP,WAAYuN,CAAAA,QAAZ,CAAqByB,KAAA,CAAM3R,CAAN,CAArB,EAA+B2R,KAAA,CAAM3R,CAAN,GAAU,CAAV,CAA/B,EAA6C5E,CAA7C,CAAlB6W;AACN,aAAOZ,MAAA,CAAOrR,CAAP,CAAA,CAAUiS,CAAV,CAAP;AAXwB,KAF5B;AAeA,WAAOL,OAAA,GACAxW,CAAD,IAAO4W,YAAA,CAAahG,KAAA,CAAM2F,KAAA,CAAM,CAAN,CAAN,EAAgBA,KAAA,CAAME,WAAN,GAAoB,CAApB,CAAhB,EAAwCzW,CAAxC,CAAb,CADN,GAED4W,YAFN;AAhC6E;AAqCjFE,UAASA,WAAU,CAACC,MAAD,EAASC,SAAT,CAAoB;AACnC,UAAMtS,MAAMqS,MAAA,CAAOA,MAAOlS,CAAAA,MAAd,GAAuB,CAAvB,CAAZ;AACA,SAAK,IAAID,IAAI,CAAb,EAAgBA,CAAhB,IAAqBoS,SAArB,EAAgCpS,CAAA,EAAhC,CAAqC;AACjC,YAAMqS,iBAAiB1P,WAAYuN,CAAAA,QAAZ,CAAqB,CAArB,EAAwBkC,SAAxB,EAAmCpS,CAAnC,CAAvB;AACAmS,YAAO7T,CAAAA,IAAP,CAAwBwB,GAAxB,IAA6BmL,CAA7B,GAAwBnL,GAAxB,IAAgCuS,cAAhC,CAAA;AAFiC;AAFF;AAQvCC,UAASA,cAAa,CAAClS,GAAD,CAAM;AACxB,UAAM+R,SAAS,CAAC,CAAD,CAAf;AACAD,cAAA,CAAWC,MAAX,EAAmB/R,GAAIH,CAAAA,MAAvB,GAAgC,CAAhC,CAAA;AACA,WAAOkS,MAAP;AAHwB;AAM5BI,UAASA,qBAAoB,CAACJ,MAAD,EAAS3G,QAAT,CAAmB;AAC5C,WAAO2G,MAAOrL,CAAAA,GAAP,CAAY0L,CAAD,IAAOA,CAAP,GAAWhH,QAAtB,CAAP;AAD4C;AAIhDiH,UAASA,cAAa,CAAChX,MAAD,EAASuU,MAAT,CAAiB;AACnC,WAAOvU,MAAOqL,CAAAA,GAAP,CAAW,EAAA,IAAMkJ,MAAN,IAAgB0C,SAA3B,CAAsCjS,CAAAA,MAAtC,CAA6C,CAA7C,EAAgDhF,MAAOwE,CAAAA,MAAvD,GAAgE,CAAhE,CAAP;AADmC;AAGvC2I,UAASA,UAAS,CAAC,CAAE4C,QAAA,GAAW,GAAb,EAAkB,UAAWmH,cAA7B,EAA6CC,KAA7C,EAAoDzB,IAAA,GAAO,WAA3D,CAAD,CAA4E;AAKpF0B,QAAAA,GAAkBC,aAAA,CAAc3B,IAAd,CAAA,GAClBA,IAAKrK,CAAAA,GAAL,CAASiM,0BAAT,CADkB,GAElBA,0BAAA,CAA2B5B,IAA3B,CAFA0B;AAON,UAAMrX,QAAQ,CACViT,KAAM,CAAA,CADI,EAEV9S,MAAOgX,cAAA,CAAe,CAAf,CAFG,CAAd;AAOMK,SAAAA,GAAgBT,oBAAA,CAGtBK,KAAA,IAASA,KAAM3S,CAAAA,MAAf,KAA0B0S,cAAe1S,CAAAA,MAAzC,GACM2S,KADN,GAEMN,aAAA,CAAcK,cAAd,CALgB,EAKenH,QALf,CAAhBwH;AAMN,UAAMC,oBAAoBvB,WAAA,CAAYsB,KAAZ,EAA2BL,cAA3B,EAA2C,CACjExB,KAAMvP,KAAMC,CAAAA,OAAN,CAAcgR,IAAd,CAAA,GACAA,IADA,GAEAJ,aAAA,CAAcE,cAAd,EAA8BE,IAA9B,CAH2D,CAA3C,CAA1B;AAKA,WAAO,CACHpD,mBAAoBjE,QADjB,EAEHkE,KAAO7M,CAAD6M,IAAO;AACTlU,WAAMG,CAAAA,KAAN,GAAcsX,iBAAA,CAAkBpQ,CAAlB,CAAd;AACArH,WAAMiT,CAAAA,IAAN,GAAa5L,CAAb,IAAkB2I,QAAlB;AACA,aAAOhQ,KAAP;AAHS,KAFV,CAAP;AA9B0F;AA0b9F0X,UAASA,oBAAmB,CAACnS,OAAD,EAAUoS,SAAV,EAAqBvK,SAArB,EAAgC,CAAEwK,KAAA,GAAQ,CAAV,EAAa5H,QAAA,GAAW,GAAxB,EAA6B3C,MAAA,GAAS,CAAtC,EAAyCC,UAAA,GAAa,MAAtD,EAA8DqI,IAAA,GAAO,WAArE,EAAkFyB,KAAlF,CAAA,GAA6F,EAA7H,CAAiI;AACnJS,aAAAA,GAAkB,CAAE,CAACF,SAAD,EAAavK,SAAf,CAAlByK;AACFT,SAAJ,KACIS,SAAgBlB,CAAAA,MADpB,GAC6BS,KAD7B;AAEM5C,QAAAA,GAASH,SAAUyD,CAAAA,uBAAV,CAAkCnC,IAAlC,EAAwC3F,QAAxC,CAATwE;AAIFpO,SAAMC,CAAAA,OAAN,CAAcmO,IAAd,CAAJ,KACIqD,SAAgBrD,CAAAA,MADpB,GAC6BA,IAD7B;AAUA,WARkBjP,OAAQwS,CAAAA,OAARC,CAAgBH,SAAhBG,EAAiC,CAC/CJ,KAD+C,EAE/C5H,QAF+C,EAG/CwE,OAASpO,KAAMC,CAAAA,OAAN,CAAcmO,IAAd,CAAD,GAAkC,QAAlC,GAAyBA,IAHc,EAI/CyD,KAAM,MAJyC,EAK/CC,WAAY7K,MAAZ6K,GAAqB,CAL0B,EAM/CC,UAA0B,SAAf,KAAA7K,UAAA,GAA2B,WAA3B,GAAyC,QANL,CAAjC0K,CAQlB;AAlByJ;AAuC7JI,UAASA,8BAA6B,CAACvS,OAAD,CAAU;AAC5C,WAAQwO,SAAUgE,CAAAA,WAAV,CAAsBxS,OAAQ8D,CAAAA,IAA9B,CAAR,IACqB,QADrB,KACI9D,OAAQ8D,CAAAA,IADZ,IAEI,CAAC0K,SAAUiE,CAAAA,sBAAV,CAAiCzS,OAAQ8P,CAAAA,IAAzC,CAFL;AAD4C;AAKhD4C,UAASA,qBAAoB,CAACnL,SAAD,EAAYvH,OAAZ,CAAqB;AAMxC2S,WAAAA,GAAkB,IAAIC,mBAAJ,CAAwB,CAC5C,GAAG5S,OADyC,EAE5CuH,SAF4C,EAG5CC,OAAQ,CAHoC,EAI5CuK,MAAO,CAJqC,EAK5CS,YAAa,CAAA,CAL+B,CAAxB,CAAlBG;AAOFxY,aAAAA,GAAQ,CAAEiT,KAAM,CAAA,CAAR,EAAe9S,MAAOiN,SAAA,CAAU,CAAV,CAAtB,CAARpN;AACJ,UAAM0Y,wBAAwB,EAA9B;AAKA,QAAIrR,IAAI,CAAR;AACA,SAAA,EAAO,CAACrH,SAAMiT,CAAAA,IAAd,IA/BgB3C,KA+BhB,GAAsBjJ,CAAtB,CAAA;AACIrH,eAEA,GAFQwY,OAAgBG,CAAAA,MAAhB,CAAuBtR,CAAvB,CAER,EADAqR,qBAAsB5V,CAAAA,IAAtB,CAA2B9C,SAAMG,CAAAA,KAAjC,CACA,EAAAkH,CAAA,IAvCYuR,EAuCZ;AAHJ;AAKA,WAAO,CACHxB,MAAOvW,IAAAA,EADJ,EAEHuM,UAAWsL,qBAFR,EAGH1I,SAAU3I,CAAV2I,GA5CY4I,EAyCT,EAIHjD,KAAM,QAJH,CAAP;AAzB8C;AAoUlDkD,UAASA,oBAAmB,CAAC,CAAEC,IAAF,EAAQ,MAAOC,MAAf,EAAuBC,aAAvB,EAAsCC,eAAtC,EAAuDC,gBAAvD,EAAyE7L,MAAzE,EAAiFC,UAAjF,EAA6F6L,WAA7F,EAA0GlO,IAA1G,EAAgHmO,OAAhH,EAAyH,GAAGlT,UAA5H,CAAD,CAA2I;AACnK,WAAO,CAAC,CAACmT,MAAOnH,CAAAA,IAAP,CAAYhM,UAAZ,CAAwBzB,CAAAA,MAAjC;AADmK;AA8GvK6U,UAASA,qBAAoB,CAAC,CAAEC,aAAF,EAAiBC,cAAjB,CAAD,EAAoCpZ,GAApC,CAAyC;AAC5DqZ,iBAAAA,GAAcF,aAAcG,CAAAA,cAAd,CAA6BtZ,GAA7B,CAAdqZ,IAA2E,CAAA,CAA3EA,KAAmDD,cAAA,CAAepZ,GAAf,CAAnDqZ;AACND,kBAAA,CAAepZ,GAAf,CAAA,GAAsB,CAAA,CAAtB;AACA,WAAOqZ,aAAP;AAHkE;AAKtEE,UAASA,cAAa,CAAC5Z,aAAD,EAAgB6Z,mBAAhB,EAAqC,CAAEhC,KAAA,GAAQ,CAAV,EAAaiC,kBAAb,EAAiClQ,IAAjC,CAAA,GAA0C,EAA/E,CAAmF;AACrG,QAAIgC,EAAJ;AACA,QAAI,CAAEzF,UAAA,GAAanG,aAAc+Z,CAAAA,oBAAd,EAAf,EAAqD7T,aAArD,EAAoE,GAAGE,MAAvE,CAAA,GAAkFyT,mBAAtF;AACIC,sBAAJ,KACI3T,UADJ,GACiB2T,kBADjB;AAEME,uBAAAA,GAAa,EAAbA;AACAC,QAAAA,GAAqBrQ,IAArBqQ,IACFja,aAAcka,CAAAA,cADZD,IAEFja,aAAcka,CAAAA,cAAeC,CAAAA,QAA7B,EAAA,CAAwCvQ,IAAxC,CAFEqQ;AAGN,SAAK,MAAM5Z,GAAX,GAAkB+F,OAAlB,CAA0B;AAChBhG,wBAAAA,GAAQJ,aAAcwG,CAAAA,QAAd,CAAuBnG,GAAvB,EAAuE,IAA3C,MAACuL,EAAD,GAAM5L,aAAcoa,CAAAA,YAAd,CAA2B/Z,GAA3B,CAAN,KAA0D,IAAK,EAA/D,KAAmDuL,EAAnD,GAAmEA,EAAnE,GAAwE,IAApG,CAARxL;AACN,YAAMia,cAAcjU,MAAA,CAAO/F,GAAP,CAApB;AACA,UAAoBS,IAAAA,EAApB,KAAIuZ,WAAJ,IACKJ,IADL,IAEQV,oBAAA,CAAqBU,IAArB,EAAyC5Z,GAAzC,CAFR;AAGI;AAHJ;AAKA,YAAMia,kBAAkB,CACpBzC,KADoB,EAEpB,GAAGvD,SAAUiG,CAAAA,kBAAV,CAA6BpU,UAA7B,IAA2C,EAA3C,EAA+C9F,GAA/C,CAFiB,CAAxB;AAQA,UAAIma,YAAY,CAAA,CAAhB;AACA,UAAIzO,MAAO0O,CAAAA,sBAAX,CAAmC;AAC/B,YAAMC,WAAW7T,oBAAA,CAAqB7G,aAArB,CAAjB;AACI0a,gBAAJ,KACUC,QACN,GADkB5O,MAAO0O,CAAAA,sBAAP,CAA8BC,QAA9B,EAAwCra,GAAxC,EAA6Cua,KAA7C,CAClB,EAAkB,IAAlB,KAAID,QAAJ,KACIL,eAAgBK,CAAAA,SAChB,GAD4BA,QAC5B,EAAAH,SAAA,GAAY,CAAA,CAFhB,CAFJ;AAF+B;AAUnC7T,0BAAA,CAAqB3G,aAArB,EAAoCK,GAApC,CAAA;AACAD,wBAAMN,CAAAA,KAAN,CAAY+a,kBAAA,CAAmBxa,GAAnB,EAAwBD,kBAAxB,EAA+Bia,WAA/B,EAA4Cra,aAAc8a,CAAAA,kBAAd,IAAoCC,cAAevZ,CAAAA,GAAf,CAAmBnB,GAAnB,CAApC,GAClD,CAAEuJ,KAAM,CAAA,CAAR,CADkD,GAElD0Q,eAFM,EAEWta,aAFX,EAE0Bwa,SAF1B,CAAZ,CAAA;AAIA,OADMvC,kBACN,GADkB7X,kBAAM6X,CAAAA,SACxB,KACI+B,mBAAWjX,CAAAA,IAAX,CAAgBkV,kBAAhB,CADJ;AAhCsB;AAoCtB/R,iBAAJ,IACI8U,OAAQC,CAAAA,GAAR,CAAYjB,mBAAZ,CAAwBkB,CAAAA,IAAxB,CAA6B,EAAA,IAAM;AAC/BN,WAAMhX,CAAAA,MAAN,CAAa,EAAA,IAAM;AACfsC,qBAAA,IAAiBF,SAAA,CAAUhG,aAAV,EAAyBkG,aAAzB,CAAjB;AADe,OAAnB,CAAA;AAD+B,KAAnC,CADJ;AAOA,WAAO8T,mBAAP;AApDqG;AAuDzGmB,UAASA,eAAc,CAACnb,aAAD,EAAgBob,OAAhB,EAAyBtV,OAAA,GAAU,EAAnC,CAAuC;AAC1D,QAAI8F,EAAJ;AACA,UAAM3F,WAAWjF,cAAA,CAAehB,aAAf,EAA8Bob,OAA9B,EAAwD,MAAjB,KAAAtV,OAAQ8D,CAAAA,IAAR,GACT,IAAzC,MAACgC,EAAD,GAAM5L,aAAcqb,CAAAA,eAApB,KAAwD,IAAK,EAA7D,KAAiDzP,EAAjD,GAAiE,IAAK,EAAtE,GAA0EA,EAAGjL,CAAAA,MAD3B,GAElDG,IAAAA,EAFW,CAAjB;AAGA,QAAI,CAAEqF,UAAA,GAAanG,aAAc+Z,CAAAA,oBAAd,EAAb,IAAqD,EAAvD,CAAA,GAA8D9T,QAA9D,IAA0E,EAA9E;AACIH,WAAQgU,CAAAA,kBAAZ,KACI3T,UADJ,GACiBL,OAAQgU,CAAAA,kBADzB;AAOMwB,MAAAA,GAAerV,QAAA,GACf,EAAA,IAAM+U,OAAQC,CAAAA,GAAR,CAAYrB,aAAA,CAAc5Z,aAAd,EAA6BiG,QAA7B,EAAuCH,OAAvC,CAAZ,CADS,GAEf,EAAA,IAAMkV,OAAQO,CAAAA,OAAR,EAFND;AAON,UAAME,qBAAqBxb,aAAcyb,CAAAA,eAAd,IAAiCzb,aAAcyb,CAAAA,eAAgBC,CAAAA,IAA/D,GACrB,CAACC,YAAA,GAAe,CAAhB,CAAA,IAAsB;AACpB,YAAM,CAAE1C,aAAA,GAAgB,CAAlB,EAAqBC,eAArB,EAAsCC,gBAAtC,CAAA,GAA4DhT,UAAlE;AACA,aAAOyV,eAAA,CAAgB5b,aAAhB,EAA+Bob,OAA/B,EAAwCnC,aAAxC,GAAwD0C,YAAxD,EAAsEzC,eAAtE,EAAuFC,gBAAvF,EAAyGrT,OAAzG,CAAP;AAFoB,KADD,GAKrB,EAAA,IAAMkV,OAAQO,CAAAA,OAAR,EALZ,EAUM,CAAExC,IAAF,CAAA,GAAW5S,UAVjB;AAWA,QAAI4S,IAAJ,CAAU;AACN,YAAM,CAAC8C,KAAD,EAAQC,IAAR,CAAA,GAAyB,gBAAT,KAAA/C,IAAA,GAChB,CAACuC,EAAD,EAAeE,kBAAf,CADgB,GAEhB,CAACA,kBAAD,EAAqBF,EAArB,CAFN;AAGA,aAAOO,KAAA,EAAQX,CAAAA,IAAR,CAAa,EAAA,IAAMY,IAAA,EAAnB,CAAP;AAJM;AAON,WAAOd,OAAQC,CAAAA,GAAR,CAAY,CAACK,EAAA,EAAD,EAAiBE,kBAAA,CAAmB1V,OAAQ+R,CAAAA,KAA3B,CAAjB,CAAZ,CAAP;AAtCsD;AAyC9D+D,UAASA,gBAAe,CAAC5b,aAAD,EAAgBob,OAAhB,EAAyBnC,aAAA,GAAgB,CAAzC,EAA4CC,eAAA,GAAkB,CAA9D,EAAiEC,gBAAA,GAAmB,CAApF,EAAuFrT,OAAvF,CAAgG;AACpH,UAAMkU,aAAa,EAAnB,EACM+B,sBAAsB/b,aAAcyb,CAAAA,eAAgBC,CAAAA,IAApDK,GAA2D,CAA3DA,IAAgE7C,eADtE,EAEM8C,0BAA+C,CAArB,KAAA7C,gBAAA,GAC1B,CAAC1U,CAAA,GAAI,CAAL,CAAA,IAAWA,CAAX,GAAeyU,eADW,GAE1B,CAACzU,CAAA,GAAI,CAAL,CAAA,IAAWsX,kBAAX,GAAgCtX,CAAhC,GAAoCyU,eAJ1C;AAKA7S,SAAM6E,CAAAA,IAAN,CAAWlL,aAAcyb,CAAAA,eAAzB,CACKQ,CAAAA,IADL,CACUC,eADV,CAEK/b,CAAAA,OAFL,CAEa,CAACgc,KAAD,EAAQ1X,CAAR,CAAA,IAAc;AACvB0X,WAAMC,CAAAA,MAAN,CAAa,gBAAb,EAA+BhB,OAA/B,CAAA;AACApB,gBAAWjX,CAAAA,IAAX,CAAgBoY,cAAA,CAAegB,KAAf,EAAsBf,OAAtB,EAA+B,CAC3C,GAAGtV,OADwC,EAE3C+R,MAAOoB,aAAPpB,GAAuBmE,uBAAA,CAAwBvX,CAAxB,CAFoB,CAA/B,CAGbyW,CAAAA,IAHa,CAGR,EAAA,IAAMiB,KAAMC,CAAAA,MAAN,CAAa,mBAAb,EAAkChB,OAAlC,CAHE,CAAhB,CAAA;AAFuB,KAF3B,CAAA;AASA,WAAOJ,OAAQC,CAAAA,GAAR,CAAYjB,UAAZ,CAAP;AAfoH;AAiBxHkC,UAASA,gBAAe,CAAC3N,CAAD,EAAIC,CAAJ,CAAO;AAC3B,WAAOD,CAAE8N,CAAAA,gBAAF,CAAmB7N,CAAnB,CAAP;AAD2B;AAI/B8N,UAASA,qBAAoB,CAACtc,aAAD,EAAgBU,UAAhB,EAA4BoF,OAAA,GAAU,EAAtC,CAA0C;AACnE9F,iBAAcoc,CAAAA,MAAd,CAAqB,gBAArB,EAAuC1b,UAAvC,CAAA;AAEA,QAAI2F,KAAMC,CAAAA,OAAN,CAAc5F,UAAd,CAAJ,CAA+B;AACrBsZ,UAAAA,YAAatZ,UAAW6K,CAAAA,GAAX,CAAgB6P,OAAD,IAAaD,cAAA,CAAenb,aAAf,EAA8Bob,OAA9B,EAAuCtV,OAAvC,CAA5B,CAAbkU;AACN/B,eAAA,GAAY+C,OAAQC,CAAAA,GAAR,CAAYjB,SAAZ,CAAZ;AAF2B,KAA/B;AAI+B,cAA1B,KAAI,MAAOtZ,WAAX,GACDuX,SADC,GACWkD,cAAA,CAAenb,aAAf,EAA8BU,UAA9B,EAA0CoF,OAA1C,CADX,IAIKyW,SAGN,GAHiD,UAAtB,KAAA,MAAO7b,WAAP,GACrBM,cAAA,CAAehB,aAAf,EAA8BU,UAA9B,EAA0CoF,OAAQnF,CAAAA,MAAlD,CADqB,GAErBD,UACN,EAAAuX,SAAA,GAAY+C,OAAQC,CAAAA,GAAR,CAAYrB,aAAA,CAAc5Z,aAAd,EAA6Buc,SAA7B,EAAiDzW,OAAjD,CAAZ,CAPX,CAAA;AAJL;AAaA,WAAOmS,SAAUiD,CAAAA,IAAV,CAAe,EAAA,IAAM;AACxBlb,mBAAcoc,CAAAA,MAAd,CAAqB,mBAArB,EAA0C1b,UAA1C,CAAA;AADwB,KAArB,CAAP;AAhBmE;AAqBvE8b,UAASA,eAAc,CAACrI,IAAD,EAAOsI,IAAP,CAAa;AAChC,QAAI,CAACpW,KAAMC,CAAAA,OAAN,CAAcmW,IAAd,CAAL;AACI,aAAO,CAAA,CAAP;AADJ;AAEA,UAAMC,aAAaD,IAAK/X,CAAAA,MAAxB;AACA,QAAIgY,UAAJ,KAAmBvI,IAAKzP,CAAAA,MAAxB;AACI,aAAO,CAAA,CAAP;AADJ;AAEA,SAAK,IAAID,IAAI,CAAb,EAAgBA,CAAhB,GAAoBiY,UAApB,EAAgCjY,CAAA,EAAhC;AACI,UAAIgY,IAAA,CAAKhY,CAAL,CAAJ,KAAgB0P,IAAA,CAAK1P,CAAL,CAAhB;AACI,eAAO,CAAA,CAAP;AADJ;AADJ;AAIA,WAAO,CAAA,CAAP;AAVgC;AAgBpCkY,UAASA,eAAc,CAAC9c,CAAD,CAAI;AACvB,WAAoB,QAApB,KAAO,MAAOA,EAAd,IAAgCwG,KAAMC,CAAAA,OAAN,CAAczG,CAAd,CAAhC;AADuB;AAgB3B+c,UAASA,kBAAiB,CAAC5c,aAAD,CAAgB;AACtC,QAAKA,aAAL,CAAA;AAEA,UAAI,CAACA,aAAc6c,CAAAA,qBAAnB,CAA0C;AACtC,YAAMC,UAAU9c,aAAc+c,CAAAA,MAAd,GACVH,iBAAA,CAAkB5c,aAAc+c,CAAAA,MAAhC,CADU,IACiC,EADjC,GAEV,EAFN;AAGoCjc,YAAAA,EAApC,KAAId,aAAcS,CAAAA,KAAMuc,CAAAA,OAAxB,KACIF,OAAQE,CAAAA,OADZ,GACsBhd,aAAcS,CAAAA,KAAMuc,CAAAA,OAD1C;AAGA,eAAOF,OAAP;AAPsC;AASpCA,aAAAA,GAAU,EAAVA;AACN,WAAK,IAAIrY,IAAI,CAAb,EAAgBA,CAAhB,GAAoBwY,eAApB,EAAqCxY,CAAA,EAArC,CAA0C;AACtC,cAAMuF,OAAOkT,YAAA,CAAazY,CAAb,CAAb,EACM0Y,OAAOnd,aAAcS,CAAAA,KAAd,CAAoBuJ,IAApB,CADb;AAEA,YAAI2S,cAAA,CAAeQ,IAAf,CAAJ,IAAqC,CAAA,CAArC,KAA4BA,IAA5B;AACIL,iBAAA,CAAQ9S,IAAR,CAAA,GAAgBmT,IAAhB;AADJ;AAHsC;AAO1C,aAAOL,OAAP;AAnBA;AADsC;AAyB1CM,UAASA,YAAW,CAACpd,aAAD,CAAgB;AAChC,WAAQga,UAAD,IAAgBgB,OAAQC,CAAAA,GAAR,CAAYjB,UAAWzO,CAAAA,GAAX,CAAe,CAAC,CAAE0M,SAAF,EAAanS,OAAb,CAAD,CAAA,IAA4BwW,oBAAA,CAAqBtc,aAArB,EAAoCiY,SAApC,EAA+CnS,OAA/C,CAA3C,CAAZ,CAAvB;AADgC;AAGpCuX,UAASA,qBAAoB,CAACrd,aAAD,CAAgB;AAoCzCsd,YAASA,eAAc,CAACC,iBAAD,CAAoB;AACvC,YAAM,CAAE9c,KAAF,CAAA,GAAYT,aAAlB,EACM8c,UAAUF,iBAAA,CAAkB5c,aAAc+c,CAAAA,MAAhC,CAAVD,IAAqD,EAD3D,EAMM9C,aAAa,EANnB,EAWMwD,cAAc,IAAI1b,GAAJ,EAXpB;AAiBA,UAAI2b,kBAAkB,EAAtB,EAKIC,sBAAsBC,QAL1B;AAYA,WAAK,IAAIlZ,IAAI,CAAb,EAAgBA,CAAhB,GAAoBmZ,iBAApB,EAAuCnZ,CAAA,EAAvC,CAA4C;AACxC,cAAMmF,OAAOiU,oBAAA,CAAqBpZ,CAArB,CAAb,EACMqZ,YAAY7d,KAAA,CAAM2J,IAAN,CADlB;AAEA,YAAMuT,OAAuBrc,IAAAA,EAAhB,KAAAL,KAAA,CAAMmJ,IAAN,CAAA,GACPnJ,KAAA,CAAMmJ,IAAN,CADO,GAEPkT,OAAA,CAAQlT,IAAR,CAFN,EAGMmU,gBAAgBpB,cAAA,CAAeQ,IAAf,CAHtB,EAQMa,cAAcpU,IAAA,KAAS2T,iBAAT,GAA6BO,SAAUG,CAAAA,QAAvC,GAAkD,IARtE;AASoB,SAAA,CAApB,KAAID,WAAJ,KACIN,mBADJ,GAC0BjZ,CAD1B;AAQA,YAAIyZ,cAAcf,IAAde,KAAuBpB,OAAA,CAAQlT,IAAR,CAAvBsU,IACAf,IADAe,KACSzd,KAAA,CAAMmJ,IAAN,CADTsU,IAEAH,aAFJ;AAMIG,mBAAJ,IACIC,eADJ,IAEIne,aAAcoe,CAAAA,sBAFlB,KAGIF,WAHJ,GAGkB,CAAA,CAHlB;AASAJ,iBAAUtE,CAAAA,aAAV,GAA0B,CAAE,GAAGiE,eAAL,CAA1B;AAEA,YAEC,CAACK,SAAUG,CAAAA,QAFZ,IAEwC,IAFxC,KAEwBD,WAFxB,IAIK,CAACb,IAJN,IAIc,CAACW,SAAUO,CAAAA,QAJzB,IAMIze,mBAAA,CAAoBud,IAApB,CANJ,IAOoB,SAPpB,KAOI,MAAOA,KAPX;AAQI;AARJ;AAeA,cAAMmB,mBAAmBC,sBAAA,CAAuBT,SAAUO,CAAAA,QAAjC,EAA2ClB,IAA3C,CAAzB;AACA,YAAIqB,oBAAoBF,gBAApBE,IAEC5U,IAFD4U,KAEUjB,iBAFViB,IAGIV,SAAUG,CAAAA,QAHdO,IAII,CAACN,WAJLM,IAKIT,aALJS,IAOC/Z,CAPD+Z,GAOKd,mBAPLc,IAO4BT,aAPhC,EAQIU,uBAAuB,CAAA,CAR3B;AAaMC,qBAAAA,GAAiBrY,KAAMC,CAAAA,OAAN,CAAc6W,IAAd,CAAA,GAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAA9CuB;AAKN,YAAIC,iBAAiBD,aAAelb,CAAAA,MAAf,CAAsBob,uBAAA,CAAwBhV,IAAxB,CAAtB,EAAqD,EAArD,CAArB;AACoB,SAAA,CAApB,KAAIoU,WAAJ,KACIW,cADJ,GACqB,EADrB;AAWA,SAAM,CAAE,mBAAAE,WAAA,GAAqB,EAAvB,CAAN,GAAoCf,SAApC;AACA,YAAMgB,UAAU,CACZ,GAAGD,WADS,EAEZ,GAAGF,cAFS,CAAhB;AAIA,cAAMI,gBAAiB1e,GAAD0e,IAAS;AAC3BP,2BAAA,GAAoB,CAAA,CAApB;AACIhB,qBAAYhc,CAAAA,GAAZ,CAAgBnB,GAAhB,CAAJ,KACIoe,oBACA,GADuB,CAAA,CACvB,EAAAjB,WAAY9a,CAAAA,MAAZ,CAAmBrC,GAAnB,CAFJ;AAIAyd,mBAAUrE,CAAAA,cAAV,CAAyBpZ,GAAzB,CAAA,GAAgC,CAAA,CAAhC;AAEA,cADMuF,GACN,GADoB5F,aAAcwG,CAAAA,QAAd,CAAuBnG,GAAvB,CACpB;AACIuF,eAAYoZ,CAAAA,SAAZ,GAAwB,CAAA,CAAxB;AADJ;AAR2B,SAA/B;AAWA,aAAK,MAAM3e,GAAX,GAAkBye,QAAlB,CAA2B;AACjB3K,iBAAAA,GAAOwK,cAAA,CAAete,GAAf,CAAP8T;AACN,gBAAMsI,OAAOoC,WAAA,CAAmBxe,GAAnB,CAAb;AAEA,cAAIod,eAAgB9D,CAAAA,cAAhB,CAA+BtZ,GAA/B,CAAJ;AACI;AADJ;AAKA,cAAI4e,kBAAkB,CAAA,CAAtB;AAOA,WALIA,eAKJ,GAvgHL5Y,KAAMC,CAAAA,OAAN,CAigH2B6N,OAjgH3B,CAigHK,IAjgHL9N,KAAMC,CAAAA,OAAN,CAigHsDmW,IAjgHtD,CAigHK,GACsB,CAACD,cAAA,CAAerI,OAAf,EAAqBsI,IAArB,CADvB,GAIsBtI,OAJtB,KAI+BsI,IAE/B,IACiB3b,IAAAA,EAAb,KAAIqT,OAAJ,IAAmC,IAAnC,KAA0BA,OAA1B,GAEI4K,aAAA,CAAc1e,GAAd,CAFJ,GAMImd,WAAYhb,CAAAA,GAAZ,CAAgBnC,GAAhB,CAPR,GAUkBS,IAAAA,EAAb,KAAIqT,OAAJ,IAA0BqJ,WAAYhc,CAAAA,GAAZ,CAAgBnB,GAAhB,CAA1B,GAKD0e,aAAA,CAAc1e,GAAd,CALC,GAYDyd,SAAUtE,CAAAA,aAAV,CAAwBnZ,GAAxB,CAZC,GAY8B,CAAA,CAtBnC;AAhBuB;AA6C3Byd,iBAAUO,CAAAA,QAAV,GAAqBlB,IAArB;AACAW,iBAAUe,CAAAA,kBAAV,GAA+BF,cAA/B;AAIIb,iBAAUG,CAAAA,QAAd,KACIR,eADJ,GACsB,CAAE,GAAGA,eAAL,EAAsB,GAAGkB,cAAzB,CADtB;AAGIR,uBAAJ,IAAuBne,aAAckf,CAAAA,qBAArC,KACIV,iBADJ,GACwB,CAAA,CADxB;AAQM/E,YAAAA,GAAiB,EADMyE,WACN,IADqBI,gBACrB,CAAjB7E,IAA0CgF,oBAA1ChF;AACF+E,yBAAJ,IAAyB/E,IAAzB,IACIO,UAAWjX,CAAAA,IAAX,CAAgB,GAAG2b,aAAenT,CAAAA,GAAf,CAAoB0M,SAAD,IAAgB,EACvCA,SADuC,EAElDnS,QAAS,CAAE8D,IAAF,CAFyC,EAAnC,CAAnB,CADJ;AAjKwC;AA6K5C,UAAI4T,WAAY9B,CAAAA,IAAhB,CAAsB;AAClB,cAAMyD,oBAAoB,EAA1B;AAK6B,iBAA7B,KAAI,MAAO1e,MAAMuc,CAAAA,OAAjB,KACUoC,iBADV,GAC8Bpe,cAAA,CAAehB,aAAf,EAA8BqG,KAAMC,CAAAA,OAAN,CAAc7F,KAAMuc,CAAAA,OAApB,CAAA,GAClDvc,KAAMuc,CAAAA,OAAN,CAAc,CAAd,CADkD,GAElDvc,KAAMuc,CAAAA,OAFc,CAD9B,KAI6BoC,iBAAkBjZ,CAAAA,UAJ/C,KAKQgZ,iBAAkBhZ,CAAAA,UAL1B,GAKuCiZ,iBAAkBjZ,CAAAA,UALzD;AAQAqX,mBAAYrd,CAAAA,OAAZ,CAAqBE,GAAD,IAAS;AACzB,gBAAMgf,iBAAiBrf,aAAcsf,CAAAA,aAAd,CAA4Bjf,GAA5B,CAAvB,EACMuF,cAAc5F,aAAcwG,CAAAA,QAAd,CAAuBnG,GAAvB,CADpB;AAEIuF,qBAAJ,KACIA,WAAYoZ,CAAAA,SADhB,GAC4B,CAAA,CAD5B;AAGAG,2BAAA,CAAkB9e,GAAlB,CAAA,GAA4C,IAAnB,KAAAgf,cAAA,IAA8C,IAAK,EAAnD,KAA2BA,cAA3B,GAAuDA,cAAvD,GAAwE,IAAjG;AANyB,SAA7B,CAAA;AAQArF,kBAAWjX,CAAAA,IAAX,CAAgB,CAAEkV,UAAWkH,iBAAb,CAAhB,CAAA;AAtBkB;AAwBlBI,uBAAAA,GAAgB,CAAA,CAAQvF,UAAWtV,CAAAA,MAAnC6a;AACApB,OAAAA,eAAJ,IACuB,CAAA,CADvB,KACK1d,KAAMuc,CAAAA,OADX,IACgCvc,KAAMuc,CAAAA,OADtC,KACkDvc,KAAMuX,CAAAA,OADxD,IAEKhY,aAAcoe,CAAAA,sBAFnB,KAGImB,iBAHJ,GAGoB,CAAA,CAHpB;AAKApB,qBAAA,GAAkB,CAAA,CAAlB;AACA,aAAOoB,iBAAA,GAAgBvH,OAAA,CAAQgC,UAAR,CAAhB,GAAsCgB,OAAQO,CAAAA,OAAR,EAA7C;AA1OuC;AAnC3C,QAAIvD,UAAUoF,WAAA,CAAYpd,aAAZ,CAAd,EACIC,QAAQuf,WAAA,EADZ,EAEIrB,kBAAkB,CAAA,CAFtB;AAOA,UAAMS,0BAA2BhV,IAADgV,IAAU,CAACnb,GAAD,EAAM/C,UAAN,CAAA,IAAqB;AAC3D,UAAIkL,EAAJ;AAIA,UAHM3F,UAGN,GAHiBjF,cAAA,CAAehB,aAAf,EAA8BU,UAA9B,EAAmD,MAAT,KAAAkJ,IAAA,GACZ,IAAzC,MAACgC,EAAD,GAAM5L,aAAcqb,CAAAA,eAApB,KAAwD,IAAK,EAA7D,KAAiDzP,EAAjD,GAAiE,IAAK,EAAtE,GAA0EA,EAAGjL,CAAAA,MADxB,GAErDG,IAAAA,EAFW,CAGjB,CAAc;AACV,cAAM,CAAEqF,UAAF,EAAcD,aAAd,EAA6B,GAAGE,MAAhC,CAAA,GAA2CH,UAAjD;AACAxC,WAAA,GAAM,CAAE,GAAGA,GAAL,EAAU,GAAG2C,MAAb,EAAqB,GAAGF,aAAxB,CAAN;AAFU;AAId,aAAOzC,GAAP;AAT2D,KAA/D;AAyRA,WAAO,CACH6Z,cADG,EAEHmC,UAhBJA,QAAkB,CAAC7V,IAAD,EAAOqU,QAAP,CAAiB;AAC/B,UAAIrS,EAAJ;AAEA,UAAI3L,KAAA,CAAM2J,IAAN,CAAYqU,CAAAA,QAAhB,KAA6BA,QAA7B;AACI,eAAOjD,OAAQO,CAAAA,OAAR,EAAP;AADJ;AAGyC,UAAzC,MAAC3P,EAAD,GAAM5L,aAAcyb,CAAAA,eAApB,KAAwD,IAAK,EAA7D,KAAiD7P,EAAjD,IAA0EA,EAAGzL,CAAAA,OAAH,CAAYgc,KAAD,IAAW;AAAE,YAAIvQ,EAAJ;AAAQ,eAAuC,IAAhC,MAACA,EAAD,GAAMuQ,KAAMjC,CAAAA,cAAZ,KAA+C,IAAK,EAApD,KAAwCtO,EAAxC,GAAwD,IAAK,EAA7D,GAAiEA,EAAG6T,CAAAA,SAAH,CAAa7V,IAAb,EAAmBqU,QAAnB,CAAxE;AAAV,OAAtB,CAA1E;AACAhe,WAAA,CAAM2J,IAAN,CAAYqU,CAAAA,QAAZ,GAAuBA,QAAvB;AACMjE,QAAAA,GAAasD,cAAA,CAAe1T,IAAf,CAAboQ;AACN,WAAK,MAAM3Z,GAAX,GAAkBJ,MAAlB;AACIA,aAAA,CAAMI,GAAN,CAAWmZ,CAAAA,aAAX,GAA2B,EAA3B;AADJ;AAGA,aAAOQ,EAAP;AAZ+B,KAc5B,EAGH0F,mBA7QJA,QAA2B,CAACC,YAAD,CAAe;AACtC3H,aAAA,GAAU2H,YAAA,CAAa3f,aAAb,CAAV;AADsC,KA0QnC,EAIHma,SAAU,EAAAA,IAAMla,KAJb,EAKH2f,MAAO,EAAAA,IAAM;AACT3f,WAAA,GAAQuf,WAAA,EAAR;AACArB,qBAAA,GAAkB,CAAA,CAAlB;AAFS,KALV,CAAP;AAjSyC;AA4S7CI,UAASA,uBAAsB,CAAC9B,IAAD,EAAOtI,IAAP,CAAa;AACxC,WAAoB,QAApB,KAAI,MAAOA,KAAX,GACWA,IADX,KACoBsI,IADpB,GAGSpW,KAAMC,CAAAA,OAAN,CAAc6N,IAAd,CAAJ,GACM,CAACqI,cAAA,CAAerI,IAAf,EAAqBsI,IAArB,CADP,GAGE,CAAA,CANP;AADwC;AAS5CoD,UAASA,gBAAe,CAAC5B,QAAA,GAAW,CAAA,CAAZ,CAAmB;AACvC,WAAO,CACHA,QADG,EAEHzE,cAAe,EAFZ,EAGHC,eAAgB,EAHb,EAIHoF,mBAAoB,EAJjB,CAAP;AADuC;AAQ3CW,UAASA,YAAW,EAAG;AACnB,WAAO,CACHxH,QAAS6H,eAAA,CAAgB,CAAA,CAAhB,CADN,EAEHC,YAAaD,eAAA,EAFV,EAGHE,WAAYF,eAAA,EAHT,EAIHG,SAAUH,eAAA,EAJP,EAKHI,UAAWJ,eAAA,EALR,EAMHK,WAAYL,eAAA,EANT,EAOHM,KAAMN,eAAA,EAPH,CAAP;AADmB;AA0HvBO,UAASA,WAAU,CAACC,IAAD,CAAO;AACtB,WAAOA,IAAK/b,CAAAA,GAAZ,GAAkB+b,IAAK9b,CAAAA,GAAvB;AADsB;AAM1B+b,UAASA,cAAa,CAACne,KAAD,EAAQsH,MAAR,EAAgBrD,MAAhB,EAAwB2I,MAAA,GAAS,GAAjC,CAAsC;AACxD5M,SAAM4M,CAAAA,MAAN,GAAeA,MAAf;AACA5M,SAAMoe,CAAAA,WAAN,GAAoBC,WAAA,CAAY/W,MAAOlF,CAAAA,GAAnB,EAAwBkF,MAAOnF,CAAAA,GAA/B,EAAoCnC,KAAM4M,CAAAA,MAA1C,CAApB;AACA5M,SAAMse,CAAAA,KAAN,GAAcL,UAAA,CAAWha,MAAX,CAAd,GAAmCga,UAAA,CAAW3W,MAAX,CAAnC;AACAtH,SAAMue,CAAAA,SAAN,GACIF,WAAA,CAAYpa,MAAO7B,CAAAA,GAAnB,EAAwB6B,MAAO9B,CAAAA,GAA/B,EAAoCnC,KAAM4M,CAAAA,MAA1C,CADJ,GACwD5M,KAAMoe,CAAAA,WAD9D;AAEA,QAjBcI,KAiBd,IAAKxe,KAAMse,CAAAA,KAAX,IAhBcG,MAgBd,IAAiCze,KAAMse,CAAAA,KAAvC,IACI7O,KAAA,CAAMzP,KAAMse,CAAAA,KAAZ,CADJ;AAEIte,WAAMse,CAAAA,KAAN,GAAc,GAAd;AAFJ;AAIA,QAlBkBI,CAAA,GAkBlB,IAAK1e,KAAMue,CAAAA,SAAX,IAjBkBI,GAiBlB,IACI3e,KAAMue,CAAAA,SADV,IAEI9O,KAAA,CAAMzP,KAAMue,CAAAA,SAAZ,CAFJ;AAGIve,WAAMue,CAAAA,SAAN,GAAkB,GAAlB;AAHJ;AAVwD;AAgB5DK,UAASA,aAAY,CAAC5e,KAAD,EAAQsH,MAAR,EAAgBrD,MAAhB,EAAwB2I,MAAxB,CAAgC;AACjDuR,iBAAA,CAAcne,KAAMwF,CAAAA,CAApB,EAAuB8B,MAAO9B,CAAAA,CAA9B,EAAiCvB,MAAOuB,CAAAA,CAAxC,EAA2CoH,MAAA,GAASA,MAAOiS,CAAAA,OAAhB,GAA0BlgB,IAAAA,EAArE,CAAA;AACAwf,iBAAA,CAAcne,KAAM8e,CAAAA,CAApB,EAAuBxX,MAAOwX,CAAAA,CAA9B,EAAiC7a,MAAO6a,CAAAA,CAAxC,EAA2ClS,MAAA,GAASA,MAAOmS,CAAAA,OAAhB,GAA0BpgB,IAAAA,EAArE,CAAA;AAFiD;AAgBrDqgB,UAASA,qBAAoB,CAAC/a,eAAD,EAASgb,eAAT,EAAiBrE,MAAjB,CAAyB;AAClBpV,QAAAA,SAAPvB,eAAOuB,CAAAA,CAAAA,EAAUA,SAAPyZ,eAAOzZ,CAAAA,CAAVA;AAJhCvB,UAAO7B,CAAAA,GAAP,GAAa6c,MAAO7c,CAAAA,GAApB,GAI6CwY,MAAOpV,CAAAA,CAJnBpD,CAAAA,GAAjC;AACA6B,UAAO9B,CAAAA,GAAP,GAAa8B,MAAO7B,CAAAA,GAApB,GAA0B6b,UAAA,CAAWgB,MAAX,CAA1B;AAIgCH,mBAAAA,GAAP7a,eAAO6a,CAAAA,CAAAA;AAAUA,mBAAAA,GAAPG,eAAOH,CAAAA,CAAAA;AAL1C7a,mBAAO7B,CAAAA,GAAP,GAAa6c,eAAO7c,CAAAA,GAApB,GAK6CwY,MAAOkE,CAAAA,CALnB1c,CAAAA,GAAjC;AACA6B,mBAAO9B,CAAAA,GAAP,GAAa8B,eAAO7B,CAAAA,GAApB,GAA0B6b,UAAA,CAAWgB,eAAX,CAA1B;AAEkD;AAmDtDC,UAASA,kBAAiB,CAAChhB,GAAD,CAAM;AAC5B,WAAQA,GAAI4I,CAAAA,UAAJ,CAAe,OAAf,CAAR,IACK5I,GAAI4I,CAAAA,UAAJ,CAAe,MAAf,CADL,IACuC,WADvC,KAC+B5I,GAD/B,IAEIA,GAAI4I,CAAAA,UAAJ,CAAe,QAAf,CAFJ,IAGI5I,GAAI4I,CAAAA,UAAJ,CAAe,OAAf,CAHJ,IAII5I,GAAI4I,CAAAA,UAAJ,CAAe,OAAf,CAJJ,IAKI5I,GAAI4I,CAAAA,UAAJ,CAAe,UAAf,CALJ,IAMIqY,gBAAiB9f,CAAAA,GAAjB,CAAqBnB,GAArB,CANJ;AAD4B;AAWhCkhB,UAASA,wBAAuB,CAACC,WAAD,CAAc;AACrCA,eAAL,KAGAC,aAHA,GAGiBphB,GAADohB,IAASphB,GAAI4I,CAAAA,UAAJ,CAAe,IAAf,CAAA,GAAuB,CAACoY,iBAAA,CAAkBhhB,GAAlB,CAAxB,GAAiDmhB,WAAA,CAAYnhB,GAAZ,CAH1E;AAD0C;AA8B9CqhB,UAASA,YAAW,CAACjhB,KAAD,EAAQkhB,KAAR,EAAeC,kBAAf,CAAmC;AACnD,UAAMC,gBAAgB,EAAtB;AACA,SAAK,MAAMxhB,GAAX,GAAkBI,MAAlB;AAQI,UAAY,QAAZ,KAAIJ,GAAJ,IAAgD,QAAhD,KAAwB,MAAOI,MAAMP,CAAAA,MAArC;AAEA,YAAIuhB,aAAA,CAAcphB,GAAd,CAAJ,IAC4B,CAAA,CAD5B,KACKuhB,kBADL,IACoCP,iBAAA,CAAkBhhB,GAAlB,CADpC,IAEK,CAACshB,KAFN,IAEe,CAACN,iBAAA,CAAkBhhB,GAAlB,CAFhB,IAIKI,KAAA,CAAA,SAJL,IAKQJ,GAAI4I,CAAAA,UAAJ,CAAe,QAAf,CALR;AAMI4Y,uBAAA,CAAcxhB,GAAd,CAAA,GACII,KAAA,CAAMJ,GAAN,CADJ;AANJ;AAFA;AARJ;AAoBA,WAAOwhB,aAAP;AAtBmD;AA+BvDhF,UAASA,sBAAqB,CAACpc,KAAD,CAAQ;AAClC,WAAQb,mBAAA,CAAoBa,KAAMuX,CAAAA,OAA1B,CAAR,IACIkF,YAAa9K,CAAAA,IAAb,CAAmBpI,IAAD,IAAU2S,cAAA,CAAelc,KAAA,CAAMuJ,IAAN,CAAf,CAA5B,CADJ;AADkC;AAItC8X,UAASA,cAAa,CAACrhB,KAAD,CAAQ;AAC1B,WAAO,EAAQ,CAAAoc,qBAAA,CAAsBpc,KAAtB,CAAR,IAA8CM,CAANN,KAAMM,CAAAA,QAA9C,CAAP;AAD0B;AAW9BghB,UAASA,YAAW,CAAClc,IAAD,CAAO;AACvB,UAAMmc,MAAMC,KAAMC,CAAAA,MAAN,CAAa,IAAb,CAAZ;AACoB,QAApB,KAAIF,GAAIphB,CAAAA,OAAR,KACIohB,GAAIphB,CAAAA,OADR,GACkBiF,IAAA,EADlB;AAGA,WAAOmc,GAAIphB,CAAAA,OAAX;AALuB;AAa3BuhB,UAASA,mBAAkB,CAAC/hB,KAAD,CAAQ;AAE/B,WAAO,CADDgiB,KACC,GAD8BhiB,KAAd,IAAcA,KAtgHeG,CAAAA,WAsgH7B,GAAuBH,KAAME,CAAAA,GAAN,EAAvB,GAAqCF,KACrD,KAp8H0B,QAo8H1B,KAp8Ha,MAo8HCgiB,MAAd,IAAcA,KAp8H0B3S,CAAAA,GAo8HxC,IAAc2S,KAp8HmCC,CAAAA,OAo8HjD,GACDD,KAAeC,CAAAA,OAAf,EADC,GAEDD,KAFN;AAF+B;AAOnCE,UAASA,UAAS,CAAC,CAAEC,2BAAF,EAA+BC,iBAA/B,EAAkDC,QAAlD,CAAD,EAAgEhiB,KAAhE,EAAuEqc,OAAvE,EAAgFzB,eAAhF,CAAiG;AAC/G,UAAMpb,QAAQ,CACVma,aAAcsI,gBAAA,CAAiBjiB,KAAjB,EAAwBqc,OAAxB,EAAiCzB,eAAjC,EAAkDkH,2BAAlD,CADJ,EAEVI,YAAaH,iBAAA,EAFH,CAAd;AAIIC,YAAJ,KAMIxiB,KAAM2iB,CAAAA,OACN,GADiBC,QAADC,IAAcL,QAAA,CAAS,CAAEhiB,KAAF,EAASG,QAASiiB,QAAlB,EAA4B,GAAG5iB,KAA/B,CAAT,CAC9B,EAAAA,KAAMwiB,CAAAA,QAAN,GAAkBziB,aAAD+iB,IAAmBN,QAAA,CAASziB,aAAT,CAPxC;AASA,WAAOC,KAAP;AAd+G;AAsBnHyiB,UAASA,iBAAgB,CAACjiB,KAAD,EAAQqc,OAAR,EAAiBzB,eAAjB,EAAkC2H,kBAAlC,CAAsD;AAC3E,UAAM9iB,SAAS,EAAf;AACM+iB,sBAAAA,GAAeD,kBAAA,CAAmBviB,KAAnB,EAA0B,EAA1B,CAAfwiB;AACN,SAAK,IAAM5iB,GAAX,GAAkB4iB,mBAAlB;AACI/iB,YAAA,CAAOG,GAAP,CAAA,GAAc8hB,kBAAA,CAAmBc,kBAAA,CAAa5iB,GAAb,CAAnB,CAAd;AADJ;AAGA,QAAI,CAAE2c,OAAF,EAAWhF,OAAX,CAAA,GAAuBvX,KAA3B;AACMyiB,OAAAA,GAA0BrG,qBAAA,CAAsBpc,KAAtB,CAA1ByiB;AACAC,sBAAAA,GAAkBrB,aAAA,CAAcrhB,KAAd,CAAlB0iB;AACFrG,WAAJ,IACIqG,kBADJ,IAEI,CAACD,GAFL,IAGsB,CAAA,CAHtB,KAGIziB,KAAM2iB,CAAAA,OAHV,KAIoBtiB,IAAAA,EAEhB,KAFIkc,OAEJ,KADIA,OACJ,GADcF,OAAQE,CAAAA,OACtB,GAAgBlc,IAAAA,EAAhB,KAAIkX,OAAJ,KACIA,OADJ,GACc8E,OAAQ9E,CAAAA,OADtB,CANJ;AAcA,SADMqL,eACN,GADqB,CADrBC,OACqB,IAJjBA,OAIiB,GAJWjI,eAAA,GACE,CAAA,CADF,KAC1BA,eAAgB2B,CAAAA,OADU,GAE1B,CAAA,CAEe,KADgD,CAAA,CAChD,KADoCA,OACpC,IAA4BhF,OAA5B,GAAsCgF,OAC3D,KAC4B,SAD5B,KACI,MAAOqG,gBADX,IAEI,CAACzjB,mBAAA,CAAoByjB,eAApB,CAFL;AAII,WADME,eACG9e,GADI4B,KAAMC,CAAAA,OAAN,CAAc+c,eAAd,CAAA,GAA8BA,eAA9B,GAA6C,CAACA,eAAD,CACjD5e,EAAAA,GAAAA,GAAI,CAAb,EAAgBA,GAAhB,GAAoB8e,eAAK7e,CAAAA,MAAzB,EAAiCD,GAAA,EAAjC;AAEI,YADMwB,kBACN,GADiBzF,uBAAA,CAAwBC,KAAxB,EAA+B8iB,eAAA,CAAK9e,GAAL,CAA/B,CACjB,CAAc;AACV,gBAAM,CAAEyB,aAAF,EAAiBC,UAAjB,EAA6B,GAAGC,MAAhC,CAAA,GAA2CH,kBAAjD;AACA,eAAK,MAAM5F,GAAX,GAAkB+F,OAAlB;AACQiU,8BAWJ,GAXkBjU,MAAA,CAAO/F,GAAP,CAWlB,EAVIgG,KAAMC,CAAAA,OAAN,CAAc+T,kBAAd,CAUJ,KAFIA,kBAEJ,GAFkBA,kBAAA,CAHAiJ,OAAAre,GACRoV,kBAAY3V,CAAAA,MADJO,GACa,CADbA,GAER,CACQ,CAElB,GAAoB,IAApB,KAAIoV,kBAAJ,KACIna,MAAA,CAAOG,GAAP,CADJ,GACkBga,kBADlB,CAAA;AAZJ;AAgBA,eAAK,MAAMha,GAAX,GAAkB6F,cAAlB;AACIhG,kBAAA,CAAOG,GAAP,CAAA,GAAc6F,aAAA,CAAc7F,GAAd,CAAd;AADJ;AAlBU;AAFlB;AAJJ;AA8BA,WAAOH,MAAP;AArD2E;AAwD/EsjB,UAASA,YAAW,CAACpd,MAAD,EAASqd,SAAT,EAAoBC,OAApB,EAA6B5d,OAAA,GAAU,CAAE6d,QAAS,CAAA,CAAX,CAAvC,CAA0D;AAC1Evd,UAAOwd,CAAAA,gBAAP,CAAwBH,SAAxB,EAAmCC,OAAnC,EAA4C5d,OAA5C,CAAA;AACA,WAAO,EAAA,IAAMM,MAAOyd,CAAAA,mBAAP,CAA2BJ,SAA3B,EAAsCC,OAAtC,CAAb;AAF0E;AAK9EI,UAASA,iBAAgB,CAACC,KAAD,CAAQ;AAC7B,WAAO,CACHC,MAAO,CACHrc,EAAGoc,KAAME,CAAAA,KADN,EAEHhD,EAAG8C,KAAMG,CAAAA,KAFN,CADJ,CAAP;AAD6B;AAYjCC,UAASA,gBAAe,CAAC/d,MAAD,EAASqd,SAAT,EAAoBC,OAApB,EAA6B5d,OAA7B,CAAsC;AAC1D,WAAO0d,WAAA,CAAYpd,MAAZ,EAAoBqd,SAApB,EAA+BW,cAAA,CAAeV,OAAf,CAA/B,EAAwD5d,OAAxD,CAAP;AAD0D;AAwC9Due,UAASA,YAAW,CAACC,SAAA,GAAY,CAAA,CAAb,CAAmB;AACnC,QAAMxH,UAAUmF,KAAMsC,CAAAA,UAAN,CAAiBC,eAAjB,CAAhB;AACA,QAAgB,IAAhB,KAAI1H,OAAJ;AACI,aAAO,CAAC,CAAA,CAAD,EAAO,IAAP,CAAP;AADJ;AAEA,UAAM,CAAE2H,SAAF,EAAaC,cAAb,EAA6BC,QAA7B,CAAA,GAA0C7H,OAAhD,EAGM8H,KAAK3C,KAAM4C,CAAAA,KAAN,EAHX;AAIA5C,SAAM6C,CAAAA,SAAN,CAAgB,EAAA,IAAM;AAClB,UAAIR,SAAJ;AACI,eAAOK,QAAA,CAASC,EAAT,CAAP;AADJ;AADkB,KAAtB,EAIG,CAACN,SAAD,CAJH,CAAA;AAKMS,WAAAA,GAAe9C,KAAM+C,CAAAA,WAAN,CAAkB,EAAA,IAAMV,SAAN,IAAmBI,cAAnB,IAAqCA,cAAA,CAAeE,EAAf,CAAvD,EAA2E,CAACA,EAAD,EAAKF,cAAL,EAAqBJ,SAArB,CAA3E,CAAfS;AACN,WAAO,CAACN,SAAD,IAAcC,cAAd,GAA+B,CAAC,CAAA,CAAD,EAAQK,OAAR,CAA/B,GAAuD,CAAC,CAAA,CAAD,CAA9D;AAdmC;AA2CvCE,UAASA,mBAAkB,CAAC7kB,KAAD,EAAQiN,SAAR,EAAmBvH,OAAnB,CAA4B;AAC7Cof,SAAAA,GAA8B9kB,KAAd,IAAcA,KA/rHgBG,CAAAA,WA+rH9B,GAAuBH,KAAvB,GAA+BwF,WAAA,CAAYxF,KAAZ,CAA/C8kB;AACNA,SAAcplB,CAAAA,KAAd,CAAoB+a,kBAAA,CAAmB,EAAnB,EAAuBqK,KAAvB,EAAsC7X,SAAtC,EAAiDvH,OAAjD,CAApB,CAAA;AACA,WAAOof,KAAcjN,CAAAA,SAArB;AAHmD;AAQvDkN,UAASA,aAAY,CAAC3f,OAAD,CAAU;AAC3B,WAAOA,OAAP,YAA0B4f,UAA1B,IAA4D,KAA5D,KAAwC5f,OAAQ6f,CAAAA,OAAhD;AAD2B;AAmC/BC,UAASA,yBAAwB,EAAG;AAChCC,4BAAyB3kB,CAAAA,OAAzB,GAAmC,CAAA,CAAnC;AACA,QAAK4kB,SAAL;AAEA,UAAIzZ,MAAO0Z,CAAAA,UAAX,CAAuB;AACnB,cAAMC,mBAAmB3Z,MAAO0Z,CAAAA,UAAP,CAAkB,0BAAlB,CAAzB;AAEAC,wBAAiBC,CAAAA,WAAjB,CADoC,EAAAC,IAAOC,oBAAqBjlB,CAAAA,OAA5BglB,GAAsCF,gBAAiBI,CAAAA,OAC3F,CAAA;AAD2CD,4BAAqBjlB,CAAAA,OAEhE,GAF0E8kB,gBAAiBI,CAAAA,OAE3F;AAJmB,OAAvB;AAOID,4BAAqBjlB,CAAAA,OAArB,GAA+B,CAAA,CAA/B;AAPJ;AAFA;AAFgC;AAolBpCmlB,UAASA,eAAc,CAAC3L,YAAD,EAAetQ,SAAf,EAA0Bkc,iBAA1B,CAA6C;AAEhE,QAAIC,kBAAkB,EAAtB,EACIC,qBAAqB,CAAA,CADzB;AAMA,SAAK,IAAIzhB,IAAI,CAAb,EAAgBA,CAAhB,GAAoB0hB,aAApB,EAAmC1hB,CAAA,EAAnC,CAAwC;AACpC,YAAMpE,MAAM+lB,kBAAA,CAAmB3hB,CAAnB,CAAZ;AACA,UAAMrE,QAAQga,YAAA,CAAa/Z,GAAb,CAAd;AACA,UAAcS,IAAAA,EAAd,KAAIV,KAAJ;AACI;AADJ;AAEA,UAAIimB,cAAJ;AAEIA,oBAAA,GADiB,QAArB,KAAI,MAAOjmB,MAAX,GACqBA,KADrB,MACgCC,GAAI4I,CAAAA,UAAJ,CAAe,OAAf,CAAA,GAA0B,CAA1B,GAA8B,CAD9D,IAI2C,CAJ3C,KAIqBI,UAAA,CAAWjJ,KAAX,CAHjB;AAKJ,UAAI,CAACimB,cAAL,IAAuBL,iBAAvB;AACUM,aAMN,GANoBC,cAAA,CAAenmB,KAAf,EAAsBomB,gBAAA,CAAiBnmB,GAAjB,CAAtB,CAMpB,EALKgmB,cAKL,KAJIH,kBAEA,GAFqB,CAAA,CAErB,EAAAD,eAAA,IAAoB,GADEQ,cAAA,CAAepmB,GAAf,CACF,IADyBA,GACzB,IAAmBimB,KAAnB,IAExB,GAAIN,iBAAJ,KACIlc,SAAA,CAAUzJ,GAAV,CADJ,GACqBimB,KADrB,CAAA;AAPJ;AAZoC;AAwBxCL,mBAAA,GAAkBA,eAAgB/Y,CAAAA,IAAhB,EAAlB;AAGI8Y,qBAAJ,GACIC,eADJ,GACsBD,iBAAA,CAAkBlc,SAAlB,EAA6Boc,kBAAA,GAAqB,EAArB,GAA0BD,eAAvD,CADtB,GAGSC,kBAHT,KAIID,eAJJ,GAIsB,MAJtB,CAAA;AAMA,WAAOA,eAAP;AAzCgE;AA4CpES,UAASA,gBAAe,CAACzmB,KAAD,EAAQma,YAAR,EAAsB4L,iBAAtB,CAAyC;AAC7D,UAAM,CAAEW,KAAF,EAASC,IAAT,EAAeC,eAAf,CAAA,GAAmC5mB,KAAzC;AAEA,QAAI6mB,eAAe,CAAA,CAAnB,EACIC,qBAAqB,CAAA,CADzB;AAQA,SAAK,MAAM1mB,GAAX,GAAkB+Z,aAAlB,CAAgC;AAC5B,UAAMha,QAAQga,YAAA,CAAa/Z,GAAb,CAAd;AACI2mB,oBAAexlB,CAAAA,GAAf,CAAmBnB,GAAnB,CAAJ,GAEIymB,YAFJ,GAEmB,CAAA,CAFnB,GAKSG,iBAAA,CAAkB5mB,GAAlB,CAAJ,GACDumB,IAAA,CAAKvmB,GAAL,CADC,GACWD,KADX,IAMKkmB,KACN,GADoBC,cAAA,CAAenmB,KAAf,EAAsBomB,gBAAA,CAAiBnmB,GAAjB,CAAtB,CACpB,EAAIA,GAAI4I,CAAAA,UAAJ,CAAe,QAAf,CAAJ,IAEI8d,kBACA,GADqB,CAAA,CACrB,EAAAF,eAAA,CAAgBxmB,GAAhB,CAAA,GACIimB,KAJR,IAOIK,KAAA,CAAMtmB,GAAN,CAPJ,GAOiBimB,KAdhB,CALL;AAF4B;AAyB3BlM,gBAAatQ,CAAAA,SAAlB,KACQgd,YAAJ,IAAoBd,iBAApB,GACIW,KAAM7c,CAAAA,SADV,GACsBic,cAAA,CAAe3L,YAAf,EAA6Bna,KAAM6J,CAAAA,SAAnC,EAA8Ckc,iBAA9C,CADtB,GAGSW,KAAM7c,CAAAA,SAHf,KAQI6c,KAAM7c,CAAAA,SARV,GAQsB,MARtB,CADJ;AAgBA,QAAIid,kBAAJ,CAAwB;AACpB,YAAM,CAAE/F,OAAA,GAAU,KAAZ,EAAmBE,OAAA,GAAU,KAA7B,EAAoCgG,OAAA,GAAU,CAA9C,CAAA,GAAqDL,eAA3D;AACAF,WAAME,CAAAA,eAAN,GAAyB,GAAE7F,OAAF,IAAaE,OAAb,IAAwBgG,OAAxB,EAAzB;AAFoB;AApDqC;AAyEjEC,UAASA,aAAY,CAACC,KAAD,EAAQ1iB,MAAR,EAAgB2iB,OAAA,GAAU,CAA1B,EAA6BzQ,MAAA,GAAS,CAAtC,EAAyC0Q,WAAA,GAAc,CAAA,CAAvD,CAA6D;AAE9EF,SAAMG,CAAAA,UAAN,GAAmB,CAAnB;AAGMpV,eAAAA,GAAOmV,WAAA,GAAcE,QAAd,GAAyBC,SAAhCtV;AAENiV,SAAA,CAAMjV,WAAKyE,CAAAA,MAAX,CAAA,GAAqB8Q,EAAG5d,CAAAA,SAAH,CAAa,CAAC8M,MAAd,CAArB;AAEM2Q,UAAAA,GAAaG,EAAG5d,CAAAA,SAAH,CAAapF,MAAb,CAAb6iB;AACAI,WAAAA,GAAcD,EAAG5d,CAAAA,SAAH,CAAaud,OAAb,CAAdM;AACNP,SAAA,CAAMjV,WAAKyV,CAAAA,KAAX,CAAA,GAAqB,GAAEL,MAAF,IAAgBI,OAAhB,EAArB;AAX8E;AAgClFE,UAASA,cAAa,CAAC5nB,KAAD,EAAQ,CAAE6nB,KAAF,EAASC,KAAT,EAAgBC,SAAhB,EAA2BhH,OAA3B,EAAoCE,OAApC,EAA6CqG,UAA7C,EAAyDI,WAAA,GAAc,CAAvE,EAA0EM,UAAA,GAAa,CAAvF,EAE9B,GAAG3S,MAF2B,CAAR,EAET4S,QAFS,EAEClC,iBAFD,CAEoB;AACtCU,mBAAA,CAAgBzmB,KAAhB,EAAuBqV,MAAvB,EAA+B0Q,iBAA/B,CAAA;AAKA,QAAIkC,QAAJ;AACQjoB,WAAM0mB,CAAAA,KAAMwB,CAAAA,OAAhB,KACIloB,KAAMmnB,CAAAA,KAAMe,CAAAA,OADhB,GAC0BloB,KAAM0mB,CAAAA,KAAMwB,CAAAA,OADtC;AADJ,UAAA;AAMAloB,WAAMmnB,CAAAA,KAAN,GAAcnnB,KAAM0mB,CAAAA,KAApB;AACA1mB,WAAM0mB,CAAAA,KAAN,GAAc,EAAd;AACA,UAAM,CAAES,KAAF,EAAST,KAAT,EAAgByB,UAAhB,CAAA,GAA+BnoB,KAArC;AAKImnB,WAAMtd,CAAAA,SAAV,KACQse,UAEJ,KADIzB,KAAM7c,CAAAA,SACV,GADsBsd,KAAMtd,CAAAA,SAC5B,GAAA,OAAOsd,KAAMtd,CAAAA,SAHjB;AAMIse,gBAAJ,KACiBtnB,IAAAA,EADjB,KACKkgB,OADL,IAC0ClgB,IAAAA,EAD1C,KAC8BogB,OAD9B,IACuDyF,KAAM7c,CAAAA,SAD7D,MAEsG,KAAlG,GAA8GhJ,IAAAA,EAAZ,KAAAogB,OAAA,GAAwBA,OAAxB,GAAkC,GAApI,EAA2DF,OAA3D,GAAuElgB,IAAAA,EAAZkgB,KAAAA,OAAAA,GAAwBA,OAAxBA,GAAkCA,GAA7F,EA9CJ,OA8CI,GA9CqB,QAAlB,KAAA,MAAOjS,QAAP,GACDA,OADC,GAED2Y,EAAG5d,CAAAA,SAAH,CA4C6Cse,UArCAzgB,CAAAA,CAP7C,GA4C6CygB,UArCcC,CAAAA,KAP3D,GAA6BtZ,OAA7B,CA4CF,EApCEuZ,KAoCF,GA9CqB,QAAlB,KAAA,MAUwBpH,MAVxB,GAUwBA,KAVxB,GAEDwG,EAAG5d,CAAAA,SAAH,CA4C6Cse,UApCAnH,CAAAA,CAR7C,GA4C6CmH,UApCcG,CAAAA,MAR3D,GAQyBrH,KARzB,CA4CF,EAAAyF,KAAME,CAAAA,eAAN,GAnCI,GAFU2B,OAEV,IAAeF,KAAf,EAiCR;AAKcxnB,UAAAA,EAAd,KAAIgnB,KAAJ,KACIV,KAAMzf,CAAAA,CADV,GACcmgB,KADd;AAEchnB,UAAAA,EAAd,KAAIinB,KAAJ,KACIX,KAAMnG,CAAAA,CADV,GACc8G,KADd;AAEkBjnB,UAAAA,EAAlB,KAAIknB,SAAJ,KACIZ,KAAM3G,CAAAA,KADV,GACkBuH,SADlB;AAGmBlnB,UAAAA,EAAnB,KAAIymB,UAAJ,IACIJ,YAAA,CAAaC,KAAb,EAAoBG,UAApB,EAAgCI,WAAhC,EAA6CM,UAA7C,EAAyD,CAAA,CAAzD,CADJ;AA/BA;AANsC;AAyE1CQ,UAASA,oBAAmB,CAAC5F,QAAD,EAAWF,WAAX,CAAwB;AAChD,OAAI;AACAA,iBAAYyF,CAAAA,UAAZ,GACgC,UAA5B,KAAA,MAAOvF,SAAS6F,CAAAA,OAAhB,GACM7F,QAAS6F,CAAAA,OAAT,EADN,GAEM7F,QAAS8F,CAAAA,qBAAT,EAHV;AADA,KAMJ,QAAOrX,CAAP,CAAU;AAENqR,iBAAYyF,CAAAA,UAAZ,GAAyB,CACrBzgB,EAAG,CADkB,EAErBsZ,EAAG,CAFkB,EAGrBoH,MAAO,CAHc,EAIrBE,OAAQ,CAJa,CAAzB;AAFM;AAPsC;AAkBpDK,UAASA,WAAU,CAACpjB,OAAD,EAAU,CAAEmhB,KAAF,EAASC,IAAT,CAAV,EAA2BiC,SAA3B,EAAsCC,UAAtC,CAAkD;AACjExP,UAAOyP,CAAAA,MAAP,CAAcvjB,OAAQmhB,CAAAA,KAAtB,EAA6BA,KAA7B,EAAoCmC,UAApC,IAAkDA,UAAWE,CAAAA,mBAAX,CAA+BH,SAA/B,CAAlD,CAAA;AAEA,SAAK,MAAMxoB,GAAX,GAAkBumB,KAAlB;AACIphB,aAAQmhB,CAAAA,KAAMsC,CAAAA,WAAd,CAA0B5oB,GAA1B,EAA+BumB,IAAA,CAAKvmB,GAAL,CAA/B,CAAA;AADJ;AAHiE;AAQrE6oB,UAASA,UAAS,CAAC1jB,OAAD,EAAUmd,WAAV,EAAuBwG,UAAvB,EAAmCL,UAAnC,CAA+C;AAC7DF,cAAA,CAAWpjB,OAAX,EAAoBmd,WAApB,EAAiC7hB,IAAAA,EAAjC,EAA4CgoB,UAA5C,CAAA;AACA,SAAK,MAAMzoB,GAAX,GAAkBsiB,YAAYyE,CAAAA,KAA9B;AACI5hB,aAAQ4jB,CAAAA,YAAR,CAAsBC,mBAAoB7nB,CAAAA,GAApB,CAAwBnB,GAAxB,CAAD,GAAmDA,GAAnD,GAAgCipB,WAAA,CAAYjpB,GAAZ,CAArD,EAA6EsiB,WAAYyE,CAAAA,KAAZ,CAAkB/mB,GAAlB,CAA7E,CAAA;AADJ;AAF6D;AAQjEkpB,UAASA,kBAAiB,CAACC,UAAD,CAAa;AACnC,SAAK,MAAMnpB,GAAX,GAAkBmpB,WAAlB;AACIC,qBAAA,CAAgBppB,GAAhB,CACA,GADuBmpB,UAAA,CAAWnpB,GAAX,CACvB,EAAI4mB,iBAAA,CAAkB5mB,GAAlB,CAAJ,KACIopB,eAAA,CAAgBppB,GAAhB,CAAqBqpB,CAAAA,aADzB,GACyC,CAAA,CADzC,CAAA;AAFJ;AADmC;AASvCC,UAASA,oBAAmB,CAACtpB,GAAD,EAAM,CAAE+gB,MAAF,EAAUwI,QAAV,CAAN,CAA4B;AACpD,WAAQ5C,cAAexlB,CAAAA,GAAf,CAAmBnB,GAAnB,CAAR,IACIA,GAAI4I,CAAAA,UAAJ,CAAe,QAAf,CADJ,KAEMmY,MAFN,IAE6BtgB,IAAAA,EAF7B,KAEgB8oB,QAFhB,MAGS,CAAC,CAACH,eAAA,CAAgBppB,GAAhB,CAHX,IAG2C,SAH3C,KAGmCA,GAHnC;AADoD;AAOxDwpB,UAASA,8BAA6B,CAACppB,KAAD,EAAQqpB,SAAR,EAAmB9pB,aAAnB,CAAkC;AACpE,QAAI4L,EAAJ;AACA,UAAM,CAAE+a,KAAF,CAAA,GAAYlmB,KAAlB,EACMspB,YAAY,EADlB;AAEA,SAAK,MAAM1pB,GAAX,GAAkBsmB,MAAlB;AACI,UAAIqD,aAAA,CAAcrD,KAAA,CAAMtmB,GAAN,CAAd,CAAJ,IACKypB,SAAUnD,CAAAA,KADf,IAEQqD,aAAA,CAAcF,SAAUnD,CAAAA,KAAV,CAAgBtmB,GAAhB,CAAd,CAFR,IAGIspB,mBAAA,CAAoBtpB,GAApB,EAAyBI,KAAzB,CAHJ,IAI6JK,IAAAA,EAJ7J,MAI0G,IAArG,MAAC8K,EAAD,GAAwB,IAAlB,KAAA5L,aAAA,IAA4C,IAAK,EAAjD,KAA0BA,aAA1B,GAAqD,IAAK,EAA1D,GAA8DA,aAAcwG,CAAAA,QAAd,CAAuBnG,GAAvB,CAApE,KAAoH,IAAK,EAAzH,KAA6GuL,EAA7G,GAA6H,IAAK,EAAlI,GAAsIA,EAAGoT,CAAAA,SAJ9I;AAKI+K,iBAAA,CAAU1pB,GAAV,CAAA,GAAiBsmB,KAAA,CAAMtmB,GAAN,CAAjB;AALJ;AADJ;AASA,WAAO0pB,SAAP;AAboE;AAgBxExH,UAASA,4BAA2B,CAAC9hB,KAAD,EAAQqpB,SAAR,EAAmB9pB,aAAnB,CAAkC;AAC5D+pB,iBAAAA,GAAYF,6BAAA,CAA8BppB,KAA9B,EAAqCqpB,SAArC,EAAgD9pB,aAAhD,CAAZ+pB;AACN,SAAK,MAAM1pB,GAAX,GAAkBI,MAAlB;AACI,UAAIupB,aAAA,CAAcvpB,KAAA,CAAMJ,GAAN,CAAd,CAAJ,IACI2pB,aAAA,CAAcF,SAAA,CAAUzpB,GAAV,CAAd,CADJ,CACmC;AAC/B,cAAM4pB,YAAgD,CAAC,CAArC,KAAA7D,kBAAmBrhB,CAAAA,OAAnB,CAA2B1E,GAA3B,CAAA,GACZ,MADY,GACHA,GAAI6pB,CAAAA,MAAJ,CAAW,CAAX,CAAcC,CAAAA,WAAd,EADG,GAC2B9pB,GAAI+pB,CAAAA,SAAJ,CAAc,CAAd,CAD3B,GAEZ/pB,GAFN;AAGA0pB,qBAAA,CAAUE,SAAV,CAAA,GAAuBxpB,KAAA,CAAMJ,GAAN,CAAvB;AAJ+B;AAFvC;AASA,WAAO0pB,aAAP;AAXkE;AA8DtEM,UAASA,wBAAuB,CAAC,CAAEC,GAAF,EAAOC,IAAP,EAAaC,KAAb,EAAoBC,MAApB,CAAD,CAAgC;AAC5D,WAAO,CACH9iB,EAAG,CAAEpD,IAAKgmB,IAAP,EAAajmB,IAAKkmB,KAAlB,CADA,EAEHvJ,EAAG,CAAE1c,IAAK+lB,GAAP,EAAYhmB,IAAKmmB,MAAjB,CAFA,CAAP;AAD4D;AAMhEC,UAASA,wBAAuB,CAAC,CAAE/iB,CAAF,EAAKsZ,CAAL,CAAD,CAAW;AACvC,WAAO,CAAEqJ,IAAKrJ,CAAE1c,CAAAA,GAAT,EAAcimB,MAAO7iB,CAAErD,CAAAA,GAAvB,EAA4BmmB,OAAQxJ,CAAE3c,CAAAA,GAAtC,EAA2CimB,KAAM5iB,CAAEpD,CAAAA,GAAnD,CAAP;AADuC;AAQ3ComB,UAASA,mBAAkB,CAAC3G,KAAD,EAAQ4G,cAAR,CAAwB;AAC/C,QAAI,CAACA,cAAL;AACI,aAAO5G,KAAP;AADJ;AAEA,UAAM6G,UAAUD,cAAA,CAAe,CAAEjjB,EAAGqc,KAAMuG,CAAAA,IAAX,EAAiBtJ,EAAG+C,KAAMsG,CAAAA,GAA1B,CAAf,CAAhB;AACMQ,SAAAA,GAAcF,cAAA,CAAe,CAAEjjB,EAAGqc,KAAMwG,CAAAA,KAAX,EAAkBvJ,EAAG+C,KAAMyG,CAAAA,MAA3B,CAAf,CAAdK;AACN,WAAO,CACHR,IAAKO,OAAQ5J,CAAAA,CADV,EAEHsJ,KAAMM,OAAQljB,CAAAA,CAFX,EAGH8iB,OAAQK,KAAY7J,CAAAA,CAHjB,EAIHuJ,MAAOM,KAAYnjB,CAAAA,CAJhB,CAAP;AAL+C;AAgBnDojB,UAASA,SAAQ,CAAC,CAAEtK,KAAF,EAASuK,MAAT,EAAiBC,MAAjB,CAAD,CAA4B;AACzC,WAAQ,EAHSnqB,IAAAA,EAGT,KAAiB2f,KAAjB,IAHgC,CAGhC,KAAiBA,KAAjB,CAAR,IACI,EAJa3f,IAAAA,EAIb,KAAiBkqB,MAAjB,IAJoC,CAIpC,KAAiBA,MAAjB,CADJ,IAEI,EALalqB,IAAAA,EAKb,KAAiBmqB,MAAjB,IALoC,CAKpC,KAAiBA,MAAjB,CAFJ;AADyC;AAK7CnE,UAASA,aAAY,CAAC5mB,MAAD,CAAS;AAC1B,WAAQ6qB,QAAA,CAAS7qB,MAAT,CAAR,IACIgrB,cAAA,CAAehrB,MAAf,CADJ,IAEIA,MAAOirB,CAAAA,CAFX,IAGIjrB,MAAOkrB,CAAAA,MAHX,IAIIlrB,MAAOmrB,CAAAA,OAJX,IAKInrB,MAAOorB,CAAAA,OALX,IAMIprB,MAAOqrB,CAAAA,KANX,IAOIrrB,MAAOsrB,CAAAA,KAPX;AAD0B;AAU9BN,UAASA,eAAc,CAAChrB,MAAD,CAAS;AAC5B,WAAOurB,aAAA,CAAcvrB,MAAOyH,CAAAA,CAArB,CAAP,IAAkC8jB,aAAA,CAAcvrB,MAAO+gB,CAAAA,CAArB,CAAlC;AAD4B;AAGhCwK,UAASA,cAAa,CAACrrB,KAAD,CAAQ;AAC1B,WAAOA,KAAP,IAA0B,IAA1B,KAAgBA,KAAhB;AAD0B;AAe9BsrB,UAASA,gBAAe,CAAC1H,KAAD,EAAQtD,SAAR,EAAmBD,KAAnB,EAA0BF,WAA1B,EAAuCoL,QAAvC,CAAiD;AACpD7qB,QAAAA,EAAjB,KAAI6qB,QAAJ,KACI3H,KADJ,GACwCzD,WADxC,GAC8BoL,QAD9B,IACuB3H,KADvB,GACwCzD,WADxC;AAGA,WAAgCA,WAAhC,GAAyBE,KAAzB,IAAkBuD,KAAlB,GAAgCzD,WAAhC,IAA+CG,SAA/C;AAJqE;AASzEkL,UAASA,eAAc,CAACvL,IAAD,EAAOK,SAAA,GAAY,CAAnB,EAAsBD,KAAA,GAAQ,CAA9B,EAAiCF,WAAjC,EAA8CoL,QAA9C,CAAwD;AAC3EtL,QAAK9b,CAAAA,GAAL,GAAWmnB,eAAA,CAAgBrL,IAAK9b,CAAAA,GAArB,EAA0Bmc,SAA1B,EAAqCD,KAArC,EAA4CF,WAA5C,EAAyDoL,QAAzD,CAAX;AACAtL,QAAK/b,CAAAA,GAAL,GAAWonB,eAAA,CAAgBrL,IAAK/b,CAAAA,GAArB,EAA0Boc,SAA1B,EAAqCD,KAArC,EAA4CF,WAA5C,EAAyDoL,QAAzD,CAAX;AAF2E;AAO/EE,UAASA,cAAa,CAACC,GAAD,EAAM,CAAEnkB,CAAF,EAAKsZ,CAAL,CAAN,CAAgB;AAClC2K,kBAAA,CAAeE,GAAInkB,CAAAA,CAAnB,EAAsBA,CAAE+Y,CAAAA,SAAxB,EAAmC/Y,CAAE8Y,CAAAA,KAArC,EAA4C9Y,CAAE4Y,CAAAA,WAA9C,CAAA;AACAqL,kBAAA,CAAeE,GAAI7K,CAAAA,CAAnB,EAAsBA,CAAEP,CAAAA,SAAxB,EAAmCO,CAAER,CAAAA,KAArC,EAA4CQ,CAAEV,CAAAA,WAA9C,CAAA;AAFkC;AAYtCwL,UAASA,gBAAe,CAACD,GAAD,EAAME,SAAN,EAAiBC,QAAjB,EAA2BC,kBAAA,GAAqB,CAAA,CAAhD,CAAuD;AAC3E,UAAMC,aAAaF,QAASvnB,CAAAA,MAA5B;AACA,QAAKynB,UAAL,CAAA;AAGAH,eAAUrkB,CAAAA,CAAV,GAAcqkB,SAAU/K,CAAAA,CAAxB,GAA4B,CAA5B;AAGA,WAAK,IAAIxc,IAAI,CAAb,EAAgBA,CAAhB,GAAoB0nB,UAApB,EAAgC1nB,CAAA,EAAhC,CAAqC;AACjC,YAAA2nB,OAAOH,QAAA,CAASxnB,CAAT,CAAP;AACA,YAAAtC,QAAQiqB,IAAKC,CAAAA,eAAb;AAKA,cAAM,CAAErsB,aAAF,CAAA,GAAoBosB,IAAKtmB,CAAAA,OAA/B;AACI9F,qBAAJ,IACIA,aAAcS,CAAAA,KAAMkmB,CAAAA,KADxB,IAE0C,UAF1C,KAEI3mB,aAAcS,CAAAA,KAAMkmB,CAAAA,KAAM2F,CAAAA,OAF9B,KAKIJ,kBAgBJ,IAfIE,IAAKtmB,CAAAA,OAAQymB,CAAAA,YAejB,IAdIH,IAAKI,CAAAA,MAcT,IAbIJ,IAaJ,KAbaA,IAAKzZ,CAAAA,IAalB,IAZI8Z,YAAA,CAAaX,GAAb,EAAkB,CACdnkB,EAAG,CAACykB,IAAKI,CAAAA,MAAO5V,CAAAA,MAAOjP,CAAAA,CADT,EAEdsZ,EAAG,CAACmL,IAAKI,CAAAA,MAAO5V,CAAAA,MAAOqK,CAAAA,CAFT,CAAlB,CAYJ,EAPI9e,KAOJ,KALI6pB,SAAUrkB,CAAAA,CAGV,IAHexF,KAAMwF,CAAAA,CAAE8Y,CAAAA,KAGvB,EAFAuL,SAAU/K,CAAAA,CAEV,IAFe9e,KAAM8e,CAAAA,CAAER,CAAAA,KAEvB,EAAAoL,aAAA,CAAcC,GAAd,EAAmB3pB,KAAnB,CAEJ,GAAI+pB,kBAAJ,IAA0BpF,YAAA,CAAasF,IAAKhS,CAAAA,YAAlB,CAA1B,IACIqS,YAAA,CAAaX,GAAb,EAAkBM,IAAKhS,CAAAA,YAAvB,CAtBJ;AARiC;AAfbsS,qBAoDxB,GAAIV,SAAUrkB,CAAAA,CAAd,IArDwBglB,cAqDxB,GACIX,SAAUrkB,CAAAA,CADd,KAEIqkB,SAAUrkB,CAAAA,CAFd,GAEkB,GAFlB;AApDwB+kB,qBAwDxB,GAAIV,SAAU/K,CAAAA,CAAd,IAzDwB0L,cAyDxB,GACIX,SAAU/K,CAAAA,CADd,KAEI+K,SAAU/K,CAAAA,CAFd,GAEkB,GAFlB;AA/CA;AAF2E;AAsD/E2L,UAASA,cAAa,CAACvM,IAAD,EAAOwM,QAAP,CAAiB;AACnCxM,QAAK9b,CAAAA,GAAL,IAAsBsoB,QAAtB;AACAxM,QAAK/b,CAAAA,GAAL,IAAsBuoB,QAAtB;AAFmC;AASvCC,UAASA,cAAa,CAACzM,IAAD,EAAO0M,aAAP,EAAsBC,SAAtB,EAAiCrB,QAAjC,EAA2CsB,UAAA,GAAa,GAAxD,CAA6D;AACzE1M,cAAAA,GAAcC,WAAA,CAAYH,IAAK9b,CAAAA,GAAjB,EAAsB8b,IAAK/b,CAAAA,GAA3B,EAAgC2oB,UAAhC,CAAd1M;AAENqL,kBAAA,CAAevL,IAAf,EAAqB0M,aAArB,EAAoCC,SAApC,EAA+CzM,UAA/C,EAA4DoL,QAA5D,CAAA;AAH+E;AAQnFc,UAASA,aAAY,CAACX,GAAD,EAAMhiB,SAAN,CAAiB;AAClCgjB,iBAAA,CAAchB,GAAInkB,CAAAA,CAAlB,EAAqBmC,SAAUnC,CAAAA,CAA/B,EAAkCmC,SAAUkhB,CAAAA,MAA5C,EAAoDlhB,SAAU2W,CAAAA,KAA9D,EAAqE3W,SAAUkX,CAAAA,OAA/E,CAAA;AACA8L,iBAAA,CAAchB,GAAI7K,CAAAA,CAAlB,EAAqBnX,SAAUmX,CAAAA,CAA/B,EAAkCnX,SAAUmhB,CAAAA,MAA5C,EAAoDnhB,SAAU2W,CAAAA,KAA9D,EAAqE3W,SAAUoX,CAAAA,OAA/E,CAAA;AAFkC;AAsDtCrJ,UAASA,MAAK,CAACvW,QAAD,EAAW4rB,OAAX,CAAoB;AAC9B,UAAMptB,QAAQqtB,IAAK/oB,CAAAA,GAAL,EAAd,EACMgpB,eAAe,CAAC,CAAEhrB,SAAF,CAAD,CAAAgrB,IAAmB;AACpBhrB,eAAViX,IAAsBvZ,KAAtBuZ;AACFA,eAAJ,IAAe6T,OAAf,KACIG,WAAA,CAAYD,YAAZ,CACA,EAAA9rB,QAAA,CAAS+X,SAAT,GAAmB6T,OAAnB,CAFJ;AAFoC,KADxC;AAQAtS,SAAMlX,CAAAA,IAAN,CAAW0pB,YAAX,EAAyB,CAAA,CAAzB,CAAA;AACA,WAAO,EAAA,IAAMC,WAAA,CAAYD,YAAZ,CAAb;AAV8B;AAclCE,UAASA,WAAU,CAAC/e,CAAD,EAAIC,CAAJ,CAAO;AAItB,WAAOnK,IAAK4M,CAAAA,IAAL,CALgB5M,IAAKwD,CAAAA,GAAL0lB,CAGChf,CAAE5G,CAAAA,CAHH4lB,GAGM/e,CAAE7G,CAAAA,CAHR4lB,CAKhB,IAAoB,CAApB,GALgBlpB,IAAKwD,CAAAA,GAAL2lB,CAICjf,CAAE0S,CAAAA,CAJHuM,GAIMhf,CAAEyS,CAAAA,CAJRuM,CAKhB,IAAkC,CAAlC,CAAP;AAJsB;AA0G1BC,UAASA,SAAQ,CAAClpB,GAAD,EAAMD,GAAN,EAAWmQ,MAAX,CAAmB;AAChC,WAAQ7G,CAAD,IAECA,CAAJ,GAAQrJ,GAAR,GACW,CADX,GAEIqJ,CAAJ,GAAQtJ,GAAR,GACW,CADX,GAEOmQ,MAAA,CAAOrN,WAAYuN,CAAAA,QAAZ,CAAqBpQ,GAArB,EAA0BD,GAA1B,EAA+BsJ,CAA/B,CAAP,CANX;AADgC;AAyBpC8f,UAASA,YAAW,CAAC5B,GAAD,EAAM6B,SAAN,CAAiB;AAChBhmB,QAAAA,OAAJmkB,GAAInkB,CAAAA,CAAAA,EAAaA,aAAVgmB,SAAUhmB,CAAAA,CAAbA;AATjB0Y,QAAK9b,CAAAA,GAAL,GAAWqpB,UAAWrpB,CAAAA,GAAtB;AACA8b,QAAK/b,CAAAA,GAAL,GAAWspB,UAAWtpB,CAAAA,GAAtB;AASiB2c,OAAAA,GAAJ6K,GAAI7K,CAAAA,CAAAA;AAAaA,aAAAA,GAAV0M,SAAU1M,CAAAA,CAAAA;AAV9BZ,OAAK9b,CAAAA,GAAL,GAAWqpB,SAAWrpB,CAAAA,GAAtB;AACA8b,OAAK/b,CAAAA,GAAL,GAAWspB,SAAWtpB,CAAAA,GAAtB;AAOiC;AASrCupB,UAASA,kBAAiB,CAAC1rB,KAAD,EAAQ2rB,WAAR,CAAqB;AAC3C3rB,SAAMue,CAAAA,SAAN,GAAkBoN,WAAYpN,CAAAA,SAA9B;AACAve,SAAMse,CAAAA,KAAN,GAAcqN,WAAYrN,CAAAA,KAA1B;AACAte,SAAMoe,CAAAA,WAAN,GAAoBuN,WAAYvN,CAAAA,WAAhC;AACApe,SAAM4M,CAAAA,MAAN,GAAe+e,WAAY/e,CAAAA,MAA3B;AAJ2C;AAU/Cgf,UAASA,iBAAgB,CAAC/J,KAAD,EAAQtD,SAAR,EAAmBD,KAAnB,EAA0BF,WAA1B,EAAuCoL,QAAvC,CAAiD;AAEtE3H,SAAA,GAAqCzD,WAArC,GAA0B,CAA1B,GAA8BE,KAA9B,IADAuD,KACA,GADStD,SACT,GAAqCH,WAArC;AACiBzf,QAAAA,EAAjB,KAAI6qB,QAAJ,KACI3H,KADJ,GAC4CzD,WAD5C,GAC8B,CAD9B,GACkCoL,QADlC,IACuB3H,KADvB,GAC4CzD,WAD5C;AAGA,WAAOyD,KAAP;AANsE;AAW1EgK,UAASA,gBAAe,CAAC3N,IAAD,EAAOK,SAAA,GAAY,CAAnB,EAAsBD,KAAA,GAAQ,CAA9B,EAAiC1R,MAAA,GAAS,GAA1C,EAA+C4c,QAA/C,EAAyDiC,UAAA,GAAavN,IAAtE,EAA4E4N,UAAA,GAAa5N,IAAzF,CAA+F;AAC/G6N,WAAQplB,CAAAA,IAAR,CAAa4X,SAAb,CAAJ,KACIA,SAEA,GAFYrX,UAAA,CAAWqX,SAAX,CAEZ,EAAAA,SAAA,GADyBF,WAAA2N,CAAYF,UAAW1pB,CAAAA,GAAvB4pB,EAA4BF,UAAW3pB,CAAAA,GAAvC6pB,EAA4CzN,SAA5CyN,GAAwD,GAAxDA,CACzB,GAA+BF,UAAW1pB,CAAAA,GAH9C;AAKyB,YAAzB,KAAI,MAAOmc,UAAX,KAEIH,MAIJ,GAJkBC,WAAA,CAAYoN,UAAWrpB,CAAAA,GAAvB,EAA4BqpB,UAAWtpB,CAAAA,GAAvC,EAA4CyK,MAA5C,CAIlB,EAHIsR,IAGJ,KAHauN,UAGb,KAFIrN,MAEJ,IAFmBG,SAEnB,GADAL,IAAK9b,CAAAA,GACL,GADWwpB,gBAAA,CAAiB1N,IAAK9b,CAAAA,GAAtB,EAA2Bmc,SAA3B,EAAsCD,KAAtC,EAA6CF,MAA7C,EAA0DoL,QAA1D,CACX,EAAAtL,IAAK/b,CAAAA,GAAL,GAAWypB,gBAAA,CAAiB1N,IAAK/b,CAAAA,GAAtB,EAA2Boc,SAA3B,EAAsCD,KAAtC,EAA6CF,MAA7C,EAA0DoL,QAA1D,CANX;AANmH;AAkBvHyC,UAASA,qBAAoB,CAAC/N,IAAD,EAAOgO,UAAP,EAAmB,CAAChuB,GAAD,EAAMiuB,QAAN,EAAgBC,SAAhB,CAAnB,EAA+Cxf,MAA/C,EAAuDkf,UAAvD,CAAmE;AAC5FD,mBAAA,CAAgB3N,IAAhB,EAAsBgO,UAAA,CAAWhuB,GAAX,CAAtB,EAAuCguB,UAAA,CAAWC,QAAX,CAAvC,EAA6DD,UAAA,CAAWE,SAAX,CAA7D,EAAoFF,UAAW5N,CAAAA,KAA/F,EAAsG1R,MAAtG,EAA8Gkf,UAA9G,CAAA;AAD4F;AAYhGO,UAASA,oBAAmB,CAAC1C,GAAD,EAAMuC,UAAN,EAAkBV,SAAlB,EAA6Bc,SAA7B,CAAwC;AAChEL,wBAAA,CAAqBtC,GAAInkB,CAAAA,CAAzB,EAA4B0mB,UAA5B,EAAwCK,KAAxC,EAA+Cf,SAAA,GAAYA,SAAUhmB,CAAAA,CAAtB,GAA0B7G,IAAAA,EAAzE,EAAoF2tB,SAAA,GAAYA,SAAU9mB,CAAAA,CAAtB,GAA0B7G,IAAAA,EAA9G,CAAA;AACAstB,wBAAA,CAAqBtC,GAAI7K,CAAAA,CAAzB,EAA4BoN,UAA5B,EAAwCM,KAAxC,EAA+ChB,SAAA,GAAYA,SAAU1M,CAAAA,CAAtB,GAA0BngB,IAAAA,EAAzE,EAAoF2tB,SAAA,GAAYA,SAAUxN,CAAAA,CAAtB,GAA0BngB,IAAAA,EAA9G,CAAA;AAFgE;AAKpE8tB,UAASA,gBAAe,CAACzsB,KAAD,CAAQ;AAC5B,WAA2B,CAA3B,KAAOA,KAAMue,CAAAA,SAAb,IAAgD,CAAhD,KAAgCve,KAAMse,CAAAA,KAAtC;AAD4B;AAMhCoO,UAASA,WAAU,CAACtgB,CAAD,EAAIC,CAAJ,CAAO;AACtB,WAAOD,CAAEhK,CAAAA,GAAT,KAAiBiK,CAAEjK,CAAAA,GAAnB,IAA0BgK,CAAEjK,CAAAA,GAA5B,KAAoCkK,CAAElK,CAAAA,GAAtC;AADsB;AAM1BwqB,UAASA,kBAAiB,CAACvgB,CAAD,EAAIC,CAAJ,CAAO;AAC7B,WAAQnK,IAAKwF,CAAAA,KAAL,CAAW0E,CAAEhK,CAAAA,GAAb,CAAR,KAA8BF,IAAKwF,CAAAA,KAAL,CAAW2E,CAAEjK,CAAAA,GAAb,CAA9B,IACIF,IAAKwF,CAAAA,KAAL,CAAW0E,CAAEjK,CAAAA,GAAb,CADJ,KAC0BD,IAAKwF,CAAAA,KAAL,CAAW2E,CAAElK,CAAAA,GAAb,CAD1B;AAD6B;AAOjCyqB,UAASA,YAAW,CAACjD,GAAD,CAAM;AACtB,WAAO1L,UAAA,CAAW0L,GAAInkB,CAAAA,CAAf,CAAP,GAA2ByY,UAAA,CAAW0L,GAAI7K,CAAAA,CAAf,CAA3B;AADsB;AAG1B+N,UAASA,gBAAe,CAACzgB,CAAD,EAAIC,CAAJ,CAAO;AAC3B,WAAQD,CAAEmS,CAAAA,SAAV,KAAwBlS,CAAEkS,CAAAA,SAA1B,IACInS,CAAEkS,CAAAA,KADN,KACgBjS,CAAEiS,CAAAA,KADlB,IAEIlS,CAAEgS,CAAAA,WAFN,KAEsB/R,CAAE+R,CAAAA,WAFxB;AAD2B;AAmK/B0O,UAASA,SAAQ,CAAC3tB,QAAD,CAAW;AACxB,WAAO,CAACA,QAAA,CAAS,GAAT,CAAD,EAAgBA,QAAA,CAAS,GAAT,CAAhB,CAAP;AADwB;AA8B5B4tB,UAASA,yBAAwB,CAAC7uB,GAAD,EAAML,aAAN,EAAqBE,MAArB,EAA6BivB,qBAA7B,CAAoD;AACjF,UAAM,CAAE/U,YAAF,CAAA,GAAmBpa,aAAzB;AAEIoa,gBAAA,CAAa/Z,GAAb,CAAJ,KACIH,MAAA,CAAOG,GAAP,CAEA,GAFc+Z,YAAA,CAAa/Z,GAAb,CAEd,EADAL,aAAcovB,CAAAA,cAAd,CAA6B/uB,GAA7B,EAAkC,CAAlC,CACA,EAAI8uB,qBAAJ,KACIA,qBAAA,CAAsB9uB,GAAtB,CADJ,GACiC,CADjC,CAHJ;AAHiF;AAWrFgvB,UAASA,uCAAsC,CAACC,cAAD,CAAiB;AAC5DA,kBAAeC,CAAAA,yBAAf,GAA2C,CAAA,CAA3C;AACA,QAAID,cAAe3c,CAAAA,IAAnB,KAA4B2c,cAA5B,CAAA;AAEA,UAAM,CAAEtvB,aAAF,CAAA,GAAoBsvB,cAAexpB,CAAAA,OAAzC;AACA,UAAK9F,aAAL,CAAA;AAEM0a,qBAAAA,GAAW7T,oBAAA,CAAqB7G,aAArB,CAAX0a;AACN,YAAI3O,MAAOyjB,CAAAA,2BAAP,CAAmC9U,aAAnC,EAA6C,WAA7C,CAAJ,CAA+D;AAC3D,gBAAM,CAAE0G,MAAF,EAAUwI,QAAV,CAAA,GAAuB0F,cAAexpB,CAAAA,OAA5C;AACAiG,gBAAO0jB,CAAAA,8BAAP,CAAsC/U,aAAtC,EAAgD,WAAhD,EAA6DE,KAA7D,EAAoE,EAAEwG,MAAF,IAAYwI,QAAZ,CAApE,CAAA;AAF2D;AAI/D,SAAM,CAAE,OAAA7M,cAAF,CAAN,GAAmBuS,cAAnB;AACIvS,sBAAJ,IAAc,CAACA,cAAOwS,CAAAA,yBAAtB,IACIF,sCAAA,CAAuCtS,cAAvC,CADJ;AARA;AAHA;AAF4D;AAiBhE2S,UAASA,uBAAsB,CAAC,CAAEC,oBAAF,EAAwBC,aAAxB,EAAuCC,aAAvC,EAAsDC,iBAAtD,EAAyEC,cAAzE,CAAD,CAA6F;AACxH,WAAO,KAAA;AACHC,iBAAW,CAAC5V,YAAA,GAAe,EAAhB,EAAoB2C,MAAA,GAA2B,IAAlB,KAAA6S,aAAA,IAA4C,IAAK,EAAjD,KAA0BA,aAA1B,GAAqD,IAAK,EAA1D,GAA8DA,aAAA,EAA3F,CAA4G;AAInH,YAAKhL,CAAAA,EAAL,GAAUA,EAAA,EAAV;AAIA,YAAKqL,CAAAA,WAAL,GAAmB,CAAnB;AAOA,YAAKC,CAAAA,QAAL,GAAgB,IAAIpuB,GAAJ,EAAhB;AAKA,YAAKgE,CAAAA,OAAL,GAAe,EAAf;AA2DA,YAAKypB,CAAAA,yBAAL,GAPA,IAAKY,CAAAA,oBAOL,GAXA,IAAKC,CAAAA,UAWL,GAhBA,IAAKC,CAAAA,KAgBL,GApBA,IAAKC,CAAAA,UAoBL,GAzBA,IAAKC,CAAAA,qBAyBL,GA1BA,IAAKC,CAAAA,qBA0BL,GA9BA,IAAKC,CAAAA,gBA8BL,GAnCA,IAAKC,CAAAA,uBAmCL,GAxCA,IAAKC,CAAAA,iBAwCL,GA7CA,IAAKC,CAAAA,aA6CL,GApDA,IAAKC,CAAAA,kBAoDL,GArDA,IAAKC,CAAAA,eAqDL,GArDuB,CAAA,CAqDvB;AASA,YAAK9E,CAAAA,SAAL,GAAiB,CAAErkB,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAjB;AAIA,YAAK8P,CAAAA,aAAL,GAAqB,IAAItlB,GAAJ,EAArB;AAGA,YAAKulB,CAAAA,eAAL,GAFA,IAAKC,CAAAA,eAEL,GAFuB,CAAA,CAEvB;AACA,YAAKC,CAAAA,cAAL,GAAsB,EAAAC,IAAM,IAAKvtB,CAAAA,MAAL,EAA5B;AACA,YAAKwtB,CAAAA,yBAAL,GAAiC,CAAA,CAAjC;AACA,YAAKC,CAAAA,iBAAL,GAAyB,EAAAC,IAAM;AACvB,cAAKhB,CAAAA,UAAT,KACI,IAAKA,CAAAA,UACL,GADkB,CAAA,CAClB,EAAA,IAAKiB,CAAAA,iBAAL,EAFJ;AAD2B,SAA/B;AAWA,YAAKC,CAAAA,gBAAL,GAAwB,EAAAC,IAAM;AAC1B,cAAKL,CAAAA,yBAAL,GAAiC,CAAA,CAAjC;AACA,cAAKM,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBwxB,mBAAnB,CAAA;AACA,cAAKD,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmByxB,kBAAnB,CAAA;AACA,cAAKF,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmB0xB,cAAnB,CAAA;AACA,cAAKH,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmB2xB,eAAnB,CAAA;AAL0B,SAA9B;AAUA,YAAKC,CAAAA,wBAAL,GAAgC,GAAhC;AACA,YAAKC,CAAAA,YAAL,GAAoB,CAAA,CAApB;AACA,YAAKC,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AACA,YAAKC,CAAAA,iBAAL,GAAyB,CAAzB;AAKA,YAAKC,CAAAA,WAAL,GAAmB,IAAI1mB,GAAJ,EAAnB;AACA,YAAK2O,CAAAA,YAAL,GAAoBA,YAApB;AACA,YAAKzH,CAAAA,IAAL,GAAYoK,MAAA,GAASA,MAAOpK,CAAAA,IAAhB,IAAwBoK,MAAxB,GAAiC,IAA7C;AACA,YAAKqV,CAAAA,IAAL,GAAYrV,MAAA,GAAS,CAAC,GAAGA,MAAOqV,CAAAA,IAAX,EAAiBrV,MAAjB,CAAT,GAAoC,EAAhD;AAEA,YAAKzQ,CAAAA,KAAL,GAAa,CADb,IAAKyQ,CAAAA,MACQ,GADCA,MACD,IAASA,MAAOzQ,CAAAA,KAAhB,GAAwB,CAAxB,GAA4B,CAAzC;AACA,aAAS7H,YAAT,GAAa,CAAb,EAAgBA,YAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,YAAA,EAAtC;AACI,cAAK2tB,CAAAA,IAAL,CAAU3tB,YAAV,CAAa0rB,CAAAA,oBAAb,GAAoC,CAAA,CAApC;AADJ;AAGI,YAAKxd,CAAAA,IAAT,KAAkB,IAAlB,KACI,IAAK+e,CAAAA,KADT,GACiB,IAAIW,QAAJ,EADjB;AAxImH;AA2IvHzO,sBAAgB,CAAC5Z,IAAD,EAAO0Z,OAAP,CAAgB;AACvB,YAAKqN,CAAAA,aAAcvvB,CAAAA,GAAnB,CAAuBwI,IAAvB,CAAL,IACI,IAAK+mB,CAAAA,aAActqB,CAAAA,GAAnB,CAAuBuD,IAAvB,EAA6B,IAAIsoB,mBAAJ,EAA7B,CADJ;AAGA,eAAO,IAAKvB,CAAAA,aAAczwB,CAAAA,GAAnB,CAAuB0J,IAAvB,CAA6BxH,CAAAA,GAA7B,CAAiCkhB,OAAjC,CAAP;AAJ4B;AAMhC6O,qBAAe,CAACvoB,IAAD,EAAO,GAAGwoB,IAAV,CAAgB;AAE3B,SADMC,IACN,GAD4B,IAAK1B,CAAAA,aAAczwB,CAAAA,GAAnB,CAAuB0J,IAAvB,CAC5B,KAAuByoB,IAAoBrW,CAAAA,MAApB,CAA2B,GAAGoW,IAA9B,CAAvB;AAF2B;AAI/BE,kBAAY,CAAC1oB,IAAD,CAAO;AACf,eAAO,IAAK+mB,CAAAA,aAAcvvB,CAAAA,GAAnB,CAAuBwI,IAAvB,CAAP;AADe;AAMnB2oB,WAAK,CAAC9P,QAAD,EAAW+N,aAAA,GAAgB,IAAKje,CAAAA,IAAKse,CAAAA,eAArC,CAAsD;AACvD,YAASpO,CAAL,IAAKA,CAAAA,QAAT,CAAA;AAEA,cAAKwN,CAAAA,KAAL,GAAalL,YAAA,CAAatC,QAAb,CAAb;AACA,cAAKA,CAAAA,QAAL,GAAgBA,QAAhB;AACA,cAAM,CAAE+G,QAAF,EAAYxI,MAAZ,EAAoBphB,aAApB,CAAA,GAAsC,IAAK8F,CAAAA,OAAjD;AACI9F,uBAAJ,IAAqB,CAACA,aAAcY,CAAAA,OAApC,IACIZ,aAAc2yB,CAAAA,KAAd,CAAoB9P,QAApB,CADJ;AAGA,cAAKlQ,CAAAA,IAAK+e,CAAAA,KAAMlvB,CAAAA,GAAhB,CAAoB,IAApB,CAAA;AACA,cAAKua,CAAAA,MAAL,IAAe,IAAKA,CAAAA,MAAOmT,CAAAA,QAAS1tB,CAAAA,GAArB,CAAyB,IAAzB,CAAf;AACIouB,uBAAJ,KAAsBxP,MAAtB,IAAgCwI,QAAhC,MACI,IAAKgH,CAAAA,aADT,GACyB,CAAA,CADzB;AAGA,cAAIjB,oBAAJ,CAA0B;AACtB,gBAAIiD,WAAJ;AACA,kBAAMC,sBAAsB,EAAAA,IAAO,IAAKlgB,CAAAA,IAAK4d,CAAAA,qBAAjBsC,GAAyC,CAAA,CAArE;AACAlD,gCAAA,CAAqB9M,QAArB,EAA+B,EAAA,IAAM;AACjC,kBAAKlQ,CAAAA,IAAK4d,CAAAA,qBAAV,GAAkC,CAAA,CAAlC;AACAqC,yBAAA,IAAeA,WAAA,EAAf;AACAA,yBAAA,GAAc/a,KAAA,CAAMgb,mBAAN,EAA2B,GAA3B,CAAd;AACIC,mCAAsBC,CAAAA,sBAA1B,KACID,qBAAsBC,CAAAA,sBACtB,GAD+C,CAAA,CAC/C,EAAA,IAAKrB,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmB6yB,eAAnB,CAFJ;AAJiC,aAArC,CAAA;AAHsB;AAatBpJ,kBAAJ,IACI,IAAKjX,CAAAA,IAAKsgB,CAAAA,kBAAV,CAA6BrJ,QAA7B,EAAuC,IAAvC,CADJ;AAI6B,WAAA,CAA7B,KAAI,IAAK9jB,CAAAA,OAAQkS,CAAAA,OAAjB,IACIhY,aADJ,KAEK4pB,QAFL,IAEiBxI,MAFjB,KAGI,IAAKwC,CAAAA,gBAAL,CAAsB,WAAtB,EAAmC,CAAC,CAAEzhB,KAAF,EAAS+wB,gBAAT,EAA2BC,wBAA3B,EAAqD,OAAQC,SAA7D,CAAD,CAAA,IAA+E;AAC9G,gBAAI,IAAKC,CAAAA,sBAAL,EAAJ;AAEI,kBAAKC,CAAAA,cAAL,GADA,IAAKltB,CAAAA,MACL,GADctF,IAAAA,EACd;AAFJ,kBAAA;AAMA,kBAAMyyB,mBAAmB,IAAKztB,CAAAA,OAAQK,CAAAA,UAAhCotB,IACFvzB,aAAc+Z,CAAAA,oBAAd,EADEwZ,IAEFC,uBAFJ,EAGM,CAAEC,sBAAF,EAA0BC,yBAA1B,CAAA,GAAyD1zB,aAAciB,CAAAA,QAAd,EAH/D,EAQyB,eARzB;AAQyB,eAAA,eAAA,GAAA,CAAA,IAAA,CAAA,YAAA,MACrB,eAAA,GAAA,IAAA,CAAA,YAAA,EAAA,eAAA,GAAA,EAjbb6tB,iBAAA,CAAkBvgB,eAAE5G,CAAAA,CAApB,EAiba6G,SAjbY7G,CAAAA,CAAzB,CAiba,IAjbkBmnB,iBAAA,CAAkBvgB,eAAE0S,CAAAA,CAApB,EAiblBzS,SAjb2CyS,CAAAA,CAAzB,CAiblB,CADqB;AAanB0S,sCAAAA,GAA+B,CAACT,gBAAhCS,IAAoDR,wBAApDQ;AACN,kBAAI,IAAK7tB,CAAAA,OAAQ8tB,CAAAA,UAAjB,IACI,IAAKC,CAAAA,UADT,IAEIF,wBAFJ,IAGKT,gBAHL,KAdyBY,eAczB,IAI6B,CAAC,IAAKC,CAAAA,gBAJnC,EAIuD;AAC/C,oBAAKF,CAAAA,UAAT,KACI,IAAKG,CAAAA,YACL,GADoB,IAAKH,CAAAA,UACzB,EAAA,IAAKG,CAAAA,YAAaA,CAAAA,YAAlB,GAAiClzB,IAAAA,EAFrC;AAIA,oBAAKmzB,CAAAA,kBAAL,CAAwB9xB,KAAxB,EAA+BwxB,wBAA/B,CAAA;AACMO,qBAAAA,GAAmB,CACrB,GAAG5f,SAAUiG,CAAAA,kBAAV,CAA6BgZ,gBAA7B,EAA+C,QAA/C,CADkB,EAErBY,OAAQV,sBAFa,EAGrBW,WAAYV,yBAHS,CAAnBQ;AAKN,oBAAIl0B,aAAc8a,CAAAA,kBAAlB,IACI,IAAKhV,CAAAA,OAAQ8tB,CAAAA,UADjB;AAEIM,uBAAiBrc,CAAAA,KACjB,GADyB,CACzB,EAAAqc,KAAiBtqB,CAAAA,IAAjB,GAAwB,CAAA,CAAxB;AAHJ;AAKA,oBAAKyqB,CAAAA,cAAL,CAAoBH,KAApB,CAAA;AAhBmD,eAJvD;AA+BI,oBAHKhB,gBAGD,IAFAF,eAAA,CAAgB,IAAhB,CAEA,EAAA,IAAKsB,CAAAA,MAAL,EAAA,IAAiB,IAAKxuB,CAAAA,OAAQ4e,CAAAA,cAAlC;AACI,sBAAK5e,CAAAA,OAAQ4e,CAAAA,cAAb,EAAA;AADJ;AA/BJ;AAmCA,kBAAK6P,CAAAA,YAAL,GAAoBnB,SAApB;AA/DA;AAD8G,WAAlH,CAHJ;AA9BA;AADuD;AAsG3DoB,aAAO,EAAG;AACN,YAAK1uB,CAAAA,OAAQ8jB,CAAAA,QAAb,IAAyB,IAAK6K,CAAAA,UAAL,EAAzB;AACA,YAAK9hB,CAAAA,IAAK+e,CAAAA,KAAMgD,CAAAA,MAAhB,CAAuB,IAAvB,CAAA;AACA,cAAMC,QAAQ,IAAKC,CAAAA,QAAL,EAAd;AACAD,aAAA,IAASA,KAAMD,CAAAA,MAAN,CAAa,IAAb,CAAT;AACA,YAAK3X,CAAAA,MAAL,IAAe,IAAKA,CAAAA,MAAOmT,CAAAA,QAASxtB,CAAAA,MAArB,CAA4B,IAA5B,CAAf;AACA,YAAKmgB,CAAAA,QAAL,GAAgB/hB,IAAAA,EAAhB;AACAusB,mBAAA,CAAY,IAAKmE,CAAAA,gBAAjB,CAAA;AAPM;AAUVqD,iBAAW,EAAG;AACV,YAAKrE,CAAAA,qBAAL,GAA6B,CAAA,CAA7B;AADU;AAGdsE,mBAAa,EAAG;AACZ,YAAKtE,CAAAA,qBAAL,GAA6B,CAAA,CAA7B;AADY;AAGhBuE,qBAAe,EAAG;AACd,eAAO,IAAKvE,CAAAA,qBAAZ,IAAqC,IAAKD,CAAAA,qBAA1C;AADc;AAGlB8C,4BAAsB,EAAG;AACrB,eAAQ,IAAKxC,CAAAA,kBAAb,IACK,IAAK9T,CAAAA,MADV,IACoB,IAAKA,CAAAA,MAAOsW,CAAAA,sBAAZ,EADpB,IAEI,CAAA,CAFJ;AADqB;AAMzB2B,iBAAW,EAAG;AACN,YAAKD,CAAAA,eAAL,EAAJ,KAEA,IAAKzE,CAAAA,UAEL,GAFkB,CAAA,CAElB,EADA,IAAKoB,CAAAA,KACL,IADc,IAAKA,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmB80B,oBAAnB,CACd,EAAA,IAAKhF,CAAAA,WAAL,EAJA;AADU;AAOdiF,0BAAoB,EAAG;AACnB,cAAM,CAAEl1B,aAAF,CAAA,GAAoB,IAAK8F,CAAAA,OAA/B;AACA,eAAO9F,aAAP,IAAwBA,aAAciB,CAAAA,QAAd,EAAyB+kB,CAAAA,iBAAjD;AAFmB;AAIvByO,gBAAU,CAACU,qBAAA,GAAwB,CAAA,CAAzB,CAA+B;AACrC,YAAKxiB,CAAAA,IAAKse,CAAAA,eAAV,GAA4B,CAAA,CAA5B;AACA,YAAI,IAAKte,CAAAA,IAAKoiB,CAAAA,eAAV,EAAJ;AACI,cAAKjvB,CAAAA,OAAQ4e,CAAAA,cAAb,IAA+B,IAAK5e,CAAAA,OAAQ4e,CAAAA,cAAb,EAA/B;AADJ;AAqBA,cALI3Y,MAAO0jB,CAAAA,8BAKFmB,IAJL,CAAC,IAAKrB,CAAAA,yBAIDqB,IAHLvB,sCAAA,CAAuC,IAAvC,CAGKuB,EADT,CAAC,IAAKje,CAAAA,IAAK2d,CAAAA,UACFM,IADgB,IAAKje,CAAAA,IAAKqiB,CAAAA,WAAV,EAChBpE,EAAAA,CAAL,IAAKA,CAAAA,aAAT,CAAA;AAEA,gBAAKA,CAAAA,aAAL,GAAqB,CAAA,CAArB;AACA,iBAAK,IAAInsB,IAAI,CAAb,EAAgBA,CAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,CAAA,EAAtC,CAA2C;AACvC,oBAAM2nB,OAAO,IAAKgG,CAAAA,IAAL,CAAU3tB,CAAV,CAAb;AACA2nB,kBAAK+D,CAAAA,oBAAL,GAA4B,CAAA,CAA5B;AACA/D,kBAAKgJ,CAAAA,YAAL,CAAkB,UAAlB,CAAA;AACIhJ,kBAAKtmB,CAAAA,OAAQ8tB,CAAAA,UAAjB,IACIxH,IAAKqI,CAAAA,UAAL,CAAgB,CAAA,CAAhB,CADJ;AAJuC;AAQ3C,gBAAM,CAAE7K,QAAF,EAAYxI,MAAZ,CAAA,GAAuB,IAAKtb,CAAAA,OAAlC;AACA,gBAAiBhF,IAAAA,EAAjB,KAAI8oB,QAAJ,IAA+BxI,MAA/B;AAGA,kBAAKiU,CAAAA,0BAIL,GAJkC,CAD5BrP,CAC4B,GADR,IAAKkP,CAAAA,oBAAL,EACQ,IAC5BlP,CAAA,CAAkB,IAAK5L,CAAAA,YAAvB,EAAqC,EAArC,CAD4B,GAE5BtZ,IAAAA,EAEN,EADA,IAAKw0B,CAAAA,cAAL,EACA,EAAAH,qBAAA,IAAyB,IAAK5C,CAAAA,eAAL,CAAqB,YAArB,CAAzB;AAPA;AAZA;AArBA;AAFqC;AA4CzC3uB,YAAM,EAAG;AACL,YAAKotB,CAAAA,eAAL,GAAuB,CAAA,CAAvB;AAKA,YAJyB,IAAK+D,CAAAA,eAALQ,EAIzB;AACI,cAAKT,CAAAA,aAAL,EAEA,EADA,IAAKvD,CAAAA,iBAAL,EACA,EAAA,IAAKG,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBq1B,iBAAnB,CAAA;AAHJ,cAAA;AAMK,cAAKlF,CAAAA,UAAV,IACI,IAAKoB,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBs1B,kBAAnB,CADJ;AAGA,cAAKnF,CAAAA,UAAL,GAAkB,CAAA,CAAlB;AAIA,cAAKoB,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBu1B,mBAAnB,CAAA;AAKA,cAAKhE,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBw1B,YAAnB,CAAA;AAKA,cAAKjE,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmBy1B,kBAAnB,CAAA;AACA,cAAKrE,CAAAA,iBAAL,EAAA;AAMA,cAAMntB,MAAM+oB,IAAK/oB,CAAAA,GAAL,EAAZ;AACAxB,mBAAUT,CAAAA,KAAV,GAAkBsO,KAAA,CAAM,CAAN,EAAS,IAAT,GAAgB,EAAhB,EAAoBrM,GAApB,GAA0BxB,SAAUR,CAAAA,SAApC,CAAlB;AACAQ,mBAAUR,CAAAA,SAAV,GAAsBgC,GAAtB;AACAxB,mBAAUZ,CAAAA,YAAV,GAAyB,CAAA,CAAzB;AACA6zB,oBAAWjyB,CAAAA,MAAOjB,CAAAA,OAAlB,CAA0BC,SAA1B,CAAA;AACAizB,oBAAWhyB,CAAAA,SAAUlB,CAAAA,OAArB,CAA6BC,SAA7B,CAAA;AACAizB,oBAAW/xB,CAAAA,MAAOnB,CAAAA,OAAlB,CAA0BC,SAA1B,CAAA;AACAA,mBAAUZ,CAAAA,YAAV,GAAyB,CAAA,CAAzB;AArCA;AANK;AA6CT8zB,eAAS,EAAG;AACH,YAAK9E,CAAAA,eAAV,KACI,IAAKA,CAAAA,eACL,GADuB,CAAA,CACvB,EAAA+E,SAAUryB,CAAAA,IAAV,CAAe,IAAKwtB,CAAAA,cAApB,CAFJ;AADQ;AAMZK,uBAAiB,EAAG;AAChB,YAAKG,CAAAA,KAAMvxB,CAAAA,OAAX,CAAmB61B,aAAnB,CAAA;AACA,YAAK7D,CAAAA,WAAYhyB,CAAAA,OAAjB,CAAyB81B,mBAAzB,CAAA;AAFgB;AAIpBC,8BAAwB,EAAG;AAClB,YAAK9E,CAAAA,yBAAV,KACI,IAAKA,CAAAA,yBACL,GADiC,CAAA,CACjC,EAAAxW,KAAM/W,CAAAA,SAAN,CAAgB,IAAK2tB,CAAAA,gBAArB,EAAuC,CAAA,CAAvC,EAA8C,CAAA,CAA9C,CAFJ;AADuB;AAM3B2E,+BAAyB,EAAG;AAMxBvb,aAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAM;AACf,cAAK6sB,CAAAA,aAAT,GACI,IAAKje,CAAAA,IAAKmjB,CAAAA,SAAV,EADJ,GAII,IAAKnjB,CAAAA,IAAK0e,CAAAA,iBAAV,EAJJ;AADmB,SAAvB,CAAA;AANwB;AAkB5BiE,oBAAc,EAAG;AACJc,SAAL,IAAKA,CAAAA,QAAT,IAAsB,IAAKvT,CAAAA,QAA3B,KAEAuT,EAAA,IAAKA,CAAAA,QAALA,GAAgB,IAAKC,CAAAA,OAAL,EAAhBD,CAFA,IAIKhW,UAAA,CAAW,IAAKgW,CAAAA,QAASE,CAAAA,WAAY3uB,CAAAA,CAArC,CAJL,IAKKyY,UAAA,CAAW,IAAKgW,CAAAA,QAASE,CAAAA,WAAYrV,CAAAA,CAArC,CALL,KAMI,IAAKmV,CAAAA,QANT,GAMoBt1B,IAAAA,EANpB;AADa;AAUjB60B,kBAAY,EAAG;AACX,YAAK,IAAK9S,CAAAA,QAAV,KAGA,IAAKuS,CAAAA,YAAL,EACI,EAAE,IAAKtvB,CAAAA,OAAQywB,CAAAA,mBAAf,IAAsC,IAAKjC,CAAAA,MAAL,EAAtC,IACC,IAAK1D,CAAAA,aALV,EAIA;AAWA,cAAI,IAAKiD,CAAAA,UAAT,IAAuB,CAAC,IAAKA,CAAAA,UAAWhR,CAAAA,QAAxC;AACI,iBAAK,IAAIpe,IAAI,CAAb,EAAgBA,CAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,CAAA,EAAtC;AACiB,kBAAK2tB,CAAAA,IAALhG,CAAU3nB,CAAV2nB,CACRgJ,CAAAA,YAAL,EAAA;AAFJ;AADJ;AAMMoB,WAAAA,GAAa,IAAKpV,CAAAA,MAAlBoV;AACN,cAAKpV,CAAAA,MAAL,GAAc,IAAKiV,CAAAA,OAAL,CAAa,CAAA,CAAb,CAAd;AACA,cAAKI,CAAAA,eAAL,GAAuBC,SAAA,EAAvB;AACA,cAAK9F,CAAAA,aAAL,GAAqB,CAAA,CAArB;AACA,cAAKvE,CAAAA,eAAL,GAAuBvrB,IAAAA,EAAvB;AACA,cAAKyxB,CAAAA,eAAL,CAAqB,SAArB,EAAgC,IAAKnR,CAAAA,MAAOuV,CAAAA,SAA5C,CAAA;AACA,cAAM,CAAE32B,aAAF,CAAA,GAAoB,IAAK8F,CAAAA,OAA/B;AACA9F,uBAAA,IACIA,aAAcoc,CAAAA,MAAd,CAAqB,eAArB,EAAsC,IAAKgF,CAAAA,MAAOuV,CAAAA,SAAlD,EAA6DH,CAAA,GAAaA,CAAWG,CAAAA,SAAxB,GAAoC71B,IAAAA,EAAjG,CADJ;AAxBA;AALW;AAgCfs0B,kBAAY,CAACwB,KAAA,GAAQ,SAAT,CAAoB;AAC5B,YAAIvrB,mBAAmB,EAAqBkhB,CAAb,IAAKzmB,CAAAA,OAAQymB,CAAAA,YAArB,IAA0C1J,CAAL,IAAKA,CAAAA,QAA1C,CAAvB;AACI,YAAK2J,CAAAA,MAAT,IACI,IAAKA,CAAAA,MAAOyD,CAAAA,WADhB,KACgC,IAAKtd,CAAAA,IAAKsd,CAAAA,WAD1C,IAEI,IAAKzD,CAAAA,MAAOoK,CAAAA,KAFhB,KAE0BA,KAF1B,KAGIvrB,gBAHJ,GAGuB,CAAA,CAHvB;AAKIA,wBAAJ,KACUwrB,gBACN,GADe/G,iBAAA,CAAkB,IAAKjN,CAAAA,QAAvB,CACf,EAAA,IAAK2J,CAAAA,MAAL,GAAc,CACVyD,YAAa,IAAKtd,CAAAA,IAAKsd,CAAAA,WADb,EAEV2G,KAFU,EAGVC,OAAAA,gBAHU,EAIVjgB,OAAQiZ,aAAA,CAAc,IAAKhN,CAAAA,QAAnB,CAJE,EAKViU,QAAS,IAAKtK,CAAAA,MAAL,GAAc,IAAKA,CAAAA,MAAOqK,CAAAA,MAA1B,GAAmCA,gBALlC,CAFlB;AAP4B;AAkBhC9G,oBAAc,EAAG;AACb,YAAKA,cAAL,CAAA;AAEA,cAAMgH,mBAAmB,IAAKnG,CAAAA,aAAxBmG,IACF,IAAK5G,CAAAA,oBADH4G,IAEF,IAAKjxB,CAAAA,OAAQywB,CAAAA,mBAFjB,EAGsB,eAHtB;AAGsB,cAAKlK,eAAL,GAAKA,IAAAA,CAAAA,eAAL;AAAwB,2BAAA,GAAA,IAAA,CAAA,eAAA,EAAA,eAAA,GAAA,EAntB/CuC,eAAA,CAAgBzsB,eAAMwF,CAAAA,CAAtB,CAmtB+C,IAntBnBinB,eAAA,CAAgBzsB,eAAM8e,CAAAA,CAAtB,CAmtBmB,CAAA;AAAxB;AACtB,cAAM+E,oBAAoB,IAAKkP,CAAAA,oBAAL,EAA1B;AACM8B,2BAAAA,GAAyBhR,iBAAA,GACzBA,iBAAA,CAAkB,IAAK5L,CAAAA,YAAvB,EAAqC,EAArC,CADyB,GAEzBtZ,IAAAA,EAFAk2B;AAGN,cAAMC,8BAA8BD,iBAA9BC,KAAyD,IAAK5B,CAAAA,0BAApE;AACI0B,0BAAJ,KACKG,eADL,IAEQpQ,YAAA,CAAa,IAAK1M,CAAAA,YAAlB,CAFR,IAGQ6c,2BAHR,MAIIlH,cAAA,CAAe,IAAKlN,CAAAA,QAApB,EAA8BmU,iBAA9B,CAEA,EADA,IAAK7G,CAAAA,oBACL,GAD4B,CAAA,CAC5B,EAAA,IAAKgH,CAAAA,cAAL,EANJ;AAXA;AADa;AAqBjBd,aAAO,CAACe,eAAA,GAAkB,CAAA,CAAnB,CAAyB;AAC5B,cAAMC,UAAU,IAAKC,CAAAA,cAAL,EAAhB;AACA,YAAIX,YAAY,IAAKY,CAAAA,mBAAL,CAAyBF,OAAzB,CAAhB;AAMID,uBAAJ,KACIT,SADJ,GACgB,IAAKS,CAAAA,eAAL,CAAqBT,SAArB,CADhB;AAGSA,uBAAAA,GAAAA,SAAAA;AAi9BjBa,iBAAA,CAAU1L,eAAInkB,CAAAA,CAAd,CAAA;AACA6vB,iBAAA,CAAU1L,eAAI7K,CAAAA,CAAd,CAAA;AAj9BQ,eAAO,CACHgP,YAAa,IAAKtd,CAAAA,IAAKsd,CAAAA,WADpB,EAEHqG,YAAae,OAFV,EAGHV,SAHG,EAIHvc,aAAc,EAJX,EAKH3Q,OAAQ,IAAKmb,CAAAA,EALV,CAAP;AAZ4B;AAoBhC0S,oBAAc,EAAG;AACb,YAAI1rB,EAAJ,EACM,CAAE5L,aAAF,CAAA,GAAoB,IAAK8F,CAAAA,OAD/B;AAEA,YAAI,CAAC9F,aAAL;AACI,iBAAO02B,SAAA,EAAP;AADJ;AAEM5K,qBAAAA,GAAM9rB,aAAcy3B,CAAAA,kBAAd,EAAN3L;AAEN,SADgD,IAAvB,MAAClgB,EAAD,GAAM,IAAK4gB,CAAAA,MAAX,KAAsC,IAAK,EAA3C,KAA+B5gB,EAA/B,GAA+C,CAA/C,GAAwDA,EAAGkrB,CAAAA,OACpF,KADgG,IAAK1E,CAAAA,IAAKhgB,CAAAA,IAAV,CAAeslB,sBAAf,CAChG,KAEU,CAAE,OAAAlL,EAAF,CACN,GADmB,IAAK7Z,CAAAA,IACxB,EAAI6Z,EAAJ,KACII,aAAA,CAAcd,aAAInkB,CAAAA,CAAlB,EAAqB6kB,EAAO5V,CAAAA,MAAOjP,CAAAA,CAAnC,CACA,EAAAilB,aAAA,CAAcd,aAAI7K,CAAAA,CAAlB,EAAqBuL,EAAO5V,CAAAA,MAAOqK,CAAAA,CAAnC,CAFJ,CAHJ;AAQA,eAAO6K,aAAP;AAfa;AAiBjByL,yBAAmB,CAACzL,GAAD,CAAM;AACrB,YAAIlgB,EAAJ;AACA,cAAM+rB,mBAAmBjB,SAAA,EAAzB;AACAhJ,mBAAA,CAAYiK,gBAAZ,EAA8B7L,GAA9B,CAAA;AACA,YAA2B,IAAvB,MAAClgB,EAAD,GAAM,IAAK4gB,CAAAA,MAAX,KAAsC,IAAK,EAA3C,KAA+B5gB,EAA/B,GAA+C,CAA/C,GAAwDA,EAAGkrB,CAAAA,OAA/D;AACI,iBAAOa,gBAAP;AADJ;AAOA,aAASlzB,EAAT,GAAa,CAAb,EAAgBA,EAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,EAAA,EAAtC,CAA2C;AACvC,gBAAM2nB,OAAO,IAAKgG,CAAAA,IAAL,CAAU3tB,EAAV,CAAb,EACM,CAAE+nB,MAAF,EAAU1mB,OAAV,CAAA,GAAsBsmB,IAD5B;AAEIA,cAAJ,KAAa,IAAKzZ,CAAAA,IAAlB,IAA0B6Z,MAA1B,IAAoC1mB,OAAQymB,CAAAA,YAA5C,KAKQC,MAAOsK,CAAAA,OAIX,IAHIpJ,WAAA,CAAYiK,gBAAZ,EAA8B7L,GAA9B,CAGJ,EADAc,aAAA,CAAc+K,gBAAiBhwB,CAAAA,CAA/B,EAAkC6kB,MAAO5V,CAAAA,MAAOjP,CAAAA,CAAhD,CACA,EAAAilB,aAAA,CAAc+K,gBAAiB1W,CAAAA,CAA/B,EAAkCuL,MAAO5V,CAAAA,MAAOqK,CAAAA,CAAhD,CATJ;AAHuC;AAe3C,eAAO0W,gBAAP;AA1BqB;AA4BzBC,oBAAc,CAAC9L,GAAD,EAAM+L,aAAA,GAAgB,CAAA,CAAtB,CAA6B;AACvC,cAAMC,iBAAiBpB,SAAA,EAAvB;AACAhJ,mBAAA,CAAYoK,cAAZ,EAA4BhM,GAA5B,CAAA;AACA,aAASrnB,GAAT,GAAa,CAAb,EAAgBA,GAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,GAAA,EAAtC,CAA2C;AACvC,gBAAM2nB,OAAO,IAAKgG,CAAAA,IAAL,CAAU3tB,GAAV,CAAb;AACI,WAACozB,aAAL,IACIzL,IAAKtmB,CAAAA,OAAQymB,CAAAA,YADjB,IAEIH,IAAKI,CAAAA,MAFT,IAGIJ,IAHJ,KAGaA,IAAKzZ,CAAAA,IAHlB,IAII8Z,YAAA,CAAaqL,cAAb,EAA6B,CACzBnwB,EAAG,CAACykB,IAAKI,CAAAA,MAAO5V,CAAAA,MAAOjP,CAAAA,CADE,EAEzBsZ,EAAG,CAACmL,IAAKI,CAAAA,MAAO5V,CAAAA,MAAOqK,CAAAA,CAFE,CAA7B,CAJJ;AASK6F,sBAAA,CAAasF,IAAKhS,CAAAA,YAAlB,CAAL,IAEAqS,YAAA,CAAaqL,cAAb,EAA6B1L,IAAKhS,CAAAA,YAAlC,CAFA;AAXuC;AAevC0M,oBAAA,CAAa,IAAK1M,CAAAA,YAAlB,CAAJ,IACIqS,YAAA,CAAaqL,cAAb,EAA6B,IAAK1d,CAAAA,YAAlC,CADJ;AAGA,eAAO0d,cAAP;AArBuC;AAuB3CV,qBAAe,CAACtL,GAAD,CAAM;AACjB,cAAMiM,sBAAsBrB,SAAA,EAA5B;AACAhJ,mBAAA,CAAYqK,mBAAZ,EAAiCjM,GAAjC,CAAA;AACA,aAASrnB,GAAT,GAAa,CAAb,EAAgBA,GAAhB,GAAoB,IAAK2tB,CAAAA,IAAK1tB,CAAAA,MAA9B,EAAsCD,GAAA,EAAtC,CAA2C;AACvC,gBAAM2nB,OAAO,IAAKgG,CAAAA,IAAL,CAAU3tB,GAAV,CAAb;AACA,cAAI,CAAC2nB,IAAKvJ,CAAAA,QAAV;AACI;AADJ;AAEA,cAAI,CAACiE,YAAA,CAAasF,IAAKhS,CAAAA,YAAlB,CAAL;AACI;AADJ;AAEA2Q,kBAAA,CAASqB,IAAKhS,CAAAA,YAAd,CAAA,IAA+BgS,IAAKkJ,CAAAA,cAAL,EAA/B;AACA,gBAAM7G,YAAYiI,SAAA,EAAlB,EACMsB,UAAU5L,IAAKkL,CAAAA,cAAL,EADhB;AAEA5J,qBAAA,CAAYe,SAAZ,EAAuBuJ,OAAvB,CAAA;AACAxJ,6BAAA,CAAoBuJ,mBAApB,EAAyC3L,IAAKhS,CAAAA,YAA9C,EAA4DgS,IAAKgK,CAAAA,QAAL,GAAgBhK,IAAKgK,CAAAA,QAASO,CAAAA,SAA9B,GAA0C71B,IAAAA,EAAtG,EAAiH2tB,SAAjH,CAAA;AAVuC;AAYvC3H,oBAAA,CAAa,IAAK1M,CAAAA,YAAlB,CAAJ,IACIoU,mBAAA,CAAoBuJ,mBAApB,EAAyC,IAAK3d,CAAAA,YAA9C,CADJ;AAGA,eAAO2d,mBAAP;AAlBiB;AAoBrBE,oBAAc,CAAC91B,KAAD,CAAQ;AAClB,YAAK+1B,CAAAA,WAAL,GAAmB/1B,KAAnB;AACA,YAAKwQ,CAAAA,IAAKujB,CAAAA,wBAAV,EAAA;AACA,YAAKvF,CAAAA,iBAAL,GAAyB,CAAA,CAAzB;AAHkB;AAKtBwH,gBAAU,CAACryB,OAAD,CAAU;AAChB,YAAKA,CAAAA,OAAL,GAAe,CACX,GAAG,IAAKA,CAAAA,OADG,EAEX,GAAGA,OAFQ,EAGXsyB,UAAiCt3B,IAAAA,EAAtB,KAAAgF,OAAQsyB,CAAAA,SAAR,GAAkCtyB,OAAQsyB,CAAAA,SAA1C,GAAsD,CAAA,CAHtD,CAAf;AADgB;AAOpB5C,uBAAiB,EAAG;AAMhB,YAAKpvB,CAAAA,MAAL,GADA,IAAK8xB,CAAAA,WACL,GAFA,IAAK7C,CAAAA,0BAEL,GAHA,IAAKe,CAAAA,QAGL,GAJA,IAAKhV,CAAAA,MAIL,GALA,IAAKoL,CAAAA,MAKL,GALc1rB,IAAAA,EAKd;AACA,YAAK8vB,CAAAA,aAAL,GAAqB,CAAA,CAArB;AAPgB;AASpByH,wCAAkC,EAAG;AAC5B,YAAKC,CAAAA,cAAV,IAQI,IAAKA,CAAAA,cAAevG,CAAAA,wBARxB,KASInvB,SAAUR,CAAAA,SATd,IAUI,IAAKk2B,CAAAA,cAAe1G,CAAAA,kBAApB,CAAuC,CAAA,CAAvC,CAVJ;AADiC;AAcrCA,wBAAkB,CAAC2G,kBAAA,GAAqB,CAAA,CAAtB,CAA6B;AAC3C,YAAI3sB,EAAJ,EAMM4sB,OAAO,IAAKC,CAAAA,OAAL,EANb;AAOA,YAAK9H,CAAAA,iBAAL,KAA2B,IAAKA,CAAAA,iBAAhC,GAAoD6H,IAAK7H,CAAAA,iBAAzD;AACA,YAAKF,CAAAA,gBAAL,KAA0B,IAAKA,CAAAA,gBAA/B,GAAkD+H,IAAK/H,CAAAA,gBAAvD;AACA,YAAKC,CAAAA,uBAAL,KAAiC,IAAKA,CAAAA,uBAAtC,GAAgE8H,IAAK9H,CAAAA,uBAArE;AACMgI,YAAAA,GAAW,CAAA,CAAQ,IAAK1E,CAAAA,YAAxB0E,IAAyC,IAAzCA,KAAkDF,IAAlDE;AAWN,YANkBH,kBAMlB,IALKG,IAKL,IALiB,IAAKhI,CAAAA,uBAKtB,IAJI,IAAKC,CAAAA,iBAIT,KAH4B,IAAvB,MAAC/kB,EAAD,GAAM,IAAKmR,CAAAA,MAAX,KAAsC,IAAK,EAA3C,KAA+BnR,EAA/B,GAA+C,CAA/C,GAAwDA,EAAG+kB,CAAAA,iBAGhE,KAFI,IAAKgI,CAAAA,8BAET,IADI,IAAKhmB,CAAAA,IAAK4d,CAAAA,qBACd,CAAA;AAEA,cAAM,CAAEnP,MAAF,EAAUwI,QAAV,CAAA,GAAuB,IAAK9jB,CAAAA,OAAlC;AAIA,cAAK,IAAKsb,CAAAA,MAAV,KAAsBA,MAAtB,IAAgCwI,QAAhC,MAEA,IAAKmI,CAAAA,wBA0BD,GA1B4BnvB,SAAUR,CAAAA,SA0BtC,EApBC,IAAK81B,CAAAA,WAoBN,IApBsB,IAAK5E,CAAAA,cAoB3B,KAlBA,CADMgF,kBACN,GADuB,IAAKM,CAAAA,0BAAL,EACvB,KACIN,kBAAelX,CAAAA,MADnB,IAE+B,CAF/B,KAEI,IAAK8Q,CAAAA,iBAFT,IAGI,IAAKoG,CAAAA,cAKL,GALsBA,kBAKtB,EAJA,IAAKD,CAAAA,kCAAL,EAIA,EAHA,IAAK/E,CAAAA,cAGL,GAHsBoD,SAAA,EAGtB,EAFA,IAAKmC,CAAAA,oBAEL,GAF4BnC,SAAA,EAE5B,EADAvV,oBAAA,CAAqB,IAAK0X,CAAAA,oBAA1B,EAAgD,IAAKzX,CAAAA,MAAOuV,CAAAA,SAA5D;AAAuE2B,4BAAelX,CAAAA,MAAOuV,CAAAA,SAA7F,CACA,EAAAjJ,WAAA,CAAY,IAAK4F,CAAAA,cAAjB,EAAiC,IAAKuF,CAAAA,oBAAtC,CARJ,IAWI,IAAKP,CAAAA,cAXT,GAW0B,IAAKhF,CAAAA,cAX/B,GAWgDxyB,IAAAA,EAOhD,GAAC,IAAKwyB,CAAAA,cAAN,IAAyB,IAAK4E,CAAAA,WA5BlC,EA4BA;AAKK,gBAAK9xB,CAAAA,MAAV,KACI,IAAKA,CAAAA,MACL,GADcswB,SAAA,EACd,EAAA,IAAKoC,CAAAA,oBAAL,GAA4BpC,SAAA,EAFhC;AAOA,gBAAI,IAAKpD,CAAAA,cAAT,IACI,IAAKuF,CAAAA,oBADT,IAEI,IAAKP,CAAAA,cAFT,IAGI,IAAKA,CAAAA,cAAelyB,CAAAA,MAHxB,CAGgC;AAC5B,kBAAKiyB,CAAAA,kCAAL,EAAA;AACqBjyB,kBAAAA,GAALA,IAAKA,CAAAA,MAAAA;AAAaktB,gBAAAA,GAALA,IAAKA,CAAAA,cAAAA;AAAoCltB,gCAAAA,GAApBA,IAAKkyB,CAAAA,cAAelyB,CAAAA,MAAAA;AA9pF1DuB,kBAAAA,SAAPvB,IAAOuB,CAAAA,CAAAA,EAAYA,WAAToxB,EAASpxB,CAAAA,CAAZA;AAJxBvB,oBAAO7B,CAAAA,GAAP,GAIuCwY,kBAAOpV,CAAAA,CAJ1BpD,CAAAA,GAApB,GAA0Bw0B,QAASx0B,CAAAA,GAAnC;AACA6B,oBAAO9B,CAAAA,GAAP,GAAa8B,MAAO7B,CAAAA,GAApB,GAA0B6b,UAAA,CAAW2Y,QAAX,CAA1B;AAIwB9X,kBAAAA,GAAP7a,IAAO6a,CAAAA,CAAAA;AAAYA,gBAAAA,GAAT8X,EAAS9X,CAAAA,CAAAA;AALpC7a,kBAAO7B,CAAAA,GAAP,GAKuCwY,kBAAOkE,CAAAA,CAL1B1c,CAAAA,GAApB,GAA0Bw0B,EAASx0B,CAAAA,GAAnC;AACA6B,kBAAO9B,CAAAA,GAAP,GAAa8B,IAAO7B,CAAAA,GAApB,GAA0B6b,UAAA,CAAW2Y,EAAX,CAA1B;AA+pFwC,aAHhC;AAUS,kBAAKb,CAAAA,WAAT,IACW,IAAKlE,CAAAA,YAAjB,GAEI,IAAK5tB,CAAAA,MAFT,GAEkB,IAAKwxB,CAAAA,cAAL,CAAoB,IAAKxW,CAAAA,MAAOuV,CAAAA,SAAhC,CAFlB,GAKIjJ,WAAA,CAAY,IAAKtnB,CAAAA,MAAjB,EAAyB,IAAKgb,CAAAA,MAAOuV,CAAAA,SAArC,CAEJ,EAAA9K,aAAA,CAAc,IAAKzlB,CAAAA,MAAnB,EAA2B,IAAK8xB,CAAAA,WAAhC,CARC,IAcDxK,WAAA,CAAY,IAAKtnB,CAAAA,MAAjB,EAAyB,IAAKgb,CAAAA,MAAOuV,CAAAA,SAArC,CAdC;AAVL;AA6BI,gBAAKgC,CAAAA,8BAAT,KACI,IAAKA,CAAAA,8BAEL,GAFsC,CAAA,CAEtC,EAAA,CADML,kBACN,GADuB,IAAKM,CAAAA,0BAAL,EACvB,KACI,CAAA,CAAQN,kBAAetE,CAAAA,YAD3B,KAEQ,CAAA,CAAQ,IAAKA,CAAAA,YAFrB,IAGI,CAACsE,kBAAexyB,CAAAA,OAAQymB,CAAAA,YAH5B,IAII+L,kBAAelyB,CAAAA,MAJnB,IAK+B,CAL/B,KAKI,IAAK8rB,CAAAA,iBALT,IAMI,IAAKoG,CAAAA,cAKL,GALsBA,kBAKtB,EAJA,IAAKD,CAAAA,kCAAL,EAIA,EAHA,IAAK/E,CAAAA,cAGL,GAHsBoD,SAAA,EAGtB,EAFA,IAAKmC,CAAAA,oBAEL,GAF4BnC,SAAA,EAE5B,EADAvV,oBAAA,CAAqB,IAAK0X,CAAAA,oBAA1B;AAAgD,gBAAKzyB,CAAAA,MAArD,EAA6DkyB,kBAAelyB,CAAAA,MAA5E,CACA,EAAAsnB,WAAA,CAAY,IAAK4F,CAAAA,cAAjB,EAAiC,IAAKuF,CAAAA,oBAAtC,CAXJ,IAcI,IAAKP,CAAAA,cAdT,GAc0B,IAAKhF,CAAAA,cAd/B,GAcgDxyB,IAAAA,EAjBpD;AAzCA;AAlCA;AAtB2C;AAsH/C83B,gCAA0B,EAAG;AACzB,YAAK,IAAK7b,CAAAA,MAAV,IACI,CAAAgO,QAAA,CAAS,IAAKhO,CAAAA,MAAO3C,CAAAA,YAArB,CADJ,IAEI,CAAA8Q,cAAA,CAAe,IAAKnO,CAAAA,MAAO3C,CAAAA,YAA3B,CAFJ;AAKA,iBAAI,IAAK2C,CAAAA,MAAOic,CAAAA,YAAZ,EAAJ,GACW,IAAKjc,CAAAA,MADhB,GAIW,IAAKA,CAAAA,MAAO6b,CAAAA,0BAAZ,EAJX;AALA;AADyB;AAa7BI,kBAAY,EAAG;AACX,eAAO,EAAS,EAAA,IAAK1F,CAAAA,cAAL,IACZ,IAAK4E,CAAAA,WADO,IAEZ,IAAKpyB,CAAAA,OAAQ8tB,CAAAA,UAFD,CAAT,IAGExS,CAAL,IAAKA,CAAAA,MAHF,CAAP;AADW;AAMfyQ,oBAAc,EAAG;AACb,YAAIjmB,EAAJ,EACM4sB,OAAO,IAAKC,CAAAA,OAAL,EADb;AAEA,cAAMC,WAAW,CAAA,CAAQ,IAAK1E,CAAAA,YAAxB0E,IAAyC,IAAzCA,KAAkDF,IAAxD;AACA,YAAIS,UAAU,CAAA,CAAd;AAKA,YAAI,IAAKtI,CAAAA,iBAAT,KAAsD,IAAvB,MAAC/kB,EAAD,GAAM,IAAKmR,CAAAA,MAAX,KAAsC,IAAK,EAA3C,KAA+BnR,EAA/B,GAA+C,CAA/C,GAAwDA,EAAG+kB,CAAAA,iBAA1F;AACIsI,iBAAA,GAAU,CAAA,CAAV;AADJ;AAOIP,gBAAJ,KACK,IAAKhI,CAAAA,uBADV,IACqC,IAAKD,CAAAA,gBAD1C,MAEIwI,OAFJ,GAEc,CAAA,CAFd;AAQI,YAAKlH,CAAAA,wBAAT,KAAsCnvB,SAAUR,CAAAA,SAAhD,KACI62B,OADJ,GACc,CAAA,CADd;AAGA,YAAIA,CAAAA,OAAJ,CAAA;AAEA,cAAM,CAAE7X,MAAF,EAAUwI,QAAV,CAAA,GAAuB,IAAK9jB,CAAAA,OAAlC;AAKA,cAAKgrB,CAAAA,eAAL,GAAuB,CAAA,EAAS,IAAK/T,CAAAA,MAAd,IAAwB,IAAKA,CAAAA,MAAO+T,CAAAA,eAApC,IACnB,IAAKiD,CAAAA,gBADc,IAEnB,IAAKmF,CAAAA,gBAFc,CAAvB;AAGK,cAAKpI,CAAAA,eAAV,KACI,IAAKoH,CAAAA,WADT,GACuB,IAAK5E,CAAAA,cAD5B,GAC6CxyB,IAAAA,EAD7C;AAGK,cAAKsgB,CAAAA,MAAV,KAAsBA,MAAtB,IAAgCwI,QAAhC,MAMA8D,WAAA,CAAY,IAAK+I,CAAAA,eAAjB,EAAkC,IAAKrV,CAAAA,MAAOuV,CAAAA,SAA9C,CAsBA,EAlBMwC,EAkBN,GAlBuB,IAAKnN,CAAAA,SAAUrkB,CAAAA,CAkBtC,EAjBMyxB,OAiBN,GAjBuB,IAAKpN,CAAAA,SAAU/K,CAAAA,CAiBtC,EAZA8K,eAAA,CAAgB,IAAK0K,CAAAA,eAArB,EAAsC,IAAKzK,CAAAA,SAA3C,EAAsD,IAAKoG,CAAAA,IAA3D,EAAiEsG,QAAjE,CAYA,EAPStX,CAALoX,IAAKpX,CAAAA,MAOT,IANKoX,IAAKpyB,CAAAA,MAMV,IAL0B,CAK1B,KALK,IAAK4lB,CAAAA,SAAUrkB,CAAAA,CAKpB,IALoD,CAKpD,KAL+B,IAAKqkB,CAAAA,SAAU/K,CAAAA,CAK9C,KAJIuX,IAAKpyB,CAAAA,MACL,GADcoyB,IAAKpX,CAAAA,MAAOuV,CAAAA,SAC1B,EAAA6B,IAAKM,CAAAA,oBAAL,GAA4BpC,SAAA,EAGhC,GADM,CAAE,OAAAtwB,IAAF,CACN,GADmBoyB,IACnB,EAAKpyB,IAAL,IAYK,IAAKimB,CAAAA,eAAV,IAA8B,IAAKgN,CAAAA,mBAAnC,IAIIxL,iBAAA,CAAkB,IAAKwL,CAAAA,mBAAoB1xB,CAAAA,CAA3C;AAA8C,cAAK0kB,CAAAA,eAAgB1kB,CAAAA,CAAnE,CACA,EAAAkmB,iBAAA,CAAkB,IAAKwL,CAAAA,mBAAoBpY,CAAAA,CAA3C,EAA8C,IAAKoL,CAAAA,eAAgBpL,CAAAA,CAAnE,CALJ,IACI,IAAKqY,CAAAA,sBAAL,EAgBJ,EADAvY,YAAA,CAAa,IAAKsL,CAAAA,eAAlB,EAAmC,IAAKoK,CAAAA,eAAxC,EAAyDrwB,IAAzD,EAAiE,IAAKgU,CAAAA,YAAtE,CACA,EAAI,IAAK4R,CAAAA,SAAUrkB,CAAAA,CAAnB,KAAyBwxB,EAAzB,IACI,IAAKnN,CAAAA,SAAU/K,CAAAA,CADnB,KACyBmY,OADzB,IAEKpK,eAAA,CAAgB,IAAK3C,CAAAA,eAAgB1kB,CAAAA,CAArC,EAAwC,IAAK0xB,CAAAA,mBAAoB1xB,CAAAA,CAAjE,CAFL,IAGKqnB,eAAA,CAAgB,IAAK3C,CAAAA,eAAgBpL,CAAAA,CAArC,EAAwC,IAAKoY,CAAAA,mBAAoBpY,CAAAA,CAAjE,CAHL,KAII,IAAK+Q,CAAAA,YAEL,GAFoB,CAAA,CAEpB,EADA,IAAKmF,CAAAA,cAAL,EACA,EAAA,IAAK5E,CAAAA,eAAL,CAAqB,kBAArB;AAAyCnsB,cAAzC,CANJ,CA7BA,IAMQ,IAAKizB,CAAAA,mBANb,KAOQ,IAAKC,CAAAA,sBAAL,EACA,EAAA,IAAKnC,CAAAA,cAAL,EARR,CA5BA;AAbA;AA3Ba;AA0GjBoC,UAAI,EAAG;AACH,YAAKtH,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AADG;AAIPuH,UAAI,EAAG;AACH,YAAKvH,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AADG;AAIPkF,oBAAc,CAACsC,SAAA,GAAY,CAAA,CAAb,CAAmB;AAC7B,YAAI7tB,EAAJ;AACsC,YAAtC,MAACA,EAAD,GAAM,IAAK9F,CAAAA,OAAQ9F,CAAAA,aAAnB,KAAqD,IAAK,EAA1D,KAA8C4L,EAA9C,IAAuEA,EAAGurB,CAAAA,cAAH,EAAvE;AACIsC,iBAAJ,KACU9E,SADV,GACkB,IAAKC,CAAAA,QAAL,EADlB,KAEaD,SAAMwC,CAAAA,cAAN,EAFb;AAII,YAAKnD,CAAAA,YAAT,IAAyB,CAAC,IAAKA,CAAAA,YAAanR,CAAAA,QAA5C,KACI,IAAKmR,CAAAA,YADT,GACwBlzB,IAAAA,EADxB;AAP6B;AAWjCw4B,4BAAsB,EAAG;AACrB,YAAKD,CAAAA,mBAAL,GA34Fe,CACvB1xB,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CA24Ff;AACA,YAAKrN,CAAAA,eAAL,GA54Fe,CACvB1kB,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CA44Ff;AACA,YAAKC,CAAAA,4BAAL,GA74Fe,CACvBhyB,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CA64Ff;AAHqB;AAKzBzF,wBAAkB,CAAC9xB,KAAD,EAAQwxB,4BAAA,GAA+B,CAAA,CAAvC,CAA8C;AAC5D,cAAMyC,WAAW,IAAKA,CAAAA,QAAtB,EACMwD,uBAAuBxD,QAAA,GACvBA,QAAShc,CAAAA,YADc,GAEvB,EAHN,EAIMyf,cAAc,CAAE,GAAG,IAAKzf,CAAAA,YAAV,CAJpB,EAKM8d,cAr5FS,CACvBvwB,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CAg5Ff;AAMK,YAAKpB,CAAAA,cAAV,IACK,IAAKA,CAAAA,cAAexyB,CAAAA,OAAQ8tB,CAAAA,UADjC,KAEI,IAAKN,CAAAA,cAFT,GAE0B,IAAKuF,CAAAA,oBAF/B,GAEsD/3B,IAAAA,EAFtD;AAIA,YAAK63B,CAAAA,8BAAL,GAAsC,CAAChF,4BAAvC;AACA,cAAMmG,iBAAiBpD,SAAA,EAAvB,EAGMqD,2BAFiB3D,QAAA4D,GAAW5D,QAAS3sB,CAAAA,MAApBuwB,GAA6Bl5B,IAAAA,EAE9Ci5B,OADe,IAAK3Y,CAAAA,MAAL6Y,GAAc,IAAK7Y,CAAAA,MAAO3X,CAAAA,MAA1BwwB,GAAmCn5B,IAAAA,EAClDi5B,CAHN;AAIMpF,oCAAAA,GAAQ,IAAKC,CAAAA,QAAL,EAARD;AACN,cAAMuF,eAAe,CAACvF,4BAAhBuF,IAAiD,CAAjDA,IAAyBvF,4BAAMwF,CAAAA,OAAQz1B,CAAAA,MAA7C,EACM01B,yBAAyB,EAAQL,CAAAA,uBAAR,IAC1BG,YAD0B,IAEA,CAAA,CAFA,KAE3B,IAAKp0B,CAAAA,OAAQsyB,CAAAA,SAFc,IAG1B,IAAKhG,CAAAA,IAAKhgB,CAAAA,IAAV,CAAeioB,mBAAf,CAH0B,CAD/B;AAKA,YAAKnI,CAAAA,iBAAL,GAAyB,CAAzB;AACA,YAAIoI,kBAAJ;AACA,YAAKC,CAAAA,cAAL,GAAuBjlB,MAADklB,IAAY;AACbllB,gBAAXX,IAAoB,IAApBA;AACN8lB,sBAAA,CAAavC,WAAYvwB,CAAAA,CAAzB,EAA4BxF,KAAMwF,CAAAA,CAAlC,EAAqCgN,MAArC,CAAA;AACA8lB,sBAAA,CAAavC,WAAYjX,CAAAA,CAAzB,EAA4B9e,KAAM8e,CAAAA,CAAlC,EAAqCtM,MAArC,CAAA;AACA,cAAKsjB,CAAAA,cAAL,CAAoBC,WAApB,CAAA;AACA,cAAI,IAAK5E,CAAAA,cAAT,IACI,IAAKuF,CAAAA,oBADT,IAEI,IAAKzX,CAAAA,MAFT,IAGI,IAAKkX,CAAAA,cAHT,IAII,IAAKA,CAAAA,cAAelX,CAAAA,MAJxB,CAIgC;AAC5BD,gCAAA,CAAqB2Y,cAArB,EAAqC,IAAK1Y,CAAAA,MAAOuV,CAAAA,SAAjD,EAA4D,IAAK2B,CAAAA,cAAelX,CAAAA,MAAOuV,CAAAA,SAAvF,CAAA;AACYrD,gBAAAA,SAALA,IAAKA,CAAAA,cAAAA,EAAqBuF,OAALA,IAAKA,CAAAA,oBAArBvF,EAogBb3rB,kBAAPgC,MAAOhC,CAAAA,CApgBa2rB,EAogBL3rB,gBAALuD,IAAKvD,CAAAA,CApgBK2rB,EAogBC3rB,KApgB0CmyB,cAogB1CnyB,CAAAA,CApgBD2rB;AAggB5B3pB,2BAAOpF,CAAAA,GAAP,GAAaic,WAAA,CAAYtV,aAAK3G,CAAAA,GAAjB,EAAsBmL,EAAGnL,CAAAA,GAAzB,EAhgB0EoQ,MAggB1E,CAAb;AACAhL,2BAAOrF,CAAAA,GAAP,GAAakc,WAAA,CAAYtV,aAAK5G,CAAAA,GAAjB,EAAsBoL,EAAGpL,CAAAA,GAAzB,EAjgB0EqQ,MAigB1E,CAAb;AAIesM,kBAAAA,GAAPtX,MAAOsX,CAAAA,CAAAA;AAAQA,gBAAAA,GAAL/V,IAAK+V,CAAAA,CAAAA;AAAMA,2BAAAA,GArgB0C6Y,cAqgB1C7Y,CAAAA,CAAAA;AAL7BtX,kBAAOpF,CAAAA,GAAP,GAAaic,WAAA,CAAYtV,IAAK3G,CAAAA,GAAjB,EAAsBmL,eAAGnL,CAAAA,GAAzB,EAhgB0EoQ,MAggB1E,CAAb;AACAhL,kBAAOrF,CAAAA,GAAP,GAAakc,WAAA,CAAYtV,IAAK5G,CAAAA,GAAjB,EAAsBoL,eAAGpL,CAAAA,GAAzB,EAjgB0EqQ,MAigB1E,CAAb;AA5foB,gBAAA2lB,IAAA,GAAAA,kBAAA;AACA,kBA/pCpB,GA+pCoB,IAAA,CAAA,cA/pCpB,EA+pCoB,MA/pCpB,GA+pCoB,kBA/pCpB,EAAA,IAAA,GAAOzL,UAAA,CAAWtgB,IAAE5G,CAAAA,CAAb,EAAgB6G,MAAE7G,CAAAA,CAAlB,CAAP,IAA+BknB,UAAA,CAAWtgB,IAAE0S,CAAAA,CAAb,EAAgBzS,MAAEyS,CAAAA,CAAlB,CAA/B;AA8pCoB;AAAA,gBAAJ,KAEI,IAAK0P,CAAAA,iBAFT,GAE6B,CAAA,CAF7B;AAIK2J,8BAAL,KACIA,kBADJ,GACyB5D,SAAA,EADzB;AAEAhJ,uBAAA,CAAY4M,kBAAZ,EAAgC,IAAKhH,CAAAA,cAArC,CAAA;AAb4B;AAehC,cAAIyG,uBAAJ,CAA6B;AACzB,gBAAKW,CAAAA,eAAL,GAAuBb,WAAvB;AACkDzf,gBAAAA,GAALA,IAAKA,CAAAA,YAAAA;AAAwBggB,kCAl1C1F,IAk1C0BP,WAj1Cfc,CAAAA,OAGP,GAHiBna,WAAA,CAAY,CAAZ,EAEA1f,IAAAA,EAAjB,KAAA03B,IAAKmC,CAAAA,OAAL,GAA6BnC,IAAKmC,CAAAA,OAAlC,GAA4C,CAF3B,EAE8BC,eAAA,CA+0C6BjmB,MA/0C7B,CAF9B,CAGjB,EA80CsBklB,WA90CfgB,CAAAA,WAAP,GAAqBra,WAAA,CAA+B1f,IAAAA,EAAnB,KA80CE84B,oBA90CKe,CAAAA,OAAP,GA80CEf,oBA90CoCe,CAAAA,OAAtC,GAAgD,CAA5D,EAA+D,CAA/D,EAAkEG,gBAAA,CA80CXnmB,MA90CW,CAAlE,CAJzB,IAk1CkHulB,YAl1ClH,KAk1C0BL,WA30Cfc,CAAAA,OAPX,GAOqBna,WAAA,CAA+B1f,IAAAA,EAAnB,KA20CM84B,oBA30CCe,CAAAA,OAAP,GA20CMf,oBA30CgCe,CAAAA,OAAtC,GAAgD,CAA5D,EAAgF75B,IAAAA,EAAjB,KAAA03B,IAAKmC,CAAAA,OAAL,GAA6BnC,IAAKmC,CAAAA,OAAlC,GAA4C,CAA3G,EA20C2DhmB,MA30C3D,CAPrB,CAAA;AAYA,iBAASlQ,MAAT,GAAa,CAAb,EAAgBA,MAAhB,GAAoBs2B,UAApB,EAAgCt2B,MAAA,EAAhC;AAII,kBAHMu2B,eAGF,GAHiB,SAAQC,OAAA,CAAQx2B,MAAR,CAAR,QAGjB,EAFAy2B,aAEA,GAyBsBp6B,IAAAA,EAAvB,KAyyCgC84B,oBAzyChC,CA3BkCoB,eA2BlC,CAAA,GAyyCgCpB,oBAxyCjC,CA5BmCoB,eA4BnC,CADC,GAyyCgCpB,oBAvyC1BuB,CAAAA,YA3BL,EADAC,EACA,GAyBsBt6B,IAAAA,EAAvB,KA1BwB03B,IA0BxB,CA1B8BwC,eA0B9B,CAAA,GA1BwBxC,IA2BzB,CA3B+BwC,eA2B/B,CADC,GA1BwBxC,IA4BlB2C,CAAAA,YA3BL,EAAiBr6B,IAAAA,EAAjB,KAAAo6B,aAAA,IAA6Cp6B,IAAAA,EAA7C,KAA8Bs6B,EAAlC;AAOA,oBALAF,aAEeG,KAFEH,aAEFG,GAFiB,CAEjBA,GADfD,EACeC,KADAD,EACAC,GADa,CACbA,GAAiB,CAAjBA,KAAAH,aAAAG,IACI,CADJA,KACXD,EADWC,KAtBkB,QAsBlBA,KAtBC,MAwBPH,cAFMG,IAtB8B3T,EAAG5e,CAAAA,IAAH,CAwBpCoyB,aAxBoC,CAsB9BG,OAtBkB,QAsBlBA,KAtBC,MAwBgBD,GAFjBC,IAtB8B3T,EAAG5e,CAAAA,IAAH,CAwBbsyB,EAxBa,CAsB9BC,CAGf;AAEI,sBAyzCkBxB,WA1zClB,CAAOmB,eAAP,CACI,GADkB32B,IAAKC,CAAAA,GAAL,CAASkc,WAAA,CAAY8a,QAAA,CAASJ,aAAT,CAAZ,EAAoCI,QAAA,CAASF,EAAT,CAApC,EA0zCyCzmB,MA1zCzC,CAAT,EAA8E,CAA9E,CAClB,EAAAuZ,OAAQplB,CAAAA,IAAR,CAAasyB,EAAb,CAAA,IAA4BlN,OAAQplB,CAAAA,IAAR,CAAaoyB,aAAb,CAAhC;AAyzCkBrB,+BAxzCd,CAAOmB,eAAP,CAAA,IAAuB,GAAvB;AADJ;AAFJ;AA2zCsBnB,6BApzClB,CAAOmB,eAAP,CAAA,GAAsBI,EAAtB;AAPJ;AAPA;AAJJ;AAwBA,gBA8yCuCxB,oBA9yC5BxO,CAAAA,MAAX,IAAqBoN,IAAKpN,CAAAA,MAA1B;AA8yC0ByO,yBA7yCfzO,CAAAA,MAAP,GAAgB5K,WAAA,CA6yCmBoZ,oBA7yCAxO,CAAAA,MAAnB,IAA6B,CAA7B,EAAgCoN,IAAKpN,CAAAA,MAArC,IAA+C,CAA/C,EA6yC4DzW,MA7yC5D,CAAhB;AADJ;AA4yCyC;AAI7B,cAAKhC,CAAAA,IAAKujB,CAAAA,wBAAV,EAAA;AACA,cAAKiB,CAAAA,cAAL,EAAA;AACA,cAAKjF,CAAAA,iBAAL,GAAyBvd,MAAzB;AA9B8B,SAAlC;AAgCA,YAAK4lB,CAAAA,cAAL,CAAoB,IAAKz0B,CAAAA,OAAQ8tB,CAAAA,UAAb,GAA0B,IAA1B,GAAiC,CAArD,CAAA;AAxD4D;AA0DhES,oBAAc,CAACvuB,OAAD,CAAU;AACpB,YAAKysB,CAAAA,eAAL,CAAqB,gBAArB,CAAA;AACA,YAAKwB,CAAAA,gBAAL,IAAyB,IAAKA,CAAAA,gBAAiBwH,CAAAA,IAAtB,EAAzB;AACI,YAAKvH,CAAAA,YAAT,IAAyB,IAAKA,CAAAA,YAAaD,CAAAA,gBAA3C,IACI,IAAKC,CAAAA,YAAaD,CAAAA,gBAAiBwH,CAAAA,IAAnC,EADJ;AAGI,YAAKrC,CAAAA,gBAAT,KACI7L,WAAA,CAAY,IAAK6L,CAAAA,gBAAjB,CACA,EAAA,IAAKA,CAAAA,gBAAL,GAAwBp4B,IAAAA,EAF5B;AASA,YAAKo4B,CAAAA,gBAAL,GAAwBte,KAAMhX,CAAAA,MAAN,CAAa,EAAA,IAAM;AACvCkvB,+BAAsBC,CAAAA,sBAAtB,GAA+C,CAAA,CAA/C;AACA,cAAKgB,CAAAA,gBAAL,GAAwB9O,kBAAA,CAAmB,CAAnB,EAt/BhBuW,IAs/BgB,EAAuC,CAC3D,GAAG11B,OADwD,EAE3D2c,SAAWnN,MAADmN,IAAY;AAClB,gBAAK8X,CAAAA,cAAL,CAAoBjlB,MAApB,CAAA;AACAxP,mBAAQ2c,CAAAA,QAAR,IAAoB3c,OAAQ2c,CAAAA,QAAR,CAAiBnN,MAAjB,CAApB;AAFkB,WAFqC,EAM3DmmB,OAAQ,EAAAA,IAAM;WAN6C,EAQ3DrH,WAAY,EAAAA,IAAM;AACdtuB,mBAAQsuB,CAAAA,UAAR,IAAsBtuB,OAAQsuB,CAAAA,UAAR,EAAtB;AACA,gBAAKsH,CAAAA,iBAAL,EAAA;AAFc,WARyC,CAAvC,CAAxB;AAaI,cAAK1H,CAAAA,YAAT,KACI,IAAKA,CAAAA,YAAaD,CAAAA,gBADtB,GACyC,IAAKA,CAAAA,gBAD9C;AAGA,cAAKmF,CAAAA,gBAAL,GAAwBp4B,IAAAA,EAAxB;AAlBuC,SAAnB,CAAxB;AAfoB;AAoCxB46B,uBAAiB,EAAG;AACZ,YAAK1H,CAAAA,YAAT,KACI,IAAKA,CAAAA,YAAaD,CAAAA,gBAClB,GADqCjzB,IAAAA,EACrC,EAAA,IAAKkzB,CAAAA,YAAa2H,CAAAA,eAAlB,GAAoC76B,IAAAA,EAFxC;AAIA,cAAM6zB,QAAQ,IAAKC,CAAAA,QAAL,EAAd;AACAD,aAAA,IAASA,KAAMiH,CAAAA,qBAAN,EAAT;AACA,YAAK5H,CAAAA,YAAL,GACI,IAAKD,CAAAA,gBADT,GAEQ,IAAK2G,CAAAA,eAFb,GAGY55B,IAAAA,EAHZ;AAIA,YAAKyxB,CAAAA,eAAL,CAAqB,mBAArB,CAAA;AAXgB;AAapBS,qBAAe,EAAG;AACV,YAAKe,CAAAA,gBAAT,KACI,IAAKwG,CAAAA,cACL,IADuB,IAAKA,CAAAA,cAAL,CAxhCfiB,IAwhCe,CACvB,EAAA,IAAKzH,CAAAA,gBAAiBwH,CAAAA,IAAtB,EAFJ;AAIA,YAAKG,CAAAA,iBAAL,EAAA;AALc;AAOlBG,6BAAuB,EAAG;AACtB,cAAMrD,OAAO,IAAKC,CAAAA,OAAL,EAAb;AACA,YAAI,CAAEK,oBAAF,EAAwB1yB,MAAxB,EAAgCgb,MAAhC,EAAwChH,YAAxC,CAAA,GAAyDoe,IAA7D;AACA,YAAKM,oBAAL,IAA8B1yB,MAA9B,IAAyCgb,MAAzC,CAAA;AAOA,cAAI,IAAJ,KAAaoX,IAAb,IACI,IAAKpX,CAAAA,MADT,IAEIA,MAFJ,IAGI0a,yBAAA,CAA0B,IAAKh2B,CAAAA,OAAQi2B,CAAAA,aAAvC,EAAsD,IAAK3a,CAAAA,MAAOuV,CAAAA,SAAlE,EAA6EvV,MAAOuV,CAAAA,SAApF,CAHJ,CAGoG;AAChGvwB,kBAAA,GAAS,IAAKA,CAAAA,MAAd,IAAwBswB,SAAA,EAAxB;AACA,gBAAMsF,UAAU5b,UAAA,CAAW,IAAKgB,CAAAA,MAAOuV,CAAAA,SAAUhvB,CAAAA,CAAjC,CAAhB;AACAvB,kBAAOuB,CAAAA,CAAEpD,CAAAA,GAAT,GAAei0B,IAAKpyB,CAAAA,MAAOuB,CAAAA,CAAEpD,CAAAA,GAA7B;AACA6B,kBAAOuB,CAAAA,CAAErD,CAAAA,GAAT,GAAe8B,MAAOuB,CAAAA,CAAEpD,CAAAA,GAAxB,GAA8By3B,OAA9B;AACMC,mBAAAA,GAAU7b,UAAA,CAAW,IAAKgB,CAAAA,MAAOuV,CAAAA,SAAU1V,CAAAA,CAAjC,CAAVgb;AACN71B,kBAAO6a,CAAAA,CAAE1c,CAAAA,GAAT,GAAei0B,IAAKpyB,CAAAA,MAAO6a,CAAAA,CAAE1c,CAAAA,GAA7B;AACA6B,kBAAO6a,CAAAA,CAAE3c,CAAAA,GAAT,GAAe8B,MAAO6a,CAAAA,CAAE1c,CAAAA,GAAxB,GAA8B03B,OAA9B;AAPgG;AASpGvO,qBAAA,CAAYoL,oBAAZ,EAAkC1yB,MAAlC,CAAA;AAMAqmB,sBAAA,CAAaqM,oBAAb,EAAmC1e,YAAnC,CAAA;AAOA2G,sBAAA,CAAa,IAAK4Y,CAAAA,4BAAlB,EAAgD,IAAKlD,CAAAA,eAArD,EAAsEqC,oBAAtE,EAA4F1e,YAA5F,CAAA;AAhCA;AAHsB;AAqC1B6Y,wBAAkB,CAACrJ,QAAD,EAAWwC,IAAX,CAAiB;AAC1B,YAAK+F,CAAAA,WAAY3wB,CAAAA,GAAjB,CAAqBooB,QAArB,CAAL,IACI,IAAKuI,CAAAA,WAAY1rB,CAAAA,GAAjB,CAAqBmjB,QAArB,EAA+B,IAAIsS,SAAJ,EAA/B,CADJ;AAGc,YAAK/J,CAAAA,WAAY7xB,CAAAA,GAAjBq0B,CAAqB/K,QAArB+K,CACRnyB,CAAAA,GAAN,CAAU4pB,IAAV,CAAA;AACM+P,gBAAAA,GAAS/P,IAAKtmB,CAAAA,OAAQs2B,CAAAA,sBAAtBD;AACN/P,YAAKiQ,CAAAA,OAAL,CAAa,CACTl2B,WAAYg2B,QAAA,GAASA,QAAOh2B,CAAAA,UAAhB,GAA6BrF,IAAAA,EADhC,EAETw7B,sBAAuBH,QAAA,IAAUA,QAAOI,CAAAA,2BAAjB,GACjBJ,QAAOI,CAAAA,2BAAP,CAAmCnQ,IAAnC,CADiB,GAEjBtrB,IAAAA,EAJG,CAAb,CAAA;AAP+B;AAcnCwzB,YAAM,EAAG;AACL,cAAMK,QAAQ,IAAKC,CAAAA,QAAL,EAAd;AACA,eAAOD,KAAA,GAAQA,KAAM6D,CAAAA,IAAd,KAAuB,IAAvB,GAA8B,CAAA,CAArC;AAFK;AAITC,aAAO,EAAG;AACN,YAAI7sB,EAAJ;AACA,cAAM,CAAEge,QAAF,CAAA,GAAe,IAAK9jB,CAAAA,OAA1B;AACA,eAAO8jB,QAAA,IAAuC,IAA3B,MAAChe,EAAD,GAAM,IAAKgpB,CAAAA,QAAL,EAAN,KAA0C,IAAK,EAA/C,KAAmChpB,EAAnC,GAAmD,IAAK,EAAxD,GAA4DA,EAAG4sB,CAAAA,IAA3E,KAAoF,IAApF,GAA2F,IAAlG;AAHM;AAKVgE,iBAAW,EAAG;AACV,YAAI5wB,EAAJ;AACA,cAAM,CAAEge,QAAF,CAAA,GAAe,IAAK9jB,CAAAA,OAA1B;AACA,eAAO8jB,QAAA,GAAsC,IAA3B,MAAChe,EAAD,GAAM,IAAKgpB,CAAAA,QAAL,EAAN,KAA0C,IAAK,EAA/C,KAAmChpB,EAAnC,GAAmD,IAAK,EAAxD,GAA4DA,EAAG6wB,CAAAA,QAA1E,GAAqF37B,IAAAA,EAA5F;AAHU;AAKd8zB,cAAQ,EAAG;AACP,cAAM,CAAEhL,QAAF,CAAA,GAAe,IAAK9jB,CAAAA,OAA1B;AACA,YAAI8jB,QAAJ;AACI,iBAAO,IAAKjX,CAAAA,IAAKwf,CAAAA,WAAY7xB,CAAAA,GAAtB,CAA0BspB,QAA1B,CAAP;AADJ;AAFO;AAKXyS,aAAO,CAAC,CAAEjM,UAAF,EAAcjqB,UAAd,EAA0Bm2B,qBAA1B,CAAA,GAAqD,EAAtD,CAA0D;AAC7D,cAAM3H,QAAQ,IAAKC,CAAAA,QAAL,EAAd;AACID,aAAJ,IACIA,KAAM0H,CAAAA,OAAN,CAAc,IAAd,EAAoBC,qBAApB,CADJ;AAEIlM,kBAAJ,KACI,IAAK/D,CAAAA,eACL,GADuBvrB,IAAAA,EACvB,EAAA,IAAKsvB,CAAAA,UAAL,GAAkB,CAAA,CAFtB;AAIIjqB,kBAAJ,IACI,IAAKgyB,CAAAA,UAAL,CAAgB,CAAEhyB,UAAF,CAAhB,CADJ;AAR6D;AAWjEu2B,cAAQ,EAAG;AACP,cAAM/H,QAAQ,IAAKC,CAAAA,QAAL,EAAd;AACA,eAAID,KAAJ,GACWA,KAAM+H,CAAAA,QAAN,CAAe,IAAf,CADX,GAIW,CAAA,CAJX;AAFO;AASXzH,0BAAoB,EAAG;AACnB,cAAM,CAAEj1B,aAAF,CAAA,GAAoB,IAAK8F,CAAAA,OAA/B;AACA,YAAK9F,aAAL,CAAA;AAGA,cAAI28B,yBAAyB,CAAA,CAA7B,EAKM,CAAEviB,YAAF,CAAA,GAAmBpa,aALzB;AAMA,cAAIoa,YAAa+Q,CAAAA,CAAjB,IACI/Q,YAAagR,CAAAA,MADjB,IAEIhR,YAAaiR,CAAAA,OAFjB,IAGIjR,YAAakR,CAAAA,OAHjB,IAIIlR,YAAawiB,CAAAA,OAJjB,IAKIxiB,YAAamR,CAAAA,KALjB,IAMInR,YAAaoR,CAAAA,KANjB;AAOImR,kCAAA,GAAyB,CAAA,CAAzB;AAPJ;AAUA,cAAKA,sBAAL,CAAA;AAEME,kCAAAA,GAAc,EAAdA;AACFziB,wBAAa+Q,CAAAA,CAAjB,IACI+D,wBAAA,CAAyB,GAAzB,EAA8BlvB,aAA9B,EAA6C68B,sBAA7C,EAA0D,IAAKnC,CAAAA,eAA/D,CADJ;AAIA,iBAASj2B,YAAT,GAAa,CAAb,EAAgBA,YAAhB,GAAoBq4B,aAAcp4B,CAAAA,MAAlC,EAA0CD,YAAA,EAA1C;AACIyqB,sCAAA,CAA0B,SAAQ4N,aAAA,CAAcr4B,YAAd,CAAR,EAA1B,EAAsDzE,aAAtD,EAAqE68B,sBAArE,EAAkF,IAAKnC,CAAAA,eAAvF,CACA,EAAAxL,wBAAA,CAA0B,OAAM4N,aAAA,CAAcr4B,YAAd,CAAN,EAA1B,EAAoDzE,aAApD,EAAmE68B,sBAAnE,EAAgF,IAAKnC,CAAAA,eAArF,CAAA;AAFJ;AAMA16B,yBAAc8D,CAAAA,MAAd,EAAA;AAEA,iBAAK,MAAMzD,GAAX,GAAkBw8B,uBAAlB;AACI78B,2BAAcovB,CAAAA,cAAd,CAA6B/uB,GAA7B,EAAkCw8B,sBAAA,CAAYx8B,GAAZ,CAAlC,CACA,EAAI,IAAKq6B,CAAAA,eAAT,KACI,IAAKA,CAAAA,eAAL,CAAqBr6B,GAArB,CADJ,GACgCw8B,sBAAA,CAAYx8B,GAAZ,CADhC,CAAA;AAFJ;AAQAL,yBAAcm3B,CAAAA,cAAd,EAAA;AAvBA;AAnBA;AAFmB;AA8CvBnO,yBAAmB,CAACH,SAAD,CAAY;AAAA,YACvBjd,EADuB,EACnBmxB,EADmB;AAE3B,YAAK,IAAKla,CAAAA,QAAV,IAA2BwN,CAAL,IAAKA,CAAAA,KAA3B,CAAA;AAEA,cAAI,CAAC,IAAK4B,CAAAA,SAAV;AACI,mBAAO+K,gBAAP;AADJ;AAGA,cAAMC,SAAS,CACXC,WAAY,EADD,CAAf,EAGMlX,oBAAoB,IAAKkP,CAAAA,oBAAL,EAH1B;AAIA,cAAI,IAAK9E,CAAAA,UAAT;AAQI,mBAPA,IAAKA,CAAAA,UAOE6M,GAPW,CAAA,CAOXA,EANPA,MAAOtC,CAAAA,OAMAsC,GANU,EAMVA,EALPA,MAAOE,CAAAA,aAKAF,GAJH9a,kBAAA,CAAiC,IAAd,KAAA0G,SAAA,IAAoC,IAAK,EAAzC,KAAsBA,SAAtB,GAA6C,IAAK,EAAlD,GAAsDA,SAAUsU,CAAAA,aAAnF,CAIGF,IAJkG,EAIlGA,EAHPA,MAAOnzB,CAAAA,SAGAmzB,GAHYjX,iBAAA,GACbA,iBAAA,CAAkB,IAAK5L,CAAAA,YAAvB,EAAqC,EAArC,CADa,GAEb,MACC6iB,EAAAA,MAAP;AARJ;AAUA,cAAMzE,OAAO,IAAKC,CAAAA,OAAL,EAAb;AACA,cAAI,CAAC,IAAKpM,CAAAA,eAAV,IAA6B,CAAC,IAAKjL,CAAAA,MAAnC,IAA6C,CAACoX,IAAKpyB,CAAAA,MAAnD;AAgBI,mBAfMg3B,MAeCA,GAfa,EAebA,EAdH,IAAKt3B,CAAAA,OAAQ8jB,CAAAA,QAcVwT,KAbHA,MAAYzC,CAAAA,OAIZ,GAHkC75B,IAAAA,EAA9B,KAAA,IAAKsZ,CAAAA,YAAaugB,CAAAA,OAAlB,GACM,IAAKvgB,CAAAA,YAAaugB,CAAAA,OADxB,GAEM,CACV,EAAAyC,MAAYD,CAAAA,aAAZ,GACIhb,kBAAA,CAAiC,IAAd,KAAA0G,SAAA,IAAoC,IAAK,EAAzC,KAAsBA,SAAtB,GAA6C,IAAK,EAAlD,GAAsDA,SAAUsU,CAAAA,aAAnF,CADJ,IACyG,EAQtGC,GANH,IAAKpL,CAAAA,YAMFoL,IANkB,CAACtW,YAAA,CAAa,IAAK1M,CAAAA,YAAlB,CAMnBgjB,KALHA,MAAYtzB,CAAAA,SAGZ,GAHwBkc,iBAAA,GAClBA,iBAAA,CAAkB,EAAlB,EAAsB,EAAtB,CADkB,GAElB,MACN,EAAA,IAAKgM,CAAAA,YAAL,GAAoB,CAAA,CAEjBoL,GAAAA,MAAP;AAhBJ;AAkBA,cAAMC,iBAAiB7E,IAAKkC,CAAAA,eAAtB2C,IAAyC7E,IAAKpe,CAAAA,YAApD;AACA,cAAKyhB,CAAAA,uBAAL,EAAA;AACiDlC,cAAAA,QAALA,IAAKA,CAAAA,4BAAAA,EAAmC3N,YAALA,IAAKA,CAAAA,SAAnC2N,EA1xCrD7vB,YAAY,EA0xCyC6vB,EAnxCnD2D,aAAan7B,KAAMwF,CAAAA,CAAE+Y,CAAAA,SAArB4c,GAAiCtR,SAAUrkB,CAAAA,CAmxCQgyB,EAlxCnD4D,aAAap7B,KAAM8e,CAAAA,CAAEP,CAAAA,SAArB6c,GAAiCvR,SAAU/K,CAAAA,CAkxCQ0Y,EAjxCnD6D,cAAkC,IAApB,KAixCmFH,cAjxCnF,IAAgD,IAAK,EAArD,KAixCmFA,cAjxCnF,GAAyD,IAAK,EAA9D,GAixCmFA,cAjxCDlS,CAAAA,CAAhGqS,KAAsG,CAixCnD7D;AAhxCzD,cAAI2D,UAAJ,IAAkBC,UAAlB,IAAgCC,UAAhC;AACI1zB,qBAAA,GAAa,eAAcwzB,UAAd,OAA+BC,UAA/B,OAAgDC,UAAhD,MAAb;AADJ;AAOA,cAAoB,CAApB,KAAIxR,SAAUrkB,CAAAA,CAAd,IAAyC,CAAzC,KAAyBqkB,SAAU/K,CAAAA,CAAnC;AACInX,qBAAA,IAAc,SAAQ,CAAR,GAAYkiB,SAAUrkB,CAAAA,CAAtB,KAA4B,CAA5B,GAAgCqkB,SAAU/K,CAAAA,CAA1C,IAAd;AADJ;AAGA,cAswCuGoc,cAtwCvG,CAAqB;AACjB,kBAAM,CAAEI,oBAAF,EAAwBrS,MAAxB,EAAgCC,OAAhC,EAAyCC,OAAzC,EAAkDC,KAAlD,EAAyDC,KAAzD,CAAA,GAqwC6F6R,cArwCnG;AACII,gCAAJ,KACI3zB,SADJ,GACiB,eAAc2zB,oBAAd,OAAyC3zB,SAAzC,EADjB;AAEIshB,kBAAJ,KACIthB,SADJ,IACkB,UAASshB,MAAT,OADlB;AAEIC,mBAAJ,KACIvhB,SADJ,IACkB,WAAUuhB,OAAV,OADlB;AAEIC,mBAAJ,KACIxhB,SADJ,IACkB,WAAUwhB,OAAV,OADlB;AAEIC,iBAAJ,KACIzhB,SADJ,IACkB,SAAQyhB,KAAR,OADlB;AAEIC,iBAAJ,KACI1hB,SADJ,IACkB,SAAQ0hB,KAAR,OADlB;AAZiB;AAmBfkS,oBAAAA,GAAgBv7B,KAAMwF,CAAAA,CAAE8Y,CAAAA,KAAxBid,GAAgC1R,SAAUrkB,CAAAA,CAA1C+1B;AACAC,eAAAA,GAAgBx7B,KAAM8e,CAAAA,CAAER,CAAAA,KAAxBkd,GAAgC3R,SAAU/K,CAAAA,CAA1C0c;AACN,cAAsB,CAAtB,KAAID,UAAJ,IAA6C,CAA7C,KAA2BC,KAA3B;AACI7zB,qBAAA,IAAc,SAAQ4zB,UAAR,KAA0BC,KAA1B,GAAd;AADJ;AAivCQV,gBAAOnzB,CAAAA,SAAP,GA9uCDA,SA8uCC,IA9uCY,MA8uCZ;AACIkc,2BAAJ,KACIiX,MAAOnzB,CAAAA,SADX,GACuBkc,iBAAA,CAAkBqX,cAAlB,EAAkCJ,MAAOnzB,CAAAA,SAAzC,CADvB;AAGA,cAAM,CAAEnC,CAAF,EAAKsZ,CAAL,CAAA,GAAW,IAAKoL,CAAAA,eAAtB;AACA4Q,gBAAOpW,CAAAA,eAAP,GAA0B,GAAa,GAAb,GAAElf,CAAEoH,CAAAA,MAAJ,KAAgC,GAAhC,GAAqBkS,CAAElS,CAAAA,MAAvB,KAA1B;AAMIkuB,gBAAOtC,CAAAA,OAAP,GALAnC,IAAKkC,CAAAA,eAAT,GAMQlC,IAAA,KAAS,IAAT,GAC0G,IAApG,MAACuE,EAAD,GAAwC,IAAlC,MAACnxB,EAAD,GAAMyxB,cAAe1C,CAAAA,OAArB,KAAiD,IAAK,EAAtD,KAA0C/uB,EAA1C,GAA0DA,EAA1D,GAA+D,IAAKwO,CAAAA,YAAaugB,CAAAA,OAAvF,KAAmH,IAAK,EAAxH,KAA4GoC,EAA5G,GAA4HA,EAA5H,GAAiI,CADvI,GAEM,IAAKpB,CAAAA,eAAL,GACI,IAAKvhB,CAAAA,YAAaugB,CAAAA,OADtB,GAEI0C,cAAexC,CAAAA,WAVjC,GAkBQrC,IAAA,KAAS,IAAT,GACiC13B,IAAAA,EAA3B,KAAAu8B,cAAe1C,CAAAA,OAAf,GACI0C,cAAe1C,CAAAA,OADnB,GAEI,EAHV,GAIqC75B,IAAAA,EAA/B,KAAAu8B,cAAexC,CAAAA,WAAf,GACIwC,cAAexC,CAAAA,WADnB,GAEI,CAnBd;AAwBJ,eAAK,MAAMx6B,GAAX,GAAkBopB,gBAAlB,CAAmC;AAC/B,gBAA4B3oB,IAAAA,EAA5B,KAAIu8B,cAAA,CAAeh9B,GAAf,CAAJ;AACI;AADJ;AAEA,kBAAM,CAAEu9B,OAAF,EAAWC,OAAX,EAAoBnU,aAApB,CAAA,GAAsCD,eAAA,CAAgBppB,GAAhB,CAA5C;AAOMy9B,6BAAAA,GAAiC,MAArB,KAAAb,MAAOnzB,CAAAA,SAAP,GACZuzB,cAAA,CAAeh9B,GAAf,CADY,GAEZu9B,OAAA,CAAQP,cAAA,CAAeh9B,GAAf,CAAR,EAA6Bm4B,IAA7B,CAFAsF;AAGN,gBAAID,OAAJ;AAEI,mBADME,EACGt5B,GADGo5B,OAAQn5B,CAAAA,MACXD,EAAAA,EAAAA,GAAI,CAAb,EAAgBA,EAAhB,GAAoBs5B,EAApB,EAAyBt5B,EAAA,EAAzB;AACIw4B,sBAAA,CAAOY,OAAA,CAAQp5B,EAAR,CAAP,CAAA,GAAqBq5B,iBAArB;AADJ;AAFJ;AAUQpU,2BAAJ,GACI,IAAK5jB,CAAAA,OAAQ9F,CAAAA,aAAc2iB,CAAAA,WAAYiE,CAAAA,IAAvC,CAA4CvmB,GAA5C,CADJ,GACuDy9B,iBADvD,GAIIb,MAAA,CAAO58B,GAAP,CAJJ,GAIkBy9B,iBAJlB;AAVJ;AAb+B;AAoC/B,cAAKh4B,CAAAA,OAAQ8jB,CAAAA,QAAjB,KACIqT,MAAOE,CAAAA,aADX,GAEQ3E,IAAA,KAAS,IAAT,GACMrW,kBAAA,CAAiC,IAAd,KAAA0G,SAAA,IAAoC,IAAK,EAAzC,KAAsBA,SAAtB,GAA6C,IAAK,EAAlD,GAAsDA,SAAUsU,CAAAA,aAAnF,CADN,IAC2G,EAD3G,GAEM,MAJd;AAMA,iBAAOF,MAAP;AArHA;AAF2B;AAyH/BjH,mBAAa,EAAG;AACZ,YAAKnC,CAAAA,UAAL,GAAkB,IAAKuC,CAAAA,QAAvB,GAAkCt1B,IAAAA,EAAlC;AADY;AAIhBk9B,eAAS,EAAG;AACR,YAAKrrB,CAAAA,IAAK+e,CAAAA,KAAMvxB,CAAAA,OAAhB,CAAyBisB,IAAD,IAAU;AAAE,cAAIxgB,EAAJ;AAAQ,iBAAwC,IAAjC,MAACA,EAAD,GAAMwgB,IAAK2H,CAAAA,gBAAX,KAAgD,IAAK,EAArD,KAAyCnoB,EAAzC,GAAyD,IAAK,EAA9D,GAAkEA,EAAG2vB,CAAAA,IAAH,EAAzE;AAAV,SAAlC,CAAA;AACA,YAAK5oB,CAAAA,IAAK+e,CAAAA,KAAMvxB,CAAAA,OAAhB,CAAwBq1B,iBAAxB,CAAA;AACA,YAAK7iB,CAAAA,IAAKwf,CAAAA,WAAYnvB,CAAAA,KAAtB,EAAA;AAHQ;AAnwCT,KAAP;AADwH;AA2wC5H2yB,UAASA,aAAY,CAACvJ,IAAD,CAAO;AACxBA,QAAKuJ,CAAAA,YAAL,EAAA;AADwB;AAG5BC,UAASA,mBAAkB,CAACxJ,IAAD,CAAO;AAC9B,QAAIxgB,EAAJ;AACA,UAAMwqB,YAAuC,IAA3B,MAACxqB,EAAD,GAAMwgB,IAAKyH,CAAAA,UAAX,KAA0C,IAAK,EAA/C,KAAmCjoB,EAAnC,GAAmD,IAAK,EAAxD,GAA4DA,EAAGwqB,CAAAA,QAA3EA,KAAwFhK,IAAKgK,CAAAA,QAAnG;AACA,QAAIhK,IAAKkI,CAAAA,MAAL,EAAJ,IACIlI,IAAKhL,CAAAA,MADT,IAEIgV,QAFJ,IAGIhK,IAAKsG,CAAAA,YAAL,CAAkB,WAAlB,CAHJ,CAGoC;AAChC,YAAM,CAAE,UAAWtR,MAAb,EAAqB,YAAa6c,cAAlC,CAAA,GAAqD7R,IAAKhL,CAAAA,MAAhE;AACA,OAAM,CAAE,cAAA2a,EAAF,CAAN,GAA0B3P,IAAKtmB,CAAAA,OAA/B;AACA,YAAM4yB,WAAWtC,QAAS3sB,CAAAA,MAApBivB,KAA+BtM,IAAKhL,CAAAA,MAAO3X,CAAAA,MAAjD;AAGsB,YAAtB,KAAIsyB,EAAJ,GACI9M,QAAA,CAAU5O,IAAD,IAAU;AACf,cAAM6d,eAAexF,QAAA,GACftC,QAASE,CAAAA,WAAT,CAAqBjW,IAArB,CADe,GAEf+V,QAASO,CAAAA,SAAT,CAAmBtW,IAAnB,CAFN,EAGM3b,SAAS0b,UAAA,CAAW8d,YAAX,CAHf;AAIAA,oBAAa35B,CAAAA,GAAb,GAAmB6c,MAAA,CAAOf,IAAP,CAAa9b,CAAAA,GAAhC;AACA25B,oBAAa55B,CAAAA,GAAb,GAAmB45B,YAAa35B,CAAAA,GAAhC,GAAsCG,MAAtC;AANe,OAAnB,CADJ,GAUSo3B,yBAAA,CAA0BC,EAA1B,EAAyC3F,QAASO,CAAAA,SAAlD,EAA6DvV,MAA7D,CAVT,IAWI6N,QAAA,CAAU5O,IAAD,IAAU;AACf,cAAM6d,eAAexF,QAAA,GACftC,QAASE,CAAAA,WAAT,CAAqBjW,IAArB,CADe,GAEf+V,QAASO,CAAAA,SAAT,CAAmBtW,IAAnB,CAFN,EAGM3b,SAAS0b,UAAA,CAAWgB,MAAA,CAAOf,IAAP,CAAX,CAHf;AAIA6d,oBAAa55B,CAAAA,GAAb,GAAmB45B,YAAa35B,CAAAA,GAAhC,GAAsCG,MAAtC;AAII0nB,YAAKkH,CAAAA,cAAT,IAA2B,CAAClH,IAAK2H,CAAAA,gBAAjC,KACI3H,IAAKuE,CAAAA,iBACL,GADyB,CAAA,CACzB,EAAAvE,IAAKkH,CAAAA,cAAL,CAAoBjT,IAApB,CAA0B/b,CAAAA,GAA1B,GACI8nB,IAAKkH,CAAAA,cAAL,CAAoBjT,IAApB,CAA0B9b,CAAAA,GAD9B,GACoCG,MAHxC;AATe,OAAnB,CAXJ;AA2BMy5B,QAAAA,GAvzGa,CACvBx2B,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CAuzGbyE;AACNpd,kBAAA,CAAaod,EAAb,EAA0B/c,MAA1B,EAAkCgV,QAASO,CAAAA,SAA3C,CAAA;AACA,YAAMyH,cAzzGa,CACvBz2B,EAAG+xB,eAAA,EADoB,EAEvBzY,EAAGyY,eAAA,EAFoB,CAyzGnB;AACIhB,cAAJ,GACI3X,YAAA,CAAaqd,WAAb,EAA0BhS,IAAKwL,CAAAA,cAAL,CAAoBqG,cAApB,EAAoC,CAAA,CAApC,CAA1B,EAAqE7H,QAASE,CAAAA,WAA9E,CADJ,GAIIvV,YAAA,CAAaqd,WAAb,EAA0Bhd,MAA1B,EAAkCgV,QAASO,CAAAA,SAA3C,CAJJ;AAMA,YAAMzD,mBAAmB,EA7iDtBtE,eAAA,CA6iDmCuP,EA7iDbx2B,CAAAA,CAAtB,CA6iDsB,IA7iDMinB,eAAA,CA6iDOuP,EA7iDeld,CAAAA,CAAtB,CA6iDN,CAAzB;AACA,UAAIkS,2BAA2B,CAAA,CAA/B;AACA,UAAI,CAAC/G,IAAKyH,CAAAA,UAAV,CAAsB;AAClB,cAAMyE,iBAAiBlM,IAAKwM,CAAAA,0BAAL,EAAvB;AAKA,YAAIN,cAAJ,IAAsB,CAACA,cAAezE,CAAAA,UAAtC,CAAkD;AAC9C,gBAAM,CAAE,SAAUwK,cAAZ,EAA4B,OAAQC,YAApC,CAAA,GAAqDhG,cAA3D;AACA,cAAI+F,cAAJ,IAAsBC,YAAtB,CAAoC;AAChC,kBAAMC,mBAAmB7H,SAAA,EAAzB;AACAvV,gCAAA,CAAqBod,gBAArB,EAAuCnI,QAASO,CAAAA,SAAhD,EAA2D0H,cAAe1H,CAAAA,SAA1E,CAAA;AACA,kBAAMmD,iBAAiBpD,SAAA,EAAvB;AACAvV,gCAAA,CAAqB2Y,cAArB,EAAqC1Y,MAArC,EAA6Ckd,YAAa3H,CAAAA,SAA1D,CAAA;AA9iDT7H,6BAAA,CA+iD+ByP,gBA/iDX52B,CAAAA,CAApB,EA+iDiDmyB,cA/iDxBnyB,CAAAA,CAAzB,CA+iDS,IA/iDsBmnB,iBAAA,CA+iDAyP,gBA/iDoBtd,CAAAA,CAApB,EA+iDkB6Y,cA/iDO7Y,CAAAA,CAAzB,CA+iDtB,KACIkS,wBADJ,GAC+B,CAAA,CAD/B;AAGImF,0BAAexyB,CAAAA,OAAQ8tB,CAAAA,UAA3B,KACIxH,IAAKkH,CAAAA,cAEL,GAFsBwG,cAEtB,EADA1N,IAAKyM,CAAAA,oBACL,GAD4B0F,gBAC5B,EAAAnS,IAAKkM,CAAAA,cAAL,GAAsBA,cAH1B;AARgC;AAFU;AANhC;AAwBtBlM,UAAKmG,CAAAA,eAAL,CAAqB,WAArB,EAAkC,CAC9BnR,MAD8B,EAE9BgV,QAF8B,EAG9Bj0B,MAAOi8B,WAHuB,EAI9BD,YAAAA,EAJ8B,EAK9BjL,gBAL8B,EAM9BC,wBAN8B,CAAlC,CAAA;AApEgC,KAHpC;AAgFS/G,UAAKkI,CAAAA,MAAL,EAAJ,KACK,CAAE,eAAA5P,EAAF,CACN,GAD2B0H,IAAKtmB,CAAAA,OAChC,EAAA4e,EAAA,IAAkBA,EAAA,EAFjB;AAhFL;AAyFA0H,QAAKtmB,CAAAA,OAAQK,CAAAA,UAAb,GAA0BrF,IAAAA,EAA1B;AA5F8B;AA8FlC6wB,UAASA,oBAAmB,CAACvF,IAAD,CAAO;AAC1BA,QAAKrP,CAAAA,MAAV,KAQKqP,IAAK4M,CAAAA,YAAL,EAWL,KAVI5M,IAAKuE,CAAAA,iBAUT,GAV6BvE,IAAKrP,CAAAA,MAAO4T,CAAAA,iBAUzC,GAHAvE,IAAKsE,CAAAA,uBAGL,KAHiCtE,IAAKsE,CAAAA,uBAGtC,GAHgE,CAAA,EAAQtE,IAAKuE,CAAAA,iBAAb,IAC5DvE,IAAKrP,CAAAA,MAAO4T,CAAAA,iBADgD,IAE5DvE,IAAKrP,CAAAA,MAAO2T,CAAAA,uBAFgD,CAGhE,GAAAtE,IAAKqE,CAAAA,gBAAL,KAA0BrE,IAAKqE,CAAAA,gBAA/B,GAAkDrE,IAAKrP,CAAAA,MAAO0T,CAAAA,gBAA9D,CAnBA;AAD+B;AAsBnCqB,UAASA,gBAAe,CAAC1F,IAAD,CAAO;AAC3BA,QAAKuE,CAAAA,iBAAL,GACIvE,IAAKsE,CAAAA,uBADT,GAEQtE,IAAKqE,CAAAA,gBAFb,GAGY,CAAA,CAHZ;AAD2B;AAM/BuF,UAASA,cAAa,CAAC5J,IAAD,CAAO;AACzBA,QAAK4J,CAAAA,aAAL,EAAA;AADyB;AAG7BR,UAASA,kBAAiB,CAACpJ,IAAD,CAAO;AAC7BA,QAAKoJ,CAAAA,iBAAL,EAAA;AAD6B;AAGjCC,UAASA,mBAAkB,CAACrJ,IAAD,CAAO;AAC9BA,QAAKwE,CAAAA,aAAL,GAAqB,CAAA,CAArB;AAD8B;AAGlC8E,UAASA,oBAAmB,CAACtJ,IAAD,CAAO;AAC/B,UAAM,CAAEpsB,aAAF,CAAA,GAAoBosB,IAAKtmB,CAAAA,OAA/B;AACI9F,iBAAJ,IAAqBA,aAAciB,CAAAA,QAAd,EAAyBu9B,CAAAA,qBAA9C,IACIx+B,aAAcoc,CAAAA,MAAd,CAAqB,qBAArB,CADJ;AAGAgQ,QAAK2D,CAAAA,cAAL,EAAA;AAL+B;AAOnCiD,UAASA,gBAAe,CAAC5G,IAAD,CAAO;AAC3BA,QAAK4G,CAAAA,eAAL,EAAA;AACA5G,QAAK8L,CAAAA,WAAL,GAAmB9L,IAAKkH,CAAAA,cAAxB,GAAyClH,IAAKhmB,CAAAA,MAA9C,GAAuDtF,IAAAA,EAAvD;AACAsrB,QAAKuE,CAAAA,iBAAL,GAAyB,CAAA,CAAzB;AAH2B;AAK/BiB,UAASA,mBAAkB,CAACxF,IAAD,CAAO;AAC9BA,QAAKwF,CAAAA,kBAAL,EAAA;AAD8B;AAGlCC,UAASA,eAAc,CAACzF,IAAD,CAAO;AAC1BA,QAAKyF,CAAAA,cAAL,EAAA;AAD0B;AAG9BoD,UAASA,qBAAoB,CAAC7I,IAAD,CAAO;AAChCA,QAAK6I,CAAAA,oBAAL,EAAA;AADgC;AAGpCgB,UAASA,oBAAmB,CAACtB,KAAD,CAAQ;AAChCA,SAAM8J,CAAAA,kBAAN,EAAA;AADgC;AAGpChE,UAASA,aAAY,CAAC9wB,MAAD,EAASxH,KAAT,EAAgByL,CAAhB,CAAmB;AACpCjE,UAAO+W,CAAAA,SAAP,GAAmBF,WAAA,CAAYre,KAAMue,CAAAA,SAAlB,EAA6B,CAA7B,EAAgC9S,CAAhC,CAAnB;AACAjE,UAAO8W,CAAAA,KAAP,GAAeD,WAAA,CAAYre,KAAMse,CAAAA,KAAlB,EAAyB,CAAzB,EAA4B7S,CAA5B,CAAf;AACAjE,UAAOoF,CAAAA,MAAP,GAAgB5M,KAAM4M,CAAAA,MAAtB;AACApF,UAAO4W,CAAAA,WAAP,GAAqBpe,KAAMoe,CAAAA,WAA3B;AAJoC;AAcxC8Z,UAASA,oBAAmB,CAACjO,IAAD,CAAO;AAC/B,WAAQA,IAAKsO,CAAAA,eAAb,IAAqE55B,IAAAA,EAArE,KAAgCsrB,IAAKsO,CAAAA,eAAgBG,CAAAA,WAArD;AAD+B;AAkBnCrD,UAASA,UAAS,CAACnX,IAAD,CAAO;AAErBA,QAAK9b,CAAAA,GAAL,GAAWm6B,UAAA,CAAWre,IAAK9b,CAAAA,GAAhB,CAAX;AACA8b,QAAK/b,CAAAA,GAAL,GAAWo6B,UAAA,CAAWre,IAAK/b,CAAAA,GAAhB,CAAX;AAHqB;AASzBw3B,UAASA,0BAAyB,CAACC,aAAD,EAAgB3F,QAAhB,EAA0BhV,MAA1B,CAAkC;AACxD,QAAA,eAAA;AAAA,QAAA,EAAA,eAAA,GAAA,UAAA,KAAA,aAAA,CAAA,CAAA;AACH,UAAA,aAAA,GAAA,iBAAA,KAAA,aAAA;AAAA,gBAAA,GAAA,WAAA,CAAA,QAAA,CAAA,EAAA,MAAA,GAAA,WAAA,CAAA,MAAA,CAAA,EAAA,aAAA,GAAA,EAAAud,EAAA,IAl8GEt6B,IAAKwD,CAAAA,GAAL,CAASzH,QAAT,GAAiBgG,MAAjB,CAk8GF,CAAA;AAAA;AAAA,qBAAA,GAAA,aAAA;AADG;AAAR,WAAQ,eAAR;AADgE;AAKpEsxB,UAASA,uBAAsB,CAACtL,IAAD,CAAO;AAClC,QAAIxgB,EAAJ;AACA,WAAOwgB,IAAP,KAAgBA,IAAKzZ,CAAAA,IAArB,KAAqD,IAAvB,MAAC/G,EAAD,GAAMwgB,IAAKI,CAAAA,MAAX,KAAsC,IAAK,EAA3C,KAA+B5gB,EAA/B,GAA+C,IAAK,EAApD,GAAwDA,EAAGkrB,CAAAA,OAAzF;AAFkC;AAqCtC8H,UAASA,gBAAe,CAACC,MAAD,EAASxe,IAAT,CAAe;AACnC,WAAIA,IAAK/b,CAAAA,GAAT,KAAiB+b,IAAK9b,CAAAA,GAAtB,GACW,CADX,GAEQs6B,MAFR,IAEkBxe,IAAK/b,CAAAA,GAFvB,GAE6B+b,IAAK9b,CAAAA,GAFlC,IAE0C,GAF1C;AADmC;AAuEvCu6B,UAASA,aAAY,CAACC,QAAD,CAAW;AAC5B,SAAK,MAAM1+B,GAAX,GAAkB0+B,SAAlB;AACIC,wBAAA,CAAmB3+B,GAAnB,CAAA,GAA0B,CACtB,GAAG2+B,kBAAA,CAAmB3+B,GAAnB,CADmB,EAEtB,GAAG0+B,QAAA,CAAS1+B,GAAT,CAFmB,CAA1B;AADJ;AAD4B;AAShC4+B,UAASA,YAAW,CAACjd,GAAD,CAAM;AACtB,WAAQA,GAAR,IACmB,QADnB,KACI,MAAOA,IADX,IAEI1I,MAAO4lB,CAAAA,SAAUvlB,CAAAA,cAAewlB,CAAAA,IAAhC,CAAqCnd,GAArC,EAA0C,SAA1C,CAFJ;AADsB;AA0G1B4I,UAASA,eAAc,CAACwU,IAAD,EAAOC,kBAAP,CAA2B;AAC9C,WAAOA,kBAAA,GAAqB,CAAErb,MAAOqb,kBAAA,CAAmBD,IAAKpb,CAAAA,KAAxB,CAAT,CAArB,GAAiEob,IAAxE;AAD8C;AAGlDE,UAASA,cAAa,CAAC/wB,CAAD,EAAIC,CAAJ,CAAO;AACzB,WAAO,CAAE7G,EAAG4G,CAAE5G,CAAAA,CAALA,GAAS6G,CAAE7G,CAAAA,CAAb,EAAgBsZ,EAAG1S,CAAE0S,CAAAA,CAALA,GAASzS,CAAEyS,CAAAA,CAA3B,CAAP;AADyB;AAG7Bse,UAASA,WAAU,CAAC,CAAEvb,KAAF,CAAD,EAAYwb,OAAZ,CAAqB;AACpC,WAAO,CACHxb,KADG,EAEH7hB,MAAOm9B,aAAA,CAActb,KAAd,EAAqCwb,OASzC,CATyCA,OASzB96B,CAAAA,MAAhB,GAAyB,CAAzB,CATI,CAFJ,EAGHkS,OAAQ0oB,aAAA,CAActb,KAAd,EAAsCwb,OAK3C,CAAQ,CAAR,CALK,CAHL,EAIH3+B,SAAUN,WAAA,CAAYi/B,OAAZ,EAAqB,GAArB,CAJP,CAAP;AADoC;AAcxCj/B,UAASA,YAAW,CAACi/B,OAAD,EAAUC,SAAV,CAAqB;AACrC,QAAqB,CAArB,GAAID,OAAQ96B,CAAAA,MAAZ;AACI,aAAO,CAAEiD,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAP;AADJ;AAGA,QAAIxc,IAAI+6B,OAAQ96B,CAAAA,MAAZD,GAAqB,CAAzB;AACA,QAAIi7B,mBAAmB,IAAvB;AACA,UAAMC,YAA4BH,OAR3B,CAQ2BA,OARX96B,CAAAA,MAAhB,GAAyB,CAAzB,CAQP;AACA,SAAA,EAAY,CAAZ,IAAOD,CAAP,CAAA,CAAe;AACXi7B,sBAAA,GAAmBF,OAAA,CAAQ/6B,CAAR,CAAnB;AACA,UAAIk7B,SAAUv9B,CAAAA,SAAd,GAA0Bs9B,gBAAiBt9B,CAAAA,SAA3C,GACIgF,WAAYkJ,CAAAA,qBAAZ,CAAkCmvB,SAAlC,CADJ;AAEI;AAFJ;AAIAh7B,OAAA,EAAA;AANW;AAQf,QAAI,CAACi7B,gBAAL;AACI,aAAO,CAAE/3B,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAP;AADJ;AAGMkM,WAAAA,GAAO/lB,WAAYyJ,CAAAA,qBAAZ,CAAkC8uB,SAAUv9B,CAAAA,SAA5C,GAAwDs9B,gBAAiBt9B,CAAAA,SAAzE,CAAP+qB;AACN,QAAa,CAAb,KAAIA,OAAJ;AACI,aAAO,CAAExlB,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAP;AADJ;AAGM7M,oBAAAA,GAAkB,CACpBzM,GAAIg4B,SAAUh4B,CAAAA,CAAdA,GAAkB+3B,gBAAiB/3B,CAAAA,CAAnCA,IAAwCwlB,OADpB,EAEpBlM,GAAI0e,SAAU1e,CAAAA,CAAdA,GAAkBye,gBAAiBze,CAAAA,CAAnCA,IAAwCkM,OAFpB,CAAlB/Y;AAIoBuJ,YAA1B,KAAIvJ,gBAAgBzM,CAAAA,CAApB,KACIyM,gBAAgBzM,CAAAA,CADpB,GACwB,CADxB;AAG0BgW,YAA1B,KAAIvJ,gBAAgB6M,CAAAA,CAApB,KACI7M,gBAAgB6M,CAAAA,CADpB,GACwB,CADxB;AAGA,WAAO7M,gBAAP;AAhCqC;AAwCzCwrB,UAASA,iBAAgB,CAAC5b,KAAD,EAAQ,CAAEzf,GAAF,EAAOD,GAAP,CAAR,EAAsBu7B,OAAtB,CAA+B;AACxC/+B,QAAAA,EAAZ,KAAIyD,GAAJ,IAAyByf,KAAzB,GAAiCzf,GAAjC,GAEIyf,KAFJ,GAEY6b,OAAA,GACUt7B,GADV,IACeyf,KADf,GACUzf,GADV,IACsBs7B,OAAQt7B,CAAAA,GAD9B,GAEFF,IAAKC,CAAAA,GAAL,CAAS0f,KAAT,EAAgBzf,GAAhB,CAJV,GAMiBzD,IAAAA,EANjB,KAMSwD,GANT,IAM8B0f,KAN9B,GAMsC1f,GANtC,KAQI0f,KARJ,GAQY6b,OAAA,GACUv7B,GADV,IACe0f,KADf,GACU1f,GADV,IACsBu7B,OAAQv7B,CAAAA,GAD9B,GAEFD,IAAKE,CAAAA,GAAL,CAASyf,KAAT,EAAgB1f,GAAhB,CAVV,CAAA;AAYA,WAAO0f,KAAP;AAboD;AAoBxD8b,UAASA,4BAA2B,CAACzf,IAAD,EAAO9b,GAAP,EAAYD,GAAZ,CAAiB;AACjD,WAAO,CACHC,IAAazD,IAAAA,EAAR,KAAAyD,GAAA,GAAoB8b,IAAK9b,CAAAA,GAAzB,GAA+BA,GAA/B,GAAqCzD,IAAAA,EADvC,EAEHwD,IAAaxD,IAAAA,EAAR,KAAAwD,GAAA,GACC+b,IAAK/b,CAAAA,GADN,GACYA,GADZ,IACmB+b,IAAK/b,CAAAA,GADxB,GAC8B+b,IAAK9b,CAAAA,GADnC,IAECzD,IAAAA,EAJH,CAAP;AADiD;AAYrDi/B,UAASA,wBAAuB,CAACpJ,SAAD,EAAY,CAAErM,GAAF,EAAOC,IAAP,EAAaE,MAAb,EAAqBD,KAArB,CAAZ,CAA0C;AACtE,WAAO,CACH7iB,EAAGm4B,2BAAA,CAA4BnJ,SAAUhvB,CAAAA,CAAtC,EAAyC4iB,IAAzC,EAA+CC,KAA/C,CADA,EAEHvJ,EAAG6e,2BAAA,CAA4BnJ,SAAU1V,CAAAA,CAAtC,EAAyCqJ,GAAzC,EAA8CG,MAA9C,CAFA,CAAP;AADsE;AAS1EuV,UAASA,4BAA2B,CAACC,UAAD,EAAaC,eAAb,CAA8B;AAC9D,QAAI37B,MAAM27B,eAAgB37B,CAAAA,GAAtBA,GAA4B07B,UAAW17B,CAAAA,GAA3C,EACID,MAAM47B,eAAgB57B,CAAAA,GAAtBA,GAA4B27B,UAAW37B,CAAAA,GAD3C;AAII47B,mBAAgB57B,CAAAA,GAApB,GAA0B47B,eAAgB37B,CAAAA,GAA1C,GACI07B,UAAW37B,CAAAA,GADf,GACqB27B,UAAW17B,CAAAA,GADhC,KAEI,CAACA,GAAD,EAAMD,GAAN,CAFJ,GAEiB,CAACA,GAAD,EAAMC,GAAN,CAFjB;AAIA,WAAO,CAAEA,GAAF,EAAOD,GAAP,CAAP;AAT8D;AAqDlE67B,UAASA,mBAAkB,CAACC,WAAA,GAJLC,IAII,CAA+B;AAClC,KAAA,CAApB,KAAID,WAAJ,GACIA,WADJ,GACkB,CADlB,GAGyB,CAAA,CAHzB,KAGSA,WAHT,KAIIA,WAJJ,GALmBC,IAKnB,CAAA;AAO0BD,QAAAA,2BAAAA,WAAAA;AAK1B,4BAAA,GAAO,CACH77B,IAAK+7B,mBAAA,CAAoBF,wBAApB,EAN8BG,MAM9B,CADF,EAEHj8B,IAAKg8B,mBAAA,CAAoBF,wBAApB,EAPsCI,OAOtC,CAFF,CAAP;AAAA,eAAA,GAAO,CACHj8B,IAAK+7B,mBAAA,CAAoBF,WAApB,EAL8BG,KAK9B,CADF,EAEHj8B,IAAKg8B,mBAAA,CAAoBF,WAApB,EANqCI,QAMrC,CAFF,CAAP;AANA,WAAO,CACH74B,EAAG,wBADA,EAEHsZ,EAAG,WAFA,CAAP;AAPsD;AAkB1Dqf,UAASA,oBAAmB,CAACF,WAAD,EAAcK,KAAd,CAAqB;AAC7C,WAA8B,QAAvB,KAAA,MAAOL,YAAP,GACDA,WADC,GAEDA,WAAA,CAAYK,KAAZ,CAFC,IAEqB,CAF5B;AAD6C;AA8bjDC,UAASA,WAAU,CAACtoB,SAAD,EAAYuoB,IAAZ,EAAkBC,gBAAlB,CAAoC;AACnD,YAAkB,CAAA,CAAlB,KAASD,IAAT,IAA0BA,IAA1B,KAAmCvoB,SAAnC,MAC0B,IAD1B,KACKwoB,gBADL,IACkCA,gBADlC,KACuDxoB,SADvD;AADmD;AAWvDyoB,UAASA,oBAAmB,CAACjqB,MAAD,EAASkqB,aAAA,GAAgB,EAAzB,CAA6B;AACrD,QAAI1oB,YAAY,IAAhB;AACI/T,QAAKwD,CAAAA,GAAL,CAAS+O,MAAOqK,CAAAA,CAAhB,CAAJ,GAAyB6f,aAAzB,GACI1oB,SADJ,GACgB,GADhB,GAGS/T,IAAKwD,CAAAA,GAAL,CAAS+O,MAAOjP,CAAAA,CAAhB,CAHT,GAG8Bm5B,aAH9B,KAII1oB,SAJJ,GAIgB,GAJhB,CAAA;AAMA,WAAOA,SAAP;AARqD;AAiLzD2oB,UAASA,cAAa,CAACtgC,KAAD,CAAQ;AAC1B,UAAM,CAACgkB,SAAD,EAAYM,YAAZ,CAAA,GAA4BV,WAAA,EAAlC,EACM2c,cAAc/e,KAAMsC,CAAAA,UAAN,CAAiB0c,kBAAjB,CADpB;AAEA,WAAQC,UAAWC,CAAAA,GAAX,CAAeC,wBAAf,EAAyC,CAAE,GAAG3gC,KAAL,EAAyBugC,WAAzB,EAAsCK,kBAAmBpf,KAAMsC,CAAAA,UAAN,CAAiB+c,wBAAjB,CAAzD,EAAgH7c,SAAhH,EAAyIM,YAAzI,CAAzC,CAAR;AAH0B;AAiC9Bwc,UAASA,iBAAgB,CAACnV,IAAD,EAAOrI,KAAP,EAAcyd,SAAd,CAAyB;AAC9C,UAAM,CAAE/gC,KAAF,CAAA,GAAY2rB,IAAlB;AACIA,QAAKlS,CAAAA,cAAT,IAA2BzZ,KAAMsf,CAAAA,UAAjC,IACIqM,IAAKlS,CAAAA,cAAeuF,CAAAA,SAApB,CAA8B,YAA9B,EAA0D,OAA1D,KAA4C+hB,SAA5C,CADJ;AAIA,UAAMlgC,WAAWb,KAAA,CADE,SACF,GADc+gC,SACd,CAAjB;AACIlgC,YAAJ,IACIsZ,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAMzC,QAAA,CAASyiB,KAAT,EAAgBD,gBAAA,CAAiBC,KAAjB,CAAhB,CAAvB,CADJ;AAP8C;AA4DlD0d,UAASA,iBAAgB,CAACrV,IAAD,EAAOrI,KAAP,EAAcyd,SAAd,CAAyB;AAC9C,UAAM,CAAE/gC,KAAF,CAAA,GAAY2rB,IAAlB;AACA,QAAI,EAAAA,IAAKxrB,CAAAA,OAAL,YAAwB8gC,iBAAxB,IAA6CtV,IAAKxrB,CAAAA,OAAQ+gC,CAAAA,QAA1D,CAAJ,CAAA;AAGIvV,UAAKlS,CAAAA,cAAT,IAA2BzZ,KAAMuf,CAAAA,QAAjC,IACIoM,IAAKlS,CAAAA,cAAeuF,CAAAA,SAApB,CAA8B,UAA9B,EAAwD,OAAxD,KAA0C+hB,SAA1C,CADJ;AAIA,UAAMlgC,WAAWb,KAAA,CADE,OACF,IAD2B,KAAd,KAAA+gC,SAAA,GAAsB,EAAtB,GAA2BA,SACxC,EAAjB;AACIlgC,cAAJ,IACIsZ,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAMzC,QAAA,CAASyiB,KAAT,EAAgBD,gBAAA,CAAiBC,KAAjB,CAAhB,CAAvB,CADJ;AARA;AAF8C;AA8ClD6d,UAASA,yBAAwB,CAAC,CAAEjvB,IAAF,EAAQ,GAAG7M,OAAX,CAAD,CAAuB;AACpD,QAAM+7B,aAAalvB,IAAbkvB,IAAqBC,QAA3B;AAIKC,aAAUvgC,CAAAA,GAAV,CAAcqgC,UAAd,CAAL,IACIE,SAAUt7B,CAAAA,GAAV,CAAco7B,UAAd,EAA0B,EAA1B,CADJ;AAGMG,cAAAA,GAAgBD,SAAUzhC,CAAAA,GAAV,CAAcuhC,UAAd,CAAhBG;AACN,UAAM3hC,MAAM4hC,IAAKC,CAAAA,SAAL,CAAep8B,OAAf,CAAZ;AAKKk8B,cAAA,CAAc3hC,GAAd,CAAL,KACI2hC,UAAA,CAAc3hC,GAAd,CADJ,GACyB,IAAI8hC,oBAAJ,CAAyBC,wBAAzB,EAAmD,CAAEzvB,IAAF,EAAQ,GAAG7M,OAAX,CAAnD,CADzB;AAGA,WAAOk8B,UAAA,CAAc3hC,GAAd,CAAP;AAjBoD;AAmBxDgiC,UAASA,oBAAmB,CAAC78B,OAAD,EAAUM,OAAV,EAAmBxE,QAAnB,CAA6B;AACrD,UAAMghC,4BAA4BV,wBAAA,CAAyB97B,OAAzB,CAAlC;AACAy8B,qBAAkB97B,CAAAA,GAAlB,CAAsBjB,OAAtB,EAA+BlE,QAA/B,CAAA;AACAghC,6BAA0BE,CAAAA,OAA1B,CAAkCh9B,OAAlC,CAAA;AACA,WAAO,EAAA,IAAM;AACT+8B,uBAAkB7/B,CAAAA,MAAlB,CAAyB8C,OAAzB,CAAA;AACA88B,+BAA0BG,CAAAA,SAA1B,CAAoCj9B,OAApC,CAAA;AAFS,KAAb;AAJqD;AA0EzDk9B,UAASA,yBAAwB,CAAC,CAAEC,QAAA,GAAW,EAAb,CAAD,EAAoB,CAAE,SAAUC,YAAA,GAAe,EAA3B,CAAA,GAAkC,EAAtD,CAA0D;AACvF,WAAQ54B,IAAD,IAAU24B,QAAA,CAAS34B,IAAT,CAAV,KAA6B44B,YAAA,CAAa54B,IAAb,CAApC;AADuF;AA0B3F64B,UAASA,uBAAsB,CAACpiC,KAAD,EAAQqc,OAAR,CAAiB;AAC5C,QAAID,qBAAA,CAAsBpc,KAAtB,CAAJ,CAAkC;AAC9B,YAAM,CAAEuc,OAAF,EAAWhF,OAAX,CAAA,GAAuBvX,KAA7B;AACA,aAAO,CACHuc,QAAqB,CAAA,CAAZ,KAAAA,OAAA,IAAqBL,cAAA,CAAeK,OAAf,CAArB,GACHA,OADG,GAEHlc,IAAAA,EAHH,EAIHkX,QAAS2E,cAAA,CAAe3E,OAAf,CAAA,GAA0BA,OAA1B,GAAoClX,IAAAA,EAJ1C,CAAP;AAF8B;AASlC,WAAyB,CAAA,CAAlB,KAAAL,KAAM2iB,CAAAA,OAAN,GAA0BtG,OAA1B,GAAoC,EAA3C;AAV4C;AAahDgmB,UAASA,uBAAsB,CAACriC,KAAD,CAAQ;AACnC,UAAM,CAAEuc,OAAF,EAAWhF,OAAX,CAAA,GAAuB6qB,sBAAA,CAAuBpiC,KAAvB,EAA8BwhB,KAAMsC,CAAAA,UAAN,CAAiBwe,aAAjB,CAA9B,CAA7B;AACA,WAAO9gB,KAAM+gB,CAAAA,OAAN,CAAc,EAAA,IAAO,EAAEhmB,OAAF,EAAWhF,OAAX,EAArB,EAA4C,CAG5C3R,KAAMC,CAAAA,OAAN,CAHuE0W,OAGvE,CAAA,GAHuEA,OAG5CimB,CAAAA,IAAL,CAAU,GAAV,CAAtB,GAHuEjmB,OAA3B,EAG5C3W,KAAMC,CAAAA,OAAN,CAH2G0R,OAG3G,CAAA,GAH2GA,OAGhFirB,CAAAA,IAAL,CAAU,GAAV,CAAtB,GAH2GjrB,OAA/D,CAA5C,CAAP;AAFmC;AAcvCkrB,UAASA,aAAY,CAACC,WAAD,EAAcnjC,aAAd,EAA6BojC,WAA7B,CAA0C;AAC3D,WAAOnhB,KAAM+C,CAAAA,WAAN,CAAmBnC,QAAD,IAAc;AAC/BA,cAAJ,IACIsgB,WAAYvgB,CAAAA,OADhB,IAC2BugB,WAAYvgB,CAAAA,OAAZ,CAAoBC,QAApB,CAD3B;AAGI7iB,mBAAJ,KACQ6iB,QAAJ,GACI7iB,aAAc2yB,CAAAA,KAAd,CAAoB9P,QAApB,CADJ,GAII7iB,aAAcw0B,CAAAA,OAAd,EALR;AAQI4O,iBAAJ,KAC+B,UAA3B,KAAI,MAAOA,YAAX,GACIA,WAAA,CAAYvgB,QAAZ,CADJ,GAGSoc,WAAA,CAAYmE,WAAZ,CAHT,KAIIA,WAAYxiC,CAAAA,OAJhB,GAI0BiiB,QAJ1B,CADJ;AAZmC,KAAhC,EA0BP,CAAC7iB,aAAD,CA1BO,CAAP;AAD2D;AA8B/DqjC,UAASA,iBAAgB,CAACC,SAAD,EAAYH,WAAZ,EAAyB1iC,KAAzB,EAAgC8iC,mBAAhC,EAAqDC,yBAArD,CAAgF;AAAA,QACjG53B,EADiG,EAC7FmxB,EAD6F;AAErG,UAAM,CAAE,cAAehgB,MAAjB,CAAA,GAA4BkF,KAAMsC,CAAAA,UAAN,CAAiBwe,aAAjB,CAAlC,EACMU,cAAcxhB,KAAMsC,CAAAA,UAAN,CAAiBmf,WAAjB,CADpB,EAEMroB,kBAAkB4G,KAAMsC,CAAAA,UAAN,CAAiBC,eAAjB,CAFxB,EAGMmf,sBAAsB1hB,KAAMsC,CAAAA,UAAN,CAAiBqf,mBAAjB,CAAsCC,CAAAA,aAHlE,EAIMC,mBAAmB7hB,KAAMC,CAAAA,MAAN,CAAa,IAAb,CAJzB;AAQAqhB,uBAAA,GAAsBA,mBAAtB,IAA6CE,WAAYM,CAAAA,QAAzD;AACI,KAACD,gBAAiBljC,CAAAA,OAAtB,IAAiC2iC,mBAAjC,KACIO,gBAAiBljC,CAAAA,OADrB,GAC+B2iC,mBAAA,CAAoBD,SAApB,EAA+B,CACtDH,WADsD,EAEtDpmB,MAFsD,EAGtDtc,KAHsD,EAItD4a,eAJsD,EAKtD6D,sBAAuB7D,eAAA,GACW,CAAA,CADX,KACjBA,eAAgB2B,CAAAA,OADC,GAEjB,CAAA,CAPgD,EAQtD2mB,mBARsD,CAA/B,CAD/B;AAYA,UAAM3jC,gBAAgB8jC,gBAAiBljC,CAAAA,OAAvC;AAKMojC,aAAAA,GAA2B/hB,KAAMsC,CAAAA,UAAN,CAAiB+c,wBAAjB,CAA3B0C;AACFhkC,KAAAA,aAAJ,IACKA,aAAc8oB,CAAAA,UADnB,IAEI0a,CAAAA,yBAFJ,IAG4B,MAH5B,KAGKxjC,aAAc4J,CAAAA,IAHnB,IAG6D,KAH7D,KAGsC5J,aAAc4J,CAAAA,IAHpD,IAIIq6B,oBAAA,CAAqBH,gBAAiBljC,CAAAA,OAAtC,EAA+CH,KAA/C,EAAsD+iC,yBAAtD,EAAiFQ,SAAjF,CAJJ;AAMA,UAAME,YAAYjiB,KAAMC,CAAAA,MAAN,CAAa,CAAA,CAAb,CAAlB;AACAD,SAAMkiB,CAAAA,kBAAN,CAAyB,EAAA,IAAM;AAKvBnkC,mBAAJ,IAAqBkkC,SAAUtjC,CAAAA,OAA/B,IACIZ,aAAc4D,CAAAA,MAAd,CAAqBnD,KAArB,EAA4B4a,eAA5B,CADJ;AAL2B,KAA/B,CAAA;AAaA,UAAM+oB,oBAAoB3jC,KAAA,CAAMqG,4BAAN,CAA1B,EACMu9B,eAAepiB,KAAMC,CAAAA,MAAN,CAAa,CAAA,CAAQkiB,iBAArB,IACjB,EAA4C,IAA1C,MAACx4B,EAAD,GAAMG,MAAOu4B,CAAAA,uBAAb,KAAyD,IAAK,EAA9D,KAAkD14B,EAAlD,GAAkE,CAAlE,GAA2EA,EAAGuzB,CAAAA,IAAH,CAAQpzB,MAAR,EAAgBq4B,iBAAhB,CAA7E,CADiB,KAE8B,IAA9C,MAACrH,EAAD,GAAMhxB,MAAOyjB,CAAAA,2BAAb,KAA6D,IAAK,EAAlE,KAAsDuN,EAAtD,GAAsE,IAAK,EAA3E,GAA+EA,EAAGoC,CAAAA,IAAH,CAAQpzB,MAAR,EAAgBq4B,iBAAhB,CAF/D,EADrB;AAIAG,6BAAA,CAA0B,EAAA,IAAM;AACvBvkC,mBAAL,KAEAkkC,SAAUtjC,CAAAA,OAcV,GAdoB,CAAA,CAcpB,EAbAmL,MAAOy4B,CAAAA,eAaP,GAbyB,CAAA,CAazB,EAZAxkC,aAAcykC,CAAAA,cAAd,EAYA,EAXA1O,SAAUjyB,CAAAA,MAAV,CAAiB9D,aAAc8D,CAAAA,MAA/B,CAWA,EAAIugC,YAAazjC,CAAAA,OAAjB,IAA4BZ,aAAcka,CAAAA,cAA1C,IACIla,aAAcka,CAAAA,cAAeoD,CAAAA,cAA7B,EAjBJ;AAD4B,KAAhC,CAAA;AAqBA2E,SAAM6C,CAAAA,SAAN,CAAgB,EAAA,IAAM;AACb9kB,mBAAL,KAEI,CAACqkC,YAAazjC,CAAAA,OAGlB,IAH6BZ,aAAcka,CAAAA,cAG3C,IAFIla,aAAcka,CAAAA,cAAeoD,CAAAA,cAA7B,EAEJ,EAAI+mB,YAAazjC,CAAAA,OAAjB,KAEI8jC,cAAA,CAAe,EAAA,IAAM;AACjB,YAAI94B,EAAJ;AAC8C,YAA9C,MAACA,EAAD,GAAMG,MAAO44B,CAAAA,2BAAb,KAA6D,IAAK,EAAlE,KAAsD/4B,EAAtD,IAA+EA,EAAGuzB,CAAAA,IAAH,CAAQpzB,MAAR,EAAgBq4B,iBAAhB,CAA/E;AAFiB,OAArB,CAIA,EAAAC,YAAazjC,CAAAA,OAAb,GAAuB,CAAA,CAN3B,CALA;AADkB,KAAtB,CAAA;AAeA,WAAOZ,aAAP;AAzFqG;AA2FzGikC,UAASA,qBAAoB,CAACjkC,aAAD,EAAgBS,KAAhB,EAAuB+iC,yBAAvB,EAAkDpH,sBAAlD,CAA0E;AACnG,UAAM,CAAExS,QAAF,EAAYxI,MAAZ,EAAoBuf,IAApB,EAA0BiE,eAA1B,EAA2CrY,YAA3C,EAAyDqH,UAAzD,CAAA,GAAyEnzB,KAA/E;AACAT,iBAAc8oB,CAAAA,UAAd,GAA2B,IAAI0a,yBAAJ,CAA8BxjC,aAAcoa,CAAAA,YAA5C,EAA0D3Z,KAAA,CAAM,uBAAN,CAAA,GAC/EK,IAAAA,EAD+E,GAE/E+jC,wBAAA,CAAyB7kC,aAAc+c,CAAAA,MAAvC,CAFqB,CAA3B;AAGA/c,iBAAc8oB,CAAAA,UAAWqP,CAAAA,UAAzB,CAAoC,CAChCvO,QADgC,EAEhCxI,MAFgC,EAGhCmV,oBAAqB,CAAA,CAAQoK,IAA7BpK,IAAuCqO,eAAvCrO,IAA0D0I,WAAA,CAAY2F,eAAZ,CAH1B,EAIhC5kC,aAJgC,EAYhC+7B,cAAiC,QAAlB,KAAA,MAAO3a,OAAP,GAA6BA,MAA7B,GAAsC,MAZrB,EAahCgb,sBAbgC,EAchC7P,YAdgC,EAehCqH,UAfgC,CAApC,CAAA;AALmG;AAuBvGiR,UAASA,yBAAwB,CAAC7kC,aAAD,CAAgB;AAC7C,QAAKA,aAAL;AAEA,aAAiD,CAAA,CAA1C,KAAAA,aAAc8F,CAAAA,OAAQg/B,CAAAA,eAAtB,GACD9kC,aAAc8oB,CAAAA,UADb,GAED+b,wBAAA,CAAyB7kC,aAAc+c,CAAAA,MAAvC,CAFN;AAFA;AAD6C;AAiBjDgoB,UAASA,8BAA6B,CAAC,CAAEC,iBAAF,EAAqBzB,mBAArB,EAA0C0B,SAA1C,EAAqDC,cAArD,EAAqE5B,SAArE,CAAD,CAAoF;AAGtH6B,YAASA,gBAAe,CAAC1kC,KAAD,EAAQ2iC,WAAR,CAAqB;AAMzC,YAAMgC,iBAAiB,CACnB,GAAGnjB,KAAMsC,CAAAA,UAAN,CAAiBqf,mBAAjB,CADgB,EAEnB,GAAGnjC,KAFgB,EAGnBmpB,SAAUyb,WAAA,CAAY5kC,KAAZ,CAHS,CAAvB,EAKM,CAAE6kC,QAAF,CAAA,GAAeF,cALrB,EAMMtoB,UAAUgmB,sBAAA,CAAuBriC,KAAvB,CANhB,EAOM0iC,cAAc+B,cAAA,CAAezkC,KAAf,EAAsB6kC,QAAtB,CAPpB;AAQA,UAAI,CAACA,QAAL,IAAiB9f,SAAjB,CAA4B;AAgC1B+f,YAAAA,gBAAWtjB,KAAMsC,CAAAA,UAAN,CAAiBmf,WAAjB,CAA8B8B,CAAAA,MAAzCD;AA/BgCP,yBAoCtC,IAEIO,aAFJ,KApCsBH,cAwCHK,CAAAA,YAAf,GACMr+B,WAAYuH,CAAAA,OAAZ,CAAoB,CAAA,CAApB,EAFgB+2B,kJAEhB,CADN,GAEMt+B,WAAYmF,CAAAA,SAAZ,CAAsB,CAAA,CAAtB,EAHgBm5B,kJAGhB,CANV;AASuC;AACvC,gBAAM,CAAE/E,IAAF,EAAQvf,MAAR,CAAA,GAAmB4d,kBAAzB;AACK2B,cAAL,IAAcvf,MAAd,IAEMukB,aACN,GADiB,CAAE,GAAGhF,IAAL,EAAW,GAAGvf,MAAd,CACjB,EAAA,aAAA,GAAO,CACH2f,cAAe,CAAU,IAAT,KAAAJ,IAAA,IAA0B,IAAK,EAA/B,KAAiBA,IAAjB,GAAmC,CAAnC,GAA4CA,IAAKiF,CAAAA,SAAL,CAlDJR,cAkDI,CAA7C,MAAmF,IAAX,KAAAhkB,MAAA,IAA8B,IAAK,EAAnC,KAAmBA,MAAnB,GAAuC,CAAvC,GAAgDA,MAAOwkB,CAAAA,SAAP,CAlD/ER,cAkD+E,CAAxH,IACTO,aAAS5E,CAAAA,aADA,GAETjgC,IAAAA,EAHH,EAIH+kC,eAAgBF,aAASE,CAAAA,cAJtB,CAHP,IACI,aADJ,GACW,EADX;AAFuC;AA5C/B,cAAMC,mBAAmB,aAAzB;AACA/E,qBAAA,GAAgB+E,gBAAiB/E,CAAAA,aAAjC;AAOAjkB,eAAQ9c,CAAAA,aAAR,GAAwBqjC,gBAAA,CAAiBC,SAAjB,EAA4BH,WAA5B,EAAyCiC,cAAzC,EAAyD7B,mBAAzD,EAA8EuC,gBAAiBD,CAAAA,cAA/F,CAAxB;AAVwB;AAgB5B,aAAQ3E,UAAW6E,CAAAA,IAAX,CAAgBhD,aAAciD,CAAAA,QAA9B,EAAwC,CAAE5lC,MAAO0c,OAAT,EAAkBoT,SAAU,CAAC6Q,aAAA,IAAiBjkB,OAAQ9c,CAAAA,aAAzB,GAA0CkhC,UAAWC,CAAAA,GAAX,CAAeJ,aAAf,EAA8B,CAAE/gC,cAAe8c,OAAQ9c,CAAAA,aAAzB,EAAwC,GAAGolC,cAA3C,CAA9B,CAA1C,GAAwI,IAAzI,EAA+IH,SAAA,CAAU3B,SAAV,EAAqB7iC,KAArB,EAA4ByiC,YAAA,CAAaC,WAAb,EAA0BrmB,OAAQ9c,CAAAA,aAAlC,EAAiDojC,WAAjD,CAA5B,EAA2FD,WAA3F,EAAwGmC,QAAxG,EAAkHxoB,OAAQ9c,CAAAA,aAA1H,CAA/I,CAA5B,CAAxC,CAAR;AA9ByC;AAHyE,QAClH4L,EADkH,EAC9GmxB,EAD8G;AAEtHiI,qBAAA,IAAqBlG,YAAA,CAAakG,iBAAb,CAArB;AAiCAG,mBAAgBc,CAAAA,WAAhB,GAA+B,UAA8B,QAArB,KAAA,MAAO3C,UAAP,GAClCA,SADkC,GAEjC,UAAiG,IAAxF,MAACvG,EAAD,GAAuC,IAAjC,MAACnxB,EAAD,GAAM03B,SAAU2C,CAAAA,WAAhB,KAAgD,IAAK,EAArD,KAAyCr6B,EAAzC,GAAyDA,EAAzD,GAA8D03B,SAAUt5B,CAAAA,IAA9E,KAAuG,IAAK,EAA5G,KAAgG+yB,EAAhG,GAAgHA,EAAhH,GAAqH,EAA9H,GAFwB,EAA/B;AAGMmJ,MAAAA,GAA4BjkB,KAAMkkB,CAAAA,UAAN,CAAiBhB,eAAjB,CAA5Be;AACNA,MAAA,CAA0BE,qBAA1B,CAAA,GAAmD9C,SAAnD;AACA,WAAO4C,EAAP;AAxCsH;AA0C1Hb,UAASA,YAAW,CAAC,CAAEzb,QAAF,CAAD,CAAe;AAC/B,UAAMyc,gBAAgBpkB,KAAMsC,CAAAA,UAAN,CAAiB0c,kBAAjB,CAAqCrc,CAAAA,EAA3D;AACA,WAAOyhB,aAAA,IAA8BvlC,IAAAA,EAA9B,KAAiB8oB,QAAjB,GACDyc,aADC,GACe,GADf,GACqBzc,QADrB,GAEDA,QAFN;AAF+B;AAyCnC0c,UAASA,kBAAiB,CAAClgC,MAAD,EAASqD,MAAT,EAAiBhJ,KAAjB,CAAwB;AAC9C,SAAK,MAAMJ,GAAX,GAAkBoJ,OAAlB;AACSugB,mBAAA,CAAcvgB,MAAA,CAAOpJ,GAAP,CAAd,CAAL,IAAoCspB,mBAAA,CAAoBtpB,GAApB,EAAyBI,KAAzB,CAApC,KACI2F,MAAA,CAAO/F,GAAP,CADJ,GACkBoJ,MAAA,CAAOpJ,GAAP,CADlB;AADJ;AAD8C;AAOlDkmC,UAASA,uBAAsB,CAAC,CAAEvgB,iBAAF,CAAD,EAAwBmd,WAAxB,CAAqC;AAChE,WAAOlhB,KAAM+gB,CAAAA,OAAN,CAAc,EAAA,IAAM;AACvB,YAAM/iC,QAAQumC,qBAAA,EAAd;AACA9f,qBAAA,CAAgBzmB,KAAhB,EAAuBkjC,WAAvB,EAAoCnd,iBAApC,CAAA;AACA,aAAO1M,MAAOyP,CAAAA,MAAP,CAAc,EAAd,EAAkB9oB,KAAM2mB,CAAAA,IAAxB,EAA8B3mB,KAAM0mB,CAAAA,KAApC,CAAP;AAHuB,KAApB,EAIJ,CAACwc,WAAD,CAJI,CAAP;AADgE;AAiBpEsD,UAASA,aAAY,CAAChmC,KAAD,EAAQ0iC,WAAR,CAAqB;AAEtC,UAAMuD,YAAY,EAAlB,EAVM/f,QAAQ,EAUd;AANA2f,qBAAA,CAAkB3f,KAAlB,EAOuBlmB,KAZCkmB,CAAAA,KAKxB,IALiC,EAKjC,EAOuBlmB,KAPvB,CAAA;AACA6Y,UAAOyP,CAAAA,MAAP,CAAcpC,KAAd,EAAqB4f,sBAAA,CAME9lC,KANF,EAMS0iC,WANT,CAArB,CAAA;AAOI1iC,SAAMkgC,CAAAA,IAAV,IAAyC,CAAA,CAAzC,KAAkBlgC,KAAMkmC,CAAAA,YAAxB,KAEID,SAAUE,CAAAA,SAOV,GAPsB,CAAA,CAOtB,EAfGjgB,KAUGkgB,CAAAA,UAKN,GAfGlgB,KAWOmgB,CAAAA,gBAIV,GAfGngB,KAYWogB,CAAAA,kBAGd,GAFY,MAEZ,EAfGpgB,KAeGqgB,CAAAA,WAAN,GACmB,CAAA,CAAf,KAAAvmC,KAAMkgC,CAAAA,IAAN,GACM,MADN,GAEO,OAAqB,GAAf,KAAAlgC,KAAMkgC,CAAAA,IAAN,GAAqB,GAArB,GAA2B,GAAjC,EAZf;AAcuB7/B,QAAAA,EAAvB,KAAIL,KAAMwmC,CAAAA,QAAV,KACKxmC,KAAMymC,CAAAA,KADX,IACoBzmC,KAAM0mC,CAAAA,UAD1B,IACwC1mC,KAAMuf,CAAAA,QAD9C,MAEI0mB,SAAUO,CAAAA,QAFd,GAEyB,CAFzB;AAIAP,aAAU/f,CAAAA,KAAV,GAxBOA,KAwBP;AACA,WAAO+f,SAAP;AAvBsC;AA0D1CU,UAASA,eAAc,CAAC9D,SAAD,CAAY;AAC/B,WAKqB,QALrB,KAKA,MAAOA,UALP,IASI,CAAAA,SAAU+D,CAAAA,QAAV,CAAmB,GAAnB,CATJ,KAgB0C,CAAC,CAhB3C,GAgBAC,oBAAqBviC,CAAAA,OAArB,CAA6Bu+B,SAA7B,CAhBA,IAoBI,QAASx6B,CAAAA,IAAT,CAAcw6B,SAAd,CApBJ,IAqBW,CAAA,CArBX,GAuBO,CAAA,CAvBP;AAD+B;AAgCnCiE,UAASA,YAAW,CAAC9mC,KAAD,EAAQ0iC,WAAR,EAAqBqE,SAArB,EAAgClE,SAAhC,CAA2C;AACrDmE,aAAAA,GAAcxlB,KAAM+gB,CAAAA,OAAN,CAAc,EAAA,IAAM;AACpC,YAAM/iC,QAAQynC,oBAAA,EAAd;AACA7f,mBAAA,CAAc5nB,KAAd,EAAqBkjC,WAArB,EAAkCjb,QAAA,CAASob,SAAT,CAAlC,EAAuD7iC,KAAMulB,CAAAA,iBAA7D,CAAA;AACA,aAAO,CACH,GAAG/lB,KAAMmnB,CAAAA,KADN,EAEHT,MAAO,CAAE,GAAG1mB,KAAM0mB,CAAAA,KAAX,CAFJ,CAAP;AAHoC,KAApB,EAOjB,CAACwc,WAAD,CAPiB,CAAdsE;AAQN,QAAIhnC,KAAMkmB,CAAAA,KAAV,CAAiB;AACb,YAAMghB,YAAY,EAAlB;AACArB,uBAAA,CAAkBqB,SAAlB,EAA6BlnC,KAAMkmB,CAAAA,KAAnC,EAA0ClmB,KAA1C,CAAA;AACAgnC,eAAY9gB,CAAAA,KAAZ,GAAoB,CAAE,GAAGghB,SAAL,EAAgB,GAAGF,SAAY9gB,CAAAA,KAA/B,CAApB;AAHa;AAKjB,WAAO8gB,SAAP;AAd2D;AAiB/DG,UAASA,gBAAe,CAAChmB,kBAAA,GAAqB,CAAA,CAAtB,CAA6B;AAsBjD,WArBkB,CAAC0hB,SAAD,EAAY7iC,KAAZ,EAAmBuhB,GAAnB,EAAwB,CAAE5H,YAAF,CAAxB,EAA0CkrB,QAA1C,CAAAL,IAAuD;AAI/DwC,kBAAAA,GAAc,CAHGL,cAAA,CAAe9D,SAAf,CAAAuE,GACjBN,WADiBM,GAEjBpB,YACc,EAAehmC,KAAf,EAAsB2Z,YAAtB,EAAoCkrB,QAApC,EAA8ChC,SAA9C,CAAdmE;AACA5lB,cAAAA,GAAgBH,WAAA,CAAYjhB,KAAZ,EAAwC,QAAxC,KAAmB,MAAO6iC,UAA1B,EAAkD1hB,kBAAlD,CAAhBC;AACAimB,SAAAA,GAAexE,SAAA,KAAcrhB,KAAM8lB,CAAAA,QAApB,GACf,CAAE,GAAGlmB,QAAL,EAAoB,GAAG4lB,YAAvB,EAAoCzlB,GAApC,CADe,GAEf,EAFA8lB;AAQN,YAAM,CAAE5X,QAAF,CAAA,GAAezvB,KAArB;AACMunC,WAAAA,GAAmB/lB,KAAM+gB,CAAAA,OAAN,CAAc,EAAA,IAAqB9S,QAAd,IAAcA,QA17QZ3vB,CAAAA,WA07QF,GAA0B2vB,QAAS5vB,CAAAA,GAAT,EAA1B,GAA2C4vB,QAAhE,EAA2E,CAACA,QAAD,CAA3E,CAAnB8X;AACN,aAAO/lB,KAAMgmB,CAAAA,aAAN,CAAoB3E,SAApB,EAA+B,CAClC,GAAGwE,GAD+B,EAElC5X,SAAU8X,KAFwB,CAA/B,CAAP;AAhBqE,KAqBzE;AAtBiD;AA8ErDE,UAASA,6BAA4B,CAAClD,iBAAD,EAAoBzB,mBAApB,CAAyC;AAC1E,WAAO4E,QAA8B,CAAC7E,SAAD,EAAY,CAAE1hB,kBAAF,CAAA,GAAyB,CAAEA,mBAAoB,CAAA,CAAtB,CAArC,CAAoE;AAI/Fua,eAAAA,GAAS,CACX,IAJeiL,cAAA,CAAe9D,SAAf,CAAA8E,GACbC,eADaD,GAEbE,gBAEF,CADW,EAEXtD,iBAFW,EAGXC,UAAW2C,eAAA,CAAgBhmB,kBAAhB,CAHA,EAIX2hB,mBAJW,EAKXD,SALW,CAATnH;AAON,aAAO4I,6BAAA,CAA8B5I,SAA9B,CAAP;AAXqG,KAAzG;AAD0E;AAlsS9E,MAAI7nB,YAAY7U,OAAA,CAAQ,+CAAR,CAAhB,EACI2H,cAAc3H,OAAA,CAAQ,iDAAR,CADlB,EAEIyhC,aAAazhC,OAAA,CAAQ,uCAAR,CAFjB,EAGIwiB,QAAQxiB,OAAA,CAAQ,iCAAR,CAHZ;AAKA,QAAMwhC,qBAAqBhf,KAAMsmB,CAAAA,aAAN,CAAoB,EAApB,CAA3B,EAgDMtkC,qBAAqB,CACvBukC,eAAgB,CAAA,CADO,EAEvBtkC,gBAAiB,CAAA,CAFM,CAhD3B,EAqDMX,aAAa,0DAAA,CAAA,KAAA,CAAA,GAAA,CArDnB,EA8DMV,cAAc,CAChBzC,MAAO,IADS,EAEhBqoC,qBAAsB,IAFN,CA9DpB,EA4NM,CAAE,SAAU7tB,KAAZ,EAAmB,OAAQyS,WAA3B,EAAwC,MAAOzqB,SAA/C,EAA0D,MAAOizB,UAAjE,CAAA,GAAiF5yB,mBAAA,CAAqD,WAAjC,KAAA,MAAOylC,sBAAP,GAA+CA,qBAA/C,GAAuEthC,WAAYC,CAAAA,IAAvG,EAA6G,CAAA,CAA7G,CA5NvF,EAiOM+e,qBAAqB,iIAAA,CAAA,KAAA,CAAA,GAAA,CAjO3B;AAuPMY,mBAAiB,IAAIllB,GAAJ,CAAQskB,kBAAR,CAvPvB,EAyPMrL,iBAAiB,IAAIjZ,GAAJ,CAAQ,CAC3B,OAD2B,EAE3B,QAF2B,EAG3B,KAH2B,EAI3B,MAJ2B,EAK3B,OAL2B,EAM3B,QAN2B,EAO3B,GAAGskB,kBAPwB,CAAR,CAzPvB;AA+QA,MAAIhiB,GAAJ;AAYA,QAAM+oB,OAAO,CACT/oB,IAAK,EAAAA,IAAM;AACKtD,QAAAA,EAAZ,KAAIsD,GAAJ,IACI+oB,IAAK1mB,CAAAA,GAAL,CAAS7D,SAAUZ,CAAAA,YAAV,IAA0BiC,kBAAmBC,CAAAA,eAA7C,GACHtB,SAAUR,CAAAA,SADP,GAEH+B,WAAYC,CAAAA,GAAZ,EAFN,CADJ;AAKA,WAAOA,GAAP;AANO,GADF,EASTqC,IAAMkiC,OAADliC,IAAa;AACdrC,OAAA,GAAMukC,OAAN;AACAjE,kBAAA,CAAe//B,SAAf,CAAA;AAFc,GATT,CAAb;AAmCA,OAAM2tB,oBAAN;AACItC,eAAW,EAAG;AACV,UAAK4Y,CAAAA,aAAL,GAAqB,EAArB;AADU;AAGdpmC,OAAG,CAACkhB,OAAD,CAAU;AACT9e,mBAAA,CAAc,IAAKgkC,CAAAA,aAAnB,EAAkCllB,OAAlC,CAAA;AACA,aAAO,EAAA,IAAM1e,UAAA,CAAW,IAAK4jC,CAAAA,aAAhB,EAA+BllB,OAA/B,CAAb;AAFS;AAIbtH,UAAM,CAAC7N,CAAD,EAAIC,CAAJ,EAAO2C,CAAP,CAAU;AACZ,YAAM03B,mBAAmB,IAAKD,CAAAA,aAAclkC,CAAAA,MAA5C;AACA,UAAKmkC,gBAAL;AAEA,YAAyB,CAAzB,KAAIA,gBAAJ;AAII,cAAKD,CAAAA,aAAL,CAAmB,CAAnB,CAAA,CAAsBr6B,CAAtB,EAAyBC,CAAzB,EAA4B2C,CAA5B,CAAA;AAJJ;AAOI,eAAK,IAAI1M,IAAI,CAAb,EAAgBA,CAAhB,GAAoBokC,gBAApB,EAAsCpkC,CAAA,EAAtC,CAA2C;AAKvC,kBAAMif,UAAU,IAAKklB,CAAAA,aAAL,CAAmBnkC,CAAnB,CAAhB;AACAif,mBAAA,IAAWA,OAAA,CAAQnV,CAAR,EAAWC,CAAX,EAAc2C,CAAd,CAAX;AANuC;AAP/C;AAFA;AAFY;AAqBhB23B,WAAO,EAAG;AACN,aAAO,IAAKF,CAAAA,aAAclkC,CAAAA,MAA1B;AADM;AAGV1B,SAAK,EAAG;AACJ,UAAK4lC,CAAAA,aAAclkC,CAAAA,MAAnB,GAA4B,CAA5B;AADI;AAhCZ;AA+CA,QAAMe,SAAS,IAAI3D,GAAJ,EAAf,EAkBMinC,sBAAsB,CACxBnoC,QAASE,IAAAA,EADe,CAlB5B;AA0BA,OAAMiF,YAAN;AASIiqB,eAAW,CAACnqB,IAAD,EAAOC,OAAA,GAAU,EAAjB,CAAqB;AAK5B,UAAKkjC,CAAAA,OAAL,GAAe,QAAf;AAQA,UAAKC,CAAAA,gBAAL,GAAwB,IAAxB;AAIA,UAAKC,CAAAA,MAAL,GAAc,EAAd;AACA,UAAKC,CAAAA,eAAL,GAAuB,CAACtpC,CAAD,EAAIiE,MAAA,GAAS,CAAA,CAAb,CAAAslC,IAAsB;AACzC,cAAMC,cAAclc,IAAK/oB,CAAAA,GAAL,EAApB;AAMI,YAAKklC,CAAAA,SAAT,KAAuBD,WAAvB,IACI,IAAKE,CAAAA,iBAAL,EADJ;AAGA,YAAK9sB,CAAAA,IAAL,GAAY,IAAK7b,CAAAA,OAAjB;AACA,YAAK4oC,CAAAA,UAAL,CAAgB3pC,CAAhB,CAAA;AAEI,YAAKe,CAAAA,OAAT,KAAqB,IAAK6b,CAAAA,IAA1B,IAAkC,IAAKysB,CAAAA,MAAOO,CAAAA,MAA9C,IACI,IAAKP,CAAAA,MAAOO,CAAAA,MAAOrtB,CAAAA,MAAnB,CAA0B,IAAKxb,CAAAA,OAA/B,CADJ;AAIIkD,cAAJ,IAAc,IAAKolC,CAAAA,MAAOQ,CAAAA,aAA1B,IACI,IAAKR,CAAAA,MAAOQ,CAAAA,aAActtB,CAAAA,MAA1B,CAAiC,IAAKxb,CAAAA,OAAtC,CADJ;AAjByC,OAA7C;AAqBA,UAAK+oC,CAAAA,WAAL,GAAmB,CAAA,CAAnB;AACA,UAAKH,CAAAA,UAAL,CAAgB3jC,IAAhB,CAAA;AACA,UAAK+jC,CAAAA,KAAL,GAAa9jC,OAAQ8jC,CAAAA,KAArB;AAzC4B;AA2ChCJ,cAAU,CAAC5oC,OAAD,CAAU;AAChB,UAAKA,CAAAA,OAAL,GAAeA,OAAf;AACA,UAAK0oC,CAAAA,SAAL,GAAiBnc,IAAK/oB,CAAAA,GAAL,EAAjB;AAC8B,UAA9B,KAAI,IAAK6kC,CAAAA,gBAAT,IAAkDnoC,IAAAA,EAAlD,KAAsCF,OAAtC,KACI,IAAKqoC,CAAAA,gBADT,GAjEG,CAACr3B,KAAA,CAAMvI,UAAA,CAkE0B,IAAKzI,CAAAA,OAlE/B,CAAN,CAiEJ;AAHgB;AAOpB2oC,qBAAiB,CAACM,cAAA,GAAiB,IAAKjpC,CAAAA,OAAvB,CAAgC;AAC7C,UAAKipC,CAAAA,cAAL,GAAsBA,cAAtB;AACA,UAAKC,CAAAA,aAAL,GAAqB,IAAKR,CAAAA,SAA1B;AAF6C;AA4CjDS,YAAQ,CAACC,YAAD,CAAe;AAEf3kC,cAAA,CAAS,CAAA,CAAT,EAAiB,iFAAjB,CAAA;AAEJ,aAAO,IAAK4kC,CAAAA,EAAL,CAAQ,QAAR,EAAkBD,YAAlB,CAAP;AAJmB;AAMvBC,MAAE,CAACxmB,SAAD,EAAYniB,QAAZ,CAAsB;AACf,UAAK4nC,CAAAA,MAAL,CAAYzlB,SAAZ,CAAL,KACI,IAAKylB,CAAAA,MAAL,CAAYzlB,SAAZ,CADJ,GAC6B,IAAI6O,mBAAJ,EAD7B;AAGA,YAAM4X,cAAc,IAAKhB,CAAAA,MAAL,CAAYzlB,SAAZ,CAAuBjhB,CAAAA,GAAvB,CAA2BlB,QAA3B,CAApB;AACA,aAAkB,QAAlB,KAAImiB,SAAJ,GACW,EAAA,IAAM;AACTymB,mBAAA,EAAA;AAKAtvB,aAAMlX,CAAAA,IAAN,CAAW,EAAA,IAAM;AACR,cAAKwlC,CAAAA,MAAOO,CAAAA,MAAOX,CAAAA,OAAnB,EAAL,IACI,IAAKvN,CAAAA,IAAL,EADJ;AADa,SAAjB,CAAA;AANS,OADjB,GAcO2O,WAdP;AALoB;AAqBxBC,kBAAc,EAAG;AACb,WAAK,MAAMC,aAAX,GAA4B,KAAKlB,CAAAA,MAAjC;AACI,YAAKA,CAAAA,MAAL,CAAYkB,aAAZ,CAA2BpnC,CAAAA,KAA3B,EAAA;AADJ;AADa;AAUjBqnC,UAAM,CAACC,aAAD,EAAgBC,iBAAhB,CAAmC;AACrC,UAAKD,CAAAA,aAAL,GAAqBA,aAArB;AACA,UAAKC,CAAAA,iBAAL,GAAyBA,iBAAzB;AAFqC;AAmBzC9jC,OAAG,CAAC5G,CAAD,EAAIiE,MAAA,GAAS,CAAA,CAAb,CAAmB;AACbA,YAAL,IAAgB,IAAKwmC,CAAAA,aAArB,GAII,IAAKA,CAAAA,aAAL,CAAmBzqC,CAAnB,EAAsB,IAAKspC,CAAAA,eAA3B,CAJJ,GACI,IAAKA,CAAAA,eAAL,CAAqBtpC,CAArB,EAAwBiE,MAAxB,CADJ;AADkB;AAQtB0mC,mBAAe,CAAC/tB,IAAD,EAAO7b,OAAP,EAAgBuB,KAAhB,CAAuB;AAClC,UAAKsE,CAAAA,GAAL,CAAS7F,OAAT,CAAA;AACA,UAAK6b,CAAAA,IAAL,GAAY3b,IAAAA,EAAZ;AACA,UAAK+oC,CAAAA,cAAL,GAAsBptB,IAAtB;AACA,UAAKqtB,CAAAA,aAAL,GAAqB,IAAKR,CAAAA,SAA1B,GAAsCnnC,KAAtC;AAJkC;AAUtCsoC,QAAI,CAAC5qC,CAAD,EAAI6qC,YAAA,GAAe,CAAA,CAAnB,CAAyB;AACzB,UAAKvB,CAAAA,eAAL,CAAqBtpC,CAArB,CAAA;AACA,UAAK4c,CAAAA,IAAL,GAAY5c,CAAZ;AACA,UAAKiqC,CAAAA,aAAL,GAAqB,IAAKD,CAAAA,cAA1B,GAA2C/oC,IAAAA,EAA3C;AACA4pC,kBAAA,IAAgB,IAAKnP,CAAAA,IAAL,EAAhB;AACI,UAAKgP,CAAAA,iBAAT,IACI,IAAKA,CAAAA,iBAAL,EADJ;AALyB;AAe7BjqC,OAAG,EAAG;AACEyoC,yBAAoBnoC,CAAAA,OAAxB,IACImoC,mBAAoBnoC,CAAAA,OAAQmC,CAAAA,IAA5B,CAAiC,IAAjC,CADJ;AAGA,aAAO,IAAKnC,CAAAA,OAAZ;AAJE;AASN+pC,eAAW,EAAG;AACV,aAAO,IAAKluB,CAAAA,IAAZ;AADU;AAUdlc,eAAW,EAAG;AACV,UAAM8oC,cAAclc,IAAK/oB,CAAAA,GAAL,EAApB;AACA,UAAI,CAAC,IAAK6kC,CAAAA,gBAAV,IAC4BnoC,IAAAA,EAD5B,KACI,IAAK+oC,CAAAA,cADT,IAjOmBe,EAiOnB,GAEIvB,WAFJ,GAEkB,IAAKC,CAAAA,SAFvB;AAGI,eAAO,CAAP;AAHJ;AAKMnnC,iBAAAA,GAAQkC,IAAKE,CAAAA,GAAL,CAAS,IAAK+kC,CAAAA,SAAd,GAA0B,IAAKQ,CAAAA,aAA/B,EAtOKc,EAsOL,CAARzoC;AAEN,aAAOgD,iBAAA,CAAkBkE,UAAA,CAAW,IAAKzI,CAAAA,OAAhB,CAAlB,GACHyI,UAAA,CAAW,IAAKwgC,CAAAA,cAAhB,CADG,EAC8B1nC,WAD9B,CAAP;AATU;AAwBdrC,SAAK,CAACu0B,cAAD,CAAiB;AAClB,UAAKkH,CAAAA,IAAL,EAAA;AACA,aAMGrgB,CANI,IAAIF,OAAJ,CAAaO,OAAD,IAAa;AAC5B,YAAKouB,CAAAA,WAAL,GAAmB,CAAA,CAAnB;AACA,YAAK1xB,CAAAA,SAAL,GAAiBoc,cAAA,CAAe9Y,OAAf,CAAjB;AACI,YAAK2tB,CAAAA,MAAO2B,CAAAA,cAAhB,IACI,IAAK3B,CAAAA,MAAO2B,CAAAA,cAAezuB,CAAAA,MAA3B,EADJ;AAH4B,OAAzB,CAMJlB,EAAAA,IANI,CAMC,EAAA,IAAM;AACN,YAAKguB,CAAAA,MAAO4B,CAAAA,iBAAhB,IACI,IAAK5B,CAAAA,MAAO4B,CAAAA,iBAAkB1uB,CAAAA,MAA9B,EADJ;AAGA,YAAK2uB,CAAAA,cAAL,EAAA;AAJU,OANP,CAAP;AAFkB;AAoBtBxP,QAAI,EAAG;AACC,UAAKtjB,CAAAA,SAAT,KACI,IAAKA,CAAAA,SAAUsjB,CAAAA,IAAf,EACA,EAAI,IAAK2N,CAAAA,MAAO8B,CAAAA,eAAhB,IACI,IAAK9B,CAAAA,MAAO8B,CAAAA,eAAgB5uB,CAAAA,MAA5B,EAHR;AAMA,UAAK2uB,CAAAA,cAAL,EAAA;AAPG;AAcPE,eAAW,EAAG;AACV,aAAO,CAAC,CAAC,IAAKhzB,CAAAA,SAAd;AADU;AAGd8yB,kBAAc,EAAG;AACb,aAAO,IAAK9yB,CAAAA,SAAZ;AADa;AAYjBizB,WAAO,EAAG;AACN,UAAKf,CAAAA,cAAL,EAAA;AACA,UAAK5O,CAAAA,IAAL,EAAA;AACI,UAAKgP,CAAAA,iBAAT,IACI,IAAKA,CAAAA,iBAAL,EADJ;AAHM;AA5Rd;AA8TA,QAAMvgB,gBAAiB5pB,KAAD4pB,IAAW,EAAQ5pB,CAAAA,KAAR,IAAuBG,CAANH,KAAMG,CAAAA,WAAvB,CAAjC,EAoBM+oB,cAAe6hB,GAAD7hB,IAAS6hB,GAAIziC,CAAAA,OAAJ,CAAY,kBAAZ,EAAgC,OAAhC,CAAyC0iC,CAAAA,WAAzC,EApB7B,EAuBMtkC,+BAA+B,OAA/BA,GAAyCwiB,WAAA,CADjB+hB,gBACiB,CAvB/C,EA6BMC,wBAAwB,CAC1B1qC,QAAS,CAAA,CADiB,CA7B9B,EAmFM2qC,eAAgB92B,MAAD82B,IAAa39B,CAAD,IAAY,GAAL,IAAAA,CAAA,GAAW6G,MAAA,CAAO,CAAP,GAAW7G,CAAX,CAAX,GAA2B,CAA3B,IAAgC,CAAhC,GAAoC6G,MAAA,CAAO,CAAP,IAAY,CAAZ,GAAgB7G,CAAhB,EAApC,IAA2D,CAnFnG,EAuFM49B,gBAAiB/2B,MAAD+2B,IAAa59B,CAAD,IAAO,CAAP,GAAW6G,MAAA,CAAO,CAAP,GAAW7G,CAAX,CAvF7C,EAyFM69B,UAAwB1kC,WAAA,CAAY,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,EAA8B,IAA9B,CAzF9B,EA0FM2kC,SAAuBF,aAAA,CAAcC,OAAd,CA1F7B,EA2FME,YAA0BJ,YAAA,CAAaG,MAAb,CA3FhC;AA6FME,eAAch+B,CAADg+B,IAAkB,CAAX,IAACh+B,CAAD,IAAM,CAAN,IAAe,GAAf,GAAqB89B,MAAA,CAAO99B,CAAP,CAArB,GAAiC,GAAjC,IAAwC,CAAxC,GAA4CvJ,IAAKkN,CAAAA,GAAL,CAAS,CAAT,EAAY,CAAC,EAAb,IAAmB3D,CAAnB,GAAuB,CAAvB,EAA5C,CA7F1B,EA+FMi+B,SAAUj+B,CAADi+B,IAAO,CAAPA,GAAWxnC,IAAKsP,CAAAA,GAAL,CAAStP,IAAKynC,CAAAA,IAAL,CAAUl+B,CAAV,CAAT,CA/F1B,EAgGMm+B,UAAUP,aAAA,CAAcK,MAAd,CAhGhB,EAiGMG,YAAYT,YAAA,CAAaM,MAAb,CAjGlB,EAoHMp7B,QAAQ,CAAClM,GAAD,EAAMD,GAAN,EAAWzE,CAAX,CAAA4Q,IACN5Q,CAAJ,GAAQyE,GAAR,GACWA,GADX,GAEIzE,CAAJ,GAAQ0E,GAAR,GACWA,GADX,GAEO1E,CAzHX,EA4HMuI,SAAS,CACXU,KAAOjJ,CAADiJ,IAAoB,QAApBA,KAAO,MAAOjJ,EADT,EAEXmJ,MAAOK,UAFI,EAGXS,UAAYjK,CAADiK,IAAOjK,CAHP,CA5Hf,EAiIMqO,QAAQ,CACV,GAAG9F,MADO,EAEV0B,UAAYjK,CAADiK,IAAgBxF,CAd3B,GAc8BzE,CAd9B,GAc2ByE,CAd3B,GAcwBC,CAZxB,GAY8B1E,CAZ9B,GAYwB0E,CAZxB,GAY8B1E,CAFpB,CAjId,EAqIM4gB,QAAQ,CACV,GAAGrY,MADO,EAEVoL,QAAS,CAFC,CArId,EA8IMrJ,aAAa,6BA9InB,EAoJM8hC,mBAAmB,qHApJzB;AA0JMC,kBAAgB,CAACtiC,IAAD,EAAOuiC,QAAP,CAAAD,IAAqBrsC,CAAD,IAC/B,CAAA,EAAsB,QAAtB,KAAS,MAAOA,EAAhB,IACHosC,gBAAiBnjC,CAAAA,IAAjB,CAAsBjJ,CAAtB,CADG,IAEHA,CAAEoJ,CAAAA,UAAF,CAAaW,IAAb,CAFG,IAGFuiC,QAHE,IAVK,IAUL,IAIYtsC,CAJZ,IAKCyZ,MAAO4lB,CAAAA,SAAUvlB,CAAAA,cAAewlB,CAAAA,IAAhC,CAAqCt/B,CAArC,EAAwCssC,QAAxC,CALD,CA3JX,EAkKMC,aAAa,CAACC,KAAD,EAAQC,KAAR,EAAeC,KAAf,CAAAH,IAA0BvsC,CAAD,IAAO;AAC/C,QAAiB,QAAjB,KAAI,MAAOA,EAAX;AACI,aAAOA,CAAP;AADJ;AAEA,UAAM,CAAC0O,CAAD,EAAIC,CAAJ,EAAO2C,CAAP,EAAUjD,KAAV,CAAA,GAAmBrO,CAAEqK,CAAAA,KAAF,CAAQC,UAAR,CAAzB;AACA,WAAO,CACH,CAACkiC,KAAD,EAAShjC,UAAA,CAAWkF,CAAX,CADN,EAEH,CAAC+9B,KAAD,EAASjjC,UAAA,CAAWmF,CAAX,CAFN,EAGH,CAAC+9B,KAAD,EAASljC,UAAA,CAAW8H,CAAX,CAHN,EAIHjD,MAAiBpN,IAAAA,EAAV,KAAAoN,KAAA,GAAsB7E,UAAA,CAAW6E,KAAX,CAAtB,GAA0C,CAJ9C,CAAP;AAJ+C,GAlKnD,EA+KMs+B,UAAU,CACZ,GAAGpkC,MADS,EAEZ0B,UAAYjK,CAADiK,IAAOzF,IAAKwF,CAAAA,KAAL,CAHevF,GAzDjC,GA4D0CzE,CA5D1C,GAyDiCyE,GAzDjC,GAyD8BC,CAvD9B,GA0D0C1E,CA1D1C,GAuD8B0E,CAvD9B,GA0D0C1E,CAAxB,CAFN,CA/KhB,EAmLM4sC,OAAO,CACT3jC,KAAoBojC,aAAA,CAAc,KAAd,EAAqB,KAArB,CADX,EAETljC,MAAqBojC,UAAA,CAAW,KAAX,EAAkB,OAAlB,EAA2B,MAA3B,CAFZ,EAGTtiC,UAAW,CAAC,CAAEqE,GAAF,EAAOC,KAAP,EAAcC,IAAd,EAAoB,MAAOq+B,OAAA,GAAU,CAArC,CAAD,CAAA5iC,IAA8C,OAA9CA,GACP0iC,OAAQ1iC,CAAAA,SAAR,CAAkBqE,GAAlB,CADOrE,GAEP,IAFOA,GAGP0iC,OAAQ1iC,CAAAA,SAAR,CAAkBsE,KAAlB,CAHOtE,GAIP,IAJOA,GAKP0iC,OAAQ1iC,CAAAA,SAAR,CAAkBuE,IAAlB,CALOvE,GAMP,IANOA,GA1CSzF,IAAKwF,CAAAA,KAAL,CAAe,MAAf,GAiDPqE,KAAMpE,CAAAA,SAANjK,CAAgB6sC,OAAhB7sC,CAjDO,CA0CTiK,GA1CkC,MA0ClCA,GAQP,GAXK,CAnLb,EA+NM6iC,MAAM,CACR7jC,KAAoBojC,aAAA,CAAc,GAAd,CADZ,EAERljC,MAhCJ4jC,QAAiB,CAAC/sC,CAAD,CAAI;AACjB,QAAIgtC,CAAJ,EACIp7B,CADJ,EAEIjD,CAFJ;AAKe,KAAf,GAAI3O,CAAE6E,CAAAA,MAAN,IACImoC,CAGA,GAHIhtC,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAGJ,EAFA3Y,CAEA,GAFI5R,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAEJ,EADA5b,CACA,GADI3O,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CACJ,EAAA7b,CAAA,GAAI1O,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAJR,KAQIyiB,CAOA,GAPIhtC,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAOJ,EANA3Y,CAMA,GANI5R,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAMJ,EALA5b,CAKA,GALI3O,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAKJ,EAJA7b,CAIA,GAJI1O,CAAEuqB,CAAAA,SAAF,CAAY,CAAZ,EAAe,CAAf,CAIJ,EAHAyiB,CAGA,IAHKA,CAGL,EAFAp7B,CAEA,IAFKA,CAEL,EADAjD,CACA,IADKA,CACL,EAAAD,CAAA,IAAKA,CAfT,CAAA;AAiBA,WAAO,CACHJ,IAAK2+B,QAAA,CAASD,CAAT,EAAY,EAAZ,CADF,EAEHz+B,MAAO0+B,QAAA,CAASr7B,CAAT,EAAY,EAAZ,CAFJ,EAGHpD,KAAMy+B,QAAA,CAASt+B,CAAT,EAAY,EAAZ,CAHH,EAIHN,MAAOK,CAAA,GAAIu+B,QAAA,CAASv+B,CAAT,EAAY,EAAZ,CAAJ,GAAsB,GAAtB,GAA4B,CAJhC,CAAP;AAvBiB,GA8BT,EAGRzE,UAAW2iC,IAAK3iC,CAAAA,SAHR,CA/NZ,EAqOMijC,iBAAkB3iC,IAAD2iC,IAAW,EAC9BjkC,KAAOjJ,CAADiJ,IAAoB,QAApBA,KAAO,MAAOjJ,EAAdiJ,IAAgCjJ,CAAEmtC,CAAAA,QAAF,CAAW5iC,IAAX,CAAhCtB,IAA4E,CAA5EA,KAAoDjJ,CAAE0I,CAAAA,KAAF,CAAQ,GAAR,CAAa7D,CAAAA,MADzC,EAE9BsE,MAAOK,UAFuB,EAG9BS,UAAYjK,CAADiK,IAAQ,GAAEjK,CAAF,GAAMuK,IAAN,EAHW,EArOlC,EA0OM6iC,UAAwBF,cAAA,CAAe,KAAf,CA1O9B,EA2OM7e,UAAwB6e,cAAA,CAAe,GAAf,CA3O9B,EA4OMrlB,KAAmBqlB,cAAA,CAAe,IAAf,CA5OzB,EA6OMG,KAAmBH,cAAA,CAAe,IAAf,CA7OzB,EA8OMI,KAAmBJ,cAAA,CAAe,IAAf,CA9OzB,EA+OMK,qBAAqB,CACvB,GAAGlf,OADoB,EAEvBllB,MAAQnJ,CAADmJ,IAAOklB,OAAQllB,CAAAA,KAAR,CAAcnJ,CAAd,CAAPmJ,GAA0B,GAFV,EAGvBc,UAAYjK,CAADiK,IAAOokB,OAAQpkB,CAAAA,SAAR,CAAsB,GAAtB,GAAkBjK,CAAlB,CAHK,CA/O3B,EAqPMgP,OAAO,CACT/F,KAAoBojC,aAAA,CAAc,KAAd,EAAqB,KAArB,CADX,EAETljC,MAAqBojC,UAAA,CAAW,KAAX;AAAkB,cAAlB,EAAgC,WAAhC,CAFZ,EAGTtiC,UAAW,CAAC,CAAEiE,GAAF,EAAOC,UAAP,EAAmBC,SAAnB,EAA8B,MAAOy+B,OAAA,GAAU,CAA/C,CAAD,CAAA5iC,IACC,OADDA,GAEHzF,IAAKwF,CAAAA,KAAL,CAAWkE,GAAX,CAFGjE,GAGH,IAHGA,GAIHokB,OAAQpkB,CAAAA,SAAR,CAhHYzF,IAAKwF,CAAAA,KAAL,CAAe,MAAf,GAgHemE,UAhHf,CAgHZ,GAhHqC,MAgHrC,CAJGlE,GAKH,IALGA,GAMHokB,OAAQpkB,CAAAA,SAAR,CAlHYzF,IAAKwF,CAAAA,KAAL,CAAe,MAAf,GAkHeoE,SAlHf,CAkHZ,GAlHqC,MAkHrC,CANGnE,GAOH,IAPGA,GA5GSzF,IAAKwF,CAAAA,KAAL,CAAe,MAAf,GAoHHqE,KAAMpE,CAAAA,SAANjK,CAAgB6sC,OAAhB7sC,CApHG,CA4GTiK,GA5GkC,MA4GlCA,GASH,GAZC,CArPb,EAqQM3B,QAAQ,CACVW,KAAOjJ,CAADiJ,IAAO2jC,IAAK3jC,CAAAA,IAAL,CAAUjJ,CAAV,CAAPiJ,IAAuB6jC,GAAI7jC,CAAAA,IAAJ,CAASjJ,CAAT,CAAvBiJ,IAAsC+F,IAAK/F,CAAAA,IAAL,CAAUjJ,CAAV,CADlC,EAEVmJ,MAAQnJ,CAADmJ,IACCyjC,IAAK3jC,CAAAA,IAAL,CAAUjJ,CAAV,CAAJ,GACW4sC,IAAKzjC,CAAAA,KAAL,CAAWnJ,CAAX,CADX,GAGSgP,IAAK/F,CAAAA,IAAL,CAAUjJ,CAAV,CAAJ,GACMgP,IAAK7F,CAAAA,KAAL,CAAWnJ,CAAX,CADN,GAIM8sC,GAAI3jC,CAAAA,KAAJ,CAAUnJ,CAAV,CAVL,EAaViK,UAAYjK,CAADiK,IACa,QAAb;AAAA,QAAOjK,EAAP,GACDA,CADC,GAEDA,CAAE8Z,CAAAA,cAAF,CAAiB,KAAjB,CAAA,GACI8yB,IAAK3iC,CAAAA,SAAL,CAAejK,CAAf,CADJ,GAEIgP,IAAK/E,CAAAA,SAAL,CAAejK,CAAf,CAlBJ,CArQd,EA2RMwtC,aAAa,oHA3RnB,EA2SMzkC,eAAe,iOA3SrB,EAsWM0kC,uBAAwBztC,CAADytC,IAAoB,QAAb,KAAA,MAAOztC,EAAP;AAAwB,GAAxB,GAA4BA,CAtWhE,EA4WM8K,UAAU,CACZ7B,KAhFJA,QAAa,CAACjJ,CAAD,CAAI;AAAA,QACT+L,EADS,EACLmxB,EADK;AAEb,WAAQnrB,KAAA,CAAM/R,CAAN,CAAR,IACiB,QADjB,KACI,MAAOA,EADX,IAIQ,CAJR,KAEqC,IAA/B,MAAC+L,EAAD,GAAM/L,CAAEqK,CAAAA,KAAF,CAAQC,UAAR,CAAN,KAA8C,IAAK,EAAnD,KAAuCyB,EAAvC,GAAuD,IAAK,EAA5D,GAAgEA,EAAGlH,CAAAA,MAFzE,KAEoF,CAFpF,MAGyC,IAA/B,MAACq4B,EAAD,GAAMl9B,CAAEqK,CAAAA,KAAF,CAAQmjC,UAAR,CAAN,KAA8C,IAAK,EAAnD,KAAuCtQ,EAAvC,GAAuD,IAAK,EAA5D,GAAgEA,EAAGr4B,CAAAA,MAH7E,KAGwF,CAHxF;AAFa,GA+ED,EAEZsE,MAAOO,iBAFK,EAGZC,iBAHY,EAIZe,kBATJgjC,QAA4B,CAAC1tC,CAAD,CAAI;AAC5B,UAAM2tC,SAASjkC,iBAAA,CAAkB1J,CAAlB,CAAf;AAEA,WADoB2J,iBAAAikC,CAAkB5tC,CAAlB4tC,CACb,CAAYD,MAAOjiC,CAAAA,GAAP,CAAW+hC,oBAAX,CAAZ,CAAP;AAH4B,GAKhB,CA5WhB,EAsXMhjC,cAAc,IAAIxI,GAAJ,CAAQ,CAAC,YAAD,EAAe,UAAf,EAA2B,UAA3B,EAAuC,SAAvC,CAAR,CAtXpB,EAoYM4rC,gBAAgB,sBApYtB,EAqYMhjC,SAAS,CACX,GAAGC,OADQ,EAEXJ,kBAAoB1K,CAAD0K,IAAO;AACtB,UAAMojC,YAAY9tC,CAAEqK,CAAAA,KAAF,CAAQwjC,aAAR,CAAlB;AACA,WAAOC,SAAA,GAAYA,SAAUpiC,CAAAA,GAAV,CAAcxB,kBAAd,CAAkCk5B,CAAAA,IAAlC,CAAuC,GAAvC,CAAZ,GAA0DpjC,CAAjE;AAFsB,GAFf,CArYf,EA6YM+tC,0BAA0B,CAE5BC,YAAanmB,EAFe,EAG5BomB,eAAgBpmB,EAHY,EAI5BqmB,iBAAkBrmB,EAJU,EAK5BsmB,kBAAmBtmB,EALS,EAM5BumB,gBAAiBvmB,EANW,EAO5ByT,aAAczT,EAPc,EAQ5BwmB,OAAQxmB,EARoB,EAS5BymB,oBAAqBzmB,EATO,EAU5B0mB,qBAAsB1mB,EAVM,EAW5B2mB,wBAAyB3mB,EAXG,EAY5B4mB,uBAAwB5mB,EAZI,EAc5BW,MAAOX,EAdqB,EAe5B6mB,SAAU7mB,EAfkB,EAgB5Ba,OAAQb,EAhBoB,EAiB5B8mB,UAAW9mB,EAjBiB,EAkB5B4C,IAAK5C,EAlBuB,EAmB5B8C,MAAO9C,EAnBqB,EAoB5B+C,OAAQ/C,EApBoB,EAqB5B6C,KAAM7C,EArBsB,EAuB5B+mB,QAAS/mB,EAvBmB,EAwB5BgnB,WAAYhnB,EAxBgB,EAyB5BinB,aAAcjnB,EAzBc,EA0B5BknB,cAAelnB,EA1Ba,EA2B5BmnB,YAAannB,EA3Be,EA4B5BonB,OAAQpnB,EA5BoB,EA6B5BqnB,UAAWrnB,EA7BiB,EA8B5BsnB,YAAatnB,EA9Be,EA+B5BunB,aAAcvnB,EA/Bc,EAgC5BwnB,WAAYxnB,EAhCgB,EAkC5BynB,oBAAqBznB,EAlCO;AAmC5B0nB,sBAAqB1nB,EAnCO,CA7YhC,EA8cM2nB,MAAM,CACR,GAAGjnC,MADK,EAER0B,UAAWzF,IAAKwF,CAAAA,KAFR,CA9cZ,EAmdM2c,mBAAmB,CACrB,GAAGonB,uBADkB,EA/BrBxiB,OAAQ6hB,OA+Ba,EA9BrB5hB,QAAS4hB,OA8BY,EA7BrB3hB,QAAS2hB,OA6BY,EA5BrBrQ,QAASqQ,OA4BY,EA3BrBxsB,KA2BqB,EA1BrBuK,OAAQvK,KA0Ba,EAzBrBwK,OAAQxK,KAyBa,EAxBrB6uB,OAAQ7uB,KAwBa,EAvBrB8uB,KAAMtC,OAuBe,EAtBrB1hB,MAAO0hB,OAsBc,EArBrBzhB,MAAOyhB,OAqBc,EApBrBpgB,SAAUnF,EAoBW,EAnBrB8nB,WAAY9nB,EAmBS,EAlBrB+nB,WAAY/nB,EAkBS,EAjBrBgoB,WAAYhoB,EAiBS,EAhBrB/f,EAAG+f,EAgBkB,EAfrBzG,EAAGyG,EAekB,EAdrByD,EAAGzD,EAckB,EAbrBioB,YAAajoB,EAaQ,EAZrB+V,qBAAsB/V,EAYD,EAXrBiT,QAASzsB,KAWY,EAVrB8S,QAASosB,kBAUY,EATrBlsB,QAASksB,kBASY,EARrBlmB,QAASQ,EAQY,EAGrBkoB,OAAQP,GAHa,EAIrB3zB,KAAMgM,EAJe,EAMrBmoB,YAAa3hC,KANQ;AAOrB4hC,gBAAe5hC,KAPM,EAQrB6hC,WAAYV,GARS,CAndzB,EAieM5kC,oBAAoB,CACtB,GAAG+b,gBADmB,EAGtBre,KAHsB,EAItB6nC,gBAAiB7nC,KAJK,EAKtB8nC,aAAc9nC,KALQ,EAMtB+P,KAAM/P,KANgB,EAOtB+nC,OAAQ/nC,KAPc,EAStBgoC,YAAahoC,KATS,EAUtBioC,eAAgBjoC,KAVM,EAWtBkoC,iBAAkBloC,KAXI,EAYtBmoC,kBAAmBnoC,KAZG,EAatBooC,gBAAiBpoC,KAbK,EActBuC,MAdsB,EAetB8lC,aAAc9lC,MAfQ,CAje1B,EAugBM+lC,mBAAmB,IAAI3uC,GAAJ,CAAQ,CAAC,MAAD,EAAS,MAAT,EAAiB,GAAjB,CAAR,CAvgBzB,EA6hBM4uC,yBAAyB,CAACC,IAAD,EAAOC,IAAP,CAAAF,IAAgB,CAACG,KAAD,EAAQ,CAAE/mC,SAAF,CAAR,CAAA,IACzB,MAAlB,KAAIA,SAAJ,IAA6BA,SAA7B,GAGA,CADMgnC,KACN,GADiBhnC,SAAUI,CAAAA,KAAV,CAAgB,qBAAhB,CACjB;AALsCb,YAAA,CAMVynC,KAAAC,CAAS,CAATA,CAN4BxoC,CAAAA,KAAP,CAAa,IAAb,CAAA,CAMRqoC,IANQ,CAAX,CAKtC,GAKI,CADMG,SACN,GADejnC,SAAUI,CAAAA,KAAV,CAAgB,mBAAhB,CACf,IAVkCb,UAAA,CAWN0nC,SAAAA,CAAO,CAAPA,CAXwBxoC,CAAAA,KAAP,CAAa,IAAb,CAAA,CAWNooC,IAXM,CAAX,CAUlC,GAIW,CAZf,GACW,CA/hBf,EA8iBMK,gBAAgB,IAAIlvC,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CA9iBtB,EA+iBMgJ,gCAAgCsb,kBAAmB1b,CAAAA,MAAnB,CAA2BrK,GAAD,IAAS,CAAC2wC,aAAcxvC,CAAAA,GAAd,CAAkBnB,GAAlB,CAApC,CA/iBtC,EA2jBM4wC,mBAAmB,CAErB5oB,MAAO,CAAC,CAAE1gB,CAAF,CAAD,EAAQ,CAAEknC,WAAA,GAAc,GAAhB,EAAqBF,YAAA,GAAe,GAApC,CAAR,CAAAtmB,IAAsD1gB,CAAErD,CAAAA,GAAxD+jB,GAA8D1gB,CAAEpD,CAAAA,GAAhE8jB,GAAsEhf,UAAA,CAAWwlC,WAAX,CAAtExmB,GAAgGhf,UAAA,CAAWslC,YAAX,CAFlF,EAGrBpmB,OAAQ,CAAC,CAAEtH,CAAF,CAAD,EAAQ,CAAEytB,UAAA,GAAa,GAAf,EAAoBE,aAAA,GAAgB,GAApC,CAAR,CAAArmB,IAAsDtH,CAAE3c,CAAAA,GAAxDikB,GAA8DtH,CAAE1c,CAAAA,GAAhEgkB,GAAsElf,UAAA,CAAWqlC,UAAX,CAAtEnmB;AAA+Flf,YAAA,CAAWulC,aAAX,CAHlF,EAIrBtkB,IAAK,CAACumB,KAAD,EAAQ,CAAEvmB,GAAF,CAAR,CAAAA,IAAoBjhB,UAAA,CAAWihB,GAAX,CAJJ,EAKrBC,KAAM,CAACsmB,KAAD,EAAQ,CAAEtmB,IAAF,CAAR,CAAAA,IAAqBlhB,UAAA,CAAWkhB,IAAX,CALN,EAMrBE,OAAQ,CAAC,CAAExJ,CAAF,CAAD,EAAQ,CAAEqJ,GAAF,CAAR,CAAAG,IAAoBphB,UAAA,CAAWihB,GAAX,CAApBG,IAAuCxJ,CAAE3c,CAAAA,GAAzCmmB,GAA+CxJ,CAAE1c,CAAAA,GAAjDkmB,CANa,EAOrBD,MAAO,CAAC,CAAE7iB,CAAF,CAAD,EAAQ,CAAE4iB,IAAF,CAAR,CAAAC,IAAqBnhB,UAAA,CAAWkhB,IAAX,CAArBC,IAAyC7iB,CAAErD,CAAAA,GAA3CkmB,GAAiD7iB,CAAEpD,CAAAA,GAAnDimB,CAPc,EASrB7iB,EAAG+oC,sBAAA,CAAuB,CAAvB,EAA0B,EAA1B,CATkB,EAUrBzvB,EAAGyvB,sBAAA,CAAuB,CAAvB,EAA0B,EAA1B,CAVkB,CA3jBzB;AAwkBAO,kBAAiBzB,CAAAA,UAAjB,GAA8ByB,gBAAiBtpC,CAAAA,CAA/C;AACAspC,kBAAiBxB,CAAAA,UAAjB,GAA8BwB,gBAAiBhwB,CAAAA,CAA/C;AAEA,QAAM9V,YAAY,IAAIrJ,GAAJ,EAAlB;AACA,MAAImK,cAAc,CAAA,CAAlB,EACIjB,sBAAsB,CAAA,CAD1B;AAyDA,OAAMkmC,iBAAN;AACIlhB,eAAW,CAACmhB,mBAAD,EAAsB/c,UAAtB,EAAkCpqB,IAAlC,EAAwCpE,WAAxC,EAAqDJ,OAArD,EAA8D4rC,OAAA,GAAU,CAAA,CAAxE,CAA+E;AAqBtF,UAAKnlC,CAAAA,WAAL,GALA,IAAKZ,CAAAA,gBAKL,GAVA,IAAK+lC,CAAAA,OAUL,GAhBA,IAAKC,CAAAA,UAgBL,GAhBkB,CAAA,CAgBlB;AACA,UAAKF,CAAAA,mBAAL,GAA2B,CAAC,GAAGA,mBAAJ,CAA3B;AACA,UAAK/c,CAAAA,UAAL,GAAkBA,UAAlB;AACA,UAAKpqB,CAAAA,IAAL,GAAYA,IAAZ;AACA,UAAKpE,CAAAA,WAAL,GAAmBA,WAAnB;AACA,UAAKJ,CAAAA,OAAL,GAAeA,OAAf;AACA,UAAK4rC,CAAAA,OAAL,GAAeA,OAAf;AA3BsF;AA6B1FE,mBAAe,EAAG;AACd,UAAKrlC,CAAAA,WAAL,GAAmB,CAAA,CAAnB;AACI,UAAKmlC,CAAAA,OAAT,IACIjmC,SAAU3I,CAAAA,GAAV,CAAc,IAAd,CACA,EAAKyJ,WAAL,KACIA,WAEA,GAFc,CAAA,CAEd,EADA2O,KAAMlX,CAAAA,IAAN,CAAWyI,gBAAX,CACA,EAAAyO,KAAMjX,CAAAA,gBAAN,CAAuBoH,mBAAvB,CAHJ,CAFJ,KASI,IAAKqB,CAAAA,aAAL,EACA,EAAA,IAAKF,CAAAA,QAAL,EAVJ,CAAA;AAFc;AAelBE,iBAAa,EAAG;AACZ,YAAM,CAAE+kC,mBAAF,EAAuBnnC,IAAvB,EAA6BxE,OAA7B,EAAsCI,WAAtC,CAAA,GAAsD,IAA5D;AAKA,WAAK,IAAInB,IAAI,CAAb,EAAgBA,CAAhB,GAAoB0sC,mBAAoBzsC,CAAAA,MAAxC,EAAgDD,CAAA,EAAhD;AACI,YAA+B,IAA/B,KAAI0sC,mBAAA,CAAoB1sC,CAApB,CAAJ;AAII,cAAU,CAAV,KAAIA,CAAJ,CAAa;AACT,kBAAM8sC,eAA+B,IAAhB,KAAA3rC,WAAA,IAAwC,IAAK,EAA7C,KAAwBA,WAAxB,GAAiD,IAAK,EAAtD,GAA0DA,WAAYtF,CAAAA,GAAZ,EAA/E,EACMkN,gBAAgB2jC,mBAAA,CAAoBA,mBAAoBzsC,CAAAA,MAAxC,GAAiD,CAAjD,CADtB;AAEA,gBAAqB5D,IAAAA,EAArB,KAAIywC,YAAJ;AACIJ,iCAAA,CAAoB,CAApB,CAAA,GAAyBI,YAAzB;AADJ,kBAGK,KAAI/rC,OAAJ,IAAewE,IAAf,CAAqB;AACtB,oBAAMwnC,cAAchsC,OAAQisC,CAAAA,SAAR,CAAkBznC,IAAlB,EAAwBwD,aAAxB,CAApB;AACoB1M,kBAAAA,EAApB,KAAI0wC,WAAJ,IAAiD,IAAjD,KAAiCA,WAAjC,KACIL,mBAAA,CAAoB,CAApB,CADJ,GAC6BK,WAD7B;AAFsB;AAMK1wC,gBAAAA,EAA/B,KAAIqwC,mBAAA,CAAoB,CAApB,CAAJ,KACIA,mBAAA,CAAoB,CAApB,CADJ,GAC6B3jC,aAD7B;AAGI5H,uBAAJ,IAAoC9E,IAAAA,EAApC,KAAmBywC,YAAnB,IACI3rC,WAAYa,CAAAA,GAAZ,CAAgB0qC,mBAAA,CAAoB,CAApB,CAAhB,CADJ;AAfS,WAAb;AAoBIA,+BAAA,CAAoB1sC,CAApB,CAAA,GAAyB0sC,mBAAA,CAAoB1sC,CAApB,GAAwB,CAAxB,CAAzB;AApBJ;AAJJ;AADJ;AANY;AAoChBitC,oBAAgB,EAAG;;AACnBhmC,uBAAmB,EAAG;;AACtBimC,mBAAe,EAAG;;AAClB9lC,mBAAe,EAAG;;AAClBK,YAAQ,EAAG;AACP,UAAKmlC,CAAAA,UAAL,GAAkB,CAAA,CAAlB;AACA,UAAKjd,CAAAA,UAAL,CAAgB,IAAK+c,CAAAA,mBAArB,EAA0C,IAAK3jC,CAAAA,aAA/C,CAAA;AACArC,eAAUzI,CAAAA,MAAV,CAAiB,IAAjB,CAAA;AAHO;AAKXD,UAAM,EAAG;AACA,UAAK4uC,CAAAA,UAAV,KACI,IAAKplC,CAAAA,WACL,GADmB,CAAA,CACnB,EAAAd,SAAUzI,CAAAA,MAAV,CAAiB,IAAjB,CAFJ;AADK;AAMTkvC,UAAM,EAAG;AACA,UAAKP,CAAAA,UAAV,IACI,IAAKC,CAAAA,eAAL,EADJ;AADK;AAhGb;AA2GA,QAAMO,wBAAyB/kC,KAAD+kC,IAAYxxC,GAAD,IAAwB,QAAxB,KAAS,MAAOA,IAAhB,IAAoCA,GAAI4I,CAAAA,UAAJ,CAAe6D,KAAf,CAA7E,EACMma,oBACQ4qB,qBAAA,CAAsB,IAAtB,CAFd,EAGMC,wBACQD,qBAAA,CAAsB,QAAtB,CAJd,EAKM1kC,qBAAsB/M,KAAD+M,IACC2kC,qBAAAC,CAAsB3xC,KAAtB2xC,CACxB,GAGOC,sBAAuBlpC,CAAAA,IAAvB,CAA4B1I,KAAMmI,CAAAA,KAAN,CAAY,IAAZ,CAAA,CAAkB,CAAlB,CAAqB2E,CAAAA,IAArB,EAA5B,CAHP,GACW,CAAA,CARf,EAYM8kC,yBAAyB,qFAZ/B,EAuBMvlC,wBAEN,0DAzBA;AAsDMwlC,kBAAiBpyC,CAADoyC,IAAQroC,IAAD,IAAUA,IAAKd,CAAAA,IAAL,CAAUjJ,CAAV,CAtDvC,EAmEMqyC,sBAAsB,CAAC9pC,MAAD,EAASsf,EAAT,EAAawG,OAAb,EAAsB+e,OAAtB,EAA+BE,EAA/B,EAAmCD,EAAnC,EARfiF,CACTrpC,KAAOjJ,CAADiJ,IAAa,MAAbA,KAAOjJ,CADJsyC,EAETnpC,MAAQnJ,CAADmJ,IAAOnJ,CAFLsyC,CAQe,CAnE5B;AAyEA,OAAMC,qBAAN,QAAmClB,iBAAnC;AACIlhB,eAAW,CAACmhB,mBAAD,EAAsB/c,UAAtB,EAAkCpqB,IAAlC,EAAwCpE,WAAxC,EAAqDJ,OAArD,CAA8D;AACrE,WAAA,CAAM2rC,mBAAN,EAA2B/c,UAA3B,EAAuCpqB,IAAvC,EAA6CpE,WAA7C,EAA0DJ,OAA1D,EAAmE,CAAA,CAAnE,CAAA;AADqE;AAGzE4G,iBAAa,EAAG;AACZ,YAAM,CAAE+kC,mBAAF,EAAuB3rC,OAAvB,EAAgCwE,IAAhC,CAAA,GAAyC,IAA/C;AACA,UAAKxE,OAAL,IAAiBA,OAAQ5E,CAAAA,OAAzB,CAAA;AAEA,aAAMwL,CAAAA,aAAN,EAAA;AAIA,aAAK,IAAI3H,IAAI,CAAb,EAAgBA,CAAhB,GAAoB0sC,mBAAoBzsC,CAAAA,MAAxC,EAAgDD,CAAA,EAAhD,CAAqD;AACjD,cAAI4tC,WAAWlB,mBAAA,CAAoB1sC,CAApB,CAAf;AACA,cAAwB,QAAxB,KAAI,MAAO4tC,SAAX,KACIA,QACI,GADOA,QAASnlC,CAAAA,IAAT,EACP,EAAAC,kBAAA,CAAmBklC,QAAnB,CAFR,EAEsC;AAC9B,kBAAMpsC,WAAWoG,gBAAA,CAAiBgmC,QAAjB,EAA2B7sC,OAAQ5E,CAAAA,OAAnC,CAAjB;AACiBE,gBAAAA,EAAjB,KAAImF,QAAJ,KACIkrC,mBAAA,CAAoB1sC,CAApB,CADJ,GAC6BwB,QAD7B;AAGIxB,aAAJ,KAAU0sC,mBAAoBzsC,CAAAA,MAA9B,GAAuC,CAAvC,KACI,IAAK8I,CAAAA,aADT,GACyB6kC,QADzB;AAL8B;AAJW;AAoBrD,YAAKC,CAAAA,oBAAL,EAAA;AAOA,YAAKv3B,cAAevZ,CAAAA,GAAf,CAAmBwI,IAAnB,CAAL,IAAgE,CAAhE,KAAiCmnC,mBAAoBzsC,CAAAA,MAArD,CAAA;AAGA,cAAM,CAACqK,MAAD,EAAS3I,MAAT,CAAA,GAAmB+qC,mBAAzB;AACMoB,WAAAA,GA7CwBL,mBAAoBM,CAAAA,IAApB,CAAyBP,aAAA,CA6CbljC,MA7Ca,CAAzB,CA6CxBwjC;AACAE,kBAAAA,GA9CwBP,mBAAoBM,CAAAA,IAApB,CAAyBP,aAAA,CA8Cb7rC,MA9Ca,CAAzB,CA8CxBqsC;AAIN,cAAIF,CAAJ,KAAmBE,QAAnB;AAMA,gBAAkBF,CAAlB,KApV2BnqC,MAoV3B,IAAkBmqC,CAAlB,KApV2C7qB,EAoV3C,IAA+C+qB,QAA/C,KApV2BrqC,MAoV3B,IAA+CqqC,QAA/C,KApV2C/qB,EAoV3C;AAYI,kBAAKrc,CAAAA,gBAAL,GAAwB,CAAA,CAAxB;AAZJ;AACI,mBAAS5G,CAAT,GAAa,CAAb,EAAgBA,CAAhB,GAAoB0sC,mBAAoBzsC,CAAAA,MAAxC,EAAgDD,CAAA,EAAhD;AACUrE,wBACN,GADc+wC,mBAAA,CAAoB1sC,CAApB,CACd,EAAqB,QAArB,KAAI,MAAOrE,SAAX,KACI+wC,mBAAA,CAAoB1sC,CAApB,CADJ,GAC6B4E,UAAA,CAAWjJ,QAAX,CAD7B,CAAA;AAFJ;AADJ;AANA;AATA;AAjCA;AAFY;AAiEhBkyC,wBAAoB,EAAG;AACnB,YAAM,CAAEnB,mBAAF,EAAuBnnC,IAAvB,CAAA,GAAgC,IAAtC,EACM0oC,sBAAsB,EAD5B;AAEA,WAAK,IAAIjuC,IAAI,CAAb,EAAgBA,CAAhB,GAAoB0sC,mBAAoBzsC,CAAAA,MAAxC,EAAgDD,CAAA,EAAhD,CAAqD;AACtC,YAAA,2BAAA0sC,mBAAA,CAAoB1sC,CAApB,CAAA;AAxxBf,gCAAA,GADiB,QAArB,KAAI,MAAOrE,yBAAX,GACqB,CADrB,KACWA,wBADX,GAGmB,IAAd,KAAIA,wBAAJ,GACgB,MADhB,KACMA,wBADN,IACoC,GADpC,KAC0BA,wBAD1B,IANwB,aAAc0I,CAAAA,IAAd,CAOqC1I,wBAPrC,CAMxB,GAIM,CAAA,CANP;AAwxBQ,gCAAJ,IACIsyC,mBAAoB3vC,CAAAA,IAApB,CAAyB0B,CAAzB,CADJ;AADiD;AAKrD,UAAIiuC,mBAAoBhuC,CAAAA,MAAxB,CAAgC;AA7XhCD,SAAAA,GAAI,CAAJA;AAEJ,aADIkuC,wBACJ,GADyB7xC,IAAAA,EACzB,EAAO2D,CAAP,GA4XoC0sC,mBA5XLzsC,CAAAA,MAA/B,IAAyC,CAACiuC,wBAA1C,CAAA,CAA8D;AAC1D,gBAAMN,WA2X0BlB,mBA3Xf,CAAoB1sC,CAApB,CAAjB;AACwB,kBAAxB,KAAI,MAAO4tC,SAAX,IACI,CAAC5B,gBAAiBjvC,CAAAA,GAAjB,CAAqB6wC,QAArB,CADL,IAEIpqC,mBAAA,CAAoBoqC,QAApB,CAA8BnyC,CAAAA,MAAOwE,CAAAA,MAFzC,KAGIiuC,wBAHJ,GA0XgCxB,mBAvXP,CAAoB1sC,CAApB,CAHzB;AAKAA,WAAA,EAAA;AAP0D;AAS9D,YAAIkuC,wBAAJ,IAmX8E3oC,IAnX9E;AACI,eAAK,MAAM4oC,SAAX,IAkXqDF,mBAlXrD;AAkXgCvB,+BAjX5B,CAAoByB,SAApB,CAAA,GAAiCroC,iBAAA,CAiXqCP,IAjXrC,EAAwB2oC,wBAAxB,CAAjC;AADJ;AADJ;AAkXoC;AARb;AAYvBjnC,uBAAmB,EAAG;AAClB,YAAM,CAAElG,OAAF,EAAW2rC,mBAAX,EAAgCnnC,IAAhC,CAAA,GAAyC,IAA/C;AACA,UAAKxE,OAAL,IAAiBA,OAAQ5E,CAAAA,OAAzB,CAAA;AAEa,gBAAb,KAAIoJ,IAAJ,KACI,IAAK8B,CAAAA,gBADT,GAC4BC,MAAO8mC,CAAAA,WADnC;AAGA,YAAKC,CAAAA,cAAL,GAAsB7B,gBAAA,CAAiBjnC,IAAjB,CAAA,CAAuBxE,OAAQiyB,CAAAA,kBAAR,EAAvB,EAAqD1rB,MAAOgB,CAAAA,gBAAP,CAAwBvH,OAAQ5E,CAAAA,OAAhC,CAArD,CAAtB;AACAuwC,2BAAA,CAAoB,CAApB,CAAA,GAAyB,IAAK2B,CAAAA,cAA9B;AAEA,YAAMC,kBAAkB5B,mBAAA,CAAoBA,mBAAoBzsC,CAAAA,MAAxC,GAAiD,CAAjD,CAAxB;AACwB5D,YAAAA,EAAxB,KAAIiyC,eAAJ,IACIvtC,OAAQgB,CAAAA,QAAR,CAAiBwD,IAAjB,EAAuB+oC,eAAvB,CAAwCtI,CAAAA,IAAxC,CAA6CsI,eAA7C,EAA8D,CAAA,CAA9D,CADJ;AATA;AAFkB;AAetBlnC,mBAAe,EAAG;AACd,UAAID,EAAJ;AACA,YAAM,CAAEpG,OAAF,EAAWwE,IAAX,EAAiBmnC,mBAAjB,CAAA,GAAyC,IAA/C;AACA,UAAK3rC,OAAL,IAAiBA,OAAQ5E,CAAAA,OAAzB,CAAA;AAEA,YAAMR,QAAQoF,OAAQgB,CAAAA,QAAR,CAAiBwD,IAAjB,CAAd;AACA5J,aAAA,IAASA,KAAMqqC,CAAAA,IAAN,CAAW,IAAKqI,CAAAA,cAAhB,EAAgC,CAAA,CAAhC,CAAT;AACME,aAAAA,GAAqB7B,mBAAoBzsC,CAAAA,MAAzCsuC,GAAkD,CAAlDA;AACN,YAAMxlC,gBAAgB2jC,mBAAA,CAAoB6B,KAApB,CAAtB;AACA7B,2BAAA,CAAoB6B,KAApB,CAAA,GAA0C/B,gBAAA,CAAiBjnC,IAAjB,CAAA,CAAuBxE,OAAQiyB,CAAAA,kBAAR,EAAvB,EAAqD1rB,MAAOgB,CAAAA,gBAAP,CAAwBvH,OAAQ5E,CAAAA,OAAhC,CAArD,CAA1C;AACsB,YAAtB,KAAI4M,aAAJ,IAAqD1M,IAAAA,EAArD,KAA8B,IAAK0M,CAAAA,aAAnC,KACI,IAAKA,CAAAA,aADT,GACyBA,aADzB;AAIA,SAAsC,IAAlC,MAAC5B,EAAD,GAAM,IAAKf,CAAAA,iBAAX,KAAiD,IAAK,EAAtD,KAA0Ce,EAA1C,GAA0D,CAA1D,GAAmEA,EAAGlH,CAAAA,MAA1E,KACI,IAAKmG,CAAAA,iBAAkB1K,CAAAA,OAAvB,CAA+B,CAAC,CAAC8yC,kBAAD,EAAqBC,mBAArB,CAAD,CAAA,IAA+C;AAC1E1tC,iBACKgB,CAAAA,QADL,CACcysC,kBADd,CAEKxsC,CAAAA,GAFL,CAESysC,mBAFT,CAAA;AAD0E,SAA9E,CADJ;AAOA,YAAKZ,CAAAA,oBAAL,EAAA;AAlBA;AAHc;AAhGtB;AAkIA,QAAMa,eAAe,CAAC/yC,KAAD,EAAQ4J,IAAR,CAAAmpC,IAEJ,QAAb,KAAInpC,IAAJ,GACW,CAAA,CADX,GAKqB,QAErB,KAFI,MAAO5J,MAEX,IAFiCiG,KAAMC,CAAAA,OAAN,CAAclG,KAAd,CAEjC,IAAqB,QAArB,KAAI,MAAOA,MAAX,KACKuK,OAAQ7B,CAAAA,IAAR,CAAa1I,KAAb,CADL,IACsC,GADtC,KAC4BA,KAD5B,KAEI,CAACA,KAAM6I,CAAAA,UAAN,CAAiB,MAAjB,CAFL,GAIW,CAAA,CAJX,GAMO,CAAA,CAfX,EAuDMyE,YAAatN,KAADsN,IAAqB,IAArBA,KAAWtN,KAvD7B;AA2EA,OAAMgzC,cAAN;AACIpjB,eAAW,CAAC,CAAEqjB,QAAA,GAAW,CAAA,CAAb,EAAmBx7B,KAAA,GAAQ,CAA3B,EAA8BjO,IAAA,GAAO,WAArC,EAAkD0D,MAAA,GAAS,CAA3D,EAA8D8L,WAAA,GAAc,CAA5E,EAA+E7L,UAAA,GAAa,MAA5F,EAAoG,GAAGzH,OAAvG,CAAD,CAAmH;AAG1H,UAAKwtC,CAAAA,mBAAL,GADA,IAAKC,CAAAA,SACL,GADiB,CAAA,CACjB;AACA,UAAKC,CAAAA,SAAL,GAAiBrmB,IAAK/oB,CAAAA,GAAL,EAAjB;AACA,UAAK0B,CAAAA,OAAL,GAAe,CACXutC,QADW,EAEXx7B,KAFW,EAGXjO,IAHW,EAIX0D,MAJW,EAKX8L,WALW,EAMX7L,UANW,EAOX,GAAGzH,OAPQ,CAAf;AASA,UAAK2tC,CAAAA,qBAAL,EAAA;AAd0H;AA0B9HC,iBAAa,EAAG;AACZ,aAAK,IAAKC,CAAAA,UAAV,GA7BkBC,EA+BX,GAAA,IAAKD,CAAAA,UAAL,GAAkB,IAAKH,CAAAA,SAAvB,GACD,IAAKG,CAAAA,UADJ,GAED,IAAKH,CAAAA,SAJX,GACW,IAAKA,CAAAA,SADhB;AADY;AAYZ,gBAAW,EAAA;AACN,UAAKK,CAAAA,SAAV,IAAwB,IAAKP,CAAAA,mBAA7B,KA5aJnnC,gBAAA,EACA,EAAApB,mBAAA,EA2aI;AAGA,aAAO,IAAK8oC,CAAAA,SAAZ;AAJW;AAWfC,uBAAmB,CAACzmC,SAAD,EAAYG,aAAZ,CAA2B;AAC1C,UAAKmmC,CAAAA,UAAL,GAAkBxmB,IAAK/oB,CAAAA,GAAL,EAAlB;AACA,UAAKkvC,CAAAA,mBAAL,GAA2B,CAAA,CAA3B;AACA,YAAM,CAAEtpC,IAAF,EAAQJ,IAAR,EAAc/I,QAAd,EAAwBgX,KAAxB,EAA+Buc,UAA/B,EAA2C3R,QAA3C,EAAqDnK,WAArD,CAAA,GAAsE,IAAKxS,CAAAA,OAAjF;AAKI,UAAA,eAAA;AAAA,UAAA,eAAA,GAAA,CAAA,WAAA,CAAA;AA1GyC;AAMjD,gBAAMiuC,iBAoGkB1mC,SApGD,CAAU,CAAV,CAAvB;AACA,cAAuB,IAAvB,KAAI0mC,cAAJ;AACI,2BAAA,GAAO,CAAA,CAAP;AADJ;AAOA,gBAAa,SAAb,KA4FwB/pC,IA5FxB,IAAmC,YAAnC,KA4FwBA,IA5FxB;AACI,6BAAA,GAAO,CAAA,CAAP;AADJ,kBAAA;AAEMgqC,6BAAAA,GA0FkB3mC,SA1FD,CA0FCA,SA1FmB3I,CAAAA,MAApB,GAA6B,CAA7B,CAAjBsvC;AACN,kBAAMC,qBAAqBd,YAAA,CAAaY,cAAb,EAyFH/pC,IAzFG,CAA3B,EACMkqC,qBAAqBf,YAAA,CAAaa,eAAb,EAwFHhqC,IAxFG,CAD3B;AAEA5C,yBAAYuH,CAAAA,OAAZ,CAAoBslC,kBAApB,KAA2CC,kBAA3C,EAAgE,6BAuFxClqC,IAvFwC,UAA0C+pC,cAA1C,SAAiEC,eAAjE,MAAqFD,cAArF,8DAAiKA,cAAjK,6BAA4MC,eAA5M,8BAAhE,CAAA;AAEA,kBAAKC,kBAAL,IAA4BC,kBAA5B,CAAA;AA9BoC,iBAAA;AAEpC,sBADMtzC,eACF,GA+BIyM,SAhCQ,CAAU,CAAV,CACZ,EAAqB,CAArB,KA+BIA,SA/BM3I,CAAAA,MAAd;AACI,mCAAA,GAAO,CAAA,CAAP;AADJ,wBAAA;AAEA,yBAASD,kBAAT,GAAa,CAAb,EAAgBA,kBAAhB,GA6BQ4I,SA7BsB3I,CAAAA,MAA9B,EAAsCD,kBAAA,EAAtC;AACI,0BA4BI4I,SA5BA,CAAU5I,kBAAV,CAAJ,KAAqB7D,eAArB,CACI;AAAA,uCAAA,GAAO,CAAA,CAAP;AAAA,8BAAA,CAAA;AAAA;AAFR;AAJoC,mCAAA,GAAA,IAAA,EAAA;AAEpC;AAFoC;AAiC5B,+BAAA,GAAA,eAAA,KAAA,QAAA,KAAA,IAAA,IAAA,SAAA,CAAA,WAAA,CAAA,IAAA,CAAA,KAAA,QAAA;AAHR,eAAA;AACW,+BAAA,GAAA,CAAA,CAAA;AADX;AAPA;AAPA;AAPiD;AA0GzB,uBAAA,GAAA,CAAA,eAAA;AAAhB;AAAJ,UAAI,eAAJ,CAAkE;AAE9D,YAAI0qC,qBAAsB1qC,CAAAA,OAA1B,IAAqC,CAACiX,KAAtC,CAA6C;AACzC4K,kBAAA,IACIA,QAAA,CAASrV,gBAAA,CAAiBC,SAAjB,EAA4B,IAAKvH,CAAAA,OAAjC,EAA0C0H,aAA1C,CAAT,CADJ;AAEA4mB,oBAAA,IAAcA,UAAA,EAAd;AACA,cAAK+f,CAAAA,sBAAL,EAAA;AACA;AALyC;AASzC,YAAKruC,CAAAA,OAAQmK,CAAAA,QAAb,GAAwB,CAAxB;AAX0D;AAc5DmkC,qBAAAA,GAAoB,IAAKC,CAAAA,YAAL,CAAkBhnC,SAAlB,EAA6BG,aAA7B,CAApB4mC;AACoB,OAAA,CAA1B,KAAIA,eAAJ,KAEA,IAAKP,CAAAA,SAKL,GALiB,CACbxmC,SADa,EAEbG,aAFa,EAGb,GAAG4mC,eAHU,CAKjB,EAAA,IAAKE,CAAAA,cAAL,EAPA;AAvB0C;AAgC9CA,kBAAc,EAAG;;AAMjBp5B,QAAI,CAACK,OAAD,EAAUg5B,MAAV,CAAkB;AAClB,aAAO,IAAKC,CAAAA,sBAAuBt5B,CAAAA,IAA5B,CAAiCK,OAAjC,EAA0Cg5B,MAA1C,CAAP;AADkB;AAGtBE,WAAO,EAAG;AACN,UAAK3uC,CAAAA,OAAQ8D,CAAAA,IAAb,GAAoB,WAApB;AACA,UAAK9D,CAAAA,OAAQ8P,CAAAA,IAAb,GAAoB,QAApB;AAFM;AAIV69B,yBAAqB,EAAG;AACpB,UAAKe,CAAAA,sBAAL,GAA8B,IAAIx5B,OAAJ,CAAaO,OAAD,IAAa;AACnD,YAAK44B,CAAAA,sBAAL,GAA8B54B,OAA9B;AADmD,OAAzB,CAA9B;AADoB;AA/F5B;AA2HA,QAAMiF,cAAc,CAACtV,IAAD,EAAOwE,EAAP,EAAWiF,QAAX,CAAA6L,IACTtV,IADSsV,IACD9Q,EADC8Q,GACItV,IADJsV,IACY7L,QADhC,EAoDM+/B,iBAAiB,CAACxpC,IAAD,EAAOwE,EAAP,EAAW7P,CAAX,CAAA60C,IAAiB;AACnBxpC,QAAXypC,IAAkBzpC,IAAlBypC;AACAC,MAAAA,GAAO/0C,CAAP+0C,IAAYllC,EAAZklC,GAAiBllC,EAAjBklC,GAAsBD,IAAtBC,IAAkCD,IAAlCC;AACN,WAAc,CAAP,GAAAA,EAAA,GAAW,CAAX,GAAevwC,IAAK4M,CAAAA,IAAL,CAAU2jC,EAAV,CAAtB;AAHoC,GApDxC,EAyDMC,aAAa,CAAClI,GAAD,EAAMF,IAAN,EAAY59B,IAAZ,CAzDnB,EA0DMH,eAAgB7O,CAAD6O,IAAOmmC,UAAWrC,CAAAA,IAAX,CAAiB5oC,IAAD,IAAUA,IAAKd,CAAAA,IAAL,CAAUjJ,CAAV,CAA1B,CA1D5B,EAuEMsP,WAAW,CAACjE,IAAD,EAAOwE,EAAP,CAAAP,IAAc;AAC3B,UAAM2lC,WAAWrmC,MAAA,CAAOvD,IAAP,CAAjB,EACM6pC,SAAStmC,MAAA,CAAOiB,EAAP,CADf;AAEA,QAAI,CAAColC,QAAL,IAAiB,CAACC,MAAlB;AACI,aAAOzmC,YAAA,CAAapD,IAAb,EAAmBwE,EAAnB,CAAP;AADJ;AAGA,UAAMslC,UAAU,CAAE,GAAGF,QAAL,CAAhB;AACA,WAAQj1C,CAAD,IAAO;AACVm1C,aAAQ7mC,CAAAA,GAAR,GAAcumC,cAAA,CAAeI,QAAS3mC,CAAAA,GAAxB,EAA6B4mC,MAAO5mC,CAAAA,GAApC,EAAyCtO,CAAzC,CAAd;AACAm1C,aAAQ5mC,CAAAA,KAAR,GAAgBsmC,cAAA,CAAeI,QAAS1mC,CAAAA,KAAxB,EAA+B2mC,MAAO3mC,CAAAA,KAAtC,EAA6CvO,CAA7C,CAAhB;AACAm1C,aAAQ3mC,CAAAA,IAAR,GAAeqmC,cAAA,CAAeI,QAASzmC,CAAAA,IAAxB,EAA8B0mC,MAAO1mC,CAAAA,IAArC,EAA2CxO,CAA3C,CAAf;AACAm1C,aAAQ9mC,CAAAA,KAAR,GAAgBsS,WAAA,CAAYs0B,QAAS5mC,CAAAA,KAArB,EAA4B6mC,MAAO7mC,CAAAA,KAAnC,EAA0CrO,CAA1C,CAAhB;AACA,aAAO4sC,IAAK3iC,CAAAA,SAAL,CAAekrC,OAAf,CAAP;AALU,KAAd;AAP2B,GAvE/B,EA8FM9+B,mBAAmB,CAAC3H,CAAD,EAAIC,CAAJ,CAAA0H,IAAWrW,CAAD,IAAO2O,CAAA,CAAED,CAAA,CAAE1O,CAAF,CAAF,CA9F1C,EAiGMmP,kBAAkB,IAAIlN,GAAJ,CAAQ,CAAC,MAAD,EAAS,QAAT,CAAR,CAjGxB,EA6KMsN,aAAa,CAACL,MAAD,EAAS3I,MAAT,CAAAgJ,IAAoB;AACnC,UAAM6lC,WAAWtqC,OAAQnB,CAAAA,iBAAR,CAA0BpD,MAA1B,CAAjB,EACM8uC,cAAcjtC,mBAAA,CAAoB8G,MAApB,CADpB,EAEMomC,cAAcltC,mBAAA,CAAoB7B,MAApB,CAFpB;AAMA,QAHuB8uC,WAAYhtC,CAAAA,OAAQG,CAAAA,GAAI3D,CAAAA,MAG/C,KAH0DywC,WAAYjtC,CAAAA,OAAQG,CAAAA,GAAI3D,CAAAA,MAGlF,IAFIwwC,WAAYhtC,CAAAA,OAAQC,CAAAA,KAAMzD,CAAAA,MAE9B,KAFyCywC,WAAYjtC,CAAAA,OAAQC,CAAAA,KAAMzD,CAAAA,MAEnE,IADIwwC,WAAYhtC,CAAAA,OAAQE,CAAAA,MAAO1D,CAAAA,MAC/B,IADyCywC,WAAYjtC,CAAAA,OAAQE,CAAAA,MAAO1D,CAAAA,MACpE,CAAoB;AAChB,UAAKsK,eAAgBxN,CAAAA,GAAhB,CAAoBuN,MAApB,CAAL,IACI,CAAComC,WAAYj1C,CAAAA,MAAOwE,CAAAA,MADxB,IAEKsK,eAAgBxN,CAAAA,GAAhB,CAAoB4E,MAApB,CAFL,IAGQ,CAAC8uC,WAAYh1C,CAAAA,MAAOwE,CAAAA,MAH5B;AAII,eAAOoK,aAAA,CAAcC,MAAd,EAAsB3I,MAAtB,CAAP;AAJJ;AAMYiJ,YAAAA,GAAAA,QAAAA;AA1BhB,UAAIzD,EAAJ;AACMwpC,YAAAA,GAAgB,EAAhBA;AACN,YAAMC,WAAW,CAAEltC,MAAO,CAAT,EAAYE,IAAK,CAAjB,EAAoBD,OAAQ,CAA5B,CAAjB;AACA,WAAK,IAAI3D,IAAI,CAAb,EAAgBA,CAAhB,GAuBiD0wC,WAvBtBj1C,CAAAA,MAAOwE,CAAAA,MAAlC,EAA0CD,CAAA,EAA1C,CAA+C;AAC3C,cAAMmF,OAsBuCurC,WAtBzB7sC,CAAAA,KAAP,CAAa7D,CAAb,CAAb,EAEM6wC,cAAoD,IAAtC,MAAC1pC,EAAD,GAoBYspC,WApBCh1C,CAAAA,MAAP,CAoBMg1C,WArBLhtC,CAAAA,OAAP,CAAe0B,IAAf,CAAA2rC,CAAqBF,QAAA,CAASzrC,IAAT,CAArB2rC,CACM,CAAN,KAAqD,IAAK,EAA1D,KAA8C3pC,EAA9C,GAA8DA,EAA9D,GAAmE,CAFvF;AAGAwpC,cAAA,CAAc3wC,CAAd,CAAA,GAAmB6wC,WAAnB;AACAD,gBAAA,CAASzrC,IAAT,CAAA,EAAA;AAL2C;AAuB3C,aAAY4rC,CAAAnmC,MAAA,CAhBT+lC,MAgBS,EAA+CD,WAAYj1C,CAAAA,MAA3D,CAAAs1C,EAAoEP,QAApEO,CA5F2BhyC,CAAAA,MAAb,CAAoB0S,gBAApB,CA4F1B;AAPgB;AAUhB9O,eAAYuH,CAAAA,OAAZ,CAAoB,CAAA,CAApB,EAA2B,mBAAkBI,MAAlB,UAAkC3I,MAAlC,0KAA3B,CAAA;AACA,WAAOkI,YAAA,CAAaS,MAAb,EAAqB3I,MAArB,CAAP;AAlB+B,GA7KvC,EAmNM8J,iBAAiB,CAEnB2B,UAAW,GAFQ,EAGnBC,QAAS,EAHU,EAInB1B,KAAM,GAJa,EAKnBvP,SAAU,GALS,EAOnBoP,SAAU,GAPS,EAQnBE,OAAQ,GARW,EASnBuC,eAAgB,GATG,EAWnBM,UAAW,CACPO,SAAU,IADH,EAEPC,QAAS,CAFF,CAXQ,EAenBP,UAAW,CACPM,SAAU,KADH,EAEPC,QAAS,GAFF,CAfQ,EAoBnB5C,YAAa,IApBM,EAqBnBL,YAAa,IArBM,EAsBnBG,WAAY,IAtBO,EAuBnBC,WAAY,CAvBO,CAnNvB,EA6TM8B,eAAe,CAAC,UAAD,EAAa,QAAb,CA7TrB,EA8TMD,cAAc,CAAC,WAAD,EAAc,SAAd,EAAyB,MAAzB,CA9TpB,EA8iBMijC,SAAuB1uC,WAAA,CAAY,IAAZ,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CA9iB7B,EA+iBM2uC,UAAwB3uC,WAAA,CAAY,CAAZ,EAAe,CAAf,EAAkB,IAAlB,EAAwB,CAAxB,CA/iB9B,EAgjBMoQ,YAA0BpQ,WAAA,CAAY,IAAZ,EAAkB,CAAlB,EAAqB,IAArB,EAA2B,CAA3B,CAhjBhC,EAkjBMwQ,gBAAiB3B,IAAD2B,IACXlR,KAAMC,CAAAA,OAAN,CAAcsP,IAAd,CADW2B;AAC+B,UAD/BA,KACY,MAAO3B,KAAA,CAAK,CAAL,CAnjBzC,EAsjBM+/B,eAAe,CACjBC,OAAQxuC,WAAYC,CAAAA,IADH,EAEjBouC,MAFiB,EAGjBt+B,SAHiB,EAIjBu+B,OAJiB,EAKjB7J,MALiB,EAMjBG,SANiB,EAOjBD,OAPiB,EAQjBL,MARiB,EASjBC,SATiB,EAUjBF,OAViB,EAWjBG,UAXiB,CAtjBrB,EAmkBMp0B,6BAA8B9W,UAAD8W,IAAgB;AAC/C,QAAIlD,SAAUuhC,CAAAA,kBAAV,CAA6Bn1C,UAA7B,CAAJ,CAA8C;AAE1C0G,iBAAYmF,CAAAA,SAAZ,CAA4C,CAA5C,KAAsB7L,UAAWgE,CAAAA,MAAjC,EAAgD,yDAAhD,CAAA;AACA,YAAM,CAACoxC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAA,GAAmBv1C,UAAzB;AACA,aAAOqG,WAAA,CAAY+uC,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB,CAAP;AAJ0C;AAMzC,WAA0B,QAA1B,KAAI,MAAOv1C,WAAX,IAED0G,WAAYmF,CAAAA,SAAZ,CAAmDzL,IAAAA,EAAnD,KAAsB60C,YAAA,CAAaj1C,UAAb,CAAtB,EAA+D,wBAAuBA,UAAvB,GAA/D,CACO,EAAAi1C,YAAA,CAAaj1C,UAAb,CAHN,IAKEA,UALF;AAP0C,GAnkBnD,EAqtBMw1C,kBAAmBtyC,MAADsyC,IAAY;AAChC,UAAMC,gBAAgB,CAAC,CAAE/zC,SAAF,CAAD,CAAA+zC,IAAmBvyC,MAAA,CAAOxB,SAAP,CAAzC;AACA,WAAO,CACHtC,MAAO,EAAAA,IAAM8a,KAAMhX,CAAAA,MAAN,CAAauyC,aAAb,EAA4B,CAAA,CAA5B,CADV,EAEH5a,KAAM,EAAAA,IAAMlO,WAAA,CAAY8oB,aAAZ,CAFT,EAOH/xC,IAAK,EAAAA,IAAOxB,SAAUZ,CAAAA,YAAV,GAAyBY,SAAUR,CAAAA,SAAnC,GAA+C+qB,IAAK/oB,CAAAA,GAAL,EAPxD,CAAP;AAFgC,GArtBpC,EAkuBMgyC,aAAa,CACfC,MAAOzhC,OADQ,EAEfA,OAFe,EAGf0hC,MAAOjpC,SAHQ,EAIJA,SAJI,EAKfyF,MALe,CAluBnB,EAyuBMyjC,oBAAqBroB,OAADqoB,IAAaroB,OAAbqoB,GAAuB,GAzuBjD;AA+uBA,OAAM79B,oBAAN,QAAkC06B,cAAlC;AACIpjB,eAAW,CAAClqB,OAAD,CAAU;AACjB,WAAA,CAAMA,OAAN,CAAA;AAQA,UAAK0wC,CAAAA,UAAL,GAJA,IAAKC,CAAAA,QAIL,GAJgB,IAIhB;AAIA,UAAKpN,CAAAA,WAAL,GAAmB,CAAnB;AAIA,UAAKqN,CAAAA,aAAL,GAAqB,CAArB;AAMA,UAAKC,CAAAA,gBAAL,GAAwB,SAAxB;AAIA,UAAKh8B,CAAAA,SAAL,GAAiB,IAAjB;AACA,UAAK1a,CAAAA,KAAL,GAAa,MAAb;AAKA,UAAKs7B,CAAAA,IAAL,GAAY,EAAAqb,IAAM;AACd,YAAKxrC,CAAAA,QAAS3I,CAAAA,MAAd,EAAA;AACA,YAAK8wC,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AACA,YAAmB,MAAnB,KAAI,IAAKtzC,CAAAA,KAAT,CAAA;AAEA,cAAK42C,CAAAA,QAAL,EAAA;AACA,cAAM,CAAEpb,MAAF,CAAA,GAAa,IAAK31B,CAAAA,OAAxB;AACA21B,gBAAA,IAAUA,MAAA,EAAV;AAJA;AAHc,OAAlB;AASA,YAAM,CAAEzxB,IAAF,EAAQpE,WAAR,EAAqBJ,OAArB,EAA8B6H,SAA9B,CAAA,GAA4C,IAAKvH,CAAAA,OAAvD;AAGA,UAAKsF,CAAAA,QAAL,GAAgB,MAFwB,IAAZ,KAAA5F,OAAA,IAAgC,IAAK,EAArC,KAAoBA,OAApB,GAAyC,IAAK,EAA9C,GAAkDA,OAAQ0rC,CAAAA,gBAEtE,KAF2FA,gBAE3F,EAAuB7jC,SAAvB,EADG,CAACI,iBAAD,EAAoBD,aAApB,CAAAspC,IAAsC,IAAKhD,CAAAA,mBAAL,CAAyBrmC,iBAAzB,EAA4CD,aAA5C,CACzC,EAA8CxD,IAA9C,EAAoDpE,WAApD,EAAiEJ,OAAjE,CAAhB;AACA,UAAK4F,CAAAA,QAASkmC,CAAAA,eAAd,EAAA;AA9CiB;AAgDrBmD,WAAO,EAAG;AACN,WAAMA,CAAAA,OAAN,EAAA;AAEI,UAAKZ,CAAAA,SAAT,IACIv6B,MAAOyP,CAAAA,MAAP,CAAc,IAAK8qB,CAAAA,SAAnB,EAA8B,IAAKQ,CAAAA,YAAL,CAAkB,IAAKR,CAAAA,SAAUxmC,CAAAA,SAAjC,CAA9B,CADJ;AAHM;AAOVgnC,gBAAY,CAAC0C,WAAD,CAAc;AACtB,YAAM,CAAEntC,IAAA,GAAO,WAAT,EAAsB0D,MAAA,GAAS,CAA/B,EAAkC8L,WAAA,GAAc,CAAhD,EAAmD7L,UAAnD,EAA+D1M,QAAA,GAAW,CAA1E,CAAA,GAAiF,IAAKiF,CAAAA,OAA5F;AACA,UAAMkxC,mBAAmB1iC,SAAUgE,CAAAA,WAAV,CAAsB1O,IAAtB,CAAA,GACnBA,IADmB,GAEnBwsC,UAAA,CAAWxsC,IAAX,CAFmB,IAECyD,SAF1B;AASA,UAAI4pC,qBAAJ,EACIC,iBADJ;AAGIF,sBADJ,KACyB3pC,SADzB,IAEIjG,WAAYmF,CAAAA,SAAZ,CAA4C,CAA5C,IAAsBwqC,WAAYryC,CAAAA,MAAlC,EAAgD,gGAA+FqyC,WAA/F,EAAhD,CAFJ;AAIIC,sBAAJ,KAAyB3pC,SAAzB,IAC8B,QAD9B,KACI,MAAO0pC,YAAA,CAAY,CAAZ,CADX,KAEIE,qBACA,GAD6BV,CAAAA,iBAAAA,EAAmB9mC,GAAA,CAAIsnC,WAAA,CAAY,CAAZ,CAAJ,EAAoBA,WAAA,CAAY,CAAZ,CAApB,CAAnBR,CA3tBM/yC,CAAAA,MAAb,CAAoB0S,gBAApB,CA4tBtB,EAAA6gC,WAAA,GAAc,CAAC,CAAD,EAAI,GAAJ,CAHlB;AAKA,YAAM9iC,YAAY+iC,gBAAA,CAAiB,CAAE,GAAG,IAAKlxC,CAAAA,OAAV,EAAmBuH,UAAW0pC,WAA9B,CAAjB,CAAlB;AAKmB,cAAnB,KAAIxpC,UAAJ,KACI2pC,iBADJ,GACwBF,gBAAA,CAAiB,CACjC,GAAG,IAAKlxC,CAAAA,OADyB,EAEjCuH,UAAW,CAAC,GAAG0pC,WAAJ,CAAiBvgC,CAAAA,OAAjB,EAFsB,EAGjC3V,SAAU,CAACA,QAHsB,CAAjB,CADxB;AAeqC,UAArC,KAAIoT,SAAUC,CAAAA,kBAAd,KACID,SAAUC,CAAAA,kBADd,GACmCI,SAAUC,CAAAA,qBAAV,CAAgCN,SAAhC,CADnC;AAGA,OAAM,CAAE,mBAAAC,WAAF,CAAN,GAA+BD,SAA/B;AACMkjC,sBAAAA,GAAmBjjC,WAAnBijC,GAAwC/9B,WAAxC+9B;AAEN,aAAO,CACHljC,SADG,EAEHijC,iBAFG,EAGHD,qBAHG,EAIH/iC,mBAAAA,WAJG,EAKHijC,iBAAAA,gBALG,EAMHC,cAPkBD,gBAOlBC,IAPsC9pC,MAOtC8pC,GAP+C,CAO/CA,IAPoDh+B,WACjD,CAAP;AAhDsB;AAyD1Bk7B,kBAAc,EAAG;AACb,YAAM,CAAEjB,QAAA,GAAW,CAAA,CAAb,CAAA,GAAsB,IAAKvtC,CAAAA,OAAjC;AACA,UAAKuxC,CAAAA,IAAL,EAAA;AAC8B,cAA9B,KAAI,IAAKV,CAAAA,gBAAT,IAA2CtD,QAA3C,GAII,IAAKpzC,CAAAA,KAJT,GAIiB,IAAK02C,CAAAA,gBAJtB,GACI,IAAKW,CAAAA,KAAL,EADJ;AAHa;AAUjBC,QAAI,CAACn1C,SAAD,EAAYwW,MAAA,GAAS,CAAA,CAArB,CAA4B;AAC5B,UAAM,CAAE3S,QAAF,CAAA,GAAe,IAArB;AAEA,UAAI,CAACA,QAAL;AAEI,eADM,CAAE,UAAAoH,SAAF,CACC,GADe,IAAKvH,CAAAA,OACpB,EAAA,CAAEoN,KAAM,CAAA,CAAR,EAAc9S,MAAOiN,SAAA,CAAUA,SAAU3I,CAAAA,MAApB,GAA6B,CAA7B,CAArB,CAAP;AAFJ;AAIA,YAAM,CAAE8I,aAAF,EAAiByG,SAAjB,EAA4BijC,iBAA5B,EAA+CD,qBAA/C,EAAsE5pC,SAAtE,EAAiF6G,kBAAjF,EAAqGkjC,aAArG,EAAoHD,gBAApH,CAAA,GAA0IlxC,QAAhJ;AACA,UAAuB,IAAvB,KAAI,IAAK0U,CAAAA,SAAT;AACI,eAAO1G,SAAUE,CAAAA,IAAV,CAAe,CAAf,CAAP;AADJ;AAEA,YAAM,CAAE0D,KAAF,EAASvK,MAAT,EAAiBC,UAAjB,EAA6B6L,WAA7B,EAA0CqJ,QAA1C,CAAA,GAAuD,IAAK3c,CAAAA,OAAlE;AAOiB,OAAjB,GAAI,IAAK0xC,CAAAA,KAAT,GACI,IAAK78B,CAAAA,SADT,GACqBtW,IAAKE,CAAAA,GAAL,CAAS,IAAKoW,CAAAA,SAAd,EAAyBvY,SAAzB,CADrB,GAGsB,CAHtB,GAGS,IAAKo1C,CAAAA,KAHd,KAII,IAAK78B,CAAAA,SAJT,GAIqBtW,IAAKE,CAAAA,GAAL,CAASnC,SAAT,GAAqBg1C,aAArB,GAAqC,IAAKI,CAAAA,KAA1C,EAAiD,IAAK78B,CAAAA,SAAtD,CAJrB,CAAA;AAQI,UAAK0uB,CAAAA,WAAL,GADAzwB,MAAJ,GACuBxW,SADvB,GAG2B,IAAtB,KAAI,IAAKq0C,CAAAA,QAAT,GACkB,IAAKA,CAAAA,QADvB,GAQGpyC,IAAKwF,CAAAA,KAAL,CAAWzH,SAAX,GAAuB,IAAKuY,CAAAA,SAA5B,CARH,GAQ4C,IAAK68B,CAAAA,KAVlD;AAaEC,YAAAA,GAAmB,IAAKpO,CAAAA,WAAxBoO,GAAsC5/B,KAAtC4/B,IAA6D,CAAd,IAAA,IAAKD,CAAAA,KAAL,GAAkB,CAAlB,GAAsB,CAAC,CAAtEC;AACAC,eAAAA,GAA+B,CAAd,IAAA,IAAKF,CAAAA,KAAL,GACE,CADF,GACjBC,MADiB,GAEjBA,MAFiB,GAEEL,aAFnBM;AAGN,UAAKrO,CAAAA,WAAL,GAAmBhlC,IAAKC,CAAAA,GAAL,CAASmzC,MAAT,EAA2B,CAA3B,CAAnB;AAEmB,gBAAnB,KAAI,IAAKx3C,CAAAA,KAAT,IAAmD,IAAnD,KAAiC,IAAKw2C,CAAAA,QAAtC,KACI,IAAKpN,CAAAA,WADT,GACuB+N,aADvB;AAGI/9B,cAAAA,GAAU,IAAKgwB,CAAAA,WAAfhwB;AACAs+B,YAAAA,GAAiB1jC,SAAjB0jC;AACJ,UAAIrqC,MAAJ,CAAY;AAMFqH,gBAAAA,GAAWtQ,IAAKE,CAAAA,GAAL,CAAS,IAAK8kC,CAAAA,WAAd,EAA2B+N,aAA3B,CAAXziC,GAAuDwiC,gBAAvDxiC;AAKN,YAAIijC,mBAAmBvzC,IAAKwzC,CAAAA,KAAL,CAAWljC,QAAX,CAAvB,EAKImjC,oBAAoBnjC,QAApBmjC,GAA+B,GALnC;AAUI,SAACA,iBAAL,IAAsC,CAAtC,IAA0BnjC,QAA1B,KACImjC,iBADJ,GACwB,CADxB;AAGsB,SAAtB,KAAAA,iBAAA,IAA2BF,gBAAA,EAA3B;AACAA,wBAAA,GAAmBvzC,IAAKE,CAAAA,GAAL,CAASqzC,gBAAT,EAA2BtqC,MAA3B,GAAoC,CAApC,CAAnB;AAI+BsqC,wBAC/B,GADkD,CAClD,KACuB,SAAnB,KAAIrqC,UAAJ,IACIuqC,iBACA,GADoB,CACpB,GADwBA,iBACxB,EAAI1+B,WAAJ,KACI0+B,iBADJ,IACyB1+B,WADzB,GACuC+9B,gBADvC,CAFJ,IAMwB,QANxB,KAMS5pC,UANT,KAOIoqC,MAPJ,GAOqBT,iBAPrB,CADJ;AAWA79B,gBAAA,IAAmB/U,CAh9D3B,GAg9D8BwzC,iBAh9D9B,GAg9D2BxzC,CAh9D3B,GAg9DwBC,CA98DxB,GA88D8BuzC,iBA98D9B,GA88DwBvzC,CA98DxB,GA88D8BuzC,iBAAtB,IAA2CX,gBAA3C;AAzCQ;AAgDNl3C,YAAAA,GAAQy3C,SAAA,GACR,CAAExkC,KAAM,CAAA,CAAR,EAAe9S,MAAOiN,SAAA,CAAU,CAAV,CAAtB,CADQ,GAERsqC,MAAexjC,CAAAA,IAAf,CAAoBkF,QAApB,CAFApZ;AAGFg3C,2BAAJ,KACIh3C,MAAMG,CAAAA,KADV,GACkB62C,qBAAA,CAAsBh3C,MAAMG,CAAAA,KAA5B,CADlB;AAGA,OAAI,CAAE,KAAA8S,QAAF,CAAJ,GAAejT,MAAf;AACKy3C,eAAL,IAA8C,IAA9C,KAAuBxjC,kBAAvB,KACIhB,QADJ,GAEsB,CAAd,IAAA,IAAKskC,CAAAA,KAAL,GACM,IAAKnO,CAAAA,WADX,IAC0B+N,aAD1B,GAE0B,CAF1B,IAEM,IAAK/N,CAAAA,WAJnB;AAQA,OAFM0O,SAEN,GAF8C,IAE9C,KAF4B,IAAKtB,CAAAA,QAEjC,KADoB,UACpB,KADK,IAAKx2C,CAAAA,KACV,IADkD,SAClD,KADmC,IAAKA,CAAAA,KACxC,IAD+DiT,QAC/D,MAA6CpS,IAAAA,EAA7C,KAA2B0M,aAA3B,KACIvN,MAAMG,CAAAA,KADV,GACkBgN,gBAAA,CAAiBC,SAAjB,EAA4B,IAAKvH,CAAAA,OAAjC,EAA0C0H,aAA1C,CADlB;AAGIiV,cAAJ,IACIA,QAAA,CAASxiB,MAAMG,CAAAA,KAAf,CADJ;AAGI23C,eAAJ,IACI,IAAKC,CAAAA,MAAL,EADJ;AAGA,aAAO/3C,MAAP;AAzH4B;AA2H5B,gBAAW,EAAA;AACX,YAAM,CAAEgG,QAAF,CAAA,GAAe,IAArB;AACA,aAAOA,QAAA,GAAWmB,WAAYyJ,CAAAA,qBAAZ,CAAkC5K,QAASiO,CAAAA,kBAA3C,CAAX,GAA4E,CAAnF;AAFW;AAIX,YAAO,EAAA;AACP,aAAO9M,WAAYyJ,CAAAA,qBAAZ,CAAkC,IAAKw4B,CAAAA,WAAvC,CAAP;AADO;AAGP,YAAI,CAACV,OAAD,CAAU;AAEd,UAAKU,CAAAA,WAAL,GADAV,OACA,GADUvhC,WAAYkJ,CAAAA,qBAAZ,CAAkCq4B,OAAlC,CACV;AACsB,UAAtB,KAAI,IAAK8N,CAAAA,QAAT,IAA6C,CAA7C,KAA8B,IAAKe,CAAAA,KAAnC,GACI,IAAKf,CAAAA,QADT,GACoB9N,OADpB,GAGS,IAAKsP,CAAAA,MAHd,KAII,IAAKt9B,CAAAA,SAJT,GAIqB,IAAKs9B,CAAAA,MAAO7zC,CAAAA,GAAZ,EAJrB,GAIyCukC,OAJzC,GAImD,IAAK6O,CAAAA,KAJxD,CAAA;AAHc;AAUd,aAAQ,EAAA;AACR,aAAO,IAAKd,CAAAA,aAAZ;AADQ;AAGR,aAAK,CAACwB,QAAD,CAAW;AAChB,YAAMC,aAAa,IAAKzB,CAAAA,aAAlByB,KAAoCD,QAA1C;AACA,UAAKxB,CAAAA,aAAL,GAAqBwB,QAArB;AACIC,gBAAJ,KACI,IAAKhrB,CAAAA,IADT,GACgB/lB,WAAYyJ,CAAAA,qBAAZ,CAAkC,IAAKw4B,CAAAA,WAAvC,CADhB;AAHgB;AAOpBgO,QAAI,EAAG;AACE,UAAKjsC,CAAAA,QAASa,CAAAA,WAAnB,IACI,IAAKb,CAAAA,QAASwmC,CAAAA,MAAd,EADJ;AAGA,UAAI,CAAC,IAAKiC,CAAAA,SAAV;AACI,YAAK8C,CAAAA,gBAAL,GAAwB,SAAxB;AADJ;AAIA,YAASpD,CAAL,IAAKA,CAAAA,SAAT,CAAA;AAEA,cAAM,CAAE0E,MAAA,GAAS/B,eAAX,EAA4B/hB,MAA5B,EAAoCxZ,SAApC,CAAA,GAAkD,IAAK7U,CAAAA,OAA7D;AACK,cAAKmyC,CAAAA,MAAV,KACI,IAAKA,CAAAA,MADT,GACkBA,MAAA,CAAQ71C,SAAD,IAAe,IAAKm1C,CAAAA,IAAL,CAAUn1C,SAAV,CAAtB,CADlB;AAGA+xB,gBAAA,IAAUA,MAAA,EAAV;AACA,cAAM/vB,MAAM,IAAK6zC,CAAAA,MAAO7zC,CAAAA,GAAZ,EAAZ;AACsB,cAAtB,KAAI,IAAKqyC,CAAAA,QAAT,GACI,IAAK97B,CAAAA,SADT,GACqBvW,GADrB,GAC2B,IAAKqyC,CAAAA,QADhC,GAGU,IAAK97B,CAAAA,SAAV,GAGmB,UAHnB,KAGI,IAAK1a,CAAAA,KAHT,KAID,IAAK0a,CAAAA,SAJJ,GAIgBvW,GAJhB,IACD,IAAKuW,CAAAA,SADJ,GAC8B,IAAd,KAAAA,SAAA,IAAoC,IAAK,EAAzC,KAAsBA,SAAtB,GAA6CA,SAA7C,GAAyD,IAAK+4B,CAAAA,aAAL,EAJ9E;AASmB,oBAAnB,KAAI,IAAKzzC,CAAAA,KAAT,IACI,IAAKwzC,CAAAA,qBAAL,EADJ;AAGA,cAAK+C,CAAAA,UAAL,GAAkB,IAAK77B,CAAAA,SAAvB;AACA,cAAK87B,CAAAA,QAAL,GAAgB,IAAhB;AAKA,cAAKx2C,CAAAA,KAAL,GAAa,SAAb;AACA,cAAKg4C,CAAAA,MAAOn4C,CAAAA,KAAZ,EAAA;AA3BA;AAJA;AAJG;AAqCPw3C,SAAK,EAAG;AACJ,UAAI1rC,EAAJ;AACK,UAAKioC,CAAAA,SAAV,IAIA,IAAK5zC,CAAAA,KACL,GADa,QACb,EAAA,IAAKw2C,CAAAA,QAAL,GAA4C,IAA5B,MAAC7qC,EAAD,GAAM,IAAKy9B,CAAAA,WAAX,KAA2C,IAAK,EAAhD,KAAoCz9B,EAApC,GAAoDA,EAApD,GAAyD,CALzE,IACI,IAAK+qC,CAAAA,gBADT,GAC4B,QAD5B;AAFI;AASRzqC,YAAQ,EAAG;AACY,eAAnB,KAAI,IAAKjM,CAAAA,KAAT,IACI,IAAKo3C,CAAAA,IAAL,EADJ;AAGA,UAAKV,CAAAA,gBAAL,GAAwB,IAAK12C,CAAAA,KAA7B,GAAqC,UAArC;AACA,UAAKw2C,CAAAA,QAAL,GAAgB,IAAhB;AALO;AAOXuB,UAAM,EAAG;AACL,UAAKnB,CAAAA,QAAL,EAAA;AACA,UAAK52C,CAAAA,KAAL,GAAa,UAAb;AACA,YAAM,CAAEm0B,UAAF,CAAA,GAAiB,IAAKtuB,CAAAA,OAA5B;AACAsuB,gBAAA,IAAcA,UAAA,EAAd;AAJK;AAMT3xB,UAAM,EAAG;AACmB,UAAxB,KAAI,IAAK+zC,CAAAA,UAAT,IACI,IAAKe,CAAAA,IAAL,CAAU,IAAKf,CAAAA,UAAf,CADJ;AAGA,UAAKK,CAAAA,QAAL,EAAA;AACA,UAAKpD,CAAAA,qBAAL,EAAA;AALK;AAOToD,YAAQ,EAAG;AACP,UAAK52C,CAAAA,KAAL,GAAa,MAAb;AACA,UAAKm4C,CAAAA,UAAL,EAAA;AACA,UAAKjE,CAAAA,sBAAL,EAAA;AACA,UAAKV,CAAAA,qBAAL,EAAA;AACA,UAAK94B,CAAAA,SAAL,GAAiB,IAAK67B,CAAAA,UAAtB,GAAmC,IAAnC;AACA,UAAKprC,CAAAA,QAAS3I,CAAAA,MAAd,EAAA;AANO;AAQX21C,cAAU,EAAG;AACJ,UAAKH,CAAAA,MAAV,KAEA,IAAKA,CAAAA,MAAO1c,CAAAA,IAAZ,EACA,EAAA,IAAK0c,CAAAA,MAAL,GAAcn3C,IAAAA,EAHd;AADS;AAMb8X,UAAM,CAACuU,IAAD,CAAO;AACT,UAAKxS,CAAAA,SAAL,GAAiB,CAAjB;AACA,aAAO,IAAK48B,CAAAA,IAAL,CAAUpqB,IAAV,EAAgB,CAAA,CAAhB,CAAP;AAFS;AAjWjB;AA8WA,QAAMkrB,oBAAoB,IAAIv2C,GAAJ,CAAQ,CAC9B,SAD8B,EAE9B,UAF8B,EAG9B,QAH8B,EAI9B,WAJ8B,CAAR,CAA1B,EA+BMw2C,gBAA8BlxC,WAAYmxC,CAAAA,IAAZ,CAAiB,EAAA,IAAMj/B,MAAOK,CAAAA,cAAewlB,CAAAA,IAAtB,CAA2BqZ,OAAQtZ,CAAAA,SAAnC,EAA8C,SAA9C,CAAvB,CA/BpC,EAsFMuZ,6BAA6B,CAC/B7M,UAD+B,EAE/BD,SAF+B,EAG/BK,SAH+B,CAtFnC;AA8FA,OAAM0M,qBAAN,QAAmCtF,cAAnC;AACIpjB,eAAW,CAAClqB,OAAD,CAAU;AACjB,WAAA,CAAMA,OAAN,CAAA;AACA,YAAM,CAAEkE,IAAF,EAAQpE,WAAR,EAAqBJ,OAArB,EAA8B6H,SAA9B,CAAA,GAA4C,IAAKvH,CAAAA,OAAvD;AACA,UAAKsF,CAAAA,QAAL,GAAgB,IAAIgnC,oBAAJ,CAAyB/kC,SAAzB,EAAoC,CAACI,iBAAD,EAAoBD,aAApB,CAAA,IAAsC,IAAKsmC,CAAAA,mBAAL,CAAyBrmC,iBAAzB,EAA4CD,aAA5C,CAA1E,EAAsIxD,IAAtI,EAA4IpE,WAA5I,EAAyJJ,OAAzJ,CAAhB;AACA,UAAK4F,CAAAA,QAASkmC,CAAAA,eAAd,EAAA;AAJiB;AAMrB+C,gBAAY,CAAChnC,SAAD,EAAYG,aAAZ,CAA2B;AACnC,UAAI,CAAEyC,QAAA,GAAW,GAAb,EAAkBoH,KAAlB,EAAyBzB,IAAzB,EAA+BhM,IAA/B,EAAqChE,WAArC,EAAkDoE,IAAlD,EAAwD2Q,SAAxD,CAAA,GAAuE,IAAK7U,CAAAA,OAAhF;AAKA,UAAI,CAACF,WAAYgkC,CAAAA,KAAjB,IAA0B,CAAChkC,WAAYgkC,CAAAA,KAAMhpC,CAAAA,OAA7C;AACI,eAAO,CAAA,CAAP;AADJ;AAQoB,cAApB,KAAI,MAAOgV,KAAX,IACItB,SAAUqkC,CAAAA,oBAAV,EADJ,IAEsB/iC,IAFtB,IAvBU6iC,0BAuBV,KAGI7iC,IAHJ,GAGW6iC,0BAAA,CAA2B7iC,IAA3B,CAHX;AAQA,UAAIyC,6BAAA,CAA8B,IAAKvS,CAAAA,OAAnC,CAAJ,CAAiD;AAC7C,cAAM,CAAEsuB,UAAF,EAAc3R,QAAd,EAAwB7c,WAAxB,EAAqCJ,OAArC,EAA8C,GAAGM,OAAjD,CAAA,GAA6D,IAAKA,CAAAA,OAAxE;AACA,YAAM8yC,wBAAwBpgC,oBAAA,CAAqBnL,SAArB,EAAgCvH,OAAhC,CAA9B;AACAuH,iBAAA,GAAYurC,qBAAsBvrC,CAAAA,SAAlC;AAIyB,SAAzB,KAAIA,SAAU3I,CAAAA,MAAd,KACI2I,SAAA,CAAU,CAAV,CADJ,GACmBA,SAAA,CAAU,CAAV,CADnB;AAGA4C,gBAAA,GAAW2oC,qBAAsB3oC,CAAAA,QAAjC;AACAoH,aAAA,GAAQuhC,qBAAsBvhC,CAAAA,KAA9B;AACAzB,YAAA,GAAOgjC,qBAAsBhjC,CAAAA,IAA7B;AACAhM,YAAA,GAAO,WAAP;AAb6C;AAe3CqO,2BAAAA,GAAYN,mBAAA,CAAoB/R,WAAYgkC,CAAAA,KAAMhpC,CAAAA,OAAtC,EAA+CoJ,IAA/C,EAAqDqD,SAArD,EAAgE,CAAE,GAAG,IAAKvH,CAAAA,OAAV,EAAmBmK,QAAnB,EAA6BoH,KAA7B,EAAoCzB,IAApC,CAAhE,CAAZqC;AAGNA,2BAAU0C,CAAAA,SAAV,GAAoC,IAAd,KAAAA,SAAA,IAAoC,IAAK,EAAzC,KAAsBA,SAAtB,GAA6CA,SAA7C,GAAyD,IAAK+4B,CAAAA,aAAL,EAA/E;AACI,UAAKmF,CAAAA,eAAT,IACIvkC,SAAUwkC,CAAAA,cAAV,CAAyB7gC,qBAAzB,EAAoC,IAAK4gC,CAAAA,eAAzC,CACA,EAAA,IAAKA,CAAAA,eAAL,GAAuB/3C,IAAAA,EAF3B,IAaImX,qBAAU8gC,CAAAA,QAbd,GAayB,EAAAC,IAAM;AACvB,cAAM,CAAE5kB,UAAF,CAAA,GAAiB,IAAKtuB,CAAAA,OAA5B;AACAF,mBAAYa,CAAAA,GAAZ,CAAgB2G,gBAAA,CAAiBC,SAAjB,EAA4B,IAAKvH,CAAAA,OAAjC,EAA0C0H,aAA1C,CAAhB,CAAA;AACA4mB,kBAAA,IAAcA,UAAA,EAAd;AACA,YAAK3xB,CAAAA,MAAL,EAAA;AACA,YAAK0xC,CAAAA,sBAAL,EAAA;AALuB,OAb/B;AAqBA,aAAO,CACHl8B,UAAAA,qBADG,EAEHhI,QAFG,EAGHoH,KAHG,EAIHzN,IAJG,EAKHgM,IALG,EAMQvI,SANR,CAAP;AA9DmC;AAuEnC,gBAAW,EAAA;AACX,UAAM,CAAEpH,QAAF,CAAA,GAAe,IAArB;AACA,UAAI,CAACA,QAAL;AACI,eAAO,CAAP;AADJ;AAEA,OAAM,CAAE,SAAAgK,QAAF,CAAN,GAAqBhK,QAArB;AACA,aAAOmB,WAAYyJ,CAAAA,qBAAZ,CAAkCZ,QAAlC,CAAP;AALW;AAOX,YAAO,EAAA;AACP,UAAM,CAAEhK,QAAF,CAAA,GAAe,IAArB;AACA,UAAI,CAACA,QAAL;AACI,eAAO,CAAP;AADJ;AAEA,OAAM,CAAE,UAAAgS,QAAF,CAAN,GAAsBhS,QAAtB;AACA,aAAOmB,WAAYyJ,CAAAA,qBAAZ,CAAkCoH,QAAUoxB,CAAAA,WAA5C,IAA2D,CAA3D,CAAP;AALO;AAOP,YAAI,CAACV,OAAD,CAAU;AACd,UAAM,CAAE1iC,QAAF,CAAA,GAAe,IAArB;AACKA,cAAL,KAEM,CAAE,UAAAgS,QAAF,CACN,GADsBhS,QACtB,EAAAgS,QAAUoxB,CAAAA,WAAV,GAAwBjiC,WAAYkJ,CAAAA,qBAAZ,CAAkCq4B,OAAlC,CAHxB;AAFc;AAOd,aAAQ,EAAA;AACR,UAAM,CAAE1iC,QAAF,CAAA,GAAe,IAArB;AACA,UAAI,CAACA,QAAL;AACI,eAAO,CAAP;AADJ;AAEA,OAAM,CAAE,UAAAgS,QAAF,CAAN,GAAsBhS,QAAtB;AACA,aAAOgS,QAAUghC,CAAAA,YAAjB;AALQ;AAOR,aAAK,CAACf,QAAD,CAAW;AAChB,UAAM,CAAEjyC,QAAF,CAAA,GAAe,IAArB;AACKA,cAAL,KAEM,CAAE,UAAAgS,QAAF,CACN,GADsBhS,QACtB,EAAAgS,QAAUghC,CAAAA,YAAV,GAAyBf,QAHzB;AAFgB;AAOhB,aAAQ,EAAA;AACR,UAAM,CAAEjyC,QAAF,CAAA,GAAe,IAArB;AACA,UAAI,CAACA,QAAL;AACI,eAAO,MAAP;AADJ;AAEA,OAAM,CAAE,UAAAgS,QAAF,CAAN,GAAsBhS,QAAtB;AACA,aAAOgS,QAAUihC,CAAAA,SAAjB;AALQ;AAOR,iBAAY,EAAA;AACZ,UAAM,CAAEjzC,QAAF,CAAA,GAAe,IAArB;AACA,UAAI,CAACA,QAAL;AACI,eAAO,IAAP;AADJ;AAEA,OAAM,CAAE,UAAAgS,QAAF,CAAN,GAAsBhS,QAAtB;AAGA,aAAOgS,QAAU0C,CAAAA,SAAjB;AAPY;AAahBm+B,kBAAc,CAACK,QAAD,CAAW;AACrB,UAAK,IAAKtF,CAAAA,SAAV,CAGK;AACD,YAAM,CAAE5tC,QAAF,CAAA,GAAe,IAArB;AACA,YAAI,CAACA,QAAL;AACI,iBAAOmB,WAAYC,CAAAA,IAAnB;AADJ;AAEA,SAAM,CAAE,UAAA4Q,QAAF,CAAN,GAAsBhS,QAAtB;AACAqO,iBAAUwkC,CAAAA,cAAV,CAAyB7gC,QAAzB,EAAoCkhC,QAApC,CAAA;AALC,OAHL;AACI,YAAKN,CAAAA,eAAL,GAAuBM,QAAvB;AADJ;AAUA,aAAO/xC,WAAYC,CAAAA,IAAnB;AAXqB;AAazBgwC,QAAI,EAAG;AACH,UAAS9D,CAAL,IAAKA,CAAAA,SAAT,CAAA;AAEA,YAAM,CAAEttC,QAAF,CAAA,GAAe,IAArB;AACKA,gBAAL,KAEM,CAAE,UAAAgS,QAAF,CAIN,GAJsBhS,QAItB,EAH4B,UAG5B,KAHIgS,QAAUihC,CAAAA,SAGd,IAFI,IAAKzF,CAAAA,qBAAL,EAEJ,EAAAx7B,QAAUo/B,CAAAA,IAAV,EANA;AAHA;AADG;AAYPC,SAAK,EAAG;AACJ,UAAM,CAAErxC,QAAF,CAAA,GAAe,IAArB;AACKA,cAAL,KAEM,CAAE,UAAAgS,QAAF,CACN,GADsBhS,QACtB,EAAAgS,QAAUq/B,CAAAA,KAAV,EAHA;AAFI;AAOR/b,QAAI,EAAG;AACH,UAAKnwB,CAAAA,QAAS3I,CAAAA,MAAd,EAAA;AACA,UAAK8wC,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AACA,UAAmB,MAAnB,KAAI,IAAKtzC,CAAAA,KAAT,CAAA;AAEA,YAAKk0C,CAAAA,sBAAL,EAAA;AACA,YAAKV,CAAAA,qBAAL,EAAA;AACA,YAAM,CAAExtC,QAAF,CAAA,GAAe,IAArB;AACA,YAAKA,QAAL,CAAA;AAEA,cAAM,CAAEgS,SAAF,EAAa5K,SAAb,EAAwB4C,QAAxB,EAAkCrG,IAAlC,EAAwCgM,IAAxC,EAA8CyB,KAA9C,CAAA,GAAwDpR,QAA9D;AACA,cAA4B,MAA5B,KAAIgS,SAAUihC,CAAAA,SAAd,IAC4B,UAD5B,KACIjhC,SAAUihC,CAAAA,SADd,CAAA;AAYA,gBAAI,IAAK/rB,CAAAA,IAAT,CAAe;AACX,oBAAM,CAAEvnB,WAAF,EAAe6c,QAAf,EAAyB2R,UAAzB,EAAqC5uB,OAArC,EAA8C,GAAGM,OAAjD,CAAA,GAA6D,IAAKA,CAAAA,OAAxE;AACM2S,sBAAAA,GAAkB,IAAIC,mBAAJ,CAAwB,CAC5C,GAAG5S,OADyC,EAE5CuH,SAF4C,EAG5C4C,QAH4C,EAI5CrG,IAJ4C,EAK5CgM,IAL4C,EAM5CyB,KAN4C,EAO5CiB,YAAa,CAAA,CAP+B,CAAxB,CAAlBG;AASN,oBAAM2gC,aAAahyC,WAAYkJ,CAAAA,qBAAZ,CAAkC,IAAK6c,CAAAA,IAAvC,CAAnB;AACAvnB,yBAAY4kC,CAAAA,eAAZ,CAA4B/xB,QAAgBG,CAAAA,MAAhB,CAAuBwgC,UAAvB,GAhQpBvgC,EAgQoB,CAAiDzY,CAAAA,KAA7E,EAAoFqY,QAAgBG,CAAAA,MAAhB,CAAuBwgC,UAAvB,CAAmCh5C,CAAAA,KAAvH,EAhQQyY,EAgQR,CAAA;AAZW;AAcf,aAAM,CAAE,OAAA4iB,QAAF,CAAN,GAAmB,IAAK31B,CAAAA,OAAxB;AACA21B,oBAAA,IAAUA,QAAA,EAAV;AACA,gBAAKh5B,CAAAA,MAAL,EAAA;AA5BA;AAHA;AALA;AAHG;AAyCPyJ,YAAQ,EAAG;AACP,YAAM,CAAEjG,QAAF,CAAA,GAAe,IAArB;AACKA,cAAL,IAEAA,QAASgS,CAAAA,SAAU+/B,CAAAA,MAAnB,EAFA;AAFO;AAMXv1C,UAAM,EAAG;AACL,YAAM,CAAEwD,QAAF,CAAA,GAAe,IAArB;AACKA,cAAL,IAEAA,QAASgS,CAAAA,SAAUxV,CAAAA,MAAnB,EAFA;AAFK;AAMF42C,mBAAQ,CAACvzC,OAAD,CAAU;AACrB,YAAM,CAAEF,WAAF,EAAeoE,IAAf,EAAqBoP,WAArB,EAAkC7L,UAAlC,EAA8CuE,OAA9C,EAAuDlI,IAAvD,CAAA,GAAgE9D,OAAtE;AACA,UAAI,EAACF,WAAD,IACCA,WAAYgkC,CAAAA,KADb,IAEEhkC,WAAYgkC,CAAAA,KAAMhpC,CAAAA,OAFpB,YAEuC04C,WAFvC,CAAJ;AAGI,eAAO,CAAA,CAAP;AAHJ;AAKA,YAAM,CAAE72B,QAAF,EAAYuD,iBAAZ,CAAA,GAAkCpgB,WAAYgkC,CAAAA,KAAM3oC,CAAAA,QAAlB,EAAxC;AACA,aAAQq3C,aAAA,EAAR,IACItuC,IADJ,IAEIquC,iBAAkB72C,CAAAA,GAAlB,CAAsBwI,IAAtB,CAFJ,IAOI,CAACyY,QAPL,IAQI,CAACuD,iBARL,IASI,CAAC5M,WATL,IAUmB,QAVnB,KAUI7L,UAVJ,IAWgB,CAXhB,KAWIuE,OAXJ,IAYa,SAZb,KAYIlI,IAZJ;AARqB;AA1N7B;AAkPA,QAAM2vC,oBAAoB,CACtB3vC,KAAM,QADgB,EAEtBiI,UAAW,GAFW,EAGtBC,QAAS,EAHa,EAItBkB,UAAW,EAJW,CAA1B,EAYMwmC,sBAAsB,CACxB5vC,KAAM,WADkB,EAExBqG,SAAU,GAFc,CAZ5B,EAoBM2F,OAAO,CACThM,KAAM,WADG,EAETgM,KAAM,CAAC,IAAD,EAAO,GAAP,EAAY,IAAZ,EAAkB,CAAlB,CAFG,EAGT3F,SAAU,GAHD,CApBb,EAyBM8J,uBAAuB,CAAC0/B,QAAD,EAAW,CAAEpsC,SAAF,CAAX,CAAA0M,IACF,CAAvB,GAAI1M,SAAU3I,CAAAA,MAAd,GACW80C,mBADX,GAGSxyB,cAAexlB,CAAAA,GAAf,CAAmBi4C,QAAnB,CAAJ,GACMA,QAASxwC,CAAAA,UAAT,CAAoB,OAApB,CAAA,GAxB6B,CACxCW,KAAM,QADkC,EAExCiI,UAAW,GAF6B,EAGxCC,QAAoB,CAAX,KAsBwBzE,SAAAjH,CAAU,CAAVA,CAtBxB,GAAe,CAAf,GAAmB/B,IAAK4M,CAAAA,IAAL,CAAU,GAAV,CAAnB,GAAoC,EAHL,EAIxC+B,UAAW,EAJ6B,CAwB7B,GAEDumC,iBAHL,GAKE3jC,IAlCX,EA8CMiF;AAAqB,GAAC7Q,IAAD,EAAO5J,KAAP,EAAcgG,MAAd,EAAsBD,UAAA,GAAa,EAAnC,EAAuCX,OAAvC,EAAgDgV,SAAhD,CAAAK,IAA+DuZ,UAAD,IAAgB;AACrG,UAAM9Z,kBAAkBhG,SAAUiG,CAAAA,kBAAV,CAA6BpU,UAA7B,EAAyC6D,IAAzC,CAAlBsQ,IAAoE,EAA1E;AAMA,QAAMzC,QAAQyC,eAAgBzC,CAAAA,KAAxBA,IAAiC1R,UAAW0R,CAAAA,KAA5CA,IAAqD,CAA3D;AAKA,QAAI,CAAEwB,OAAA,GAAU,CAAZ,CAAA,GAAkBlT,UAAtB;AACUkT,WAAV,IAAoBjS,WAAYkJ,CAAAA,qBAAZ,CAAkCuH,KAAlC,CAApB;AACA,QAAI/R,UAAU,CACVuH,UAAWhH,KAAMC,CAAAA,OAAN,CAAcF,MAAd,CAAA,GAAwBA,MAAxB,GAAiC,CAAC,IAAD,EAAOA,MAAP,CADlC,EAEVwP,KAAM,SAFI,EAGV/U,SAAUT,KAAMG,CAAAA,WAAN,EAHA,EAIV,GAAG+Z,eAJO,EAKVzC,MAAO,CAACwB,OALE,EAMVoJ,SAAW5iB,CAAD4iB,IAAO;AACbriB,WAAMqG,CAAAA,GAAN,CAAU5G,CAAV,CAAA;AACAya,qBAAgBmI,CAAAA,QAAhB,IAA4BnI,eAAgBmI,CAAAA,QAAhB,CAAyB5iB,CAAzB,CAA5B;AAFa,KANP,EAUVu0B,WAAY,EAAAA,IAAM;AACdA,gBAAA,EAAA;AACA9Z,qBAAgB8Z,CAAAA,UAAhB,IAA8B9Z,eAAgB8Z,CAAAA,UAAhB,EAA9B;AAFc,KAVR,EAcVpqB,IAdU,EAeVpE,YAAaxF,KAfH,EAgBVoF,QAASgV,SAAA,GAAY1Z,IAAAA,EAAZ,GAAwB0E,OAhBvB,CAAd;AAsBKsT,uBAAA,CAAoBwB,eAApB,CAAL,KACIxU,OADJ,GACc,CACN,GAAGA,OADG,EAEN,GAAGiU,oBAAA,CAAqB/P,IAArB,EAA2BlE,OAA3B,CAFG,CADd;AAWIA,WAAQmK,CAAAA,QAAZ,KACInK,OAAQmK,CAAAA,QADZ,GACuB7I,WAAYkJ,CAAAA,qBAAZ,CAAkCxK,OAAQmK,CAAAA,QAA1C,CADvB;AAGInK,WAAQsT,CAAAA,WAAZ,KACItT,OAAQsT,CAAAA,WADZ,GAC0BhS,WAAYkJ,CAAAA,qBAAZ,CAAkCxK,OAAQsT,CAAAA,WAA1C,CAD1B;AAGqBtY,QAAAA,EAArB,KAAIgF,OAAQoF,CAAAA,IAAZ,KACIpF,OAAQuH,CAAAA,SAAR,CAAkB,CAAlB,CADJ,GAC2BvH,OAAQoF,CAAAA,IADnC;AAGIwuC,SAAAA,GAAa,CAAA,CAAbA;AACJ,QAAqB,CAAA,CAArB,KAAI5zC,OAAQ8D,CAAAA,IAAZ,IAC0B,CAD1B,KACK9D,OAAQmK,CAAAA,QADb,IAC+B,CAACnK,OAAQsT,CAAAA,WADxC;AAEItT,aAAQmK,CAAAA,QACR,GADmB,CACnB,EAAsB,CAAtB,KAAInK,OAAQ+R,CAAAA,KAAZ,KACI6hC,KADJ,GACiB,CAAA,CADjB,CAAA;AAHJ;AAOA,QAAIpO,qBAAsB1qC,CAAAA,OAA1B,IACIqD,kBAAmBukC,CAAAA,cADvB;AAEIkR,WAEA,GAFa,CAAA,CAEb,EADA5zC,OAAQmK,CAAAA,QACR,GADmB,CACnB,EAAAnK,OAAQ+R,CAAAA,KAAR,GAAgB,CAAhB;AAJJ;AAWA,QAAI6hC,KAAJ,IAAkB,CAACl/B,SAAnB,IAAgD1Z,IAAAA,EAAhD,KAAgCV,KAAME,CAAAA,GAAN,EAAhC,CAA2D;AACvD,YAAMkN,gBAAgBJ,gBAAA,CAAiBtH,OAAQuH,CAAAA,SAAzB,EAAoCiN,eAApC,CAAtB;AACA,UAAsBxZ,IAAAA,EAAtB,KAAI0M,aAAJ;AAOI,eANAoN,KAAMhX,CAAAA,MAAN,CAAa,EAAA,IAAM;AACfkC,iBAAQ2c,CAAAA,QAAR,CAAiBjV,aAAjB,CAAA;AACA1H,iBAAQsuB,CAAAA,UAAR,EAAA;AAFe,SAAnB,CAMO,EAAA,IAAI9f,SAAUqlC,CAAAA,qBAAd,CAAoC,EAApC,CAAP;AAPJ;AAFuD;AAiB3D,WAAI,CAACn/B,SAAL,IAAkBk+B,oBAAqBW,CAAAA,QAArB,CAA8BvzC,OAA9B,CAAlB,GACW,IAAI4yC,oBAAJ,CAAyB5yC,OAAzB,CADX,GAIW,IAAI4S,mBAAJ,CAAwB5S,OAAxB,CAJX;AA5FqG,GA9CzG,EA2TM8zC,uBAAuB,mEAAA,CAAA,KAAA,CAAA,GAAA,CA3T7B,EAoUM18B,eAAe,CAAC,SAAD,EAAY,GAAG08B,oBAAf,CApUrB,EAsUM38B,kBAAkBC,YAAaxY,CAAAA,MAtUrC,EA8VMmZ,uBAAuB,CAAC,GAAG+7B,oBAAJ,CAA0BpjC,CAAAA,OAA1B,EA9V7B,EA+VMoH,oBAAoBg8B,oBAAqBl1C,CAAAA,MA/V/C;AA4qBA,OAAMm1C,QAAN;AACI7pB,eAAW,CAAC5D,IAAD,CAAO;AACd,UAAK8X,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AACA,UAAK9X,CAAAA,IAAL,GAAYA,IAAZ;AAFc;AAIlBxoB,UAAM,EAAG;;AALb;AAQA,OAAMk2C,iBAAN,QAA+BD,QAA/B;AAMI7pB,eAAW,CAAC5D,IAAD,CAAO;AACd,WAAA,CAAMA,IAAN,CAAA;AACAA,UAAKlS,CAAAA,cAAL,KAAwBkS,IAAKlS,CAAAA,cAA7B,GAA8CmD,oBAAA,CAAqB+O,IAArB,CAA9C;AAFc;AAIlB2tB,uCAAmC,EAAG;AAClC,YAAM,CAAE/hC,OAAF,CAAA,GAAc,IAAKoU,CAAAA,IAAKnrB,CAAAA,QAAV,EAApB;AACIrB,yBAAA,CAAoBoY,OAApB,CAAJ,KACI,IAAKgiC,CAAAA,eADT,GAC2BhiC,OAAQsM,CAAAA,SAAR,CAAkB,IAAK8H,CAAAA,IAAvB,CAD3B;AAFkC;AAStCuG,SAAK,EAAG;AACJ,UAAKonB,CAAAA,mCAAL,EAAA;AADI;AAGRn2C,UAAM,EAAG;AACL,YAAM,CAAEoU,OAAF,CAAA,GAAc,IAAKoU,CAAAA,IAAKnrB,CAAAA,QAAV,EAApB,EACM,CAAE,QAASg5C,WAAX,CAAA,GAA2B,IAAK7tB,CAAAA,IAAKtC,CAAAA,SAArC,IAAkD,EADxD;AAEI9R,aAAJ,KAAgBiiC,WAAhB,IACI,IAAKF,CAAAA,mCAAL,EADJ;AAHK;AAOTvlB,WAAO,EAAG;AACN,UAAI5oB,EAAJ;AACA,UAAKwgB,CAAAA,IAAKlS,CAAAA,cAAe0F,CAAAA,KAAzB,EAAA;AACgC,UAAhC,MAAChU,EAAD,GAAM,IAAKouC,CAAAA,eAAX,KAA+C,IAAK,EAApD,KAAwCpuC,EAAxC,IAAiEA,EAAGuzB,CAAAA,IAAH,CAAQ,IAAR,CAAjE;AAHM;AA7Bd;AAoCA,MAAI+a,OAAO,CAAX;AACA,OAAMC,qBAAN,QAAmCN,QAAnC;AACI7pB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKx1B,CAAAA,EAAL,GAAUs1B,IAAA,EAAV;AAFU;AAIdt2C,UAAM,EAAG;AACL,UAAK,IAAKwoB,CAAAA,IAAK/Q,CAAAA,eAAf,CAAA;AAEA,YAAM,CAAEoJ,SAAF,EAAaC,cAAb,CAAA,GAAgC,IAAK0H,CAAAA,IAAK/Q,CAAAA,eAAhD,EACM,CAAE,UAAWg/B,aAAb,CAAA,GAA+B,IAAKjuB,CAAAA,IAAKkuB,CAAAA,mBAAzC,IAAgE,EADtE;AAEK,YAAKluB,CAAAA,IAAKlS,CAAAA,cAAf,IAAiCuK,SAAjC,KAA+C41B,aAA/C,KAGME,aACN,GADsB,IAAKnuB,CAAAA,IAAKlS,CAAAA,cAAeuF,CAAAA,SAAzB,CAAmC,MAAnC,EAA2C,CAACgF,SAA5C,CACtB,EAAIC,cAAJ,IAAsB,CAACD,SAAvB,IACI81B,aAAcr/B,CAAAA,IAAd,CAAmB,EAAA,IAAM;AACrBwJ,wBAAA,CAAe,IAAKE,CAAAA,EAApB,CAAA;AADqB,SAAzB,CALJ;AAJA;AADK;AAeT+N,SAAK,EAAG;AACJ,YAAM,CAAEhO,QAAF,EAAYD,cAAZ,CAAA,GAA+B,IAAK0H,CAAAA,IAAK/Q,CAAAA,eAAzC,IAA4D,EAAlE;AACIqJ,oBAAJ,IACIA,cAAA,CAAe,IAAKE,CAAAA,EAApB,CADJ;AAGID,cAAJ,KACI,IAAK6P,CAAAA,OADT,GACmB7P,QAAA,CAAS,IAAKC,CAAAA,EAAd,CADnB;AALI;AASR4P,WAAO,EAAG;;AA7Bd;AAgCA,QAAMxa,aAAa,CACf/B,UAAW,CACP4hC,QAASC,gBADF,CADI,EAIf35B,KAAM,CACF05B,QAASM,oBADP,CAJS,CAAnB,EASMpX,gBAAgC9gB,KAAMsmB,CAAAA,aAAN,CAAoB,EAApB,CATtC,EAWM7O,kBAAkB,EAAAA,IAAO,EAC3BhZ,UAAW,CADgB,EAE3BD,MAAO,CAFoB,EAG3B1R,OAAQ,CAHmB,EAI3BwR,YAAa,CAJc,EAX/B,EAsBMmW,YAAY,EAAAA,IAAO,EACrB/uB,EAFsB,CAAEpD,IAAK,CAAP,EAAUD,IAAK,CAAf,CACD,EAErB2c,EAHsB,CAAE1c,IAAK,CAAP,EAAUD,IAAK,CAAf,CACD,EAtBzB,EAkFMgd,mBAAmB,IAAIxf,GAAJ,CAAQ,2WAAA,CAAA,KAAA,CAAA,GAAA,CAAR,CAlFzB;AAoIA,MAAI2f,gBAAiBphB,GAADohB,IAAS,CAACJ,iBAAA,CAAkBhhB,GAAlB,CAA9B;AAoBA,KAAI;AAMAkhB,2BAAA,CAAwB9hB,OAAA,CAAQ,2EAAR,CAAkC+T,CAAAA,OAA1D,CAAA;AANA,GAQJ,QAAO5H,EAAP,CAAW;;AA+BX,QAAM4Y,kBACUvC,KAAMsmB,CAAAA,aAAN,CAAoB,IAApB,CADhB,EAsDMiS,qBAAsBre,MAADqe,IAAY,CAAC/5C,KAAD,EAAQ6kC,QAAR,CAAA,IAAqB;AACxD,UAAMxoB,UAAUmF,KAAMsC,CAAAA,UAAN,CAAiBwe,aAAjB,CAAhB,EACM1nB,kBAAkB4G,KAAMsC,CAAAA,UAAN,CAAiBC,eAAjB,CADxB,EAEMi2B,OAAO,EAAAA,IAAMn4B,SAAA,CAAU6Z,MAAV,EAAkB17B,KAAlB,EAAyBqc,OAAzB,EAAkCzB,eAAlC,CAFnB;AAGA,WAAOiqB,QAAA,GAAWmV,IAAA,EAAX,GAAoB14B,WAAA,CAAY04B,IAAZ,CAA3B;AAJwD,GAtD5D,EAiIMr2B,iBAAkBV,OAADU,IACXL,KAAD,IAAWzP,SAAUomC,CAAAA,gBAAV,CAA2B32B,KAA3B,CAAX,IAAgDL,OAAA,CAAQK,KAAR,EAAeD,gBAAA,CAAiBC,KAAjB,CAAf,CAlI3D,EAyIMyB,YAA8B,WAA9BA,KAAY,MAAOzZ,OAzIzB,EA2IMw4B,4BAA4B/e,SAAA,GAAYvD,KAAM04B,CAAAA,eAAlB,GAAoC14B,KAAM6C,CAAAA,SA3I5E,EAgJM8e,sBAAsB3hB,KAAMsmB,CAAAA,aAAN,CAAoB,CAC5ClJ,mBAAqBzxB,CAADyxB,IAAOzxB,CADiB,EAE5C03B,SAAU,CAAA,CAFkC,EAG5CzB,cAAe,OAH6B,CAApB,CAhJ5B,EA8NM+W,qBAAqB,IAAIC,OAAJ,EA9N3B,EAoOMC,eAAe,CACjB7iC,UAAW,4EAAA,CAAA,KAAA,CAAA,GAAA,CADM;AAWjBkI,OAAM,CAAC,MAAD,CAXW,EAYjBwgB,KAAM,CAAC,MAAD,EAAS,cAAT,CAZW,EAajBoa,MAAO,CAAC,YAAD,CAbU,EAcjBC,MAAO,CAAC,YAAD,EAAe,cAAf,EAA+B,YAA/B,CAdU,EAejBC,IAAK,CAAC,UAAD,EAAa,OAAb,EAAsB,YAAtB,EAAoC,aAApC,CAfY,EAgBjBC,IAAK,CAAC,OAAD,EAAU,YAAV,EAAwB,mBAAxB,EAA6C,UAA7C,CAhBY,EAiBjBC,OAAQ,CAAC,aAAD,EAAgB,iBAAhB,EAAmC,iBAAnC,CAjBS,EAkBjB/5B,OAAQ,CAAC,QAAD,EAAW,UAAX,CAlBS,CApOrB,EAwPM4d,qBAAqB,EAxP3B;AAyPA,OAAK,MAAM3+B,GAAX,GAAkBy6C,aAAlB;AACI9b,sBAAA,CAAmB3+B,GAAnB,CAAA,GAA0B,CACtBulC,UAAYnlC,KAADmlC,IAAWkV,YAAA,CAAaz6C,GAAb,CAAkB+R,CAAAA,IAAlB,CAAwBpI,IAAD,IAAU,CAAC,CAACvJ,KAAA,CAAMuJ,IAAN,CAAnC,CADA,CAA1B;AADJ;AAOA,QAAM6b,uBAAuB,CAAEjlB,QAAS,IAAX,CAA7B,EACM2kB,2BAA2B,CAAE3kB,QAAS,CAAA,CAAX,CADjC,EAqBMw6C,aAAa,CAAC,GAAGlJ,mBAAJ,EAAyB/pC,KAAzB,EAAgCwC,OAAhC,CArBnB,EAiFM0wC,oBAAoB,wHAAA,CAAA,KAAA,CAAA,GAAA,CAjF1B;AA8FA,OAAMC,cAAN;AAQI/4B,+BAA2B,CAACg5B,MAAD,EAASC,UAAT,EAAqBC,cAArB,CAAqC;AAC5D,aAAO,EAAP;AAD4D;AAGhEzrB,eAAW,CAAC,CAAEjT,MAAF,EAAUtc,KAAV,EAAiB4a,eAAjB,EAAkCsoB,mBAAlC,EAAuDzkB,qBAAvD,EAA8EikB,WAA9E,CAAD,EAA+Fr9B,OAAA,GAAU,EAAzG,CAA6G;AAKpH,UAAKlF,CAAAA,OAAL,GAAe,IAAf;AAIA,UAAKsvB,CAAAA,QAAL,GAAgB,IAAIpuB,GAAJ,EAAhB;AAKA,UAAK+a,CAAAA,qBAAL,GADA,IAAKiF,CAAAA,aACL,GADqB,CAAA,CACrB;AAQA,UAAKhH,CAAAA,kBAAL,GAA0B,IAA1B;AAMA,UAAK5a,CAAAA,MAAL,GAAc,IAAIuL,GAAJ,EAAd;AACA,UAAKylC,CAAAA,gBAAL,GAAwBA,gBAAxB;AAIA,UAAKnS,CAAAA,QAAL,GAAgB,EAAhB;AAKA,UAAK2c,CAAAA,kBAAL,GAA0B,IAAIjwC,GAAJ,EAA1B;AAMA,UAAKkwC,CAAAA,gBAAL,GAAwB,EAAxB;AAIA,UAAKzS,CAAAA,MAAL,GAAc,EAAd;AAMA,UAAK0S,CAAAA,sBAAL,GAA8B,EAA9B;AACA,UAAKC,CAAAA,YAAL,GAAoB,EAAAC,IAAM,IAAK1/B,CAAAA,MAAL,CAAY,QAAZ,EAAsB,IAAKhC,CAAAA,YAA3B,CAA1B;AACA,UAAKtW,CAAAA,MAAL,GAAc,EAAAi4C,IAAM;AACX,YAAKn7C,CAAAA,OAAV,KAEA,IAAKo7C,CAAAA,YAAL,EACA,EAAA,IAAKC,CAAAA,cAAL,CAAoB,IAAKr7C,CAAAA,OAAzB,EAAkC,IAAK+hB,CAAAA,WAAvC,EAAoD,IAAKliB,CAAAA,KAAMkmB,CAAAA,KAA/D,EAAsE,IAAKmC,CAAAA,UAA3E,CAHA;AADgB,OAApB;AAMA,UAAKozB,CAAAA,iBAAL,GAAyB,GAAzB;AACA,UAAK/kB,CAAAA,cAAL,GAAsB,EAAAglB,IAAM;AACxB,cAAM/3C,MAAM+oB,IAAK/oB,CAAAA,GAAL,EAAZ;AACI,YAAK83C,CAAAA,iBAAT,GAA6B93C,GAA7B,KACI,IAAK83C,CAAAA,iBACL,GADyB93C,GACzB,EAAAwW,KAAM9W,CAAAA,MAAN,CAAa,IAAKA,CAAAA,MAAlB,EAA0B,CAAA,CAA1B,EAAiC,CAAA,CAAjC,CAFJ;AAFwB,OAA5B;AAOA,YAAM,CAAEsW,YAAF,EAAgBuI,WAAhB,EAA6BF,QAA7B,CAAA,GAA0C0gB,WAAhD;AACA,UAAK1gB,CAAAA,QAAL,GAAgBA,QAAhB;AACA,UAAKrI,CAAAA,YAAL,GAAoBA,YAApB;AACA,UAAKgiC,CAAAA,UAAL,GAAkB,CAAE,GAAGhiC,YAAL,CAAlB;AACA,UAAKiiC,CAAAA,aAAL,GAAqB57C,KAAMuc,CAAAA,OAAN,GAAgB,CAAE,GAAG5C,YAAL,CAAhB,GAAsC,EAA3D;AACA,UAAKuI,CAAAA,WAAL,GAAmBA,WAAnB;AACA,UAAK5F,CAAAA,MAAL,GAAcA,MAAd;AACA,UAAKtc,CAAAA,KAAL,GAAaA,KAAb;AACA,UAAK4a,CAAAA,eAAL,GAAuBA,eAAvB;AACA,UAAK/O,CAAAA,KAAL,GAAayQ,MAAA,GAASA,MAAOzQ,CAAAA,KAAhB,GAAwB,CAAxB,GAA4B,CAAzC;AACA,UAAKq3B,CAAAA,mBAAL,GAA2BA,mBAA3B;AACA,UAAK79B,CAAAA,OAAL,GAAeA,OAAf;AACA,UAAKoZ,CAAAA,qBAAL,GAA6B,CAAA,CAAQA,qBAArC;AACA,UAAKrC,CAAAA,qBAAL,GAA6BA,qBAAA,CAAsBpc,KAAtB,CAA7B;AAEA,UADA,IAAKqhB,CAAAA,aACL,GADqBA,aAAA,CAAcrhB,KAAd,CACrB;AACI,YAAKgb,CAAAA,eAAL,GAAuB,IAAI3Z,GAAJ,EAAvB;AADJ;AAGA,UAAKsc,CAAAA,sBAAL,GAA8B,EAAQrB,CAAAA,MAAR,IAAyBnc,CAAPmc,MAAOnc,CAAAA,OAAzB,CAA9B;AAWA,YAAM,CAAEgG,UAAF,EAAc,GAAG01C,mBAAjB,CAAA,GAAyC,IAAK/5B,CAAAA,2BAAL,CAAiC9hB,KAAjC,EAAwC,EAAxC,EAA4C,IAA5C,CAA/C;AACA,WAAK,MAAMJ,GAAX,GAAkBi8C,oBAAlB;AACUl8C,cACN,GADck8C,mBAAA,CAAoBj8C,GAApB,CACd,EAA0BS,IAAAA,EAA1B,KAAIsZ,YAAA,CAAa/Z,GAAb,CAAJ,IAAqDD,MAArD,IAAqDA,MAr7HTG,CAAAA,WAq7H5C,IACIH,MAAMqG,CAAAA,GAAN,CAAU2T,YAAA,CAAa/Z,GAAb,CAAV,EAA6B,CAAA,CAA7B,CADJ;AAFJ;AApGoH;AA2GxHsyB,SAAK,CAAC9P,QAAD,CAAW;AACZ,UAAKjiB,CAAAA,OAAL,GAAeiiB,QAAf;AACA+3B,wBAAmBn0C,CAAAA,GAAnB,CAAuBoc,QAAvB,EAAiC,IAAjC,CAAA;AACI,UAAKiG,CAAAA,UAAT,IAAuB,CAAC,IAAKA,CAAAA,UAAWjG,CAAAA,QAAxC,IACI,IAAKiG,CAAAA,UAAW6J,CAAAA,KAAhB,CAAsB9P,QAAtB,CADJ;AAGI,UAAK9F,CAAAA,MAAT,IAAmB,IAAK+E,CAAAA,aAAxB,IAAyC,CAAC,IAAKjF,CAAAA,qBAA/C,KACI,IAAK0/B,CAAAA,qBADT,GACiC,IAAKx/B,CAAAA,MAAOy/B,CAAAA,eAAZ,CAA4B,IAA5B,CADjC;AAGA,UAAKt8C,CAAAA,MAAOC,CAAAA,OAAZ,CAAoB,CAACC,KAAD,EAAQC,GAAR,CAAA,IAAgB,IAAKo8C,CAAAA,iBAAL,CAAuBp8C,GAAvB,EAA4BD,KAA5B,CAApC,CAAA;AACKmlB,8BAAyB3kB,CAAAA,OAA9B,IACI0kB,wBAAA,EADJ;AAGA,UAAKxK,CAAAA,kBAAL,GACiC,OAA7B,KAAA,IAAK6oB,CAAAA,mBAAL,GACM,CAAA,CADN,GAEmC,QAA7B,KAAA,IAAKA,CAAAA,mBAAL,GACI,CAAA,CADJ,GAEI9d,oBAAqBjlB,CAAAA,OALnC;AAOIyE,cAAA,CAAqC,CAAA,CAArC,KAAS,IAAKyV,CAAAA,kBAAd,EAA2C,wFAA3C,CAAA;AAEA,UAAKiC,CAAAA,MAAT,IACI,IAAKA,CAAAA,MAAOmT,CAAAA,QAAS1tB,CAAAA,GAArB,CAAyB,IAAzB,CADJ;AAEA,UAAKoB,CAAAA,MAAL,CAAY,IAAKnD,CAAAA,KAAjB,EAAwB,IAAK4a,CAAAA,eAA7B,CAAA;AAxBY;AA0BhBmZ,WAAO,EAAG;AACN,UAAK1L,CAAAA,UAAL,IAAmB,IAAKA,CAAAA,UAAW0L,CAAAA,OAAhB,EAAnB;AACAnH,iBAAA,CAAY,IAAKwuB,CAAAA,YAAjB,CAAA;AACAxuB,iBAAA,CAAY,IAAKvpB,CAAAA,MAAjB,CAAA;AACA,UAAK43C,CAAAA,kBAAmBv7C,CAAAA,OAAxB,CAAiCu0B,MAAD,IAAYA,MAAA,EAA5C,CAAA;AACA,UAAKgnB,CAAAA,kBAAmB14C,CAAAA,KAAxB,EAAA;AACA,UAAKu5C,CAAAA,qBAAL,IAA8B,IAAKA,CAAAA,qBAAL,EAA9B;AACA,UAAKx/B,CAAAA,MAAL,IAAe,IAAKA,CAAAA,MAAOmT,CAAAA,QAASxtB,CAAAA,MAArB,CAA4B,IAA5B,CAAf;AACA,WAAK,IAAMrC,YAAX,GAAkB,KAAK6oC,CAAAA,MAAvB;AACI,YAAKA,CAAAA,MAAL,CAAY7oC,YAAZ,CAAiB2C,CAAAA,KAAjB,EAAA;AADJ;AAGA,WAAK,MAAM3C,GAAX,GAAkB,KAAK0+B,CAAAA,QAAvB;AAEI,YADM2d,YACN,GADgB,IAAK3d,CAAAA,QAAL,CAAc1+B,GAAd,CAChB;AACIq8C,sBAAQloB,CAAAA,OAAR,EACA,EAAAkoB,YAAQxY,CAAAA,SAAR,GAAoB,CAAA,CAApB;AAFJ;AAFJ;AAOA,UAAKtjC,CAAAA,OAAL,GAAe,IAAf;AAlBM;AAoBV67C,qBAAiB,CAACp8C,GAAD,EAAMD,KAAN,CAAa;AACtB,UAAKs7C,CAAAA,kBAAmBl6C,CAAAA,GAAxB,CAA4BnB,GAA5B,CAAJ,IACI,IAAKq7C,CAAAA,kBAAmBp7C,CAAAA,GAAxB,CAA4BD,GAA5B,CAAA,EADJ;AAGA,YAAMs8C,mBAAmB31B,cAAexlB,CAAAA,GAAf,CAAmBnB,GAAnB,CAAzB;AACA,UAAIs8C,gBAAJ,IAAwB,IAAKC,CAAAA,eAA7B;AACI,YAAKA,CAAAA,eAAL,EAAA;AADJ;AAGA,YAAMC,iBAAiBz8C,KAAM6pC,CAAAA,EAAN,CAAS,QAAT,EAAoB6S,WAAD,IAAiB;AACvD,YAAK1iC,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAA,GAAyBy8C,WAAzB;AACA,YAAKr8C,CAAAA,KAAMgiB,CAAAA,QAAX,IAAuB7H,KAAM/W,CAAAA,SAAN,CAAgB,IAAKg4C,CAAAA,YAArB,CAAvB;AACIc,wBAAJ,IAAwB,IAAK7zB,CAAAA,UAA7B,KACI,IAAKA,CAAAA,UAAW2H,CAAAA,gBADpB,GACuC,CAAA,CADvC;AAHuD,OAApC,CAAvB,EAOMssB,wBAAwB38C,KAAM6pC,CAAAA,EAAN,CAAS,eAAT,EAA0B,IAAK9S,CAAAA,cAA/B,CAP9B;AAQA,UAAI6lB,eAAJ;AACIjxC,YAAOkxC,CAAAA,qBAAX,KACID,eADJ,GACsBjxC,MAAOkxC,CAAAA,qBAAP,CAA6B,IAA7B,EAAmC58C,GAAnC,EAAwCD,KAAxC,CADtB;AAGA,UAAKs7C,CAAAA,kBAAmBj1C,CAAAA,GAAxB,CAA4BpG,GAA5B,EAAiC,EAAA,IAAM;AACnCw8C,sBAAA,EAAA;AACAE,6BAAA,EAAA;AACIC,uBAAJ,IACIA,eAAA,EADJ;AAEI58C,aAAMwpC,CAAAA,KAAV,IACIxpC,KAAMm7B,CAAAA,IAAN,EADJ;AALmC,OAAvC,CAAA;AApB0B;AA6B9Blf,oBAAgB,CAAC6gC,KAAD,CAAQ;AAIpB,aAAK,IAAKt8C,CAAAA,OAAV,IACK,IAAKu8C,CAAAA,wBADV,IAEI,IAAKvzC,CAAAA,IAFT,KAEkBszC,KAAMtzC,CAAAA,IAFxB,GAKO,IAAKuzC,CAAAA,wBAAL,CAA8B,IAAKv8C,CAAAA,OAAnC,EAA4Cs8C,KAAMt8C,CAAAA,OAAlD,CALP,GAGW,CAHX;AAJoB;AAWxB6jC,kBAAc,EAAG;AACb,UAAIpkC,MAAM,WAAV;AACA,WAAKA,GAAL,GAAY2+B,mBAAZ,CAAgC;AAC5B,YAAMoe,oBAAoBpe,kBAAA,CAAmB3+B,GAAnB,CAA1B;AACA,YAAI,CAAC+8C,iBAAL;AACI;AADJ;AAEA,cAAM,CAAExX,SAAF,EAAa,QAASyX,kBAAtB,CAAA,GAA6CD,iBAAnD;AAII,SAAC,IAAKre,CAAAA,QAAL,CAAc1+B,GAAd,CAAL,IACIg9C,kBADJ,IAEIzX,SAAA,CAAU,IAAKnlC,CAAAA,KAAf,CAFJ,KAGI,IAAKs+B,CAAAA,QAAL,CAAc1+B,GAAd,CAHJ,GAGyB,IAAIg9C,kBAAJ,CAAuB,IAAvB,CAHzB;AAQI,YAAKte,CAAAA,QAAL,CAAc1+B,GAAd,CAAJ,KACUq8C,iBACN,GADgB,IAAK3d,CAAAA,QAAL,CAAc1+B,GAAd,CAChB,EAAIq8C,iBAAQxY,CAAAA,SAAZ,GACIwY,iBAAQ94C,CAAAA,MAAR,EADJ,IAII84C,iBAAQ/pB,CAAAA,KAAR,EACA,EAAA+pB,iBAAQxY,CAAAA,SAAR,GAAoB,CAAA,CALxB,CAFJ;AAhB4B;AAFnB;AA8BjB8X,gBAAY,EAAG;AACX,UAAKsB,CAAAA,KAAL,CAAW,IAAK36B,CAAAA,WAAhB,EAA6B,IAAKvI,CAAAA,YAAlC,EAAgD,IAAK3Z,CAAAA,KAArD,CAAA;AADW;AAQfg3B,sBAAkB,EAAG;AACjB,aAAO,IAAK72B,CAAAA,OAAL,GACD,IAAK28C,CAAAA,0BAAL,CAAgC,IAAK38C,CAAAA,OAArC,EAA8C,IAAKH,CAAAA,KAAnD,CADC,GAEDi2B,SAAA,EAFN;AADiB;AAKrB8mB,kBAAc,CAACn9C,GAAD,CAAM;AAChB,aAAO,IAAK+Z,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAP;AADgB;AAGpB+uB,kBAAc,CAAC/uB,GAAD,EAAMD,KAAN,CAAa;AACvB,UAAKga,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAA,GAAyBD,KAAzB;AADuB;AAO3BwD,UAAM,CAACnD,KAAD,EAAQ4a,eAAR,CAAyB;AAC3B,OAAI5a,KAAMulB,CAAAA,iBAAV,IAA+B,IAAKvlB,CAAAA,KAAMulB,CAAAA,iBAA1C,KACI,IAAKmR,CAAAA,cAAL,EADJ;AAGA,UAAKrN,CAAAA,SAAL,GAAiB,IAAKrpB,CAAAA,KAAtB;AACA,UAAKA,CAAAA,KAAL,GAAaA,KAAb;AACA,UAAK65C,CAAAA,mBAAL,GAA2B,IAAKj/B,CAAAA,eAAhC;AACA,UAAKA,CAAAA,eAAL,GAAuBA,eAAvB;AAIA,WAAS5W,eAAT,GAAa,CAAb,EAAgBA,eAAhB,GAAoB42C,iBAAkB32C,CAAAA,MAAtC,EAA8CD,eAAA,EAA9C,CAAmD;AAC/C,YAAMpE,eAAMg7C,iBAAA,CAAkB52C,eAAlB,CAAZ;AACI,YAAKm3C,CAAAA,sBAAL,CAA4Bv7C,YAA5B,CAAJ,KACI,IAAKu7C,CAAAA,sBAAL,CAA4Bv7C,YAA5B,CAAA,EACA,EAAA,OAAO,IAAKu7C,CAAAA,sBAAL,CAA4Bv7C,YAA5B,CAFX;AAKA,YAAMo9C,WAAWh9C,KAAA,CADK,IACL,GADYJ,YACZ,CAAjB;AACIo9C,gBAAJ,KACI,IAAK7B,CAAAA,sBAAL,CAA4Bv7C,YAA5B,CADJ,GACuC,IAAK4pC,CAAAA,EAAL,CAAQ5pC,YAAR,EAAao9C,QAAb,CADvC;AAR+C;AAYO,WAAA,GAAA,IAAKl7B,CAAAA,2BAAL,CAAiC9hB,KAAjC,EAAwC,IAAKqpB,CAAAA,SAA7C,EAAwD,IAAxD,CAAA;AAAoE6xB,qBAAAA,GAALA,IAAKA,CAAAA,gBAAAA;AA1VlI,WAAK,MAAMt7C,GAAX,GAAkB8T,MAAlB;AACUupC,oBAEN,GAFkBvpC,KAAA,CAAK9T,GAAL,CAElB,EADMs9C,QACN,GADkBlhC,eAAA,CAAKpc,GAAL,CAClB,EAAkBq9C,YAAlB,IAAkBA,YArwH8Bn9C,CAAAA,WAqwHhD,IAuVoDiF,IAlVxCkB,CAAAA,QAAR,CAAiBrG,GAAjB,EAAsBq9C,YAAtB,CAMI,EAAAr4C,QAAA,CAA+B,QAA/B,KAASq4C,YAAU1U,CAAAA,OAAnB,EAA0C,qCAAoC0U,YAAU1U,CAAAA,OAA9C,wCAA1C,CAXR,IAcuB2U,QAAlB,IAAkBA,QAnxHyBp9C,CAAAA,WAmxH3C,GAyU+CiF,IApUxCkB,CAAAA,QAAR,CAAiBrG,GAAjB,EAAsBuF,WAAA,CAAY83C,YAAZ,EAAuB,CAAE9T,MAoUCpkC,IApUH,CAAvB,CAAtB,CALC,GAOIm4C,QAPJ,KAOkBD,YAPlB,KAyU+Cl4C,IA5TpCe,CAAAA,QAAR,CAAiBlG,GAAjB,CAAJ,IACUu9C,QACN,GA0T4Cp4C,IA3TdgB,CAAAA,QAAR,CAAiBnG,GAAjB,CACtB,EAAgC,CAAA,CAAhC,KAAIu9C,QAAc5+B,CAAAA,SAAlB,GACI4+B,QAAcnT,CAAAA,IAAd,CAAmBiT,YAAnB,CADJ;AAGUE,gBAAcjU,CAAAA,WAHxB,IAIIiU,QAAcn3C,CAAAA,GAAd,CAAkBi3C,YAAlB,CANR,KAUUZ,QACN,GAiT4Ct3C,IAlThBg4C,CAAAA,cAAR,CAAuBn9C,GAAvB,CACpB,EAiT4CmF,IAjTpCkB,CAAAA,QAAR,CAAiBrG,GAAjB,EAAsBuF,WAAA,CAA4B9E,IAAAA,EAAhB,KAAAg8C,QAAA,GAA4BA,QAA5B,GAA0CY,YAAtD,EAAiE,CAAE9T,MAiT7CpkC,IAjT2C,CAAjE,CAAtB,CAXJ,CAbC,CAdL;AAHJ;AA8CA,WAAK,MAAMnF,GAAX,GAAkBoc,gBAAlB;AACsB3b,YAAAA,EAAlB,KAAIqT,KAAA,CAAK9T,GAAL,CAAJ,IA2SoDmF,IA1SxCq4C,CAAAA,WAAR,CAAoBx9C,GAApB,CADJ;AADJ;AA4SI,UAAKs7C,CAAAA,gBAAL,GAxSGxnC,KAwSH;AACI,UAAK2pC,CAAAA,sBAAT,IACI,IAAKA,CAAAA,sBAAL,EADJ;AAGA,UAAKr7B,CAAAA,QAAL,IAAiB,IAAKA,CAAAA,QAAL,CAAc,IAAd,CAAjB;AA3B2B;AA6B/BxhB,YAAQ,EAAG;AACP,aAAO,IAAKR,CAAAA,KAAZ;AADO;AAMXs9C,cAAU,CAAC/zC,IAAD,CAAO;AACb,aAAO,IAAKvJ,CAAAA,KAAMM,CAAAA,QAAX,GAAsB,IAAKN,CAAAA,KAAMM,CAAAA,QAAX,CAAoBiJ,IAApB,CAAtB,GAAkDlJ,IAAAA,EAAzD;AADa;AAMjBiZ,wBAAoB,EAAG;AACnB,aAAO,IAAKtZ,CAAAA,KAAM0F,CAAAA,UAAlB;AADmB;AAGvB63C,yBAAqB,EAAG;AACpB,aAAO,IAAKv9C,CAAAA,KAAM4+B,CAAAA,kBAAlB;AADoB;AAGxB4e,yBAAqB,EAAG;AACpB,aAAO,IAAKn8B,CAAAA,aAAL,GACD,IADC,GAED,IAAK/E,CAAAA,MAAL,GACI,IAAKA,CAAAA,MAAOkhC,CAAAA,qBAAZ,EADJ,GAEIn9C,IAAAA,EAJV;AADoB;AAUxB07C,mBAAe,CAACrgC,KAAD,CAAQ;AACnB,YAAM+hC,qBAAqB,IAAKD,CAAAA,qBAAL,EAA3B;AACA,UAAIC,kBAAJ;AAGI,eAFAA,kBAAmBziC,CAAAA,eAEZ,IADHyiC,kBAAmBziC,CAAAA,eAAgBjZ,CAAAA,GAAnC,CAAuC2Z,KAAvC,CACG,EAAA,EAAA,IAAM+hC,kBAAmBziC,CAAAA,eAAgB/Y,CAAAA,MAAnC,CAA0CyZ,KAA1C,CAAb;AAHJ;AAFmB;AAWvBzV,YAAQ,CAACrG,GAAD,EAAMD,KAAN,CAAa;AAEjB,YAAMw9C,gBAAgB,IAAK19C,CAAAA,MAAOI,CAAAA,GAAZ,CAAgBD,GAAhB,CAAtB;AACID,WAAJ,KAAcw9C,aAAd,KACQA,aAIJ,IAHI,IAAKC,CAAAA,WAAL,CAAiBx9C,GAAjB,CAGJ,EAFA,IAAKo8C,CAAAA,iBAAL,CAAuBp8C,GAAvB,EAA4BD,KAA5B,CAEA,EADA,IAAKF,CAAAA,MAAOuG,CAAAA,GAAZ,CAAgBpG,GAAhB,EAAqBD,KAArB,CACA,EAAA,IAAKga,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAA,GAAyBD,KAAME,CAAAA,GAAN,EAL7B;AAHiB;AAcrBu9C,eAAW,CAACx9C,GAAD,CAAM;AACb,UAAKH,CAAAA,MAAOwC,CAAAA,MAAZ,CAAmBrC,GAAnB,CAAA;AACA,YAAM6pC,cAAc,IAAKwR,CAAAA,kBAAmBp7C,CAAAA,GAAxB,CAA4BD,GAA5B,CAApB;AACI6pC,iBAAJ,KACIA,WAAA,EACA,EAAA,IAAKwR,CAAAA,kBAAmBh5C,CAAAA,MAAxB,CAA+BrC,GAA/B,CAFJ;AAIA,aAAO,IAAK+Z,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAP;AACA,UAAK89C,CAAAA,0BAAL,CAAgC99C,GAAhC,EAAqC,IAAKsiB,CAAAA,WAA1C,CAAA;AARa;AAajBpc,YAAQ,CAAClG,GAAD,CAAM;AACV,aAAO,IAAKH,CAAAA,MAAOsB,CAAAA,GAAZ,CAAgBnB,GAAhB,CAAP;AADU;AAGdmG,YAAQ,CAACnG,GAAD,EAAMgK,YAAN,CAAoB;AACxB,UAAI,IAAK5J,CAAAA,KAAMP,CAAAA,MAAf,IAAyB,IAAKO,CAAAA,KAAMP,CAAAA,MAAX,CAAkBG,GAAlB,CAAzB;AACI,eAAO,IAAKI,CAAAA,KAAMP,CAAAA,MAAX,CAAkBG,GAAlB,CAAP;AADJ;AAGA,UAAID,QAAQ,IAAKF,CAAAA,MAAOI,CAAAA,GAAZ,CAAgBD,GAAhB,CAAZ;AACcS,UAAAA,EAAd,KAAIV,KAAJ,IAA4CU,IAAAA,EAA5C,KAA2BuJ,YAA3B,KACIjK,KACA,GADQwF,WAAA,CAA6B,IAAjB,KAAAyE,YAAA,GAAwBvJ,IAAAA,EAAxB,GAAoCuJ,YAAhD,EAA8D,CAAEu/B,MAAO,IAAT,CAA9D,CACR,EAAA,IAAKljC,CAAAA,QAAL,CAAcrG,GAAd,EAAmBD,KAAnB,CAFJ;AAIA,aAAOA,KAAP;AATwB;AAgB5BqxC,aAAS,CAACpxC,GAAD,EAAM+F,MAAN,CAAc;AACnB,UAAIwF,EAAJ;AACA,UAAIxL,QAAmCU,IAAAA,EAA3B,KAAA,IAAKsZ,CAAAA,YAAL,CAAkB/Z,GAAlB,CAAA,IAAyC,IAAKO,CAAAA,OAA9C,GAEkD,IAAxD,MAACgL,EAAD,GAAM,IAAKwyC,CAAAA,sBAAL,CAA4B,IAAK39C,CAAAA,KAAjC,EAAwCJ,GAAxC,CAAN,KAAuE,IAAK,EAA5E,KAAgEuL,EAAhE,GAAgFA,EAAhF,GAAqF,IAAKyyC,CAAAA,qBAAL,CAA2B,IAAKz9C,CAAAA,OAAhC,EAAyCP,GAAzC,EAA8C,IAAKyF,CAAAA,OAAnD,CAF/E,GACN,IAAKsU,CAAAA,YAAL,CAAkB/Z,GAAlB,CADN;AAGcS,UAAAA,EAAd,KAAIV,KAAJ,IAAqC,IAArC,KAA2BA,KAA3B,KACyB,QAArB,KAAI,MAAOA,MAAX,KA/8GqB,8BAA+B0I,CAAAA,IAA/B,CAg9GE1I,KAh9GF,CA+8GrB,IAvlIqB,aAAc0I,CAAAA,IAAd,CAwlI8B1I,KAxlI9B,CAulIrB,IAGIA,KAHJ,GAGYiJ,UAAA,CAAWjJ,KAAX,CAHZ,GAKS,CAncQg7C,UAAW5I,CAAAA,IAAX,CAAgBP,aAAA,CAmcT7xC,KAncS,CAAhB,CA8bjB,IAKkCuK,OAAQ7B,CAAAA,IAAR,CAAa1C,MAAb,CALlC,KAMIhG,KANJ,GAMYmK,iBAAA,CAAkBlK,GAAlB,EAAuB+F,MAAvB,CANZ,CAQA,EAAA,IAAKk4C,CAAAA,aAAL,CAAmBj+C,GAAnB,EAAsCD,KAAd,IAAcA,KArsIMG,CAAAA,WAqsIpB,GAAuBH,KAAME,CAAAA,GAAN,EAAvB,GAAqCF,KAA7D,CATJ;AAWA,aAAqBA,KAAd,IAAcA,KAvsI2BG,CAAAA,WAusIzC,GAAuBH,KAAME,CAAAA,GAAN,EAAvB,GAAqCF,KAA5C;AAhBmB;AAsBvBk+C,iBAAa,CAACj+C,GAAD,EAAMD,KAAN,CAAa;AACtB,UAAKg8C,CAAAA,UAAL,CAAgB/7C,GAAhB,CAAA,GAAuBD,KAAvB;AADsB;AAO1Bkf,iBAAa,CAACjf,GAAD,CAAM;AACf,UAAIuL,EAAJ;AACA,YAAM,CAAEoR,OAAF,CAAA,GAAc,IAAKvc,CAAAA,KAAzB;AACA,UAAI89C,gBAAJ;AACA,UAAuB,QAAvB,KAAI,MAAOvhC,QAAX,IAAsD,QAAtD,KAAmC,MAAOA,QAA1C,CAAgE;AAC5D,cAAM5B,UAAU5a,uBAAA,CAAwB,IAAKC,CAAAA,KAA7B,EAAoCuc,OAApC,EAA6E,IAAhC,MAACpR,EAAD,GAAM,IAAKyP,CAAAA,eAAX,KAA+C,IAAK,EAApD,KAAwCzP,EAAxC,GAAwD,IAAK,EAA7D,GAAiEA,EAAGjL,CAAAA,MAAjH,CAAhB;AACIya,eAAJ,KACImjC,gBADJ,GACuBnjC,OAAA,CAAQ/a,GAAR,CADvB;AAF4D;AAShE,UAAI2c,OAAJ,IAAoClc,IAAAA,EAApC,KAAey9C,gBAAf;AACI,eAAOA,gBAAP;AADJ;AAOMn4C,QAAAA,GAAS,IAAKg4C,CAAAA,sBAAL,CAA4B,IAAK39C,CAAAA,KAAjC,EAAwCJ,GAAxC,CAAT+F;AACN,aAAetF,IAAAA,EAAf,KAAIsF,EAAJ,IAA2CA,EAA3C,IAA2CA,EAzuIK7F,CAAAA,WAyuIhD,GAMmCO,IAAAA,EAA5B,KAAA,IAAKu7C,CAAAA,aAAL,CAAmBh8C,GAAnB,CAAA,IACkBS,IAAAA,EADlB,KACHy9C,gBADG,GAEDz9C,IAAAA,EAFC,GAGD,IAAKs7C,CAAAA,UAAL,CAAgB/7C,GAAhB,CATN,GACW+F,EADX;AArBe;AAgCnB6jC,MAAE,CAACxmB,SAAD,EAAYniB,QAAZ,CAAsB;AACf,UAAK4nC,CAAAA,MAAL,CAAYzlB,SAAZ,CAAL,KACI,IAAKylB,CAAAA,MAAL,CAAYzlB,SAAZ,CADJ,GAC6B,IAAI6O,mBAAJ,EAD7B;AAGA,aAAO,IAAK4W,CAAAA,MAAL,CAAYzlB,SAAZ,CAAuBjhB,CAAAA,GAAvB,CAA2BlB,QAA3B,CAAP;AAJoB;AAMxB8a,UAAM,CAACqH,SAAD,EAAY,GAAG+O,IAAf,CAAqB;AACnB,UAAK0W,CAAAA,MAAL,CAAYzlB,SAAZ,CAAJ,IACI,IAAKylB,CAAAA,MAAL,CAAYzlB,SAAZ,CAAuBrH,CAAAA,MAAvB,CAA8B,GAAGoW,IAAjC,CADJ;AADuB;AAtb/B;AA6bA,OAAMgsB,iBAAN,QAA+BlD,cAA/B;AACItrB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKlJ,CAAAA,gBAAL,GAAwBkB,oBAAxB;AAFU;AAId+K,4BAAwB,CAAC5uC,CAAD,EAAIC,CAAJ,CAAO;AAM3B,aAAOD,CAAEkwC,CAAAA,uBAAF,CAA0BjwC,CAA1B,CAAA,GAA+B,CAA/B,GAAmC,CAAnC,GAAuC,CAAC,CAA/C;AAN2B;AAQ/B4vC,0BAAsB,CAAC39C,KAAD,EAAQJ,GAAR,CAAa;AAC/B,aAAOI,KAAMkmB,CAAAA,KAAN,GACDlmB,KAAMkmB,CAAAA,KAAN,CAAYtmB,GAAZ,CADC,GAEDS,IAAAA,EAFN;AAD+B;AAKnCq9C,8BAA0B,CAAC99C,GAAD,EAAM,CAAEumB,IAAF,EAAQD,KAAR,CAAN,CAAuB;AAC7C,aAAOC,IAAA,CAAKvmB,GAAL,CAAP;AACA,aAAOsmB,KAAA,CAAMtmB,GAAN,CAAP;AAF6C;AAIjDy9C,0BAAsB,EAAG;AACjB,UAAKY,CAAAA,iBAAT,KACI,IAAKA,CAAAA,iBAAL,EACA,EAAA,OAAO,IAAKA,CAAAA,iBAFhB;AAIA,YAAM,CAAExuB,QAAF,CAAA,GAAe,IAAKzvB,CAAAA,KAA1B;AACkByvB,cAAlB,IAAkBA,QA7xI8B3vB,CAAAA,WA6xIhD,KACI,IAAKm+C,CAAAA,iBADT,GAC6BxuB,QAAS+Z,CAAAA,EAAT,CAAY,QAAZ,EAAuB30B,MAAD,IAAY;AACnD,YAAK1U,CAAAA,OAAT,KACI,IAAKA,CAAAA,OAAQ+9C,CAAAA,WADjB,GACgC,GAAErpC,MAAF,EADhC;AADuD,OAAlC,CAD7B;AANqB;AAtB7B;AAyCA,QAAMiR,iBAAiB,CAACnmB,KAAD,EAAQwJ,IAAR,CAAA2c,IACZ3c,IAAA,IAAyB,QAAzB,KAAQ,MAAOxJ,MAAf,GACDwJ,IAAKE,CAAAA,SAAL,CAAe1J,KAAf,CADC,GAEDA,KAHV,EAMMqmB,iBAAiB,CACnB9e,EAAG,YADgB,EAEnBsZ,EAAG,YAFgB,EAGnBkK,EAAG,YAHgB,EAInBsS,qBAAsB,aAJH,CANvB,EAYMtX,gBAAgBC,kBAAmB1hB,CAAAA,MAZzC,EAyHM8iB,WAAW,CACb5Q,OAAQ,mBADK,EAEbgR,MAAO,kBAFM,CAzHjB,EA6HMH,YAAY,CACd7Q,OAAQ,kBADM,EAEdgR,MAAO,iBAFO,CA7HlB,EAuNMyB,sBAAsB,IAAIvnB,GAAJ,CAAQ,wSAAA,CAAA,KAAA,CAAA,GAAA,CAAR,CAvN5B;AAiPMomB,aAAY02B,GAAD12B,IAAwB,QAAxBA,KAAS,MAAO02B,IAAhB12B,IAA0D,KAA1DA,KAAoC02B,GAAIxT,CAAAA,WAAJ,EAjPrD,EAoRM3hB,kBAAkB,EApRxB;AAmUA,OAAMo1B,iBAAN,QAA+BL,iBAA/B;AACIxuB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKxwC,CAAAA,IAAL,GAAY,KAAZ;AACA,UAAKse,CAAAA,QAAL,GAAgB,CAAA,CAAhB;AACA,UAAKq1B,CAAAA,0BAAL,GAAkC7mB,SAAlC;AACA,UAAKooB,CAAAA,gBAAL,GAAwB,EAAAC,IAAM;AACtB,YAAKn+C,CAAAA,OAAT,IAAoB,CAAC,IAAK+hB,CAAAA,WAAYyF,CAAAA,UAAtC,IACIK,mBAAA,CAAoB,IAAK7nB,CAAAA,OAAzB,EAAkC,IAAK+hB,CAAAA,WAAvC,CADJ;AAD0B,OAA9B;AALU;AAWdy7B,0BAAsB,CAAC39C,KAAD,EAAQJ,GAAR,CAAa;AAC/B,aAAOI,KAAA,CAAMJ,GAAN,CAAP;AAD+B;AAGnCg+C,yBAAqB,CAACx7B,QAAD,EAAWxiB,GAAX,CAAgB;AACjC,UAAI2mB,cAAexlB,CAAAA,GAAf,CAAmBnB,GAAnB,CAAJ;AAEI,eAAO,CADD2+C,QACC,GA1oIkBv0C,iBAAA,CAyoIepK,GAzoIf,CA0oIlB,IAAc2+C,QAAYxrC,CAAAA,OAA1B,IAAqC,CAArC,GAAyC,CAAhD;AAFJ;AAIAnT,SAAA,GAAOgpB,mBAAoB7nB,CAAAA,GAApB,CAAwBnB,GAAxB,CAAD,GAAmDA,GAAnD,GAAgCipB,WAAA,CAAYjpB,GAAZ,CAAtC;AACA,aAAOwiB,QAASo8B,CAAAA,YAAT,CAAsB5+C,GAAtB,CAAP;AANiC;AAQrCkiB,+BAA2B,CAAC9hB,KAAD,EAAQqpB,SAAR,EAAmB9pB,aAAnB,CAAkC;AACzD,aAAOuiB,2BAAA,CAA4B9hB,KAA5B,EAAmCqpB,SAAnC,EAA8C9pB,aAA9C,CAAP;AADyD;AAG7D48C,mBAAe,EAAG;AACV,UAAKh8C,CAAAA,OAAT,IAAoB,CAAC,IAAK+hB,CAAAA,WAAYyF,CAAAA,UAAtC,IACIxN,KAAM7W,CAAAA,UAAN,CAAiB,IAAK+6C,CAAAA,gBAAtB,CADJ;AADc;AAKlBxB,SAAK,CAAC36B,WAAD,EAAcvI,YAAd,EAA4B3Z,KAA5B,CAAmC;AACpConB,mBAAA,CAAclF,WAAd,EAA2BvI,YAA3B,EAAyC,IAAK8N,CAAAA,QAA9C,EAAwDznB,KAAMulB,CAAAA,iBAA9D,CAAA;AADoC;AAGxCi2B,kBAAc,CAACp5B,QAAD,EAAWF,WAAX,EAAwBkG,SAAxB,EAAmCC,UAAnC,CAA+C;AACzDI,eAAA,CAAUrG,QAAV,EAAoBF,WAApB,EAAiCkG,SAAjC,EAA4CC,UAA5C,CAAA;AADyD;AAG7D6J,SAAK,CAAC9P,QAAD,CAAW;AACZ,UAAKqF,CAAAA,QAAL,GAAgBA,QAAA,CAASrF,QAASwC,CAAAA,OAAlB,CAAhB;AACA,WAAMsN,CAAAA,KAAN,CAAY9P,QAAZ,CAAA;AAFY;AArCpB;AAuOA,OAAMq8B,kBAAN,QAAgCV,iBAAhC;AACIxuB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKxwC,CAAAA,IAAL,GAAY,MAAZ;AACA,UAAKqyC,CAAAA,cAAL,GAAsBrzB,UAAtB;AAHU;AAKdy1B,yBAAqB,CAACx7B,QAAD,EAAWxiB,GAAX,CAAgB;AACjC,UAAI2mB,cAAexlB,CAAAA,GAAf,CAAmBnB,GAAnB,CAAJ;AAEI,eAAO,CADD2+C,GACC,GAx2IkBv0C,iBAAA,CAu2IepK,GAv2If,CAw2IlB,IAAc2+C,GAAYxrC,CAAAA,OAA1B,IAAqC,CAArC,GAAyC,CAAhD;AAFJ;AAKU2rC,cAAAA,GAdPpzC,MAAOgB,CAAAA,gBAAP,CAcwC8V,QAdxC,CAcOs8B;AACA/+C,SAAAA,IAAS6mB,iBAAA,CAAkB5mB,GAAlB,CAAA,GACT8+C,QAAcnyC,CAAAA,gBAAd,CAA+B3M,GAA/B,CADS,GAET8+C,QAAA,CAAc9+C,GAAd,CAFAD,KAEuB,CAFvBA;AAGN,aAAwB,QAAjB,KAAA,MAAOA,IAAP,GAA4BA,GAAM8M,CAAAA,IAAN,EAA5B,GAA2C9M,GAAlD;AAV6B;AAarCm9C,8BAA0B,CAAC16B,QAAD,EAAW,CAAEwc,kBAAF,CAAX,CAAmC;AACzD,aAnCGhV,uBAAA,CAAwBM,kBAAA,CAmCD9H,QAnC6B8F,CAAAA,qBAAT,EAAnB,EAmCS0W,kBAnCT,CAAxB,CAmCH;AADyD;AAG7Die,SAAK,CAAC36B,WAAD,EAAcvI,YAAd,EAA4B3Z,KAA5B,CAAmC;AACpCimB,qBAAA,CAAgB/D,WAAhB,EAA6BvI,YAA7B,EAA2C3Z,KAAMulB,CAAAA,iBAAjD,CAAA;AADoC;AAGxCzD,+BAA2B,CAAC9hB,KAAD,EAAQqpB,SAAR,EAAmB9pB,aAAnB,CAAkC;AACzD,aAAO6pB,6BAAA,CAA8BppB,KAA9B,EAAqCqpB,SAArC,EAAgD9pB,aAAhD,CAAP;AADyD;AAzBjE;AAsDA,QAAM,CAAE,SAAU+1B,SAAZ,CAAA,GAAmD9yB,mBAAA,CAAoByhC,cAApB,EAAoC,CAAA,CAApC,CAAzD,EAEM0a,iBAAiB,CAAC7wC,CAAD,EAAIC,CAAJ,CAAA4wC,IAAU7wC,CAAEjC,CAAAA,KAAZ8yC,GAAoB5wC,CAAElC,CAAAA,KAF7C;AAIA,OAAM+lB,SAAN;AACIrC,eAAW,EAAG;AACV,UAAKE,CAAAA,QAAL,GAAgB,EAAhB;AACA,UAAKmvB,CAAAA,OAAL,GAAe,CAAA,CAAf;AAFU;AAId78C,OAAG,CAAC2Z,KAAD,CAAQ;AACPvX,mBAAA,CAAc,IAAKsrB,CAAAA,QAAnB,EAA6B/T,KAA7B,CAAA;AACA,UAAKkjC,CAAAA,OAAL,GAAe,CAAA,CAAf;AAFO;AAIX3qB,UAAM,CAACvY,KAAD,CAAQ;AACVnX,gBAAA,CAAW,IAAKkrB,CAAAA,QAAhB,EAA0B/T,KAA1B,CAAA;AACA,UAAKkjC,CAAAA,OAAL,GAAe,CAAA,CAAf;AAFU;AAIdl/C,WAAO,CAACmB,QAAD,CAAW;AACd,UAAK+9C,CAAAA,OAAL,IAAgB,IAAKnvB,CAAAA,QAASjU,CAAAA,IAAd,CAAmBmjC,cAAnB,CAAhB;AACA,UAAKC,CAAAA,OAAL,GAAe,CAAA,CAAf;AACA,UAAKnvB,CAAAA,QAAS/vB,CAAAA,OAAd,CAAsBmB,QAAtB,CAAA;AAHc;AAbtB;AAoBA,QAAM25B,UAAU,CAAC,SAAD,EAAY,UAAZ,EAAwB,YAAxB,EAAsC,aAAtC,CAAhB,EACMF,aAAaE,OAAQv2B,CAAAA,MAD3B,EAEM42B,WAAYl7B,KAADk7B,IAA4B,QAAjB,KAAA,MAAOl7B,MAAP,GAA4BiJ,UAAA,CAAWjJ,KAAX,CAA5B,GAAgDA,KAF5E,EAyEMw6B,kBAAgCnN,QAAA,CAAS,CAAT,EAAY,GAAZ,EAAiBse,OAAjB,CAzEtC,EA0EMjR,mBAAiCrN,QAAA,CAAS,GAAT,EAAc,IAAd,EAAoBrmB,WAAYC,CAAAA,IAAhC,CA1EvC,EA0JMqnB,QAAQ,CAAC,GAAD,EAAM,QAAN,EAAgB,SAAhB,CA1Jd,EA2JMC,QAAQ,CAAC,GAAD,EAAM,QAAN,EAAgB,SAAhB,CA3Jd;AAiMA,OAAMuN,UAAN;AACIlM,eAAW,EAAG;AACV,UAAKmK,CAAAA,OAAL,GAAe,EAAf;AADU;AAGd33B,OAAG,CAAC4pB,IAAD,CAAO;AACNxnB,mBAAA,CAAc,IAAKu1B,CAAAA,OAAnB,EAA4B/N,IAA5B,CAAA;AACAA,UAAK+K,CAAAA,cAAL,EAAA;AAFM;AAIVzC,UAAM,CAACtI,IAAD,CAAO;AACTpnB,gBAAA,CAAW,IAAKm1B,CAAAA,OAAhB,EAAyB/N,IAAzB,CAAA;AACIA,UAAJ,KAAa,IAAKqQ,CAAAA,QAAlB,KACI,IAAKA,CAAAA,QADT,GACoB37B,IAAAA,EADpB;AAGIsrB,UAAJ,KAAa,IAAKoM,CAAAA,IAAlB,KACUiE,IADV,GACqB,IAAKtC,CAAAA,OAAL,CAAa,IAAKA,CAAAA,OAAQz1B,CAAAA,MAA1B,GAAmC,CAAnC,CADrB,KAGQ,IAAK23B,CAAAA,OAAL,CAAaI,IAAb,CAHR;AALS;AAYbC,YAAQ,CAACtQ,IAAD,CAAO;AACX,UAAMkzB,cAAc,IAAKnlB,CAAAA,OAAQolB,CAAAA,SAAb,CAAwBC,MAAD,IAAYpzB,IAAZ,KAAqBozB,MAA5C,CAApB;AACA,UAAoB,CAApB,KAAIF,WAAJ;AACI,eAAO,CAAA,CAAP;AADJ;AAKA,UAAI7iB,QAAJ;AACA,WAAA,EAA+B,CAA/B,IAA0Bh4B,WAA1B,EAAkCA,WAAA,EAAlC,CAAuC;AACnC,cAAM+6C,SAAS,IAAKrlB,CAAAA,OAAL,CAAa11B,WAAb,CAAf;AACA,YAAyB,CAAA,CAAzB,KAAI+6C,MAAO/6B,CAAAA,SAAX,CAAgC;AAC5BgY,kBAAA,GAAW+iB,MAAX;AACA;AAF4B;AAFG;AAOvC,aAAI/iB,QAAJ,IACI,IAAKJ,CAAAA,OAAL,CAAaI,QAAb,CACO,EAAA,CAAA,CAFX,IAKW,CAAA,CALX;AAfW;AAuBfJ,WAAO,CAACjQ,IAAD,EAAOkQ,qBAAP,CAA8B;AACjC,YAAMG,WAAW,IAAKjE,CAAAA,IAAtB;AACIpM,UAAJ,KAAaqQ,QAAb,KAEA,IAAKA,CAAAA,QAGL,GAHgBA,QAGhB,EAFA,IAAKjE,CAAAA,IAEL,GAFYpM,IAEZ,EADAA,IAAKoN,CAAAA,IAAL,EACA,EAAIiD,QAAJ,KACIA,QAAS5Z,CAAAA,QAeT,IAfqB4Z,QAAStF,CAAAA,cAAT,EAerB,EAdA/K,IAAK+K,CAAAA,cAAL,EAcA,EAbA/K,IAAKyH,CAAAA,UAaL,GAbkB4I,QAalB,EAZIH,qBAYJ,KAXIlQ,IAAKyH,CAAAA,UAAW8H,CAAAA,eAWpB,GAXsC,CAAA,CAWtC,GATIc,QAASrG,CAAAA,QASb,KARIhK,IAAKgK,CAAAA,QACL,GADgBqG,QAASrG,CAAAA,QACzB,EAAAhK,IAAKgK,CAAAA,QAAShc,CAAAA,YAAd,GACIqiB,QAAS/B,CAAAA,eADb,IACgC+B,QAASriB,CAAAA,YAM7C,GAJIgS,IAAKzZ,CAAAA,IAIT,IAJiByZ,IAAKzZ,CAAAA,IAAK2d,CAAAA,UAI3B,KAHIlE,IAAKwE,CAAAA,aAGT,GAHyB,CAAA,CAGzB,GADM,CAAE,UAAAwH,IAAF,CACN,GADsBhM,IAAKtmB,CAAAA,OAC3B,EAAkB,CAAA,CAAlB;AAAIsyB,UAAJ,IACIqE,QAASlD,CAAAA,IAAT,EAjBR,CALA;AAFiC;AAwCrCqC,yBAAqB,EAAG;AACpB,UAAKzB,CAAAA,OAAQh6B,CAAAA,OAAb,CAAsBisB,IAAD,IAAU;AAC3B,cAAM,CAAEtmB,OAAF,EAAWkuB,YAAX,CAAA,GAA4B5H,IAAlC;AACAtmB,eAAQ4e,CAAAA,cAAR,IAA0B5e,OAAQ4e,CAAAA,cAAR,EAA1B;AACIsP,oBAAJ,IACIA,YAAaluB,CAAAA,OAAQ4e,CAAAA,cADzB,IAEQsP,YAAaluB,CAAAA,OAAQ4e,CAAAA,cAArB,EAFR;AAH2B,OAA/B,CAAA;AADoB;AAUxByS,kBAAc,EAAG;AACb,UAAKgD,CAAAA,OAAQh6B,CAAAA,OAAb,CAAsBisB,IAAD,IAAU;AAC3BA,YAAKvJ,CAAAA,QAAL,IAAiBuJ,IAAK+K,CAAAA,cAAL,CAAoB,CAAA,CAApB,CAAjB;AAD2B,OAA/B,CAAA;AADa;AASjBsH,sBAAkB,EAAG;AACb,UAAKjG,CAAAA,IAAT,IAAiB,IAAKA,CAAAA,IAAKpC,CAAAA,QAA3B,KACI,IAAKoC,CAAAA,IAAKpC,CAAAA,QADd,GACyBt1B,IAAAA,EADzB;AADiB;AAtGzB;AAsKA,QAAMgyB,wBAAwB,CAK1BC,uBAAwB,CAAA,CALE,EAU1B0sB,eAAgB,CAAA,CAVU,CAA9B,EAaM3iB,gBAAgB,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,CAbtB,EAcME,mBAAmB,CAAEE,WAAY,QAAd,CAdzB;AAoBA,MAAItY,KAAK,CAAT;AAu9CA,QAAM4O,0BAA0B,CAC5BvjB,SAAU,IADkB,EAE5B2F,KAAM,CAAC,GAAD,EAAM,CAAN,EAAS,GAAT,EAAc,CAAd,CAFsB,CAAhC,EAIM8pC,oBAAqBC,MAADD,IAAiC,WAAjCA,KAAY,MAAOE,UAAnBF,IACtBE,SAAUC,CAAAA,SADYH,IAEtBE,SAAUC,CAAAA,SAAUzU,CAAAA,WAApB,EAAkC/D,CAAAA,QAAlC,CAA2CsY,MAA3C,CANJ,EAYMjhB,aAAaghB,iBAAA,CAAkB,cAAlB,CAAA,IAAqC,CAACA,iBAAA,CAAkB,SAAlB,CAAtC,GACbr7C,IAAKwF,CAAAA,KADQ,GAEbzC,WAAYC,CAAAA,IAdlB,EAkCMy4C,yBAAyBpwB,sBAAA,CAAuB,CAClDC,qBAAsB,CAAC3N,GAAD,EAAM5F,MAAN,CAAAuT,IAAiBnM,WAAA,CAAYxB,GAAZ,EAAiB,QAAjB,EAA2B5F,MAA3B,CADW,EAElDyT,cAAe,EAAAA,IAAO,EAClBloB,EAAGm6B,QAASie,CAAAA,eAAgBC,CAAAA,UAA5Br4C;AAA0Cm6B,UAASme,CAAAA,IAAKD,CAAAA,UADtC,EAElB/+B,EAAG6gB,QAASie,CAAAA,eAAgBG,CAAAA,SAA5Bj/B,IAAyC6gB,QAASme,CAAAA,IAAKC,CAAAA,SAFrC,EAF4B,EAMlDpwB,kBAAmB,EAAAA,IAAM,CAAA,CANyB,CAAvB,CAlC/B,EA2CMqwB,qBAAqB,CACvBv/C,QAASE,IAAAA,EADc,CA3C3B,EA8CMs/C,qBAAqB1wB,sBAAA,CAAuB,CAC9CG,cAAgBhN,QAADgN,IAAe,EAC1BloB,EAAGkb,QAASm9B,CAAAA,UADc,EAE1B/+B,EAAG4B,QAASq9B,CAAAA,SAFc,EADgB,EAK9CtwB,cAAe,EAAAA,IAAM;AACjB,QAAI,CAACuwB,kBAAmBv/C,CAAAA,OAAxB,CAAiC;AAC7B,YAAMy/C,eAAe,IAAIP,sBAAJ,CAA2B,EAA3B,CAArB;AACAO,kBAAa1tB,CAAAA,KAAb,CAAmB5mB,MAAnB,CAAA;AACAs0C,kBAAaloB,CAAAA,UAAb,CAAwB,CAAE5L,aAAc,CAAA,CAAhB,CAAxB,CAAA;AACA4zB,wBAAmBv/C,CAAAA,OAAnB,GAA6By/C,YAA7B;AAJ6B;AAMjC,WAAOF,kBAAmBv/C,CAAAA,OAA1B;AAPiB,GALyB,EAc9CmvB,eAAgB,CAAClN,QAAD,EAAWziB,KAAX,CAAA2vB,IAAqB;AACjClN,YAAS8D,CAAAA,KAAM7c,CAAAA,SAAf,GAAqChJ,IAAAA,EAAV,KAAAV,KAAA,GAAsBA,KAAtB,GAA8B,MAAzD;AADiC,GAdS,EAiB9C0vB,kBAAoBjN,QAADiN,IAAqE,OAArEA,KAAsB/jB,MAAOgB,CAAAA,gBAAP,CAAwB8V,QAAxB,CAAkCy9B,CAAAA,QAjB7B,CAAvB,CA9C3B,EA8EMC,sBAAsB,CACxB3iB,QAAS,CAACtoB,MAAD,EAAS8W,IAAT,CAAAwR,IAAkB;AACvB,QAAI,CAACxR,IAAKhmB,CAAAA,MAAV;AACI,aAAOkP,MAAP;AADJ;AAMA,QAAsB,QAAtB,KAAI,MAAOA,OAAX;AACI,UAAIoS,EAAG5e,CAAAA,IAAH,CAAQwM,MAAR,CAAJ;AACIA,cAAA,GAASjM,UAAA,CAAWiM,MAAX,CAAT;AADJ;AAII,eAAOA,MAAP;AAJJ;AADJ;AAYA,UAAM3N,IAAIi3B,eAAA,CAAgBtpB,MAAhB,EAAwB8W,IAAKhmB,CAAAA,MAAOuB,CAAAA,CAApC,CAAV;AACMsZ,UAAAA,GAAI2d,eAAA,CAAgBtpB,MAAhB,EAAwB8W,IAAKhmB,CAAAA,MAAO6a,CAAAA,CAApC,CAAJA;AACN,WAAQ,GAAEtZ,CAAF,KAAQsZ,MAAR,GAAR;AArBuB,GADH,CA9E5B,EAuIMyiB,cAAczhB,KAAMsmB,CAAAA,aAAN,CAAoB,CAAE/C,OAAQ,CAAA,CAAV,CAApB,CAvIpB;AA2JA,OAAMgb,WAAN;AACIxwB,eAAW,CAACjM,KAAD,EAAQ08B,QAAR,EAAkB,CAAEphB,kBAAF,EAAsBqhB,gBAAA,GAAmB,CAAA,CAAzC,CAAA,GAAmD,EAArE,CAAyE;AAYhF,UAAKC,CAAAA,iBAAL,GAJA,IAAKC,CAAAA,aAIL,GARA,IAAKC,CAAAA,UAQL,GARkB,IAQlB;AAIA,UAAKJ,CAAAA,QAAL,GAAgB,EAAhB;AACA,UAAKK,CAAAA,WAAL,GAAmB,EAAAC,IAAM;AACrB,YAAM,IAAKH,CAAAA,aAAX,IAA4B,IAAKD,CAAAA,iBAAjC,CAAA;AAEA,cAAMvhB,OAAOG,UAAA,CAAW,IAAKohB,CAAAA,iBAAhB,EAAmC,IAAKnhB,CAAAA,OAAxC,CAAb,EACMwhB,eAAmC,IAAnCA,KAAe,IAAKH,CAAAA,UAD1B,EAKMI,0BAAqE,CAArEA,IAA0B3zB,UAAA,CAAW8R,IAAKxoB,CAAAA,MAAhB,EAAwB,CAAEjP,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAxB,CALhC;AAMA,cAAK+/B,YAAL,IAAsBC,uBAAtB,CAAA;AAEA,aAAM,CAAE,MAAAj9B,uBAAF,CAAN,GAAkBob,IAAlB;AACA,gBAAM,CAAEh9B,SAAF,CAAA,GAAgBQ,SAAtB;AACA,gBAAK48B,CAAAA,OAAQz8B,CAAAA,IAAb,CAAkB,CAAE,GAAGihB,uBAAL,EAAY5hB,SAAZ,CAAlB,CAAA;AACA,gBAAM,CAAE8+C,OAAF,EAAWC,MAAX,CAAA,GAAsB,IAAKV,CAAAA,QAAjC;AACKO,wBAAL,KACIE,OACA,IADWA,OAAA,CAAQ,IAAKN,CAAAA,aAAb,EAA4BxhB,IAA5B,CACX,EAAA,IAAKyhB,CAAAA,UAAL,GAAkB,IAAKD,CAAAA,aAF3B;AAIAO,kBAAA,IAAUA,MAAA,CAAO,IAAKP,CAAAA,aAAZ,EAA2BxhB,IAA3B,CAAV;AAVA;AARA;AADqB,OAAzB;AAqBA,UAAKgiB,CAAAA,iBAAL,GAAyB,CAACr9B,KAAD,EAAQqb,IAAR,CAAAiiB,IAAiB;AACtC,YAAIt9B,KAAM3d,CAAAA,MAAV,YAA4BoyC,OAA5B,IACIz0B,KAAM3d,CAAAA,MAAOk7C,CAAAA,iBADjB,IAEwBxgD,IAAAA,EAFxB,KAEIijB,KAAMw9B,CAAAA,SAFV;AAGI,aAAI;AACA,gBAAI,CAACx9B,KAAM3d,CAAAA,MAAOk7C,CAAAA,iBAAb,CAA+Bv9B,KAAMw9B,CAAAA,SAArC,CAAL;AACI;AADJ;AADA,WAKJ,QAAOjwC,CAAP,CAAU;;AARd;AAUA,YAAKsvC,CAAAA,aAAL,GAAqB78B,KAArB;AACA,YAAK48B,CAAAA,iBAAL,GAAyB/1B,cAAA,CAAewU,IAAf,EAAqB,IAAKC,CAAAA,kBAA1B,CAAzB;AAEAzkB,aAAMhX,CAAAA,MAAN,CAAa,IAAKk9C,CAAAA,WAAlB,EAA+B,CAAA,CAA/B,CAAA;AAdsC,OAA1C;AAgBA,UAAKU,CAAAA,eAAL,GAAuB,CAACz9B,KAAD,EAAQqb,IAAR,CAAAqiB,IAAiB;AACpCntC,iBAAUotC,CAAAA,cAAV,CAAyB39B,KAAzB,EAAgC,SAAhC,CAAA;AACA,YAAK49B,CAAAA,GAAL,EAAA;AACA,cAAM,CAAEC,KAAF,EAASC,YAAT,EAAuBC,eAAvB,CAAA,GAA2C,IAAKrB,CAAAA,QAAtD;AACI,YAAKC,CAAAA,gBAAT,IACIoB,eADJ,IACuBA,eAAA,EADvB;AAEM,YAAKlB,CAAAA,aAAX,IAA4B,IAAKD,CAAAA,iBAAjC,KAEMoB,IAON,GAPgBxiB,UAAA,CAA0B,eAAf,KAAAxb,KAAMna,CAAAA,IAAN,IACR,oBADQ,KACvBma,KAAMna,CAAAA,IADiB,GAErB,IAAK+2C,CAAAA,iBAFgB,GAGrB/1B,cAAA,CAAewU,IAAf,EAAqB,IAAKC,CAAAA,kBAA1B,CAHU,EAGqC,IAAKG,CAAAA,OAH1C,CAOhB,EAHI,IAAKqhB,CAAAA,UAGT,IAHuBe,KAGvB,IAFIA,KAAA,CAAM79B,KAAN,EAAag+B,IAAb,CAEJ,EAAAF,YAAA,IAAgBA,YAAA,CAAa99B,KAAb,EAAoBg+B,IAApB,CAThB;AANoC,OAAxC;AAkBA,UAAKztC,SAAUomC,CAAAA,gBAAV,CAA2B32B,KAA3B,CAAL,CAAA;AAEA,YAAK28B,CAAAA,gBAAL,GAAwBA,gBAAxB;AACA,YAAKD,CAAAA,QAAL,GAAgBA,QAAhB;AACA,YAAKphB,CAAAA,kBAAL,GAA0BA,kBAA1B;AACMD,0BAAAA,GAAOtb,gBAAA,CAAiBC,KAAjB,CAAPqb;AACA4iB,0BAAAA,GAAcp3B,cAAA,CAAewU,kBAAf,EAAqB,IAAKC,CAAAA,kBAA1B,CAAd2iB;AACN,SAAM,CAAE,MAAAh+B,gBAAF,CAAN,GAAkBg+B,kBAAlB;AACA,YAAM,CAAE5/C,SAAF,CAAA,GAAgBQ,SAAtB;AACA,YAAK48B,CAAAA,OAAL,GAAe,CAAC,CAAE,GAAGxb,gBAAL,EAAY5hB,SAAZ,CAAD,CAAf;AACA,SAAM,CAAE,eAAA6/C,QAAF,CAAN,GAA2BxB,QAA3B;AACAwB,gBAAA,IACIA,QAAA,CAAel+B,KAAf,EAAsBwb,UAAA,CAAWyiB,kBAAX,EAAwB,IAAKxiB,CAAAA,OAA7B,CAAtB,CADJ;AAEAlrB,iBAAUotC,CAAAA,cAAV,CAAyB39B,KAAzB,EAAgC,KAAhC,CAAA;AACA,YAAKm+B,CAAAA,eAAL,GAA4B1M,CAAArxB,eAAA,CAAgBJ,KAAMo+B,CAAAA,aAAtB,EAAqC,aAArC,EAAoD,IAAKf,CAAAA,iBAAzD,CAAA5L,EAA6ErxB,eAAA,CAAgBJ,KAAMo+B,CAAAA,aAAtB,EAAqC,WAArC,EAAkD,IAAKX,CAAAA,eAAvD,CAA7EhM,EAAsJrxB,eAAA,CAAgBJ,KAAMo+B,CAAAA,aAAtB,EAAqC,eAArC,EAAsD,IAAKX,CAAAA,eAA3D,CAAtJhM,EAAmOrxB,eAAA,CAAgBJ,KAAMo+B,CAAAA,aAAtB,EAAqC,oBAArC,EAA2D,IAAKX,CAAAA,eAAhE,CAAnOhM,CAtwLWhyC,CAAAA,MAAb,CAAoB0S,gBAApB,CAswL1B;AAdA;AAxEgF;AAwFpFksC,kBAAc,CAAC3B,QAAD,CAAW;AACrB,UAAKA,CAAAA,QAAL,GAAgBA,QAAhB;AADqB;AAGzBkB,OAAG,EAAG;AACF,UAAKO,CAAAA,eAAL,IAAwB,IAAKA,CAAAA,eAAL,EAAxB;AACA70B,iBAAA,CAAY,IAAKyzB,CAAAA,WAAjB,CAAA;AAFE;AA5FV;AAmRA,QAAMuB,sBAAsB,IAAIxH,OAAJ,EAA5B;AAKA,OAAMyH,0BAAN;AACItyB,eAAW,CAAChwB,aAAD,CAAgB;AACvB,UAAKuiD,CAAAA,YAAL,GAAoB,IAApB;AACA,UAAKC,CAAAA,UAAL,GAAkB,CAAA,CAAlB;AACA,UAAK5hB,CAAAA,gBAAL,GAAwB,IAAxB;AACA,UAAKrgB,CAAAA,WAAL,GAAmB,CAAE5Y,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAAnB;AAKA,UAAKwhC,CAAAA,qBAAL,GADA,IAAKC,CAAAA,WACL,GADmB,CAAA,CACnB;AAIA,UAAK7iB,CAAAA,OAAL,GAAenJ,SAAA,EAAf;AACA,UAAK12B,CAAAA,aAAL,GAAqBA,aAArB;AAduB;AAgB3BF,SAAK,CAAC6iD,WAAD,EAAc,CAAEC,YAAA,GAAe,CAAA,CAAjB,CAAA,GAA2B,EAAzC,CAA6C;AAI9C,UAAM,CAAEvnC,eAAF,CAAA,GAAsB,IAAKrb,CAAAA,aAAjC;AACIqb,qBAAJ,IAAqD,CAAA,CAArD,KAAuBA,eAAgBoJ,CAAAA,SAAvC,KA+FM,CAAE,iBAAAi8B,eAAF,CACN,GAD6B,IAAKz/C,CAAAA,QAAL,EAC7B,EAAA,IAAK4hD,CAAAA,UAAL,GAAkB,IAAIrC,UAAJ,CAAemC,WAAf,EAA4B,CAC1CV,eA/FoBl+B,KAADk+B,IAAW;AAC9B,cAAM,CAAEvB,gBAAF,CAAA,GAAuB,IAAKz/C,CAAAA,QAAL,EAA7B;AAGAy/C,wBAAA,GAAmB,IAAKoC,CAAAA,cAAL,EAAnB,GAA2C,IAAKC,CAAAA,aAAL,EAA3C;AACIH,oBAAJ,IACI,IAAKA,CAAAA,YAAL,CAAkB9+B,gBAAA,CAAiBC,KAAjB,CAAwBC,CAAAA,KAA1C,CADJ;AAL8B,OA8FY,EAE1Ck9B,QAvFY,CAACn9B,KAAD,EAAQqb,IAAR,CAAA8hB,IAAiB;AAE7B,cAAM,CAAEvgB,IAAF,EAAQqiB,eAAR,EAAyBC,WAAzB,CAAA,GAAyC,IAAKhiD,CAAAA,QAAL,EAA/C;AACA,YAAI0/B,IAAJ,IAAY,CAACqiB,eAAb,KACQ,IAAKT,CAAAA,YAIL,IAHA,IAAKA,CAAAA,YAAL,EAGA,EAFJ,IAAKA,CAAAA,YAED,GAFgBjuC,SAAU4uC,CAAAA,WAAV,CAAsBviB,IAAtB,CAEhB,EAAA,CAAC,IAAK4hB,CAAAA,YALd;AAMQ;AANR;AAQA,YAAKC,CAAAA,UAAL,GAAkB,CAAA,CAAlB;AACA,YAAK5hB,CAAAA,gBAAL,GAAwB,IAAxB;AACA,YAAKuiB,CAAAA,kBAAL,EAAA;AACI,YAAKnjD,CAAAA,aAAc8oB,CAAAA,UAAvB,KACI,IAAK9oB,CAAAA,aAAc8oB,CAAAA,UAAW+H,CAAAA,kBAC9B,GADmD,CAAA,CACnD,EAAA,IAAK7wB,CAAAA,aAAc8oB,CAAAA,UAAW1iB,CAAAA,MAA9B,GAAuCtF,IAAAA,EAF3C;AAOAmuB,gBAAA,CAAU5O,IAAD,IAAU;AACf,cAAIzf,UAAU,IAAKwiD,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAA8B/f,CAAAA,GAA9B,EAAVM,IAAiD,CAArD;AAIA,cAAIstB,OAAQplB,CAAAA,IAAR,CAAalI,OAAb,CAAJ,CAA2B;AACvB,gBAAM,CAAEkoB,UAAF,CAAA,GAAiB,IAAK9oB,CAAAA,aAA5B;AACI8oB,sBAAJ,IAAkBA,UAAW1H,CAAAA,MAA7B,KACUiiC,UADV,GACyBv6B,UAAW1H,CAAAA,MAAOuV,CAAAA,SAAlB,CAA4BtW,IAA5B,CADzB,MAIQzf,OAJR,GAGuBwf,UAAA1b,CAAW2+C,UAAX3+C,CAHvB,IAI4B2E,UAAA,CAAWzI,OAAX,CAJ5B,GAIkD,GAJlD;AAFuB;AAU3B,cAAK2f,CAAAA,WAAL,CAAiBF,IAAjB,CAAA,GAAyBzf,OAAzB;AAfe,SAAnB,CAAA;AAkBIqiD,mBAAJ,IACIroC,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAMk/C,WAAA,CAAYl/B,KAAZ,EAAmBqb,IAAnB,CAAvB,CADJ;AAGAz4B,4BAAA,CAAqB,IAAK3G,CAAAA,aAA1B,EAAyC,WAAzC,CAAA;AACA,cAAM,CAAEka,cAAF,CAAA,GAAqB,IAAKla,CAAAA,aAAhC;AACAka,sBAAA,IAAkBA,cAAeuF,CAAAA,SAAf,CAAyB,WAAzB,EAAsC,CAAA,CAAtC,CAAlB;AA5C6B,OAqFa,EAG1C0hC,OA1CW,CAACp9B,KAAD,EAAQqb,IAAR,CAAA+hB,IAAiB;AAE5B,cAAM,CAAE6B,eAAF,EAAmBM,iBAAnB,EAAsCC,eAAtC,EAAuDC,MAAvD,CAAA,GAAmE,IAAKviD,CAAAA,QAAL,EAAzE;AAEA,YAAK+hD,eAAL,IAAyB,IAAKT,CAAAA,YAA9B,CAAA;AAEA,cAAM,CAAE3rC,MAAF,CAAA,GAAawoB,IAAnB;AAEIkkB,2BAAJ,IAAmD,IAAnD,KAAyB,IAAK1iB,CAAAA,gBAA9B,IACI,IAAKA,CAAAA,gBAGD,GAHoBC,mBAAA,CAAoBjqB,MAApB,CAGpB,EAD0B,IAC1B,KADA,IAAKgqB,CAAAA,gBACL,IAAA2iB,eAAA,IAAmBA,eAAA,CAAgB,IAAK3iB,CAAAA,gBAArB,CAJ3B,KASA,IAAK6iB,CAAAA,UAAL,CAAgB,GAAhB,EAAqBrkB,IAAKpb,CAAAA,KAA1B,EAAiCpN,MAAjC,CAaA,EAZA,IAAK6sC,CAAAA,UAAL,CAAgB,GAAhB,EAAqBrkB,IAAKpb,CAAAA,KAA1B,EAAiCpN,MAAjC,CAYA,EALA,IAAK5W,CAAAA,aAAc8D,CAAAA,MAAnB,EAKA,EAAA0/C,MAAA,IAAUA,MAAA,CAAOz/B,KAAP,EAAcqb,IAAd,CAtBV,CAAA;AAJA;AAJ4B,OAuCc,EAI1CyiB,aAXiB,CAAC99B,KAAD,EAAQqb,IAAR,CAAAyiB,IAAiB,IAAKtmB,CAAAA,IAAL,CAAUxX,KAAV,EAAiBqb,IAAjB,CAOQ,EAK1C0iB,gBAXoB,EAAAA,IAAM7yB,QAAA,CAAU5O,IAAD,IAAU;AAC7C,YAAIzU,EAAJ;AACA,eAAwC,QAAxC,KAAO,IAAK83C,CAAAA,iBAAL,CAAuBrjC,IAAvB,CAAP,KACwD,IAAnD,MAACzU,EAAD,GAAM,IAAKw3C,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAA8BpI,CAAAA,SAApC,KAAkE,IAAK,EAAvE,KAA2DrM,EAA3D,GAA2E,IAAK,EAAhF,GAAoFA,EAAGyrC,CAAAA,IAAH,EADzF;AAF6C,OAAnB,CAMgB,CAA5B,EAMf,CACChY,mBAAoB,IAAKr/B,CAAAA,aAAcg+C,CAAAA,qBAAnB,EADrB,EAEC0C,iBAAAA,eAFD,CANe,CAhGlB;AAL8C;AAgHlDnlB,QAAI,CAACxX,KAAD,EAAQqb,IAAR,CAAc;AACd,UAAMojB,aAAa,IAAKA,CAAAA,UAAxB;AACA,UAAK//C,CAAAA,MAAL,EAAA;AACA,UAAK+/C,UAAL,CAAA;AAEA,SAAM,CAAE,SAAA3hD,UAAF,CAAN,GAAqBu+B,IAArB;AACA,YAAK/K,CAAAA,cAAL,CAAoBxzB,UAApB,CAAA;AACA,YAAM,CAAE8iD,SAAF,CAAA,GAAgB,IAAK1iD,CAAAA,QAAL,EAAtB;AACI0iD,iBAAJ,IACI/oC,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAM4/C,SAAA,CAAU5/B,KAAV,EAAiBqb,IAAjB,CAAvB,CADJ;AALA;AAHc;AAYlB38B,UAAM,EAAG;AACL,UAAK+/C,CAAAA,UAAL,GAAkB,CAAA,CAAlB;AACA,YAAM,CAAE15B,UAAF,EAAc5O,cAAd,CAAA,GAAiC,IAAKla,CAAAA,aAA5C;AACI8oB,gBAAJ,KACIA,UAAW+H,CAAAA,kBADf,GACoC,CAAA,CADpC;AAGA,UAAKgyB,CAAAA,UAAL,IAAmB,IAAKA,CAAAA,UAAWlB,CAAAA,GAAhB,EAAnB;AACA,UAAKkB,CAAAA,UAAL,GAAkB/hD,IAAAA,EAAlB;AACA,YAAM,CAAEkiD,eAAF,CAAA,GAAsB,IAAK/hD,CAAAA,QAAL,EAA5B;AACI,OAAC+hD,eAAL,IAAwB,IAAKT,CAAAA,YAA7B,KACI,IAAKA,CAAAA,YAAL,EACA,EAAA,IAAKA,CAAAA,YAAL,GAAoB,IAFxB;AAIAroC,oBAAA,IAAkBA,cAAeuF,CAAAA,SAAf,CAAyB,WAAzB,EAAsC,CAAA,CAAtC,CAAlB;AAbK;AAeTgkC,cAAU,CAACpjC,IAAD,EAAOujC,MAAP,EAAehtC,MAAf,CAAuB;AAC7B,OAAM,CAAE,KAAA+pB,MAAF,CAAN,GAAiB,IAAK1/B,CAAAA,QAAL,EAAjB;AAEK2V,YAAL,IAAgB8pB,UAAA,CAAWrgB,IAAX,EAAiBsgB,MAAjB,EAAuB,IAAKC,CAAAA,gBAA5B,CAAhB,KAEMijB,MAMN,GANkB,IAAKT,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAMlB,EALIlM,MAKJ,GALW,IAAKoM,CAAAA,WAAL,CAAiBF,IAAjB,CAKX,GALoCzJ,MAAA,CAAOyJ,IAAP,CAKpC,EAHI,IAAKqiC,CAAAA,WAGT,IAHwB,IAAKA,CAAAA,WAAL,CAAiBriC,IAAjB,CAGxB,KAFIlM,MAEJ,GAFWyrB,gBAAA,CAAiBzrB,MAAjB,EAAuB,IAAKuuC,CAAAA,WAAL,CAAiBriC,IAAjB,CAAvB,EAA+C,IAAKwf,CAAAA,OAAL,CAAaxf,IAAb,CAA/C,CAEX,GAAAwjC,MAAUp9C,CAAAA,GAAV,CAAc0N,MAAd,CARA;AAH6B;AAajCgvC,sBAAkB,EAAG;AACjB,UAAIv3C,EAAJ;AACA,YAAM,CAAEg5B,eAAF,EAAmBxE,WAAnB,CAAA,GAAmC,IAAKn/B,CAAAA,QAAL,EAAzC,EACMmgB,kBAAS,IAAKphB,CAAAA,aAAc8oB,CAAAA,UAAnB,IACX,CAAC,IAAK9oB,CAAAA,aAAc8oB,CAAAA,UAAW1H,CAAAA,MADpB,GAET,IAAKphB,CAAAA,aAAc8oB,CAAAA,UAAWuN,CAAAA,OAA9B,CAAsC,CAAA,CAAtC,CAFS,GAGgC,IAAzC,MAACzqB,EAAD,GAAM,IAAK5L,CAAAA,aAAc8oB,CAAAA,UAAzB,KAAwD,IAAK,EAA7D,KAAiDld,EAAjD,GAAiE,IAAK,EAAtE,GAA0EA,EAAGwV,CAAAA,MAJnF;AAKM0iC,QAAAA,GAAkB,IAAKpB,CAAAA,WAAvBoB;AACFlf,qBAAJ,IAAuB3F,WAAA,CAAY2F,eAAZ,CAAvB,GACS,IAAK8d,CAAAA,WADd,KAEQ,IAAKA,CAAAA,WAFb,GAE2B,IAAKqB,CAAAA,qBAAL,EAF3B,IAOQ,IAAKrB,CAAAA,WAPb,GAMQ9d,eAAJ,IAAuBxjB,eAAvB,GACuB2e,uBAAA,CAAwB3e,eAAOuV,CAAAA,SAA/B,EAA0CiO,eAA1C,CADvB,GAIuB,CAAA,CAV3B;AAaA,UAAK/E,CAAAA,OAAL,GAAeM,kBAAA,CAAmBC,WAAnB,CAAf;AAKI0jB,QAAJ,KAAwB,IAAKpB,CAAAA,WAA7B,IACIthC,eADJ,IAEI,IAAKshC,CAAAA,WAFT,IAGI,CAAC,IAAKD,CAAAA,qBAHV,IAIIxzB,QAAA,CAAU5O,IAAD,IAAU;AACf,YAAyB,CAAA,CAAzB,KAAI,IAAKqiC,CAAAA,WAAT,IACI,IAAKU,CAAAA,kBAAL,CAAwB/iC,IAAxB,CADJ,CACmC;AAC1BqiC,cAAAA,wBAAL,IAAKA,CAAAA,WAAAA,EAA0C,SAAAthC,eAAOuV,CAAAA,SAAP,CAAiBtW,IAAjB,CAA1CqiC,EAAkE,cAAA,IAAKA,CAAAA,WAAL,CAAiBriC,IAAjB,CAAlEqiC;AApPrB,gBAAMsB,sBAAsB,EAA5B;AACwBljD,cAAAA,EAAxB,KAAI4hD,WAAYn+C,CAAAA,GAAhB,KACIy/C,mBAAoBz/C,CAAAA,GADxB,GAC8Bm+C,WAAYn+C,CAAAA,GAD1C,GACgD6c,MAAO7c,CAAAA,GADvD;AAGwBzD,cAAAA,EAAxB,KAAI4hD,WAAYp+C,CAAAA,GAAhB,KACI0/C,mBAAoB1/C,CAAAA,GADxB,GAC8Bo+C,WAAYp+C,CAAAA,GAD1C,GACgD8c,MAAO7c,CAAAA,GADvD;AAgPqBm+C,+BAAL,CAAiBriC,IAAjB,CAAA,GA7OT2jC,mBA6OS;AAD+B;AAFpB,OAAnB,CAJJ;AA1BiB;AAsCrBD,yBAAqB,EAAG;AACpB,YAAM,CAAE,gBAAiBrB,WAAnB,EAAgCuB,wBAAhC,CAAA,GAA6D,IAAKhjD,CAAAA,QAAL,EAAnE;AACA,UAAI,CAACyhD,WAAL,IAAoB,CAACzjB,WAAA,CAAYyjB,WAAZ,CAArB;AACI,eAAO,CAAA,CAAP;AADJ;AAEA,UAAMwB,qBAAqBxB,WAAY9hD,CAAAA,OAAvC;AACAwG,iBAAYmF,CAAAA,SAAZ,CAA6C,IAA7C,KAAsB23C,kBAAtB,EAAmD,wGAAnD,CAAA;AACA,UAAM,CAAEp7B,UAAF,CAAA,GAAiB,IAAK9oB,CAAAA,aAA5B;AAEA,UAAI,CAAC8oB,UAAL,IAAmB,CAACA,UAAW1H,CAAAA,MAA/B;AACI,eAAO,CAAA,CAAP;AADJ;AAEqEzO,UAAAA,qBAAXmW,UAAWnW,CAAAA,IAAAA,EAAM,qBAAA,IAAK3S,CAAAA,aAAcg+C,CAAAA,qBAAnB,EAANrrC;AA3jFzE,wBAAA,GAAO0X,uBAAA,CAAwBM,kBAAA,CA2jFWu5B,kBA3jFiBv7B,CAAAA,qBAAT,EAAnB,EAGiB0W,kBAHjB,CAAxB,CAAP;AAIA,OAAM,CAAE,OAAA7S,kBAAF,CAAN,GAAmB2zB,kBAAnB;AACI3zB,wBAAJ,KACII,aAAA,CAHgBu3B,kBAGUx8C,CAAAA,CAA1B,EAA6B6kB,kBAAO5V,CAAAA,MAAOjP,CAAAA,CAA3C,CACA,EAAAilB,aAAA,CAJgBu3B,kBAIUljC,CAAAA,CAA1B,EAA6BuL,kBAAO5V,CAAAA,MAAOqK,CAAAA,CAA3C,CAFJ;AAujFwE0V,gBAAAA,GAAlB7N,UAAW1H,CAAAA,MAAOuV,CAAAA,SAAAA;AAAhEytB,gBAAAA,GA7RD,CACHz8C,EAAGq4B,2BAAA,CAA4BrJ,UAAUhvB,CAAAA,CAAtC,EA7xEaw8C,kBA6xE2Cx8C,CAAAA,CAAxD,CADA,EAEHsZ,EAAG+e,2BAAA,CAA4BrJ,UAAU1V,CAAAA,CAAtC,EA9xEakjC,kBA8xE2CljC,CAAAA,CAAxD,CAFA,CA6RCmjC;AAKAH,8BAAJ,KACUI,kBAEN,GAFwBJ,wBAAA,CAAyBv5B,uBAAA,CAAwB05B,UAAxB,CAAzB,CAExB,EADA,IAAK3B,CAAAA,qBACL,GAD6B,CAAC,CAAC4B,kBAC/B,EAAIA,kBAAJ,KACID,UADJ,GAC0B/5B,uBAAA,CAAwBg6B,kBAAxB,CAD1B,CAHJ;AAOA,aAAOD,UAAP;AAvBoB;AAyBxB/vB,kBAAc,CAACxzB,QAAD,CAAW;AACrB,YAAM,CAAE8/B,IAAF,EAAQ2jB,YAAR,EAAsBlkB,WAAtB,EAAmCmkB,cAAnC,EAAmD7D,gBAAnD,EAAqE8D,mBAArE,CAAA,GAA8F,IAAKvjD,CAAAA,QAAL,EAApG,EACMyhD,cAAc,IAAKA,CAAAA,WAAnBA,IAAkC,EADxC,EAEM+B,qBAAqBx1B,QAAA,CAAU5O,IAAD,IAAU;AAC1C,YAAKqgB,UAAA,CAAWrgB,IAAX,EAAiBsgB,IAAjB,EAAuB,IAAKC,CAAAA,gBAA5B,CAAL,CAAA;AAGA,cAAIz6B,aAAcu8C,WAAdv8C,IAA6Bu8C,WAAA,CAAYriC,IAAZ,CAA7Bla,IAAmD,EAAvD;AACIu6C,0BAAJ,KACIv6C,UADJ,GACiB,CAAE5B,IAAK,CAAP,EAAUD,IAAK,CAAf,CADjB;AAwBA,iBAAO,IAAKogD,CAAAA,uBAAL,CAA6BrkC,IAA7B,EAdSzL,CACZhL,KAAM,SADMgL,EAEZ/T,SAAUyjD,YAAA,GAAezjD,QAAA,CAASwf,IAAT,CAAf,GAAgC,CAF9BzL,EAGZI,gBALoBorB,WAAAprB,GAAc,GAAdA,GAAoB,OAE5BJ,EAIZG,cALkBqrB,WAAArrB,GAAc,EAAdA,GAAmB,QACzBH,EAKZE,aAAc,GALFF,EAMZ3B,UAAW,CANC2B,EAOZ5B,UAAW,EAPC4B,EAQZ,GAAG2vC,cARS3vC,EASZ,GAAGzO,UATSyO,CAcT,CAAP;AA5BA;AAD0C,OAAnB,CAF3B;AAkCA,aAAOoG,OAAQC,CAAAA,GAAR,CAAYwpC,kBAAZ,CAAgCvpC,CAAAA,IAAhC,CAAqCspC,mBAArC,CAAP;AAnCqB;AAqCzBE,2BAAuB,CAACrkC,IAAD,EAAOla,UAAP,CAAmB;AACtC,YAAM09C,YAAY,IAAKT,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAAlB;AACA1Z,0BAAA,CAAqB,IAAK3G,CAAAA,aAA1B,EAAyCqgB,IAAzC,CAAA;AACA,aAAOwjC,SAAU/jD,CAAAA,KAAV,CAAgB+a,kBAAA,CAAmBwF,IAAnB,EAAyBwjC,SAAzB,EAAoC,CAApC,EAAuC19C,UAAvC,EAAmD,IAAKnG,CAAAA,aAAxD,EAAuE,CAAA,CAAvE,CAAhB,CAAP;AAHsC;AAK1C+iD,iBAAa,EAAG;AACZ9zB,cAAA,CAAU5O,IAAD,IAAU,IAAK+iC,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAA8Bkb,CAAAA,IAA9B,EAAnB,CAAA;AADY;AAGhBunB,kBAAc,EAAG;AACb7zB,cAAA,CAAU5O,IAAD,IAAU;AAAE,YAAIzU,EAAJ;AAAQ,eAA0D,IAAnD,MAACA,EAAD,GAAM,IAAKw3C,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAA8BpI,CAAAA,SAApC,KAAkE,IAAK,EAAvE,KAA2DrM,EAA3D,GAA2E,IAAK,EAAhF,GAAoFA,EAAG0rC,CAAAA,KAAH,EAA3F;AAAV,OAAnB,CAAA;AADa;AAGjBoM,qBAAiB,CAACrjC,IAAD,CAAO;AACpB,UAAIzU,EAAJ;AACA,aAA0D,IAAnD,MAACA,EAAD,GAAM,IAAKw3C,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAA8BpI,CAAAA,SAApC,KAAkE,IAAK,EAAvE,KAA2DrM,EAA3D,GAA2E,IAAK,EAAhF,GAAoFA,EAAG3L,CAAAA,KAA9F;AAFoB;AAUxBmjD,sBAAkB,CAAC/iC,IAAD,CAAO;AACrB,UAAMskC,UAAW,QAAOtkC,IAAK8J,CAAAA,WAAL,EAAP,EAAjB;AACA,YAAM1pB,QAAQ,IAAKT,CAAAA,aAAciB,CAAAA,QAAnB,EAAd;AAEA,aAAO,CADD2jD,OACC,GADqBnkD,KAAA,CAAMkkD,OAAN,CACrB,IACDC,OADC,GAED,IAAK5kD,CAAAA,aAAcwG,CAAAA,QAAnB,CAA4B6Z,IAA5B,GAAmC5f,KAAMuc,CAAAA,OAAN,GAC/Bvc,KAAMuc,CAAAA,OAAN,CAAcqD,IAAd,CAD+B,GAE/Bvf,IAAAA,EAFJ,KAEkB,CAFlB,CAFN;AAJqB;AAUzB8hD,gBAAY,CAAC5+B,KAAD,CAAQ;AAChBiL,cAAA,CAAU5O,IAAD,IAAU;AACf,YAAM,CAAEsgB,IAAF,CAAA,GAAW,IAAK1/B,CAAAA,QAAL,EAAjB;AAEA,YAAKy/B,UAAA,CAAWrgB,IAAX,EAAiBsgB,IAAjB,EAAuB,IAAKC,CAAAA,gBAA5B,CAAL,CAAA;AAEA,WAAM,CAAE,WAAA9X,IAAF,CAAN,GAAuB,IAAK9oB,CAAAA,aAA5B;AACA,cAAM6jD,YAAY,IAAKT,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAAlB;AACA,cAAIyI,IAAJ,IAAkBA,IAAW1H,CAAAA,MAA7B,CAAqC;AACjC,kBAAM,CAAE7c,GAAF,EAAOD,GAAP,CAAA,GAAewkB,IAAW1H,CAAAA,MAAOuV,CAAAA,SAAlB,CAA4BtW,IAA5B,CAArB;AACAwjC,qBAAUp9C,CAAAA,GAAV,CAAcud,KAAA,CAAM3D,IAAN,CAAd,IAAwC9b,GAAxC,GAAkDoQ,GAAlD,IAA6CrQ,GAA7C,GAAwCC,GAAxC,GAAA;AAFiC;AAJrC;AAHe,OAAnB,CAAA;AADgB;AAmBpBsgD,kCAA8B,EAAG;AAC7B,UAAK,IAAK7kD,CAAAA,aAAcY,CAAAA,OAAxB,CAAA;AAEA,YAAM,CAAE+/B,IAAF,EAAQiE,eAAR,CAAA,GAA4B,IAAK3jC,CAAAA,QAAL,EAAlC,EACM,CAAE6nB,UAAF,CAAA,GAAiB,IAAK9oB,CAAAA,aAD5B;AAEA,YAAKi/B,WAAA,CAAY2F,eAAZ,CAAL,IAAsC9b,UAAtC,IAAqD,IAAK45B,CAAAA,WAA1D,CAAA;AAMA,cAAKK,CAAAA,aAAL,EAAA;AAKA,cAAM+B,cAAc,CAAEn9C,EAAG,CAAL,EAAQsZ,EAAG,CAAX,CAApB;AACAgO,kBAAA,CAAU5O,IAAD,IAAU;AACf,gBAAMwjC,YAAY,IAAKT,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAAlB;AACA,gBAAIwjC,SAAJ,IAAsC,CAAA,CAAtC,KAAiB,IAAKnB,CAAAA,WAAtB,CAA6C;AACnCptC,uBAAAA,GAASuuC,SAAUvjD,CAAAA,GAAV,EAATgV;AACyB,uBAAA,GAAA,CAAE/Q,IAAK+Q,SAAP,EAAehR,IAAKgR,SAApB,CAAA;AAA8B,kBAAA,SAAA,IAAKotC,CAAAA,WAAL,CAAiBriC,IAAjB,CAAA;AA7YzE,kBAAItR,SAAS,GAAb;AACA,oBAAMg2C,eAAe3kC,UAAA,CAAW3W,SAAX,CAArB,EACMu7C,eAAe5kC,UAAA,CAAWha,MAAX,CADrB;AAEI4+C,0BAAJ,GAAmBD,YAAnB,GACIh2C,MADJ,GACa3H,WAAYuN,CAAAA,QAAZ,CAAqBvO,MAAO7B,CAAAA,GAA5B,EAAiC6B,MAAO9B,CAAAA,GAAxC,GAA8CygD,YAA9C,EAA4Dt7C,SAAOlF,CAAAA,GAAnE,CADb,GAGSwgD,YAHT,GAGwBC,YAHxB,KAIIj2C,MAJJ,GAIa3H,WAAYuN,CAAAA,QAAZ,CAAqBlL,SAAOlF,CAAAA,GAA5B,EAAiCkF,SAAOnF,CAAAA,GAAxC,GAA8C0gD,YAA9C,EAA4D5+C,MAAO7B,CAAAA,GAAnE,CAJb,CAAA;AA0YYugD,yBAAA,CAAYzkC,IAAZ,CAAA,GApYI/b,CAlgOhB,GAkgOmByK,MAlgOnB,GAkgOgBzK,CAlgOhB,GAkgOaC,CAhgOb,GAggOmBwK,MAhgOnB,GAggOaxK,CAhgOb,GAggOmBwK,MAoYP;AAFyC;AAF9B,WAAnB,CAAA;AAUA,cAAM,CAAEiX,iBAAF,CAAA,GAAwB,IAAKhmB,CAAAA,aAAciB,CAAAA,QAAnB,EAA9B;AACA,cAAKjB,CAAAA,aAAcY,CAAAA,OAAQ+lB,CAAAA,KAAM7c,CAAAA,SAAjC,GAA6Ckc,iBAAA,GACvCA,iBAAA,CAAkB,EAAlB,EAAsB,EAAtB,CADuC,GAEvC,MAFN;AAGA8C,oBAAWnW,CAAAA,IAAX,IAAmBmW,UAAWnW,CAAAA,IAAKyiB,CAAAA,YAAhB,EAAnB;AACAtM,oBAAW6M,CAAAA,YAAX,EAAA;AACA,cAAKwtB,CAAAA,kBAAL,EAAA;AAKAl0B,kBAAA,CAAU5O,IAAD,IAAU;AACf,gBAAKqgB,UAAA,CAAWrgB,IAAX,EAAiBsgB,IAAjB,EAAuB,IAAvB,CAAL,CAAA;AAKA,kBAAMkjB,YAAY,IAAKT,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAAlB,EACM,CAAE9b,GAAF,EAAOD,GAAP,CAAA,GAAe,IAAKo+C,CAAAA,WAAL,CAAiBriC,IAAjB,CADrB;AAEAwjC,uBAAUp9C,CAAAA,GAAV,CAA0BlC,GAA1B,IAA+BD,GAA/B,GAA0BC,GAA1B,IAAoCugD,WAAAnwC,CAAY0L,IAAZ1L,CAApC,CAAA;AAPA;AADe,WAAnB,CAAA;AAjCA;AAJA;AAD6B;AAiDjCswC,gBAAY,EAAG;AACX,UAAK,IAAKjlD,CAAAA,aAAcY,CAAAA,OAAxB,CAAA;AAEAyhD,2BAAoB57C,CAAAA,GAApB,CAAwB,IAAKzG,CAAAA,aAA7B,EAA4C,IAA5C,CAAA;AAKA,YAAMklD,sBAAsB/gC,eAAA,CAJZ,IAAKnkB,CAAAA,aAAcY,CAAAA,OAIP,EAAyB,aAAzB,EAAyCmjB,KAAD,IAAW;AAC3E,gBAAM,CAAE4c,IAAF,EAAQgG,YAAA,GAAe,CAAA,CAAvB,CAAA,GAAgC,IAAK1lC,CAAAA,QAAL,EAAtC;AACA0/B,cAAA,IAAQgG,YAAR,IAAwB,IAAK7mC,CAAAA,KAAL,CAAWikB,KAAX,CAAxB;AAF2E,SAAnD,CAA5B,EAIMohC,yBAAyB,EAAAA,IAAM;AACjC,gBAAM,CAAEvgB,eAAF,CAAA,GAAsB,IAAK3jC,CAAAA,QAAL,EAA5B;AACIg+B,qBAAA,CAAY2F,eAAZ,CAAJ,IAAoCA,eAAgBhkC,CAAAA,OAApD,KACI,IAAK8hD,CAAAA,WADT,GACuB,IAAKqB,CAAAA,qBAAL,EADvB;AAFiC,SAJrC,EAUM,CAAEj7B,UAAF,CAAA,GAAiB,IAAK9oB,CAAAA,aAV5B,EAWMolD,4BAA4Bt8B,UAAWlF,CAAAA,gBAAX,CAA4B,SAA5B,EAAuCuhC,sBAAvC,CAXlC;AAYIr8B,kBAAJ,IAAkB,CAACA,UAAW1H,CAAAA,MAA9B,KACI0H,UAAWnW,CAAAA,IACX,IADmBmW,UAAWnW,CAAAA,IAAKyiB,CAAAA,YAAhB,EACnB,EAAAtM,UAAW6M,CAAAA,YAAX,EAFJ;AAIA/a,aAAMlX,CAAAA,IAAN,CAAWyhD,sBAAX,CAAA;AAKA,YAAME,qBAAqB7hC,WAAA,CAAYzX,MAAZ,EAAoB,QAApB,EAA8B,EAAA,IAAM,IAAK84C,CAAAA,8BAAL,EAApC,CAA3B,EAKMS,2BAA2Bx8B,UAAWlF,CAAAA,gBAAX,CAA4B,WAA5B,EAA0C,CAAC,CAAEzhB,KAAF,EAAS+wB,gBAAT,CAAD,CAAA,IAAiC;AACpG,cAAKsvB,CAAAA,UAAT,IAAuBtvB,gBAAvB,KACIjE,QAAA,CAAU5O,IAAD,IAAU;AACf,kBAAMza,cAAc,IAAKw9C,CAAAA,kBAAL,CAAwB/iC,IAAxB,CAApB;AACKza,uBAAL,KAEA,IAAK2a,CAAAA,WAAL,CAAiBF,IAAjB,CACA,IAD0Ble,KAAA,CAAMke,IAAN,CAAYK,CAAAA,SACtC,EAAA9a,WAAYa,CAAAA,GAAZ,CAAgBb,WAAYtF,CAAAA,GAAZ,EAAhB,GAAoC6B,KAAA,CAAMke,IAAN,CAAYK,CAAAA,SAAhD,CAHA;AAFe,WAAnB,CAOA,EAAA,IAAK1gB,CAAAA,aAAc8D,CAAAA,MAAnB,EARJ;AADwG,SAA3E,CALjC;AAiBA,eAAO,EAAA,IAAM;AACTuhD,4BAAA,EAAA;AACAH,6BAAA,EAAA;AACAE,mCAAA,EAAA;AACAE,kCAAA,IAA4BA,wBAAA,EAA5B;AAJS,SAAb;AA7CA;AADW;AAqDfrkD,YAAQ,EAAG;AACP,YAAMR,QAAQ,IAAKT,CAAAA,aAAciB,CAAAA,QAAnB,EAAd,EACM,CAAE0/B,IAAA,GAAO,CAAA,CAAT,EAAgB2iB,iBAAA,GAAoB,CAAA,CAApC,EAA2CN,eAAA,GAAkB,CAAA,CAA7D,EAAoEpe,eAAA,GAAkB,CAAA,CAAtF,EAA6FxE,WAAA,GAxcpFC,IAwcT,EAA2HikB,YAAA,GAAe,CAAA,CAA1I,CAAA,GAAoJ7jD,KAD1J;AAEA,aAAO,CACH,GAAGA,KADA,EAEHkgC,IAFG,EAGH2iB,iBAHG,EAIHN,eAJG,EAKHpe,eALG,EAMHxE,WANG,EAOHkkB,YAPG,CAAP;AAHO;AAraf;AAycA,OAAMiB,YAAN,QAA0B1L,QAA1B;AACI7pB,eAAW,CAAC5D,IAAD,CAAO;AACd,WAAA,CAAMA,IAAN,CAAA;AAEA,UAAK81B,CAAAA,eAAL,GADA,IAAKsD,CAAAA,mBACL,GAD2Bp+C,WAAYC,CAAAA,IACvC;AACA,UAAKo+C,CAAAA,QAAL,GAAgB,IAAInD,yBAAJ,CAA8Bl2B,IAA9B,CAAhB;AAJc;AAMlBuG,SAAK,EAAG;AAGJ,YAAM,CAAE+yB,YAAF,CAAA,GAAmB,IAAKt5B,CAAAA,IAAKnrB,CAAAA,QAAV,EAAzB;AACIykD,kBAAJ,KACI,IAAKF,CAAAA,mBADT,GAC+BE,YAAaphC,CAAAA,SAAb,CAAuB,IAAKmhC,CAAAA,QAA5B,CAD/B;AAGA,UAAKvD,CAAAA,eAAL,GAAuB,IAAKuD,CAAAA,QAASR,CAAAA,YAAd,EAAvB,IAAuD79C,WAAYC,CAAAA,IAAnE;AAPI;AASRmtB,WAAO,EAAG;AACN,UAAKgxB,CAAAA,mBAAL,EAAA;AACA,UAAKtD,CAAAA,eAAL,EAAA;AAFM;AAhBd;AAsBA,QAAMyD,eAAgBjiC,OAADiiC,IAAa,CAAC5hC,KAAD,EAAQqb,IAAR,CAAA,IAAiB;AAC3C1b,WAAJ,IACI9I,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAM2f,OAAA,CAAQK,KAAR,EAAeqb,IAAf,CAAvB,CADJ;AAD+C,GAAnD;AAKA,OAAMwmB,WAAN,QAAyB/L,QAAzB;AACI7pB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKyL,CAAAA,yBAAL,GAAiCz+C,WAAYC,CAAAA,IAA7C;AAFU;AAIdy+C,iBAAa,CAACC,gBAAD,CAAmB;AAC5B,UAAKC,CAAAA,OAAL,GAAe,IAAIxF,UAAJ,CAAeuF,gBAAf,EAAiC,IAAKE,CAAAA,iBAAL,EAAjC,EAA2D,CACtE5mB,mBAAoB,IAAKjT,CAAAA,IAAK4xB,CAAAA,qBAAV,EADkD,CAA3D,CAAf;AAD4B;AAKhCiI,qBAAiB,EAAG;AAChB,YAAM,CAAEC,iBAAF,EAAqBC,UAArB,EAAiCC,KAAjC,EAAwCC,QAAxC,CAAA,GAAqD,IAAKj6B,CAAAA,IAAKnrB,CAAAA,QAAV,EAA3D;AACA,aAAO,CACHghD,eAAgB0D,YAAA,CAAaO,iBAAb,CADb,EAEHhF,QAASyE,YAAA,CAAaQ,UAAb,CAFN,EAGHhF,OAAQiF,KAHL,EAIHxE,MAAO,CAAC79B,KAAD,EAAQqb,IAAR,CAAAwiB,IAAiB;AACpB,eAAO,IAAKoE,CAAAA,OAAZ;AACIK,gBAAJ,IACIzrC,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAMsiD,QAAA,CAAStiC,KAAT,EAAgBqb,IAAhB,CAAvB,CADJ;AAFoB,OAJrB,CAAP;AAFgB;AAcpBzM,SAAK,EAAG;AACJ,UAAKkzB,CAAAA,yBAAL,GAAiC1hC,eAAA,CAAgB,IAAKiI,CAAAA,IAAKxrB,CAAAA,OAA1B,EAAmC,aAAnC,EAAmDmjB,KAAD,IAAW,IAAK+hC,CAAAA,aAAL,CAAmB/hC,KAAnB,CAA7D,CAAjC;AADI;AAGRngB,UAAM,EAAG;AACL,UAAKoiD,CAAAA,OAAL,IAAgB,IAAKA,CAAAA,OAAQ5D,CAAAA,cAAb,CAA4B,IAAK6D,CAAAA,iBAAL,EAA5B,CAAhB;AADK;AAGTzxB,WAAO,EAAG;AACN,UAAKqxB,CAAAA,yBAAL,EAAA;AACA,UAAKG,CAAAA,OAAL,IAAgB,IAAKA,CAAAA,OAAQrE,CAAAA,GAAb,EAAhB;AAFM;AA9Bd;AAuCA,QAAMrgB,2BAA2Brf,KAAMsmB,CAAAA,aAAN,CAAoB,EAApB,CAAjC;AAEA,OAAMnH,yBAAN,QAAuCnf,MAAMqhB,CAAAA,SAA7C;AAMIgjB,qBAAiB,EAAG;AAChB,YAAM,CAAEtmD,aAAF,EAAiBghC,WAAjB,EAA8BK,iBAA9B,EAAiDzX,QAAjD,CAAA,GAA8D,IAAKnpB,CAAAA,KAAzE,EACM,CAAEqoB,UAAF,CAAA,GAAiB9oB,aADvB;AAEAupB,uBAAA,CAAkBg9B,sBAAlB,CAAA;AACIz9B,gBAAJ,KACQkY,WAAYwlB,CAAAA,KAShB,IARIxlB,WAAYwlB,CAAAA,KAAMhkD,CAAAA,GAAlB,CAAsBsmB,UAAtB,CAQJ,EAPIuY,iBAOJ,IAPyBA,iBAAkB1c,CAAAA,QAO3C,IAPuDiF,QAOvD,IANIyX,iBAAkB1c,CAAAA,QAAlB,CAA2BmE,UAA3B,CAMJ,EAJAA,UAAWnW,CAAAA,IAAKmjB,CAAAA,SAAhB,EAIA,EAHAhN,UAAWlF,CAAAA,gBAAX,CAA4B,mBAA5B,EAAiD,EAAA,IAAM;AACnD,YAAKmB,CAAAA,YAAL,EAAA;AADmD,OAAvD,CAGA,EAAA+D,UAAWqP,CAAAA,UAAX,CAAsB,CAClB,GAAGrP,UAAWhjB,CAAAA,OADI,EAElB4e,eAAgB,EAAAA,IAAM,IAAKK,CAAAA,YAAL,EAFJ,CAAtB,CAVJ;AAeA+N,2BAAsB2sB,CAAAA,cAAtB,GAAuC,CAAA,CAAvC;AAnBgB;AAqBpBgH,2BAAuB,CAAC38B,SAAD,CAAY;AAC/B,YAAM,CAAE48B,gBAAF,EAAoB1mD,aAApB,EAAmC2gC,IAAnC,EAAyClc,SAAzC,CAAA,GAAuD,IAAKhkB,CAAAA,KAAlE,EACMqoB,aAAa9oB,aAAc8oB,CAAAA,UADjC;AAEA,UAAI,CAACA,UAAL;AACI,eAAO,IAAP;AADJ;AASAA,gBAAWrE,CAAAA,SAAX,GAAuBA,SAAvB;AACIkc,UAAJ,IACI7W,SAAU48B,CAAAA,gBADd,KACmCA,gBADnC,IAEyB5lD,IAAAA,EAFzB,KAEI4lD,gBAFJ,GAGI59B,UAAW2L,CAAAA,UAAX,EAHJ,GAMI,IAAK1P,CAAAA,YAAL,EANJ;AAQI+E,eAAUrF,CAAAA,SAAd,KAA4BA,SAA5B,KACQA,SAAJ,GACIqE,UAAWuT,CAAAA,OAAX,EADJ,GAGUvT,UAAW4T,CAAAA,QAAX,EAHV,IASI9hB,KAAM7W,CAAAA,UAAN,CAAiB,EAAA,IAAM;AACnB,cAAM4wB,QAAQ7L,UAAW8L,CAAAA,QAAX,EAAd;AACKD,aAAL,IAAeA,KAAMwF,CAAAA,OAAQz1B,CAAAA,MAA7B,IACI,IAAKqgB,CAAAA,YAAL,EADJ;AAFmB,OAAvB,CAVR;AAkBA,aAAO,IAAP;AAvC+B;AAyCnC4hC,sBAAkB,EAAG;AACjB,YAAM,CAAE79B,UAAF,CAAA,GAAiB,IAAKroB,CAAAA,KAAMT,CAAAA,aAAlC;AACI8oB,gBAAJ,KACIA,UAAWnW,CAAAA,IAAKmjB,CAAAA,SAAhB,EACA,EAAAC,SAAUhyB,CAAAA,UAAV,CAAqB,EAAA,IAAM;AACnB,SAAC+kB,UAAWiL,CAAAA,gBAAhB,IAAoCjL,UAAWwL,CAAAA,MAAX,EAApC,IACI,IAAKvP,CAAAA,YAAL,EADJ;AADuB,OAA3B,CAFJ;AAFiB;AAWrB6hC,wBAAoB,EAAG;AACnB,YAAM,CAAE5mD,aAAF,EAAiBghC,WAAjB,EAA8B,kBAAmB6lB,cAAjD,CAAA,GAAqE,IAAKpmD,CAAAA,KAAhF,EACM,CAAEqoB,UAAF,CAAA,GAAiB9oB,aADvB;AAEI8oB,gBAAJ,KACIA,UAAWqN,CAAAA,yBAAX,EAGA,EAFI6K,WAEJ,IAFmBA,WAAYwlB,CAAAA,KAE/B,IADIxlB,WAAYwlB,CAAAA,KAAM9xB,CAAAA,MAAlB,CAAyB5L,UAAzB,CACJ,EAAI+9B,cAAJ,IAAsBA,cAAeC,CAAAA,UAArC,IACID,cAAeC,CAAAA,UAAf,CAA0Bh+B,UAA1B,CALR;AAHmB;AAWvB/D,gBAAY,EAAG;AACX,YAAM,CAAEA,YAAF,CAAA,GAAmB,IAAKtkB,CAAAA,KAA9B;AACAskB,kBAAA,IAAgBA,YAAA,EAAhB;AAFW;AAIfjhB,UAAM,EAAG;AACL,aAAO,IAAP;AADK;AA9Fb;AAuGA,QAAMyiD,yBAAyB,CAC3BprB,aAAc,CACV,GAAGolB,mBADO,EAEV1iB,QAAS,CACL,qBADK,EAEL,sBAFK,EAGL,wBAHK,EAIL,yBAJK,CAFC,CADa,EAU3BsQ,oBAAqBoS,mBAVM,EAW3BnS,qBAAsBmS,mBAXK,EAY3BjS,uBAAwBiS,mBAZG,EAa3BlS,wBAAyBkS,mBAbE,EAc3BwG,UA78BqBC,CACrBppB,QAAS,CAACtoB,MAAD,EAAS,CAAE0W,SAAF,EAAaK,eAAb,CAAT,CAAAuR,IAA4C;AAEjD,UAAMqpB,SAASt8C,OAAQ3B,CAAAA,KAAR,CAAcsM,MAAd,CAAf;AAEA,QAAoB,CAApB,GAAI2xC,MAAOviD,CAAAA,MAAX;AACI,aAJa4Q,MAIb;AADJ;AAEM2/B,UAAAA,GAAWtqC,OAAQnB,CAAAA,iBAAR,CAA0B8L,MAA1B,CAAX2/B;AACN,UAAMr+B,SAA8B,QAArB,KAAA,MAAOqwC,OAAA,CAAO,CAAP,CAAP,GAAgC,CAAhC,GAAoC,CAAnD,EAEMC,SAAS76B,eAAgB1kB,CAAAA,CAAE8Y,CAAAA,KAA3BymC,GAAmCl7B,SAAUrkB,CAAAA,CAFnD;AAGMw/C,aAAAA,GAAS96B,eAAgBpL,CAAAA,CAAER,CAAAA,KAA3B0mC,GAAmCn7B,SAAU/K,CAAAA,CAA7CkmC;AACNF,UAAA,CAAO,CAAP,GAAWrwC,MAAX,CAAA,IAAsBswC,MAAtB;AACAD,UAAA,CAAO,CAAP,GAAWrwC,MAAX,CAAA,IAAsBuwC,SAAtB;AAOMC,aAAAA,GAA2BF,MAA3BE,GAA2CzyC,GAA3CyyC,IAAmCD,SAAnCC,GAA2BF,MAA3BE;AAE4B,YAAlC,KAAI,MAAOH,OAAA,CAAO,CAAP,GAAWrwC,MAAX,CAAX,KACIqwC,MAAA,CAAO,CAAP,GAAWrwC,MAAX,CADJ,IAC0BwwC,SAD1B;AAGkC,YAAlC,KAAI,MAAOH,OAAA,CAAO,CAAP,GAAWrwC,MAAX,CAAX,KACIqwC,MAAA,CAAO,CAAP,GAAWrwC,MAAX,CADJ,IAC0BwwC,SAD1B;AAEA,WAAOnS,MAAA,CAASgS,MAAT,CAAP;AA1BiD,GADhCD,CA+7BM,CAA/B,EAiBMrmB,OAAO,CACTua,IAAK,CACDrB,QAAS+L,UADR,CADI,EAITjlB,KAAM,CACFkZ,QAAS0L,WADP,EAEF1f,eAAgBua,kBAFd,EAGFrf,aAHE,CAJG,CAjBb;AAuCA,OAAMsmB,aAAN,QAA2BxN,QAA3B;AACIlnB,SAAK,EAAG;AACJ,YAAM,CAAE/xB,OAAF,CAAA,GAAc,IAAKwrB,CAAAA,IAAzB;AACKxrB,aAAL,KAEA,IAAK4zB,CAAAA,OAFL,GAEelgB,SAAU0mC,CAAAA,KAAV,CAAgBp6C,OAAhB,EAAyB,CAAC0mD,QAAD,EAAWzG,UAAX,CAAA,IAA0B;AAC9Dtf,wBAAA,CAAiB,IAAKnV,CAAAA,IAAtB,EAA4By0B,UAA5B,EAAwC,OAAxC,CAAA;AACA,eAAQ0G,QAAD,IAAchmB,gBAAA,CAAiB,IAAKnV,CAAAA,IAAtB,EAA4Bm7B,QAA5B,EAAsC,KAAtC,CAArB;AAF8D,OAAnD,CAFf;AAFI;AASR/yB,WAAO,EAAG;;AAVd;AAaA,OAAMgzB,aAAN,QAA2B3N,QAA3B;AACI7pB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AACA,UAAKn8B,CAAAA,QAAL,GAAgB,CAAA,CAAhB;AAFU;AAIdwpC,WAAO,EAAG;AACN,UAAIC,iBAAiB,CAAA,CAArB;AAOA,SAAI;AACAA,sBAAA,GAAiB,IAAKt7B,CAAAA,IAAKxrB,CAAAA,OAAQklB,CAAAA,OAAlB,CAA0B,gBAA1B,CAAjB;AADA,OAGJ,QAAOxU,CAAP,CAAU;AACNo2C,sBAAA,GAAiB,CAAA,CAAjB;AADM;AAGLA,oBAAL,IAAwB,IAAKt7B,CAAAA,IAAKlS,CAAAA,cAAlC,KAEA,IAAKkS,CAAAA,IAAKlS,CAAAA,cAAeuF,CAAAA,SAAzB,CAAmC,YAAnC,EAAiD,CAAA,CAAjD,CACA,EAAA,IAAKxB,CAAAA,QAAL,GAAgB,CAAA,CAHhB;AAdM;AAmBV0pC,UAAM,EAAG;AACA,UAAK1pC,CAAAA,QAAV,IAAuB,IAAKmO,CAAAA,IAAKlS,CAAAA,cAAjC,KAEA,IAAKkS,CAAAA,IAAKlS,CAAAA,cAAeuF,CAAAA,SAAzB,CAAmC,YAAnC,EAAiD,CAAA,CAAjD,CACA,EAAA,IAAKxB,CAAAA,QAAL,GAAgB,CAAA,CAHhB;AADK;AAMT0U,SAAK,EAAG;AACJ,UAAK6B,CAAAA,OAAL,GAAoBghB,CAAAhyB,WAAA,CAAY,IAAK4I,CAAAA,IAAKxrB,CAAAA,OAAtB,EAA+B,OAA/B,EAAwC,EAAA,IAAM,IAAK6mD,CAAAA,OAAL,EAA9C,CAAAjS,EAA+DhyB,WAAA,CAAY,IAAK4I,CAAAA,IAAKxrB,CAAAA,OAAtB,EAA+B,MAA/B,EAAuC,EAAA,IAAM,IAAK+mD,CAAAA,MAAL,EAA7C,CAA/DnS,CA9oNmBhyC,CAAAA,MAAb,CAAoB0S,gBAApB,CA8oN1B;AADI;AAGRse,WAAO,EAAG;;AAjCd;AAkDA,OAAMozB,aAAN,QAA2B/N,QAA3B;AACIlnB,SAAK,EAAG;AACJ,YAAM,CAAE/xB,OAAF,CAAA,GAAc,IAAKwrB,CAAAA,IAAzB;AACKxrB,aAAL,KAEA,IAAK4zB,CAAAA,OAFL,GAEelgB,SAAUuzC,CAAAA,KAAV,CAAgBjnD,OAAhB,EAAyB,CAAC0mD,QAAD,EAAWzG,UAAX,CAAA,IAA0B;AAC9Dpf,wBAAA,CAAiB,IAAKrV,CAAAA,IAAtB,EAA4By0B,UAA5B,EAAwC,OAAxC,CAAA;AACA,eAAO,CAAC0G,QAAD,EAAW,CAAEO,OAAF,CAAX,CAAA,IAA2BrmB,gBAAA,CAAiB,IAAKrV,CAAAA,IAAtB,EAA4Bm7B,QAA5B,EAAsCO,OAAA,GAAU,KAAV,GAAkB,QAAxD,CAAlC;AAF8D,OAAnD,EAGZ,CAAEC,gBAAiB,IAAK37B,CAAAA,IAAK3rB,CAAAA,KAAMunD,CAAAA,eAAnC,CAHY,CAFf;AAFI;AASRxzB,WAAO,EAAG;;AAVd;AAkBA,QAAM+N,oBAAoB,IAAIsY,OAAJ,EAA1B,EAMM9Y,YAAY,IAAI8Y,OAAJ,EANlB,EAOMoN,uBAAwBC,KAADD,IAAW;AACpC,UAAM3mD,WAAWihC,iBAAkBjiC,CAAAA,GAAlB,CAAsB4nD,KAAM9hD,CAAAA,MAA5B,CAAjB;AACA9E,YAAA,IAAYA,QAAA,CAAS4mD,KAAT,CAAZ;AAFoC,GAPxC,EAWM9lB,2BAA4B+lB,OAAD/lB,IAAa;AAC1C+lB,WAAQhoD,CAAAA,OAAR,CAAgB8nD,oBAAhB,CAAA;AAD0C,GAX9C,EA2CMG,iBAAiB,CACnBh2C,KAAM,CADa,EAEnB6I,IAAK,CAFc,CA3CvB;AA+CA,OAAMotC,cAAN,QAA4BxO,QAA5B;AACI7pB,eAAW,EAAG;AACV,WAAA,CAAM,GAAGoqB,SAAT,CAAA;AAEA,UAAKkO,CAAAA,QAAL,GADA,IAAKC,CAAAA,cACL,GADsB,CAAA,CACtB;AAHU;AAKdC,iBAAa,EAAG;AACZ,UAAKh0B,CAAAA,OAAL,EAAA;AACA,YAAM,CAAEmO,QAAA,GAAW,EAAb,CAAA,GAAoB,IAAKvW,CAAAA,IAAKnrB,CAAAA,QAAV,EAA1B,EACM,CAAE0R,IAAF,EAAQ,OAAQ81C,UAAhB,EAA4BC,MAAA,GAAS,MAArC,EAA6CC,IAA7C,CAAA,GAAsDhmB,QAD5D;AAoCA,aAAON,mBAAA,CAAoB,IAAKjW,CAAAA,IAAKxrB,CAAAA,OAA9B,EAlCSkF,CACZ6M,KAAMA,IAAA,GAAOA,IAAK/R,CAAAA,OAAZ,GAAsBE,IAAAA,EADhBgF,EAEZ2iD,UAFY3iD,EAGZ8iD,UAA6B,QAAlB,KAAA,MAAOF,OAAP,GAA6BA,MAA7B,GAAsCN,cAAA,CAAeM,MAAf,CAHrC5iD,CAkCT,EA7BuBoiD,KAADW,IAAW;AACpC,YAAM,CAAEC,cAAF,CAAA,GAAqBZ,KAA3B;AAIA,YAAI,IAAKI,CAAAA,QAAT,KAAsBQ,cAAtB,KAEA,IAAKR,CAAAA,QAKD,GALYQ,cAKZ,EAAAH,CAAAA,IAAA,IAASG,cAAT,IAAgCP,CAAL,IAAKA,CAAAA,cAPpC,EAUK;AAAIO,wBAAJ,KACD,IAAKP,CAAAA,cADJ,GACqB,CAAA,CADrB;AAGD,cAAKn8B,CAAAA,IAAKlS,CAAAA,cAAd,IACI,IAAKkS,CAAAA,IAAKlS,CAAAA,cAAeuF,CAAAA,SAAzB,CAAmC,aAAnC,EAAkDqpC,cAAlD,CADJ;AAOA,cAAM,CAAEC,eAAF,EAAmBC,eAAnB,CAAA,GAAuC,IAAK58B,CAAAA,IAAKnrB,CAAAA,QAAV,EAA7C;AAEA,WADMK,cACN,GADiBwnD,cAAA,GAAiBC,eAAjB,GAAmCC,eACpD,KAAY1nD,cAAA,CAAS4mD,KAAT,CAAZ;AAZK;AAf+B,OA6BjC,CAAP;AAtCY;AAwChBv1B,SAAK,EAAG;AACJ,UAAK61B,CAAAA,aAAL,EAAA;AADI;AAGR5kD,UAAM,EAAG;AACL,UAAoC,WAApC,KAAI,MAAOu+B,qBAAX,CAAA;AAEA,YAAM,CAAE1hC,KAAF,EAASqpB,SAAT,CAAA,GAAuB,IAAKsC,CAAAA,IAAlC;AAC0B,SAAC,QAAD,EAAW,QAAX,EAAqB,MAArB,CAA6Bha,CAAAA,IAA7B62C,CAAkCvmB,wBAAA,CAAyBjiC,KAAzB,EAAgCqpB,SAAhC,CAAlCm/B,CAC1B,IACI,IAAKT,CAAAA,aAAL,EADJ;AAJA;AADK;AASTh0B,WAAO,EAAG;;AA1Dd;AAgEA,QAAM00B,oBAAoB,CACtB/N,OAAQ,CACJtB,QAASwO,aADL,CADc,EAItBpN,IAAK,CACDpB,QAAS+N,YADR,CAJiB,EAOtB7M,MAAO,CACHlB,QAAS2N,YADN,CAPe,EAUtBxM,MAAO,CACHnB,QAASwN,YADN,CAVe,CAA1B,EAeMjmC,SAAS,CACXA,OAAQ,CACJykB,eAAgBua,kBADZ,EAEJrf,aAFI,CADG,CAff,EA2CMqF,wBAAwB+iB,MAAOC,CAAAA,GAAP,CAAW,uBAAX,CA3C9B,EA8RM5iB,wBAAwB,EAAAA,IAAO,EACjC7f,MAAO,EAD0B,EAEjC7c,UAAW,EAFsB,EAGjC+c,gBAAiB,EAHgB,EAIjCD,KAAM,EAJ2B,EA9RrC,EA2VM0gB,uBAAuB,yJAAA,CAAA,KAAA,CAAA,GAAA,CA3V7B;AAkZMI,yBAAuB,EAAAA,IAAO,EAChC,GAAGlB,qBAAA,EAD6B,EAEhCpf,MAAO,EAFyB,EAlZpC,EAicMkhB,mBAAmB,CACrBpD,eAAgBsV,kBAAA,CAAmB,CAC/Bj4B,4BAA6BsH,6BADE,EAE/BrH,kBAAmBgkB,qBAFY,CAAnB,CADK,CAjczB,EAwcM6iB,cAAc,0BAAA,CAAA,KAAA,CAAA,GAAA,CAxcpB,EAycMhhB,kBAAkB,CACpBnD,eAAgBsV,kBAAA,CAAmB,CACFj4B,2BADE,EAE/BC,kBAAmBklB,oBAFY,EAG/BjlB,SAAU,CAAC,CAAEhiB,KAAF,EAASqpB,SAAT,EAAoBlpB,OAApB,EAA6B+hB,WAA7B,EAA0CvI,YAA1C,CAAD,CAAAqI,IAA+D;AACrE,QAAK7hB,OAAL,CAAA;AAEA,UAAIkmB,eAAe,CAAC,CAACrmB,KAAMkgC,CAAAA,IAA3B;AACA,UAAI,CAAC7Z,YAAL;AACI,aAAK,IAAMzmB,YAAX,GAAkB+Z,aAAlB;AACI,cAAI4M,cAAexlB,CAAAA,GAAf,CAAmBnB,YAAnB,CAAJ,CAA6B;AACzBymB,wBAAA,GAAe,CAAA,CAAf;AACA;AAFyB;AADjC;AADJ;AAQA,UAAKA,YAAL,CAAA;AAEIwiC,oBAAAA,GAAe,CAACx/B,SAAhBw/B;AACJ,YAAIx/B,SAAJ;AAKI,eAASrlB,YAAT,GAAa,CAAb,EAAgBA,YAAhB,GAAoB4kD,WAAY3kD,CAAAA,MAAhC,EAAwCD,YAAA,EAAxC,CAA6C;AACzC,kBAAMpE,MAAMgpD,WAAA,CAAY5kD,YAAZ,CAAZ;AACIhE,iBAAA,CAAMJ,GAAN,CAAJ,KACIypB,SAAA,CAAUzpB,GAAV,CADJ,KAEIipD,YAFJ,GAEmB,CAAA,CAFnB;AAFyC;AALjD;AAaKA,oBAAL,IAEA1uC,KAAMlX,CAAAA,IAAN,CAAW,EAAA,IAAM;AACb+kB,6BAAA,CAAoB7nB,OAApB,EAA6B+hB,WAA7B,CAAA;AACA/H,eAAM9W,CAAAA,MAAN,CAAa,EAAA,IAAM;AACf+jB,yBAAA,CAAclF,WAAd,EAA2BvI,YAA3B,EAAyC8N,QAAA,CAAStnB,OAAQykB,CAAAA,OAAjB,CAAzC,EAAoE5kB,KAAMulB,CAAAA,iBAA1E,CAAA;AACAkD,qBAAA,CAAUtoB,OAAV,EAAmB+hB,WAAnB,CAAA;AAFe,WAAnB,CAAA;AAFa,SAAjB,CAFA;AAhBA;AAXA;AADqE,GAH1C,CAAnB,CADI,CAzcxB,EAsgBM4mC,yBAAyB,CAACjmB,SAAD,EAAYx9B,OAAZ,CAAAyjD,IACpBniB,cAAA,CAAe9D,SAAf,CAAA,GACD,IAAIub,gBAAJ,CAAqB/4C,OAArB,CADC,GAED,IAAIo5C,iBAAJ,CAAsBp5C,OAAtB,EAA+B,CAC7Bg/B,gBAAiBxB,SAAjBwB,KAA+B7iB,KAAM8lB,CAAAA,QADR,CAA/B,CAzgBV,EA8gBMI,wBAAsCD,4BAAA,CAA6B,CACrE,GAAGluB,UADkE,EAErE,GAAGkvC,iBAFkE,EAGrE,GAAGvoB,IAHkE,EAIrE,GAAGvf,MAJkE,CAA7B,EAKzCmoC,sBALyC,CA9gB5C;AAqhBA5pD,SAAQ+4C,CAAAA,oBAAR,GAA+BA,oBAA/B;AACA/4C,SAAQ0yB,CAAAA,QAAR,GAAmBA,QAAnB;AACA1yB,SAAQu/C,CAAAA,iBAAR,GAA4BA,iBAA5B;AACAv/C,SAAQshC,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAthC,SAAQ+jC,CAAAA,WAAR,GAAsBA,WAAtB;AACA/jC,SAAQikC,CAAAA,mBAAR,GAA8BA,mBAA9B;AACAjkC,SAAQojC,CAAAA,aAAR,GAAwBA,aAAxB;AACApjC,SAAQsE,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAtE,SAAQoG,CAAAA,WAAR,GAAsBA,WAAtB;AACApG,SAAQ6kB,CAAAA,eAAR,GAA0BA,eAA1B;AACA7kB,SAAQk/C,CAAAA,gBAAR,GAA2BA,gBAA3B;AACAl/C,SAAQ2hC,CAAAA,wBAAR,GAAmCA,wBAAnC;AACA3hC,SAAQ27C,CAAAA,aAAR,GAAwBA,aAAxB;AACA37C,SAAQ04C,CAAAA,iBAAR,GAA4BA,iBAA5B;AACA14C,SAAQ6jB,CAAAA,WAAR,GAAsBA,WAAtB;AACA7jB,SAAQwkB,CAAAA,eAAR,GAA0BA,eAA1B;AACAxkB,SAAQykB,CAAAA,cAAR,GAAyBA,cAAzB;AACAzkB,SAAQ4pB,CAAAA,iBAAR,GAA4BA,iBAA5B;AACA5pB,SAAQiF,CAAAA,aAAR,GAAwBA,aAAxB;AACAjF,SAAQslB,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAtlB,SAAQia,CAAAA,aAAR,GAAwBA,aAAxB;AACAja,SAAQ6pD,CAAAA,YAAR,GAr1MAA,QAAqB,CAAC1jD,OAAD,CAAU;AAC3B,WAAO,IAAI4S,mBAAJ,CAAwB5S,OAAxB,CAAP;AAD2B,GAq1M/B;AACAnG,SAAQ2c,CAAAA,oBAAR,GAA+BA,oBAA/B;AACA3c,SAAQqa,CAAAA,UAAR,GAAqBA,UAArB;AACAra,SAAQisC,CAAAA,UAAR,GAAqBA,UAArB;AACAjsC,SAAQ+rC,CAAAA,MAAR,GAAiBA,MAAjB;AACA/rC,SAAQgsC,CAAAA,SAAR,GAAoBA,SAApB;AACAhsC,SAAQ8rC,CAAAA,OAAR,GAAkBA,OAAlB;AACA9rC,SAAQiuC,CAAAA,uBAAR,GAAkCA,uBAAlC;AACAjuC,SAAQomB,CAAAA,cAAR,GAAyBA,cAAzB;AACApmB,SAAQygB,CAAAA,UAAR,GAAqBA,UAArB;AACAzgB,SAAQ2pB,CAAAA,WAAR,GAAsBA,WAAtB;AACA3pB,SAAQ0tB,CAAAA,WAAR,GAAsBA,WAAtB;AACA1tB,SAAQksC,CAAAA,MAAR,GAAiBA,MAAjB;AACAlsC,SAAQqsC,CAAAA,SAAR,GAAoBA,SAApB;AACArsC,SAAQosC,CAAAA,OAAR,GAAkBA,OAAlB;AACApsC,SAAQ8Q,CAAAA,KAAR,GAAgBA,KAAhB;AACA9Q,SAAQopC,CAAAA,mBAAR,GAA8BA,mBAA9B;AACAppC,SAAQwI,CAAAA,KAAR,GAAgBA,KAAhB;AACAxI,SAAQgL,CAAAA,OAAR,GAAkBA,OAAlB;AACAhL,SAAQ+2B,CAAAA,SAAR,GAAoBA,SAApB;AACA/2B,SAAQ4pD,CAAAA,sBAAR,GAAiCA,sBAAjC;AACA5pD,SAAQwoC,CAAAA,qBAAR,GAAgCA,qBAAhC;AACAxoC,SAAQuoC,CAAAA,4BAAR,GAAuCA,4BAAvC;AACAvoC,SAAQolC,CAAAA,6BAAR,GAAwCA,6BAAxC;AACAplC,SAAQoH,CAAAA,WAAR,GAAsBA,WAAtB;AACApH,SAAQoX,CAAAA,aAAR,GAAwBA,aAAxB;AACApX,SAAQkY,CAAAA,KAAR,GAAgBA,KAAhB;AACAlY,SAAQktB,CAAAA,QAAR,GArsHiB,CAACte,CAAD,EAAIC,CAAJ,CAAAqe,IAAUxoB,IAAKwD,CAAAA,GAAL,CAAS0G,CAAT,GAAaC,CAAb,CAqsH3B;AACA7O,SAAQ2tB,CAAAA,UAAR,GAAqBA,UAArB;AACA3tB,SAAQghC,CAAAA,IAAR,GAAeA,IAAf;AACAhhC,SAAQ81C,CAAAA,MAAR,GAAiBA,MAAjB;AACA91C,SAAQwX,CAAAA,SAAR,GAAoBA,SAApB;AACAxX,SAAQ+1C,CAAAA,OAAR,GAAkBA,OAAlB;AACA/1C,SAAQ6X,CAAAA,0BAAR,GAAqCA,0BAArC;AACA7X,SAAQgX,CAAAA,UAAR,GAAqBA,UAArB;AACAhX,SAAQ+hB,CAAAA,WAAR,GAAsBA,WAAtB;AACA/hB,SAAQqQ,CAAAA,UAAR,GAAqBA,UAArB;AACArQ,SAAQib,CAAAA,KAAR,GAAgBA,KAAhB;AACAjb,SAAQiD,CAAAA,SAAR,GAAoBA,SAApB;AACAjD,SAAQk2B,CAAAA,UAAR,GAAqBA,UAArB;AACAl2B,SAAQupD,CAAAA,iBAAR,GAA4BA,iBAA5B;AACAvpD,SAAQyN,CAAAA,gBAAR,GAA2BA,gBAA3B;AACAzN,SAAQkH,CAAAA,oBAAR,GAA+BA,oBAA/B;AACAlH,SAAQ4lB,CAAAA,wBAAR,GAAmCA,wBAAnC;AACA5lB,SAAQiV,CAAAA,OAAR,GAAkBA,OAAlB;AACAjV,SAAQ2lB,CAAAA,wBAAR,GAAmCA,wBAAnC;AACA3lB,SAAQ2rC,CAAAA,qBAAR,GAAgCA,qBAAhC;AACA3rC,SAAQwW,CAAAA,WAAR,GAAsBA,WAAtB;AACAxW,SAAQ6lB,CAAAA,SAAR,GAAoBA,SAApB;AACA7lB,SAAQ4X,CAAAA,aAAR,GAAwBA,aAAxB;AACA5X,SAAQqqB,CAAAA,aAAR,GAAwBA,aAAxB;AACArqB,SAAQwlB,CAAAA,YAAR,GAAuBA,YAAvB;AACAxlB,SAAQ0hB,CAAAA,iBAAR,GAA4BA,iBAA5B;AACA1hB,SAAQ0N,CAAAA,SAAR,GAAoBA,SAApB;AACA1N,SAAQyhB,CAAAA,MAAR,GAAiBA,MAAjB;AACAzhB,SAAQ4hB,CAAAA,uBAAR,GAAkCA,uBAAlC;AACA5hB,SAAQm/B,CAAAA,YAAR,GAAuBA,YAAvB;AACAn/B,SAAQ66C,CAAAA,kBAAR,GAA6BA,kBAA7B;AACA76C,SAAQ4rC,CAAAA,YAAR,GAAuBA,YAAvB;AACA5rC,SAAQ8P,CAAAA,GAAR,GAAcA,GAAd;AACA9P,SAAQsP,CAAAA,SAAR,GAAoBuR,WAApB;AACA7gB,SAAQymC,CAAAA,qBAAR,GAAgCA,qBAAhC;AACAzmC,SAAQiG,CAAAA,WAAR,GAAsBA,WAAtB;AACAjG,SAAQ8pD,CAAAA,QAAR,GA5/RAA,QAAiB,CAAC,CAAC,GAAG5kD,GAAJ,CAAD,EAAW6kD,SAAX,EAAsBC,OAAtB,CAA+B;AAC5C,UAAMC,aAAyB,CAAZ,GAAAF,SAAA,GAAgB7kD,GAAIH,CAAAA,MAApB,GAA6BglD,SAA7B,GAAyCA,SAA5D;AACkB,KAAlB,IAAIE,UAAJ,IAAuBA,UAAvB,GAAoC/kD,GAAIH,CAAAA,MAAxC,KACUmlD,OAEN,GAF2B,CAAV,GAAAF,OAAA,GAAc9kD,GAAIH,CAAAA,MAAlB,GAA2BilD,OAA3B,GAAqCA,OAEtD,EADM,CAAC7kD,SAAD,CACN,GADeD,GAAIK,CAAAA,MAAJ,CAAWwkD,SAAX,EAAsB,CAAtB,CACf,EAAA7kD,GAAIK,CAAAA,MAAJ,CAAW2kD,OAAX,EAAqB,CAArB,EAAwB/kD,SAAxB,CAHJ;AAKA,WAAOD,GAAP;AAP4C,GA4/RhD;AACAlF,SAAQmH,CAAAA,4BAAR,GAAuCA,4BAAvC;AACAnH,SAAQ0rC,CAAAA,qBAAR,GAvlR8BA,gBAulR9B;AACA1rC,SAAQmqD,CAAAA,IAAR,GA94Oa,CAAC,GAAGtU,YAAJ,CAAAsU,IAAqBtU,YAAahyC,CAAAA,MAAb,CAAoB0S,gBAApB,CA84OlC;AACAvW,SAAQkmB,CAAAA,oBAAR,GAA+BA,oBAA/B;AACAlmB,SAAQ+nB,CAAAA,EAAR,GAAaA,EAAb;AACA/nB,SAAQqF,CAAAA,UAAR,GAAqBA,UAArB;AACArF,SAAQwiB,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAxiB,SAAQ6rC,CAAAA,aAAR,GAAwBA,aAAxB;AACA7rC,SAAQwgD,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAxgD,SAAQqG,CAAAA,SAAR,GAAoBA,SAApB;AACArG,SAAQmT,CAAAA,MAAR,GAAiBA,MAAjB;AACAnT,SAAQgY,CAAAA,mBAAR,GAA8BA,mBAA9B;AACAhY,SAAQ4D,CAAAA,UAAR,GAAqBA,UAArB;AACA5D,SAAQ24C,CAAAA,aAAR,GAAwBA,aAAxB;AACA34C,SAAQwtB,CAAAA,IAAR,GAAeA,IAAf;AACAxtB,SAAQqnB,CAAAA,cAAR,GAAyBA,cAAzB;AACArnB,SAAQoiB,CAAAA,WAAR,GAAsBA,WAAtB;AACApiB,SAAQoqD,CAAAA,YAAR,GAt8JAA,QAAqB,EAAG;AACH,QAAA,UAAA9nC,KAAMsC,CAAAA,UAAN,CAAiBC,eAAjB,CAAA;AAAjB,WAGmB,IAAZ,KAAA1H,OAAA,GAAmB,CAAA,CAAnB,GAA0BA,OAAQ2H,CAAAA,SAHzC;AADoB,GAs8JxB;AACA9kB,SAAQ4kC,CAAAA,yBAAR,GAAoCA,yBAApC;AACA5kC,SAAQ0kB,CAAAA,WAAR,GAAsBA,WAAtB;AACA1kB,SAAQwF,CAAAA,iBAAR,GAA4BA,iBAA5B;AACAxF,SAAQi7C,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAj7C,SAAQ0F,CAAAA,QAAR,GAAmBA,QAAnB;AA/0SuH,CAAvH;;\",\n\"sources\":[\"node_modules/framer-motion/dist/cjs/create-CGKJurkh.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$framer_motion$dist$cjs$create_CGKJurkh\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar motionDom = require('motion-dom');\\nvar motionUtils = require('motion-utils');\\nvar jsxRuntime = require('react/jsx-runtime');\\nvar React = require('react');\\n\\nconst LayoutGroupContext = React.createContext({});\\n\\nfunction isAnimationControls(v) {\\n    return (v !== null &&\\n        typeof v === \\\"object\\\" &&\\n        typeof v.start === \\\"function\\\");\\n}\\n\\nfunction getValueState(visualElement) {\\n    const state = [{}, {}];\\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\\n        state[0][key] = value.get();\\n        state[1][key] = value.getVelocity();\\n    });\\n    return state;\\n}\\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\\n    /**\\n     * If the variant definition is a function, resolve.\\n     */\\n    if (typeof definition === \\\"function\\\") {\\n        const [current, velocity] = getValueState(visualElement);\\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\\n    }\\n    /**\\n     * If the variant definition is a variant label, or\\n     * the function returned a variant label, resolve.\\n     */\\n    if (typeof definition === \\\"string\\\") {\\n        definition = props.variants && props.variants[definition];\\n    }\\n    /**\\n     * At this point we've resolved both functions and variant labels,\\n     * but the resolved variant label might itself have been a function.\\n     * If so, resolve. This can only have returned a valid target object.\\n     */\\n    if (typeof definition === \\\"function\\\") {\\n        const [current, velocity] = getValueState(visualElement);\\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\\n    }\\n    return definition;\\n}\\n\\nfunction resolveVariant(visualElement, definition, custom) {\\n    const props = visualElement.getProps();\\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\\n}\\n\\nconst MotionGlobalConfig = {\\n    skipAnimations: false,\\n    useManualTiming: false,\\n};\\n\\nconst stepsOrder = [\\n    \\\"read\\\", // Read\\n    \\\"resolveKeyframes\\\", // Write/Read/Write/Read\\n    \\\"update\\\", // Compute\\n    \\\"preRender\\\", // Compute\\n    \\\"render\\\", // Write\\n    \\\"postRender\\\", // Compute\\n];\\n\\nconst statsBuffer = {\\n    value: null,\\n    addProjectionMetrics: null,\\n};\\n\\nfunction createRenderStep(runNextFrame, stepName) {\\n    /**\\n     * We create and reuse two queues, one to queue jobs for the current frame\\n     * and one for the next. We reuse to avoid triggering GC after x frames.\\n     */\\n    let thisFrame = new Set();\\n    let nextFrame = new Set();\\n    /**\\n     * Track whether we're currently processing jobs in this step. This way\\n     * we can decide whether to schedule new jobs for this frame or next.\\n     */\\n    let isProcessing = false;\\n    let flushNextFrame = false;\\n    /**\\n     * A set of processes which were marked keepAlive when scheduled.\\n     */\\n    const toKeepAlive = new WeakSet();\\n    let latestFrameData = {\\n        delta: 0.0,\\n        timestamp: 0.0,\\n        isProcessing: false,\\n    };\\n    let numCalls = 0;\\n    function triggerCallback(callback) {\\n        if (toKeepAlive.has(callback)) {\\n            step.schedule(callback);\\n            runNextFrame();\\n        }\\n        numCalls++;\\n        callback(latestFrameData);\\n    }\\n    const step = {\\n        /**\\n         * Schedule a process to run on the next frame.\\n         */\\n        schedule: (callback, keepAlive = false, immediate = false) => {\\n            const addToCurrentFrame = immediate && isProcessing;\\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\\n            if (keepAlive)\\n                toKeepAlive.add(callback);\\n            if (!queue.has(callback))\\n                queue.add(callback);\\n            return callback;\\n        },\\n        /**\\n         * Cancel the provided callback from running on the next frame.\\n         */\\n        cancel: (callback) => {\\n            nextFrame.delete(callback);\\n            toKeepAlive.delete(callback);\\n        },\\n        /**\\n         * Execute all schedule callbacks.\\n         */\\n        process: (frameData) => {\\n            latestFrameData = frameData;\\n            /**\\n             * If we're already processing we've probably been triggered by a flushSync\\n             * inside an existing process. Instead of executing, mark flushNextFrame\\n             * as true and ensure we flush the following frame at the end of this one.\\n             */\\n            if (isProcessing) {\\n                flushNextFrame = true;\\n                return;\\n            }\\n            isProcessing = true;\\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\\n            // Execute this frame\\n            thisFrame.forEach(triggerCallback);\\n            /**\\n             * If we're recording stats then\\n             */\\n            if (stepName && statsBuffer.value) {\\n                statsBuffer.value.frameloop[stepName].push(numCalls);\\n            }\\n            numCalls = 0;\\n            // Clear the frame so no callbacks remain. This is to avoid\\n            // memory leaks should this render step not run for a while.\\n            thisFrame.clear();\\n            isProcessing = false;\\n            if (flushNextFrame) {\\n                flushNextFrame = false;\\n                step.process(frameData);\\n            }\\n        },\\n    };\\n    return step;\\n}\\n\\nconst maxElapsed = 40;\\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\\n    let runNextFrame = false;\\n    let useDefaultElapsed = true;\\n    const state = {\\n        delta: 0.0,\\n        timestamp: 0.0,\\n        isProcessing: false,\\n    };\\n    const flagRunNextFrame = () => (runNextFrame = true);\\n    const steps = stepsOrder.reduce((acc, key) => {\\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\\n        return acc;\\n    }, {});\\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\\n    const processBatch = () => {\\n        const timestamp = MotionGlobalConfig.useManualTiming\\n            ? state.timestamp\\n            : performance.now();\\n        runNextFrame = false;\\n        if (!MotionGlobalConfig.useManualTiming) {\\n            state.delta = useDefaultElapsed\\n                ? 1000 / 60\\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\\n        }\\n        state.timestamp = timestamp;\\n        state.isProcessing = true;\\n        // Unrolled render loop for better per-frame performance\\n        read.process(state);\\n        resolveKeyframes.process(state);\\n        update.process(state);\\n        preRender.process(state);\\n        render.process(state);\\n        postRender.process(state);\\n        state.isProcessing = false;\\n        if (runNextFrame && allowKeepAlive) {\\n            useDefaultElapsed = false;\\n            scheduleNextBatch(processBatch);\\n        }\\n    };\\n    const wake = () => {\\n        runNextFrame = true;\\n        useDefaultElapsed = true;\\n        if (!state.isProcessing) {\\n            scheduleNextBatch(processBatch);\\n        }\\n    };\\n    const schedule = stepsOrder.reduce((acc, key) => {\\n        const step = steps[key];\\n        acc[key] = (process, keepAlive = false, immediate = false) => {\\n            if (!runNextFrame)\\n                wake();\\n            return step.schedule(process, keepAlive, immediate);\\n        };\\n        return acc;\\n    }, {});\\n    const cancel = (process) => {\\n        for (let i = 0; i < stepsOrder.length; i++) {\\n            steps[stepsOrder[i]].cancel(process);\\n        }\\n    };\\n    return { schedule, cancel, state, steps };\\n}\\n\\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \\\"undefined\\\" ? requestAnimationFrame : motionUtils.noop, true);\\n\\n/**\\n * Generate a list of every possible transform key.\\n */\\nconst transformPropOrder = [\\n    \\\"transformPerspective\\\",\\n    \\\"x\\\",\\n    \\\"y\\\",\\n    \\\"z\\\",\\n    \\\"translateX\\\",\\n    \\\"translateY\\\",\\n    \\\"translateZ\\\",\\n    \\\"scale\\\",\\n    \\\"scaleX\\\",\\n    \\\"scaleY\\\",\\n    \\\"rotate\\\",\\n    \\\"rotateX\\\",\\n    \\\"rotateY\\\",\\n    \\\"rotateZ\\\",\\n    \\\"skew\\\",\\n    \\\"skewX\\\",\\n    \\\"skewY\\\",\\n];\\n/**\\n * A quick lookup for transform props.\\n */\\nconst transformProps = new Set(transformPropOrder);\\n\\nconst positionalKeys = new Set([\\n    \\\"width\\\",\\n    \\\"height\\\",\\n    \\\"top\\\",\\n    \\\"left\\\",\\n    \\\"right\\\",\\n    \\\"bottom\\\",\\n    ...transformPropOrder,\\n]);\\n\\nconst isKeyframesTarget = (v) => {\\n    return Array.isArray(v);\\n};\\n\\nconst isCustomValue = (v) => {\\n    return Boolean(v && typeof v === \\\"object\\\" && v.mix && v.toValue);\\n};\\nconst resolveFinalValueInKeyframes = (v) => {\\n    // TODO maybe throw if v.length - 1 is placeholder token?\\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\\n};\\n\\nlet now;\\nfunction clearTime() {\\n    now = undefined;\\n}\\n/**\\n * An eventloop-synchronous alternative to performance.now().\\n *\\n * Ensures that time measurements remain consistent within a synchronous context.\\n * Usually calling performance.now() twice within the same synchronous context\\n * will return different values which isn't useful for animations when we're usually\\n * trying to sync animations to the same frame.\\n */\\nconst time = {\\n    now: () => {\\n        if (now === undefined) {\\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\\n                ? frameData.timestamp\\n                : performance.now());\\n        }\\n        return now;\\n    },\\n    set: (newTime) => {\\n        now = newTime;\\n        queueMicrotask(clearTime);\\n    },\\n};\\n\\nfunction addUniqueItem(arr, item) {\\n    if (arr.indexOf(item) === -1)\\n        arr.push(item);\\n}\\nfunction removeItem(arr, item) {\\n    const index = arr.indexOf(item);\\n    if (index > -1)\\n        arr.splice(index, 1);\\n}\\n// Adapted from array-move\\nfunction moveItem([...arr], fromIndex, toIndex) {\\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\\n    if (startIndex >= 0 && startIndex < arr.length) {\\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\\n        const [item] = arr.splice(fromIndex, 1);\\n        arr.splice(endIndex, 0, item);\\n    }\\n    return arr;\\n}\\n\\nclass SubscriptionManager {\\n    constructor() {\\n        this.subscriptions = [];\\n    }\\n    add(handler) {\\n        addUniqueItem(this.subscriptions, handler);\\n        return () => removeItem(this.subscriptions, handler);\\n    }\\n    notify(a, b, c) {\\n        const numSubscriptions = this.subscriptions.length;\\n        if (!numSubscriptions)\\n            return;\\n        if (numSubscriptions === 1) {\\n            /**\\n             * If there's only a single handler we can just call it without invoking a loop.\\n             */\\n            this.subscriptions[0](a, b, c);\\n        }\\n        else {\\n            for (let i = 0; i < numSubscriptions; i++) {\\n                /**\\n                 * Check whether the handler exists before firing as it's possible\\n                 * the subscriptions were modified during this loop running.\\n                 */\\n                const handler = this.subscriptions[i];\\n                handler && handler(a, b, c);\\n            }\\n        }\\n    }\\n    getSize() {\\n        return this.subscriptions.length;\\n    }\\n    clear() {\\n        this.subscriptions.length = 0;\\n    }\\n}\\n\\n/*\\n  Convert velocity into velocity per second\\n\\n  @param [number]: Unit per frame\\n  @param [number]: Frame duration in ms\\n*/\\nfunction velocityPerSecond(velocity, frameDuration) {\\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\\n}\\n\\nconst warned = new Set();\\nfunction warnOnce(condition, message, element) {\\n    if (condition || warned.has(message))\\n        return;\\n    console.warn(message);\\n    if (element)\\n        console.warn(element);\\n    warned.add(message);\\n}\\n\\n/**\\n * Maximum time between the value of two frames, beyond which we\\n * assume the velocity has since been 0.\\n */\\nconst MAX_VELOCITY_DELTA = 30;\\nconst isFloat = (value) => {\\n    return !isNaN(parseFloat(value));\\n};\\nconst collectMotionValues = {\\n    current: undefined,\\n};\\n/**\\n * `MotionValue` is used to track the state and velocity of motion values.\\n *\\n * @public\\n */\\nclass MotionValue {\\n    /**\\n     * @param init - The initiating value\\n     * @param config - Optional configuration options\\n     *\\n     * -  `transformer`: A function to transform incoming values with.\\n     *\\n     * @internal\\n     */\\n    constructor(init, options = {}) {\\n        /**\\n         * This will be replaced by the build step with the latest version number.\\n         * When MotionValues are provided to motion components, warn if versions are mixed.\\n         */\\n        this.version = \\\"12.4.7\\\";\\n        /**\\n         * Tracks whether this value can output a velocity. Currently this is only true\\n         * if the value is numerical, but we might be able to widen the scope here and support\\n         * other value types.\\n         *\\n         * @internal\\n         */\\n        this.canTrackVelocity = null;\\n        /**\\n         * An object containing a SubscriptionManager for each active event.\\n         */\\n        this.events = {};\\n        this.updateAndNotify = (v, render = true) => {\\n            const currentTime = time.now();\\n            /**\\n             * If we're updating the value during another frame or eventloop\\n             * than the previous frame, then the we set the previous frame value\\n             * to current.\\n             */\\n            if (this.updatedAt !== currentTime) {\\n                this.setPrevFrameValue();\\n            }\\n            this.prev = this.current;\\n            this.setCurrent(v);\\n            // Update update subscribers\\n            if (this.current !== this.prev && this.events.change) {\\n                this.events.change.notify(this.current);\\n            }\\n            // Update render subscribers\\n            if (render && this.events.renderRequest) {\\n                this.events.renderRequest.notify(this.current);\\n            }\\n        };\\n        this.hasAnimated = false;\\n        this.setCurrent(init);\\n        this.owner = options.owner;\\n    }\\n    setCurrent(current) {\\n        this.current = current;\\n        this.updatedAt = time.now();\\n        if (this.canTrackVelocity === null && current !== undefined) {\\n            this.canTrackVelocity = isFloat(this.current);\\n        }\\n    }\\n    setPrevFrameValue(prevFrameValue = this.current) {\\n        this.prevFrameValue = prevFrameValue;\\n        this.prevUpdatedAt = this.updatedAt;\\n    }\\n    /**\\n     * Adds a function that will be notified when the `MotionValue` is updated.\\n     *\\n     * It returns a function that, when called, will cancel the subscription.\\n     *\\n     * When calling `onChange` inside a React component, it should be wrapped with the\\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\\n     *\\n     * ```jsx\\n     * export const MyComponent = () => {\\n     *   const x = useMotionValue(0)\\n     *   const y = useMotionValue(0)\\n     *   const opacity = useMotionValue(1)\\n     *\\n     *   useEffect(() => {\\n     *     function updateOpacity() {\\n     *       const maxXY = Math.max(x.get(), y.get())\\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\\n     *       opacity.set(newOpacity)\\n     *     }\\n     *\\n     *     const unsubscribeX = x.on(\\\"change\\\", updateOpacity)\\n     *     const unsubscribeY = y.on(\\\"change\\\", updateOpacity)\\n     *\\n     *     return () => {\\n     *       unsubscribeX()\\n     *       unsubscribeY()\\n     *     }\\n     *   }, [])\\n     *\\n     *   return <motion.div style={{ x }} />\\n     * }\\n     * ```\\n     *\\n     * @param subscriber - A function that receives the latest value.\\n     * @returns A function that, when called, will cancel this subscription.\\n     *\\n     * @deprecated\\n     */\\n    onChange(subscription) {\\n        if (process.env.NODE_ENV !== \\\"production\\\") {\\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\\\"change\\\", callback).`);\\n        }\\n        return this.on(\\\"change\\\", subscription);\\n    }\\n    on(eventName, callback) {\\n        if (!this.events[eventName]) {\\n            this.events[eventName] = new SubscriptionManager();\\n        }\\n        const unsubscribe = this.events[eventName].add(callback);\\n        if (eventName === \\\"change\\\") {\\n            return () => {\\n                unsubscribe();\\n                /**\\n                 * If we have no more change listeners by the start\\n                 * of the next frame, stop active animations.\\n                 */\\n                frame.read(() => {\\n                    if (!this.events.change.getSize()) {\\n                        this.stop();\\n                    }\\n                });\\n            };\\n        }\\n        return unsubscribe;\\n    }\\n    clearListeners() {\\n        for (const eventManagers in this.events) {\\n            this.events[eventManagers].clear();\\n        }\\n    }\\n    /**\\n     * Attaches a passive effect to the `MotionValue`.\\n     *\\n     * @internal\\n     */\\n    attach(passiveEffect, stopPassiveEffect) {\\n        this.passiveEffect = passiveEffect;\\n        this.stopPassiveEffect = stopPassiveEffect;\\n    }\\n    /**\\n     * Sets the state of the `MotionValue`.\\n     *\\n     * @remarks\\n     *\\n     * ```jsx\\n     * const x = useMotionValue(0)\\n     * x.set(10)\\n     * ```\\n     *\\n     * @param latest - Latest value to set.\\n     * @param render - Whether to notify render subscribers. Defaults to `true`\\n     *\\n     * @public\\n     */\\n    set(v, render = true) {\\n        if (!render || !this.passiveEffect) {\\n            this.updateAndNotify(v, render);\\n        }\\n        else {\\n            this.passiveEffect(v, this.updateAndNotify);\\n        }\\n    }\\n    setWithVelocity(prev, current, delta) {\\n        this.set(current);\\n        this.prev = undefined;\\n        this.prevFrameValue = prev;\\n        this.prevUpdatedAt = this.updatedAt - delta;\\n    }\\n    /**\\n     * Set the state of the `MotionValue`, stopping any active animations,\\n     * effects, and resets velocity to `0`.\\n     */\\n    jump(v, endAnimation = true) {\\n        this.updateAndNotify(v);\\n        this.prev = v;\\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\\n        endAnimation && this.stop();\\n        if (this.stopPassiveEffect)\\n            this.stopPassiveEffect();\\n    }\\n    /**\\n     * Returns the latest state of `MotionValue`\\n     *\\n     * @returns - The latest state of `MotionValue`\\n     *\\n     * @public\\n     */\\n    get() {\\n        if (collectMotionValues.current) {\\n            collectMotionValues.current.push(this);\\n        }\\n        return this.current;\\n    }\\n    /**\\n     * @public\\n     */\\n    getPrevious() {\\n        return this.prev;\\n    }\\n    /**\\n     * Returns the latest velocity of `MotionValue`\\n     *\\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\\n     *\\n     * @public\\n     */\\n    getVelocity() {\\n        const currentTime = time.now();\\n        if (!this.canTrackVelocity ||\\n            this.prevFrameValue === undefined ||\\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\\n            return 0;\\n        }\\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\\n        // Casts because of parseFloat's poor typing\\n        return velocityPerSecond(parseFloat(this.current) -\\n            parseFloat(this.prevFrameValue), delta);\\n    }\\n    /**\\n     * Registers a new animation to control this `MotionValue`. Only one\\n     * animation can drive a `MotionValue` at one time.\\n     *\\n     * ```jsx\\n     * value.start()\\n     * ```\\n     *\\n     * @param animation - A function that starts the provided animation\\n     *\\n     * @internal\\n     */\\n    start(startAnimation) {\\n        this.stop();\\n        return new Promise((resolve) => {\\n            this.hasAnimated = true;\\n            this.animation = startAnimation(resolve);\\n            if (this.events.animationStart) {\\n                this.events.animationStart.notify();\\n            }\\n        }).then(() => {\\n            if (this.events.animationComplete) {\\n                this.events.animationComplete.notify();\\n            }\\n            this.clearAnimation();\\n        });\\n    }\\n    /**\\n     * Stop the currently active animation.\\n     *\\n     * @public\\n     */\\n    stop() {\\n        if (this.animation) {\\n            this.animation.stop();\\n            if (this.events.animationCancel) {\\n                this.events.animationCancel.notify();\\n            }\\n        }\\n        this.clearAnimation();\\n    }\\n    /**\\n     * Returns `true` if this value is currently animating.\\n     *\\n     * @public\\n     */\\n    isAnimating() {\\n        return !!this.animation;\\n    }\\n    clearAnimation() {\\n        delete this.animation;\\n    }\\n    /**\\n     * Destroy and clean up subscribers to this `MotionValue`.\\n     *\\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\\n     * created a `MotionValue` via the `motionValue` function.\\n     *\\n     * @public\\n     */\\n    destroy() {\\n        this.clearListeners();\\n        this.stop();\\n        if (this.stopPassiveEffect) {\\n            this.stopPassiveEffect();\\n        }\\n    }\\n}\\nfunction motionValue(init, options) {\\n    return new MotionValue(init, options);\\n}\\n\\n/**\\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\\n * it doesn't exist.\\n */\\nfunction setMotionValue(visualElement, key, value) {\\n    if (visualElement.hasValue(key)) {\\n        visualElement.getValue(key).set(value);\\n    }\\n    else {\\n        visualElement.addValue(key, motionValue(value));\\n    }\\n}\\nfunction setTarget(visualElement, definition) {\\n    const resolved = resolveVariant(visualElement, definition);\\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\\n    target = { ...target, ...transitionEnd };\\n    for (const key in target) {\\n        const value = resolveFinalValueInKeyframes(target[key]);\\n        setMotionValue(visualElement, key, value);\\n    }\\n}\\n\\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\\n\\nfunction isWillChangeMotionValue(value) {\\n    return Boolean(isMotionValue(value) && value.add);\\n}\\n\\nfunction addValueToWillChange(visualElement, key) {\\n    const willChange = visualElement.getValue(\\\"willChange\\\");\\n    /**\\n     * It could be that a user has set willChange to a regular MotionValue,\\n     * in which case we can't add the value to it.\\n     */\\n    if (isWillChangeMotionValue(willChange)) {\\n        return willChange.add(key);\\n    }\\n}\\n\\n/**\\n * Convert camelCase to dash-case properties.\\n */\\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \\\"$1-$2\\\").toLowerCase();\\n\\nconst optimizedAppearDataId = \\\"framerAppearId\\\";\\nconst optimizedAppearDataAttribute = \\\"data-\\\" + camelToDash(optimizedAppearDataId);\\n\\nfunction getOptimisedAppearId(visualElement) {\\n    return visualElement.props[optimizedAppearDataAttribute];\\n}\\n\\nconst instantAnimationState = {\\n    current: false,\\n};\\n\\n/*\\n  Bezier function generator\\n  This has been modified from Ga\\u00ebtan Renaudeau's BezierEasing\\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\\n  \\n  I've removed the newtonRaphsonIterate algo because in benchmarking it\\n  wasn't noticiably faster than binarySubdivision, indeed removing it\\n  usually improved times, depending on the curve.\\n  I also removed the lookup table, as for the added bundle size and loop we're\\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\\n  to 12 to compensate and this still tended to be faster for no perceivable\\n  loss in accuracy.\\n  Usage\\n    const easeOut = cubicBezier(.17,.67,.83,.67);\\n    const x = easeOut(0.5); // returns 0.627...\\n*/\\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\\n    t;\\nconst subdivisionPrecision = 0.0000001;\\nconst subdivisionMaxIterations = 12;\\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\\n    let currentX;\\n    let currentT;\\n    let i = 0;\\n    do {\\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\\n        currentX = calcBezier(currentT, mX1, mX2) - x;\\n        if (currentX > 0.0) {\\n            upperBound = currentT;\\n        }\\n        else {\\n            lowerBound = currentT;\\n        }\\n    } while (Math.abs(currentX) > subdivisionPrecision &&\\n        ++i < subdivisionMaxIterations);\\n    return currentT;\\n}\\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\\n    // If this is a linear gradient, return linear easing\\n    if (mX1 === mY1 && mX2 === mY2)\\n        return motionUtils.noop;\\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\\n    // If animation is at start/end, return t without easing\\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\\n}\\n\\n// Accepts an easing function and returns a new one that outputs mirrored values for\\n// the second half of the animation. Turns easeIn into easeInOut.\\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\\n\\n// Accepts an easing function and returns a new one that outputs reversed values.\\n// Turns easeIn into easeOut.\\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\\n\\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\\n\\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\\n\\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\\nconst circOut = reverseEasing(circIn);\\nconst circInOut = mirrorEasing(circIn);\\n\\n/**\\n * Check if the value is a zero value string like \\\"0px\\\" or \\\"0%\\\"\\n */\\nconst isZeroValueString = (v) => /^0[^.\\\\s]+$/u.test(v);\\n\\nfunction isNone(value) {\\n    if (typeof value === \\\"number\\\") {\\n        return value === 0;\\n    }\\n    else if (value !== null) {\\n        return value === \\\"none\\\" || value === \\\"0\\\" || isZeroValueString(value);\\n    }\\n    else {\\n        return true;\\n    }\\n}\\n\\nconst clamp = (min, max, v) => {\\n    if (v > max)\\n        return max;\\n    if (v < min)\\n        return min;\\n    return v;\\n};\\n\\nconst number = {\\n    test: (v) => typeof v === \\\"number\\\",\\n    parse: parseFloat,\\n    transform: (v) => v,\\n};\\nconst alpha = {\\n    ...number,\\n    transform: (v) => clamp(0, 1, v),\\n};\\nconst scale = {\\n    ...number,\\n    default: 1,\\n};\\n\\n// If this number is a decimal, make it just five decimal places\\n// to avoid exponents\\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\\n\\nconst floatRegex = /-?(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)/gu;\\n\\nfunction isNullish(v) {\\n    return v == null;\\n}\\n\\nconst singleColorRegex = /^(?:#[\\\\da-f]{3,8}|(?:rgb|hsl)a?\\\\((?:-?[\\\\d.]+%?[,\\\\s]+){2}-?[\\\\d.]+%?\\\\s*(?:[,/]\\\\s*)?(?:\\\\b\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)?%?\\\\))$/iu;\\n\\n/**\\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\\n * but false if a number or multiple colors\\n */\\nconst isColorString = (type, testProp) => (v) => {\\n    return Boolean((typeof v === \\\"string\\\" &&\\n        singleColorRegex.test(v) &&\\n        v.startsWith(type)) ||\\n        (testProp &&\\n            !isNullish(v) &&\\n            Object.prototype.hasOwnProperty.call(v, testProp)));\\n};\\nconst splitColor = (aName, bName, cName) => (v) => {\\n    if (typeof v !== \\\"string\\\")\\n        return v;\\n    const [a, b, c, alpha] = v.match(floatRegex);\\n    return {\\n        [aName]: parseFloat(a),\\n        [bName]: parseFloat(b),\\n        [cName]: parseFloat(c),\\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\\n    };\\n};\\n\\nconst clampRgbUnit = (v) => clamp(0, 255, v);\\nconst rgbUnit = {\\n    ...number,\\n    transform: (v) => Math.round(clampRgbUnit(v)),\\n};\\nconst rgba = {\\n    test: /*@__PURE__*/ isColorString(\\\"rgb\\\", \\\"red\\\"),\\n    parse: /*@__PURE__*/ splitColor(\\\"red\\\", \\\"green\\\", \\\"blue\\\"),\\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \\\"rgba(\\\" +\\n        rgbUnit.transform(red) +\\n        \\\", \\\" +\\n        rgbUnit.transform(green) +\\n        \\\", \\\" +\\n        rgbUnit.transform(blue) +\\n        \\\", \\\" +\\n        sanitize(alpha.transform(alpha$1)) +\\n        \\\")\\\",\\n};\\n\\nfunction parseHex(v) {\\n    let r = \\\"\\\";\\n    let g = \\\"\\\";\\n    let b = \\\"\\\";\\n    let a = \\\"\\\";\\n    // If we have 6 characters, ie #FF0000\\n    if (v.length > 5) {\\n        r = v.substring(1, 3);\\n        g = v.substring(3, 5);\\n        b = v.substring(5, 7);\\n        a = v.substring(7, 9);\\n        // Or we have 3 characters, ie #F00\\n    }\\n    else {\\n        r = v.substring(1, 2);\\n        g = v.substring(2, 3);\\n        b = v.substring(3, 4);\\n        a = v.substring(4, 5);\\n        r += r;\\n        g += g;\\n        b += b;\\n        a += a;\\n    }\\n    return {\\n        red: parseInt(r, 16),\\n        green: parseInt(g, 16),\\n        blue: parseInt(b, 16),\\n        alpha: a ? parseInt(a, 16) / 255 : 1,\\n    };\\n}\\nconst hex = {\\n    test: /*@__PURE__*/ isColorString(\\\"#\\\"),\\n    parse: parseHex,\\n    transform: rgba.transform,\\n};\\n\\nconst createUnitType = (unit) => ({\\n    test: (v) => typeof v === \\\"string\\\" && v.endsWith(unit) && v.split(\\\" \\\").length === 1,\\n    parse: parseFloat,\\n    transform: (v) => `${v}${unit}`,\\n});\\nconst degrees = /*@__PURE__*/ createUnitType(\\\"deg\\\");\\nconst percent = /*@__PURE__*/ createUnitType(\\\"%\\\");\\nconst px = /*@__PURE__*/ createUnitType(\\\"px\\\");\\nconst vh = /*@__PURE__*/ createUnitType(\\\"vh\\\");\\nconst vw = /*@__PURE__*/ createUnitType(\\\"vw\\\");\\nconst progressPercentage = {\\n    ...percent,\\n    parse: (v) => percent.parse(v) / 100,\\n    transform: (v) => percent.transform(v * 100),\\n};\\n\\nconst hsla = {\\n    test: /*@__PURE__*/ isColorString(\\\"hsl\\\", \\\"hue\\\"),\\n    parse: /*@__PURE__*/ splitColor(\\\"hue\\\", \\\"saturation\\\", \\\"lightness\\\"),\\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\\n        return (\\\"hsla(\\\" +\\n            Math.round(hue) +\\n            \\\", \\\" +\\n            percent.transform(sanitize(saturation)) +\\n            \\\", \\\" +\\n            percent.transform(sanitize(lightness)) +\\n            \\\", \\\" +\\n            sanitize(alpha.transform(alpha$1)) +\\n            \\\")\\\");\\n    },\\n};\\n\\nconst color = {\\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\\n    parse: (v) => {\\n        if (rgba.test(v)) {\\n            return rgba.parse(v);\\n        }\\n        else if (hsla.test(v)) {\\n            return hsla.parse(v);\\n        }\\n        else {\\n            return hex.parse(v);\\n        }\\n    },\\n    transform: (v) => {\\n        return typeof v === \\\"string\\\"\\n            ? v\\n            : v.hasOwnProperty(\\\"red\\\")\\n                ? rgba.transform(v)\\n                : hsla.transform(v);\\n    },\\n};\\n\\nconst colorRegex = /(?:#[\\\\da-f]{3,8}|(?:rgb|hsl)a?\\\\((?:-?[\\\\d.]+%?[,\\\\s]+){2}-?[\\\\d.]+%?\\\\s*(?:[,/]\\\\s*)?(?:\\\\b\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)?%?\\\\))/giu;\\n\\nfunction test(v) {\\n    var _a, _b;\\n    return (isNaN(v) &&\\n        typeof v === \\\"string\\\" &&\\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\\n            0);\\n}\\nconst NUMBER_TOKEN = \\\"number\\\";\\nconst COLOR_TOKEN = \\\"color\\\";\\nconst VAR_TOKEN = \\\"var\\\";\\nconst VAR_FUNCTION_TOKEN = \\\"var(\\\";\\nconst SPLIT_TOKEN = \\\"${}\\\";\\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\\nconst complexRegex = /var\\\\s*\\\\(\\\\s*--(?:[\\\\w-]+\\\\s*|[\\\\w-]+\\\\s*,(?:\\\\s*[^)(\\\\s]|\\\\s*\\\\((?:[^)(]|\\\\([^)(]*\\\\))*\\\\))+\\\\s*)\\\\)|#[\\\\da-f]{3,8}|(?:rgb|hsl)a?\\\\((?:-?[\\\\d.]+%?[,\\\\s]+){2}-?[\\\\d.]+%?\\\\s*(?:[,/]\\\\s*)?(?:\\\\b\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)?%?\\\\)|-?(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)/giu;\\nfunction analyseComplexValue(value) {\\n    const originalValue = value.toString();\\n    const values = [];\\n    const indexes = {\\n        color: [],\\n        number: [],\\n        var: [],\\n    };\\n    const types = [];\\n    let i = 0;\\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\\n        if (color.test(parsedValue)) {\\n            indexes.color.push(i);\\n            types.push(COLOR_TOKEN);\\n            values.push(color.parse(parsedValue));\\n        }\\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\\n            indexes.var.push(i);\\n            types.push(VAR_TOKEN);\\n            values.push(parsedValue);\\n        }\\n        else {\\n            indexes.number.push(i);\\n            types.push(NUMBER_TOKEN);\\n            values.push(parseFloat(parsedValue));\\n        }\\n        ++i;\\n        return SPLIT_TOKEN;\\n    });\\n    const split = tokenised.split(SPLIT_TOKEN);\\n    return { values, split, indexes, types };\\n}\\nfunction parseComplexValue(v) {\\n    return analyseComplexValue(v).values;\\n}\\nfunction createTransformer(source) {\\n    const { split, types } = analyseComplexValue(source);\\n    const numSections = split.length;\\n    return (v) => {\\n        let output = \\\"\\\";\\n        for (let i = 0; i < numSections; i++) {\\n            output += split[i];\\n            if (v[i] !== undefined) {\\n                const type = types[i];\\n                if (type === NUMBER_TOKEN) {\\n                    output += sanitize(v[i]);\\n                }\\n                else if (type === COLOR_TOKEN) {\\n                    output += color.transform(v[i]);\\n                }\\n                else {\\n                    output += v[i];\\n                }\\n            }\\n        }\\n        return output;\\n    };\\n}\\nconst convertNumbersToZero = (v) => typeof v === \\\"number\\\" ? 0 : v;\\nfunction getAnimatableNone$1(v) {\\n    const parsed = parseComplexValue(v);\\n    const transformer = createTransformer(v);\\n    return transformer(parsed.map(convertNumbersToZero));\\n}\\nconst complex = {\\n    test,\\n    parse: parseComplexValue,\\n    createTransformer,\\n    getAnimatableNone: getAnimatableNone$1,\\n};\\n\\n/**\\n * Properties that should default to 1 or 100%\\n */\\nconst maxDefaults = new Set([\\\"brightness\\\", \\\"contrast\\\", \\\"saturate\\\", \\\"opacity\\\"]);\\nfunction applyDefaultFilter(v) {\\n    const [name, value] = v.slice(0, -1).split(\\\"(\\\");\\n    if (name === \\\"drop-shadow\\\")\\n        return v;\\n    const [number] = value.match(floatRegex) || [];\\n    if (!number)\\n        return v;\\n    const unit = value.replace(number, \\\"\\\");\\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\\n    if (number !== value)\\n        defaultValue *= 100;\\n    return name + \\\"(\\\" + defaultValue + unit + \\\")\\\";\\n}\\nconst functionRegex = /\\\\b([a-z-]*)\\\\(.*?\\\\)/gu;\\nconst filter = {\\n    ...complex,\\n    getAnimatableNone: (v) => {\\n        const functions = v.match(functionRegex);\\n        return functions ? functions.map(applyDefaultFilter).join(\\\" \\\") : v;\\n    },\\n};\\n\\nconst browserNumberValueTypes = {\\n    // Border props\\n    borderWidth: px,\\n    borderTopWidth: px,\\n    borderRightWidth: px,\\n    borderBottomWidth: px,\\n    borderLeftWidth: px,\\n    borderRadius: px,\\n    radius: px,\\n    borderTopLeftRadius: px,\\n    borderTopRightRadius: px,\\n    borderBottomRightRadius: px,\\n    borderBottomLeftRadius: px,\\n    // Positioning props\\n    width: px,\\n    maxWidth: px,\\n    height: px,\\n    maxHeight: px,\\n    top: px,\\n    right: px,\\n    bottom: px,\\n    left: px,\\n    // Spacing props\\n    padding: px,\\n    paddingTop: px,\\n    paddingRight: px,\\n    paddingBottom: px,\\n    paddingLeft: px,\\n    margin: px,\\n    marginTop: px,\\n    marginRight: px,\\n    marginBottom: px,\\n    marginLeft: px,\\n    // Misc\\n    backgroundPositionX: px,\\n    backgroundPositionY: px,\\n};\\n\\nconst transformValueTypes = {\\n    rotate: degrees,\\n    rotateX: degrees,\\n    rotateY: degrees,\\n    rotateZ: degrees,\\n    scale,\\n    scaleX: scale,\\n    scaleY: scale,\\n    scaleZ: scale,\\n    skew: degrees,\\n    skewX: degrees,\\n    skewY: degrees,\\n    distance: px,\\n    translateX: px,\\n    translateY: px,\\n    translateZ: px,\\n    x: px,\\n    y: px,\\n    z: px,\\n    perspective: px,\\n    transformPerspective: px,\\n    opacity: alpha,\\n    originX: progressPercentage,\\n    originY: progressPercentage,\\n    originZ: px,\\n};\\n\\nconst int = {\\n    ...number,\\n    transform: Math.round,\\n};\\n\\nconst numberValueTypes = {\\n    ...browserNumberValueTypes,\\n    ...transformValueTypes,\\n    zIndex: int,\\n    size: px,\\n    // SVG\\n    fillOpacity: alpha,\\n    strokeOpacity: alpha,\\n    numOctaves: int,\\n};\\n\\n/**\\n * A map of default value types for common values\\n */\\nconst defaultValueTypes = {\\n    ...numberValueTypes,\\n    // Color props\\n    color,\\n    backgroundColor: color,\\n    outlineColor: color,\\n    fill: color,\\n    stroke: color,\\n    // Border props\\n    borderColor: color,\\n    borderTopColor: color,\\n    borderRightColor: color,\\n    borderBottomColor: color,\\n    borderLeftColor: color,\\n    filter,\\n    WebkitFilter: filter,\\n};\\n/**\\n * Gets the default ValueType for the provided value key\\n */\\nconst getDefaultValueType = (key) => defaultValueTypes[key];\\n\\nfunction getAnimatableNone(key, value) {\\n    let defaultValueType = getDefaultValueType(key);\\n    if (defaultValueType !== filter)\\n        defaultValueType = complex;\\n    // If value is not recognised as animatable, ie \\\"none\\\", create an animatable version origin based on the target\\n    return defaultValueType.getAnimatableNone\\n        ? defaultValueType.getAnimatableNone(value)\\n        : undefined;\\n}\\n\\n/**\\n * If we encounter keyframes like \\\"none\\\" or \\\"0\\\" and we also have keyframes like\\n * \\\"#fff\\\" or \\\"200px 200px\\\" we want to find a keyframe to serve as a template for\\n * the \\\"none\\\" keyframes. In this case \\\"#fff\\\" or \\\"200px 200px\\\" - then these get turned into\\n * zero equivalents, i.e. \\\"#fff0\\\" or \\\"0px 0px\\\".\\n */\\nconst invalidTemplates = new Set([\\\"auto\\\", \\\"none\\\", \\\"0\\\"]);\\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\\n    let i = 0;\\n    let animatableTemplate = undefined;\\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\\n        const keyframe = unresolvedKeyframes[i];\\n        if (typeof keyframe === \\\"string\\\" &&\\n            !invalidTemplates.has(keyframe) &&\\n            analyseComplexValue(keyframe).values.length) {\\n            animatableTemplate = unresolvedKeyframes[i];\\n        }\\n        i++;\\n    }\\n    if (animatableTemplate && name) {\\n        for (const noneIndex of noneKeyframeIndexes) {\\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\\n        }\\n    }\\n}\\n\\nconst isNumOrPxType = (v) => v === number || v === px;\\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\\\", \\\")[pos]);\\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\\n    if (transform === \\\"none\\\" || !transform)\\n        return 0;\\n    const matrix3d = transform.match(/^matrix3d\\\\((.+)\\\\)$/u);\\n    if (matrix3d) {\\n        return getPosFromMatrix(matrix3d[1], pos3);\\n    }\\n    else {\\n        const matrix = transform.match(/^matrix\\\\((.+)\\\\)$/u);\\n        if (matrix) {\\n            return getPosFromMatrix(matrix[1], pos2);\\n        }\\n        else {\\n            return 0;\\n        }\\n    }\\n};\\nconst transformKeys = new Set([\\\"x\\\", \\\"y\\\", \\\"z\\\"]);\\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\\nfunction removeNonTranslationalTransform(visualElement) {\\n    const removedTransforms = [];\\n    nonTranslationalTransformKeys.forEach((key) => {\\n        const value = visualElement.getValue(key);\\n        if (value !== undefined) {\\n            removedTransforms.push([key, value.get()]);\\n            value.set(key.startsWith(\\\"scale\\\") ? 1 : 0);\\n        }\\n    });\\n    return removedTransforms;\\n}\\nconst positionalValues = {\\n    // Dimensions\\n    width: ({ x }, { paddingLeft = \\\"0\\\", paddingRight = \\\"0\\\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\\n    height: ({ y }, { paddingTop = \\\"0\\\", paddingBottom = \\\"0\\\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\\n    top: (_bbox, { top }) => parseFloat(top),\\n    left: (_bbox, { left }) => parseFloat(left),\\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\\n    // Transform\\n    x: getTranslateFromMatrix(4, 13),\\n    y: getTranslateFromMatrix(5, 14),\\n};\\n// Alias translate longform names\\npositionalValues.translateX = positionalValues.x;\\npositionalValues.translateY = positionalValues.y;\\n\\nconst toResolve = new Set();\\nlet isScheduled = false;\\nlet anyNeedsMeasurement = false;\\nfunction measureAllKeyframes() {\\n    if (anyNeedsMeasurement) {\\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\\n        const transformsToRestore = new Map();\\n        /**\\n         * Write pass\\n         * If we're measuring elements we want to remove bounding box-changing transforms.\\n         */\\n        elementsToMeasure.forEach((element) => {\\n            const removedTransforms = removeNonTranslationalTransform(element);\\n            if (!removedTransforms.length)\\n                return;\\n            transformsToRestore.set(element, removedTransforms);\\n            element.render();\\n        });\\n        // Read\\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\\n        // Write\\n        elementsToMeasure.forEach((element) => {\\n            element.render();\\n            const restore = transformsToRestore.get(element);\\n            if (restore) {\\n                restore.forEach(([key, value]) => {\\n                    var _a;\\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\\n                });\\n            }\\n        });\\n        // Read\\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\\n        // Write\\n        resolversToMeasure.forEach((resolver) => {\\n            if (resolver.suspendedScrollY !== undefined) {\\n                window.scrollTo(0, resolver.suspendedScrollY);\\n            }\\n        });\\n    }\\n    anyNeedsMeasurement = false;\\n    isScheduled = false;\\n    toResolve.forEach((resolver) => resolver.complete());\\n    toResolve.clear();\\n}\\nfunction readAllKeyframes() {\\n    toResolve.forEach((resolver) => {\\n        resolver.readKeyframes();\\n        if (resolver.needsMeasurement) {\\n            anyNeedsMeasurement = true;\\n        }\\n    });\\n}\\nfunction flushKeyframeResolvers() {\\n    readAllKeyframes();\\n    measureAllKeyframes();\\n}\\nclass KeyframeResolver {\\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\\n        /**\\n         * Track whether this resolver has completed. Once complete, it never\\n         * needs to attempt keyframe resolution again.\\n         */\\n        this.isComplete = false;\\n        /**\\n         * Track whether this resolver is async. If it is, it'll be added to the\\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\\n         * to trigger read/write thrashing don't need to be async.\\n         */\\n        this.isAsync = false;\\n        /**\\n         * Track whether this resolver needs to perform a measurement\\n         * to resolve its keyframes.\\n         */\\n        this.needsMeasurement = false;\\n        /**\\n         * Track whether this resolver is currently scheduled to resolve\\n         * to allow it to be cancelled and resumed externally.\\n         */\\n        this.isScheduled = false;\\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\\n        this.onComplete = onComplete;\\n        this.name = name;\\n        this.motionValue = motionValue;\\n        this.element = element;\\n        this.isAsync = isAsync;\\n    }\\n    scheduleResolve() {\\n        this.isScheduled = true;\\n        if (this.isAsync) {\\n            toResolve.add(this);\\n            if (!isScheduled) {\\n                isScheduled = true;\\n                frame.read(readAllKeyframes);\\n                frame.resolveKeyframes(measureAllKeyframes);\\n            }\\n        }\\n        else {\\n            this.readKeyframes();\\n            this.complete();\\n        }\\n    }\\n    readKeyframes() {\\n        const { unresolvedKeyframes, name, element, motionValue } = this;\\n        /**\\n         * If a keyframe is null, we hydrate it either by reading it from\\n         * the instance, or propagating from previous keyframes.\\n         */\\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\\n            if (unresolvedKeyframes[i] === null) {\\n                /**\\n                 * If the first keyframe is null, we need to find its value by sampling the element\\n                 */\\n                if (i === 0) {\\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\\n                    if (currentValue !== undefined) {\\n                        unresolvedKeyframes[0] = currentValue;\\n                    }\\n                    else if (element && name) {\\n                        const valueAsRead = element.readValue(name, finalKeyframe);\\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\\n                            unresolvedKeyframes[0] = valueAsRead;\\n                        }\\n                    }\\n                    if (unresolvedKeyframes[0] === undefined) {\\n                        unresolvedKeyframes[0] = finalKeyframe;\\n                    }\\n                    if (motionValue && currentValue === undefined) {\\n                        motionValue.set(unresolvedKeyframes[0]);\\n                    }\\n                }\\n                else {\\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\\n                }\\n            }\\n        }\\n    }\\n    setFinalKeyframe() { }\\n    measureInitialState() { }\\n    renderEndStyles() { }\\n    measureEndState() { }\\n    complete() {\\n        this.isComplete = true;\\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\\n        toResolve.delete(this);\\n    }\\n    cancel() {\\n        if (!this.isComplete) {\\n            this.isScheduled = false;\\n            toResolve.delete(this);\\n        }\\n    }\\n    resume() {\\n        if (!this.isComplete)\\n            this.scheduleResolve();\\n    }\\n}\\n\\n/**\\n * Check if value is a numerical string, ie a string that is purely a number eg \\\"100\\\" or \\\"-100.1\\\"\\n */\\nconst isNumericalString = (v) => /^-?(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)$/u.test(v);\\n\\nconst checkStringStartsWith = (token) => (key) => typeof key === \\\"string\\\" && key.startsWith(token);\\nconst isCSSVariableName = \\n/*@__PURE__*/ checkStringStartsWith(\\\"--\\\");\\nconst startsAsVariableToken = \\n/*@__PURE__*/ checkStringStartsWith(\\\"var(--\\\");\\nconst isCSSVariableToken = (value) => {\\n    const startsWithToken = startsAsVariableToken(value);\\n    if (!startsWithToken)\\n        return false;\\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\\n    return singleCssVariableRegex.test(value.split(\\\"/*\\\")[0].trim());\\n};\\nconst singleCssVariableRegex = /var\\\\(--(?:[\\\\w-]+\\\\s*|[\\\\w-]+\\\\s*,(?:\\\\s*[^)(\\\\s]|\\\\s*\\\\((?:[^)(]|\\\\([^)(]*\\\\))*\\\\))+\\\\s*)\\\\)$/iu;\\n\\n/**\\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\\n *\\n * ```\\n * `var(--foo, #fff)` => [`--foo`, '#fff']\\n * ```\\n *\\n * @param current\\n */\\nconst splitCSSVariableRegex = \\n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\\n/^var\\\\(--(?:([\\\\w-]+)|([\\\\w-]+), ?([a-zA-Z\\\\d ()%#.,-]+))\\\\)/u;\\nfunction parseCSSVariable(current) {\\n    const match = splitCSSVariableRegex.exec(current);\\n    if (!match)\\n        return [,];\\n    const [, token1, token2, fallback] = match;\\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\\n}\\nconst maxDepth = 4;\\nfunction getVariableValue(current, element, depth = 1) {\\n    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \\\"${current}\\\". This may indicate a circular fallback dependency.`);\\n    const [token, fallback] = parseCSSVariable(current);\\n    // No CSS variable detected\\n    if (!token)\\n        return;\\n    // Attempt to read this CSS variable off the element\\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\\n    if (resolved) {\\n        const trimmed = resolved.trim();\\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\\n    }\\n    return isCSSVariableToken(fallback)\\n        ? getVariableValue(fallback, element, depth + 1)\\n        : fallback;\\n}\\n\\n/**\\n * Tests a provided value against a ValueType\\n */\\nconst testValueType = (v) => (type) => type.test(v);\\n\\n/**\\n * ValueType for \\\"auto\\\"\\n */\\nconst auto = {\\n    test: (v) => v === \\\"auto\\\",\\n    parse: (v) => v,\\n};\\n\\n/**\\n * A list of value types commonly used for dimensions\\n */\\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\\n/**\\n * Tests a dimensional value against the list of dimension ValueTypes\\n */\\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\\n\\nclass DOMKeyframesResolver extends KeyframeResolver {\\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\\n    }\\n    readKeyframes() {\\n        const { unresolvedKeyframes, element, name } = this;\\n        if (!element || !element.current)\\n            return;\\n        super.readKeyframes();\\n        /**\\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\\n         */\\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\\n            let keyframe = unresolvedKeyframes[i];\\n            if (typeof keyframe === \\\"string\\\") {\\n                keyframe = keyframe.trim();\\n                if (isCSSVariableToken(keyframe)) {\\n                    const resolved = getVariableValue(keyframe, element.current);\\n                    if (resolved !== undefined) {\\n                        unresolvedKeyframes[i] = resolved;\\n                    }\\n                    if (i === unresolvedKeyframes.length - 1) {\\n                        this.finalKeyframe = keyframe;\\n                    }\\n                }\\n            }\\n        }\\n        /**\\n         * Resolve \\\"none\\\" values. We do this potentially twice - once before and once after measuring keyframes.\\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\\n         * have a far bigger performance impact.\\n         */\\n        this.resolveNoneKeyframes();\\n        /**\\n         * Check to see if unit type has changed. If so schedule jobs that will\\n         * temporarily set styles to the destination keyframes.\\n         * Skip if we have more than two keyframes or this isn't a positional value.\\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\\n         */\\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\\n            return;\\n        }\\n        const [origin, target] = unresolvedKeyframes;\\n        const originType = findDimensionValueType(origin);\\n        const targetType = findDimensionValueType(target);\\n        /**\\n         * Either we don't recognise these value types or we can animate between them.\\n         */\\n        if (originType === targetType)\\n            return;\\n        /**\\n         * If both values are numbers or pixels, we can animate between them by\\n         * converting them to numbers.\\n         */\\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\\n                const value = unresolvedKeyframes[i];\\n                if (typeof value === \\\"string\\\") {\\n                    unresolvedKeyframes[i] = parseFloat(value);\\n                }\\n            }\\n        }\\n        else {\\n            /**\\n             * Else, the only way to resolve this is by measuring the element.\\n             */\\n            this.needsMeasurement = true;\\n        }\\n    }\\n    resolveNoneKeyframes() {\\n        const { unresolvedKeyframes, name } = this;\\n        const noneKeyframeIndexes = [];\\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\\n            if (isNone(unresolvedKeyframes[i])) {\\n                noneKeyframeIndexes.push(i);\\n            }\\n        }\\n        if (noneKeyframeIndexes.length) {\\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\\n        }\\n    }\\n    measureInitialState() {\\n        const { element, unresolvedKeyframes, name } = this;\\n        if (!element || !element.current)\\n            return;\\n        if (name === \\\"height\\\") {\\n            this.suspendedScrollY = window.pageYOffset;\\n        }\\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\\n        unresolvedKeyframes[0] = this.measuredOrigin;\\n        // Set final key frame to measure after next render\\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\\n        if (measureKeyframe !== undefined) {\\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\\n        }\\n    }\\n    measureEndState() {\\n        var _a;\\n        const { element, name, unresolvedKeyframes } = this;\\n        if (!element || !element.current)\\n            return;\\n        const value = element.getValue(name);\\n        value && value.jump(this.measuredOrigin, false);\\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\\n            this.finalKeyframe = finalKeyframe;\\n        }\\n        // If we removed transform values, reapply them before the next render\\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\\n                element\\n                    .getValue(unsetTransformName)\\n                    .set(unsetTransformValue);\\n            });\\n        }\\n        this.resolveNoneKeyframes();\\n    }\\n}\\n\\n/**\\n * Check if a value is animatable. Examples:\\n *\\n * \\u2705: 100, \\\"100px\\\", \\\"#fff\\\"\\n * \\u274c: \\\"block\\\", \\\"url(2.jpg)\\\"\\n * @param value\\n *\\n * @internal\\n */\\nconst isAnimatable = (value, name) => {\\n    // If the list of keys tat might be non-animatable grows, replace with Set\\n    if (name === \\\"zIndex\\\")\\n        return false;\\n    // If it's a number or a keyframes array, we can animate it. We might at some point\\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\\n    // but for now lets leave it like this for performance reasons\\n    if (typeof value === \\\"number\\\" || Array.isArray(value))\\n        return true;\\n    if (typeof value === \\\"string\\\" && // It's animatable if we have a string\\n        (complex.test(value) || value === \\\"0\\\") && // And it contains numbers and/or colors\\n        !value.startsWith(\\\"url(\\\") // Unless it starts with \\\"url(\\\"\\n    ) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nfunction hasKeyframesChanged(keyframes) {\\n    const current = keyframes[0];\\n    if (keyframes.length === 1)\\n        return true;\\n    for (let i = 0; i < keyframes.length; i++) {\\n        if (keyframes[i] !== current)\\n            return true;\\n    }\\n}\\nfunction canAnimate(keyframes, name, type, velocity) {\\n    /**\\n     * Check if we're able to animate between the start and end keyframes,\\n     * and throw a warning if we're attempting to animate between one that's\\n     * animatable and another that isn't.\\n     */\\n    const originKeyframe = keyframes[0];\\n    if (originKeyframe === null)\\n        return false;\\n    /**\\n     * These aren't traditionally animatable but we do support them.\\n     * In future we could look into making this more generic or replacing\\n     * this function with mix() === mixImmediate\\n     */\\n    if (name === \\\"display\\\" || name === \\\"visibility\\\")\\n        return true;\\n    const targetKeyframe = keyframes[keyframes.length - 1];\\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\\n    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \\\"${originKeyframe}\\\" to \\\"${targetKeyframe}\\\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\\\`style\\\\` property.`);\\n    // Always skip if any of these are true\\n    if (!isOriginAnimatable || !isTargetAnimatable) {\\n        return false;\\n    }\\n    return (hasKeyframesChanged(keyframes) ||\\n        ((type === \\\"spring\\\" || motionDom.isGenerator(type)) && velocity));\\n}\\n\\nconst isNotNull = (value) => value !== null;\\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \\\"loop\\\" }, finalKeyframe) {\\n    const resolvedKeyframes = keyframes.filter(isNotNull);\\n    const index = repeat && repeatType !== \\\"loop\\\" && repeat % 2 === 1\\n        ? 0\\n        : resolvedKeyframes.length - 1;\\n    return !index || finalKeyframe === undefined\\n        ? resolvedKeyframes[index]\\n        : finalKeyframe;\\n}\\n\\n/**\\n * Maximum time allowed between an animation being created and it being\\n * resolved for us to use the latter as the start time.\\n *\\n * This is to ensure that while we prefer to \\\"start\\\" an animation as soon\\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\\n * between these two moments.\\n */\\nconst MAX_RESOLVE_DELAY = 40;\\nclass BaseAnimation {\\n    constructor({ autoplay = true, delay = 0, type = \\\"keyframes\\\", repeat = 0, repeatDelay = 0, repeatType = \\\"loop\\\", ...options }) {\\n        // Track whether the animation has been stopped. Stopped animations won't restart.\\n        this.isStopped = false;\\n        this.hasAttemptedResolve = false;\\n        this.createdAt = time.now();\\n        this.options = {\\n            autoplay,\\n            delay,\\n            type,\\n            repeat,\\n            repeatDelay,\\n            repeatType,\\n            ...options,\\n        };\\n        this.updateFinishedPromise();\\n    }\\n    /**\\n     * This method uses the createdAt and resolvedAt to calculate the\\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\\n     * as the following frame would then be the first frame of the animation in\\n     * progress, which would feel snappier.\\n     *\\n     * However, if there's a delay (main thread work) between the creation of\\n     * the animation and the first commited frame, we prefer to use resolvedAt\\n     * to avoid a sudden jump into the animation.\\n     */\\n    calcStartTime() {\\n        if (!this.resolvedAt)\\n            return this.createdAt;\\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\\n            ? this.resolvedAt\\n            : this.createdAt;\\n    }\\n    /**\\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\\n     * this.resolved will synchronously flush all pending keyframe resolvers.\\n     * This is a deoptimisation, but at its worst still batches read/writes.\\n     */\\n    get resolved() {\\n        if (!this._resolved && !this.hasAttemptedResolve) {\\n            flushKeyframeResolvers();\\n        }\\n        return this._resolved;\\n    }\\n    /**\\n     * A method to be called when the keyframes resolver completes. This method\\n     * will check if its possible to run the animation and, if not, skip it.\\n     * Otherwise, it will call initPlayback on the implementing class.\\n     */\\n    onKeyframesResolved(keyframes, finalKeyframe) {\\n        this.resolvedAt = time.now();\\n        this.hasAttemptedResolve = true;\\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\\n        /**\\n         * If we can't animate this value with the resolved keyframes\\n         * then we should complete it immediately.\\n         */\\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\\n            // Finish immediately\\n            if (instantAnimationState.current || !delay) {\\n                onUpdate &&\\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\\n                onComplete && onComplete();\\n                this.resolveFinishedPromise();\\n                return;\\n            }\\n            // Finish after a delay\\n            else {\\n                this.options.duration = 0;\\n            }\\n        }\\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\\n        if (resolvedAnimation === false)\\n            return;\\n        this._resolved = {\\n            keyframes,\\n            finalKeyframe,\\n            ...resolvedAnimation,\\n        };\\n        this.onPostResolved();\\n    }\\n    onPostResolved() { }\\n    /**\\n     * Allows the returned animation to be awaited or promise-chained. Currently\\n     * resolves when the animation finishes at all but in a future update could/should\\n     * reject if its cancels.\\n     */\\n    then(resolve, reject) {\\n        return this.currentFinishedPromise.then(resolve, reject);\\n    }\\n    flatten() {\\n        this.options.type = \\\"keyframes\\\";\\n        this.options.ease = \\\"linear\\\";\\n    }\\n    updateFinishedPromise() {\\n        this.currentFinishedPromise = new Promise((resolve) => {\\n            this.resolveFinishedPromise = resolve;\\n        });\\n    }\\n}\\n\\n/*\\n  Value in range from progress\\n\\n  Given a lower limit and an upper limit, we return the value within\\n  that range as expressed by progress (usually a number from 0 to 1)\\n\\n  So progress = 0.5 would change\\n\\n  from -------- to\\n\\n  to\\n\\n  from ---- to\\n\\n  E.g. from = 10, to = 20, progress = 0.5 => 15\\n\\n  @param [number]: Lower limit of range\\n  @param [number]: Upper limit of range\\n  @param [number]: The progress between lower and upper limits expressed 0-1\\n  @return [number]: Value as calculated from progress within range (not limited within range)\\n*/\\nconst mixNumber$1 = (from, to, progress) => {\\n    return from + (to - from) * progress;\\n};\\n\\n// Adapted from https://gist.github.com/mjackson/5311256\\nfunction hueToRgb(p, q, t) {\\n    if (t < 0)\\n        t += 1;\\n    if (t > 1)\\n        t -= 1;\\n    if (t < 1 / 6)\\n        return p + (q - p) * 6 * t;\\n    if (t < 1 / 2)\\n        return q;\\n    if (t < 2 / 3)\\n        return p + (q - p) * (2 / 3 - t) * 6;\\n    return p;\\n}\\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\\n    hue /= 360;\\n    saturation /= 100;\\n    lightness /= 100;\\n    let red = 0;\\n    let green = 0;\\n    let blue = 0;\\n    if (!saturation) {\\n        red = green = blue = lightness;\\n    }\\n    else {\\n        const q = lightness < 0.5\\n            ? lightness * (1 + saturation)\\n            : lightness + saturation - lightness * saturation;\\n        const p = 2 * lightness - q;\\n        red = hueToRgb(p, q, hue + 1 / 3);\\n        green = hueToRgb(p, q, hue);\\n        blue = hueToRgb(p, q, hue - 1 / 3);\\n    }\\n    return {\\n        red: Math.round(red * 255),\\n        green: Math.round(green * 255),\\n        blue: Math.round(blue * 255),\\n        alpha,\\n    };\\n}\\n\\nfunction mixImmediate(a, b) {\\n    return (p) => (p > 0 ? b : a);\\n}\\n\\n// Linear color space blending\\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\\nconst mixLinearColor = (from, to, v) => {\\n    const fromExpo = from * from;\\n    const expo = v * (to * to - fromExpo) + fromExpo;\\n    return expo < 0 ? 0 : Math.sqrt(expo);\\n};\\nconst colorTypes = [hex, rgba, hsla];\\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\\nfunction asRGBA(color) {\\n    const type = getColorType(color);\\n    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\\n    if (!Boolean(type))\\n        return false;\\n    let model = type.parse(color);\\n    if (type === hsla) {\\n        // TODO Remove this cast - needed since Motion's stricter typing\\n        model = hslaToRgba(model);\\n    }\\n    return model;\\n}\\nconst mixColor = (from, to) => {\\n    const fromRGBA = asRGBA(from);\\n    const toRGBA = asRGBA(to);\\n    if (!fromRGBA || !toRGBA) {\\n        return mixImmediate(from, to);\\n    }\\n    const blended = { ...fromRGBA };\\n    return (v) => {\\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\\n        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);\\n        return rgba.transform(blended);\\n    };\\n};\\n\\n/**\\n * Pipe\\n * Compose other transformers to run linearily\\n * pipe(min(20), max(40))\\n * @param  {...functions} transformers\\n * @return {function}\\n */\\nconst combineFunctions = (a, b) => (v) => b(a(v));\\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\\n\\nconst invisibleValues = new Set([\\\"none\\\", \\\"hidden\\\"]);\\n/**\\n * Returns a function that, when provided a progress value between 0 and 1,\\n * will return the \\\"none\\\" or \\\"hidden\\\" string only when the progress is that of\\n * the origin or target.\\n */\\nfunction mixVisibility(origin, target) {\\n    if (invisibleValues.has(origin)) {\\n        return (p) => (p <= 0 ? origin : target);\\n    }\\n    else {\\n        return (p) => (p >= 1 ? target : origin);\\n    }\\n}\\n\\nfunction mixNumber(a, b) {\\n    return (p) => mixNumber$1(a, b, p);\\n}\\nfunction getMixer(a) {\\n    if (typeof a === \\\"number\\\") {\\n        return mixNumber;\\n    }\\n    else if (typeof a === \\\"string\\\") {\\n        return isCSSVariableToken(a)\\n            ? mixImmediate\\n            : color.test(a)\\n                ? mixColor\\n                : mixComplex;\\n    }\\n    else if (Array.isArray(a)) {\\n        return mixArray;\\n    }\\n    else if (typeof a === \\\"object\\\") {\\n        return color.test(a) ? mixColor : mixObject;\\n    }\\n    return mixImmediate;\\n}\\nfunction mixArray(a, b) {\\n    const output = [...a];\\n    const numValues = output.length;\\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\\n    return (p) => {\\n        for (let i = 0; i < numValues; i++) {\\n            output[i] = blendValue[i](p);\\n        }\\n        return output;\\n    };\\n}\\nfunction mixObject(a, b) {\\n    const output = { ...a, ...b };\\n    const blendValue = {};\\n    for (const key in output) {\\n        if (a[key] !== undefined && b[key] !== undefined) {\\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\\n        }\\n    }\\n    return (v) => {\\n        for (const key in blendValue) {\\n            output[key] = blendValue[key](v);\\n        }\\n        return output;\\n    };\\n}\\nfunction matchOrder(origin, target) {\\n    var _a;\\n    const orderedOrigin = [];\\n    const pointers = { color: 0, var: 0, number: 0 };\\n    for (let i = 0; i < target.values.length; i++) {\\n        const type = target.types[i];\\n        const originIndex = origin.indexes[type][pointers[type]];\\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\\n        orderedOrigin[i] = originValue;\\n        pointers[type]++;\\n    }\\n    return orderedOrigin;\\n}\\nconst mixComplex = (origin, target) => {\\n    const template = complex.createTransformer(target);\\n    const originStats = analyseComplexValue(origin);\\n    const targetStats = analyseComplexValue(target);\\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\\n    if (canInterpolate) {\\n        if ((invisibleValues.has(origin) &&\\n            !targetStats.values.length) ||\\n            (invisibleValues.has(target) &&\\n                !originStats.values.length)) {\\n            return mixVisibility(origin, target);\\n        }\\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\\n    }\\n    else {\\n        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\\n        return mixImmediate(origin, target);\\n    }\\n};\\n\\nfunction mix(from, to, p) {\\n    if (typeof from === \\\"number\\\" &&\\n        typeof to === \\\"number\\\" &&\\n        typeof p === \\\"number\\\") {\\n        return mixNumber$1(from, to, p);\\n    }\\n    const mixer = getMixer(from);\\n    return mixer(from, to);\\n}\\n\\nconst velocitySampleDuration = 5; // ms\\nfunction calcGeneratorVelocity(resolveValue, t, current) {\\n    const prevT = Math.max(t - velocitySampleDuration, 0);\\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\\n}\\n\\nconst springDefaults = {\\n    // Default spring physics\\n    stiffness: 100,\\n    damping: 10,\\n    mass: 1.0,\\n    velocity: 0.0,\\n    // Default duration/bounce-based options\\n    duration: 800, // in ms\\n    bounce: 0.3,\\n    visualDuration: 0.3, // in seconds\\n    // Rest thresholds\\n    restSpeed: {\\n        granular: 0.01,\\n        default: 2,\\n    },\\n    restDelta: {\\n        granular: 0.005,\\n        default: 0.5,\\n    },\\n    // Limits\\n    minDuration: 0.01, // in seconds\\n    maxDuration: 10.0, // in seconds\\n    minDamping: 0.05,\\n    maxDamping: 1,\\n};\\n\\nconst safeMin = 0.001;\\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\\n    let envelope;\\n    let derivative;\\n    motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), \\\"Spring duration must be 10 seconds or less\\\");\\n    let dampingRatio = 1 - bounce;\\n    /**\\n     * Restrict dampingRatio and duration to within acceptable ranges.\\n     */\\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));\\n    if (dampingRatio < 1) {\\n        /**\\n         * Underdamped spring\\n         */\\n        envelope = (undampedFreq) => {\\n            const exponentialDecay = undampedFreq * dampingRatio;\\n            const delta = exponentialDecay * duration;\\n            const a = exponentialDecay - velocity;\\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\\n            const c = Math.exp(-delta);\\n            return safeMin - (a / b) * c;\\n        };\\n        derivative = (undampedFreq) => {\\n            const exponentialDecay = undampedFreq * dampingRatio;\\n            const delta = exponentialDecay * duration;\\n            const d = delta * velocity + velocity;\\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\\n            const f = Math.exp(-delta);\\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\\n            return (factor * ((d - e) * f)) / g;\\n        };\\n    }\\n    else {\\n        /**\\n         * Critically-damped spring\\n         */\\n        envelope = (undampedFreq) => {\\n            const a = Math.exp(-undampedFreq * duration);\\n            const b = (undampedFreq - velocity) * duration + 1;\\n            return -safeMin + a * b;\\n        };\\n        derivative = (undampedFreq) => {\\n            const a = Math.exp(-undampedFreq * duration);\\n            const b = (velocity - undampedFreq) * (duration * duration);\\n            return a * b;\\n        };\\n    }\\n    const initialGuess = 5 / duration;\\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\\n    duration = motionUtils.secondsToMilliseconds(duration);\\n    if (isNaN(undampedFreq)) {\\n        return {\\n            stiffness: springDefaults.stiffness,\\n            damping: springDefaults.damping,\\n            duration,\\n        };\\n    }\\n    else {\\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\\n        return {\\n            stiffness,\\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\\n            duration,\\n        };\\n    }\\n}\\nconst rootIterations = 12;\\nfunction approximateRoot(envelope, derivative, initialGuess) {\\n    let result = initialGuess;\\n    for (let i = 1; i < rootIterations; i++) {\\n        result = result - envelope(result) / derivative(result);\\n    }\\n    return result;\\n}\\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\\n}\\n\\nconst durationKeys = [\\\"duration\\\", \\\"bounce\\\"];\\nconst physicsKeys = [\\\"stiffness\\\", \\\"damping\\\", \\\"mass\\\"];\\nfunction isSpringType(options, keys) {\\n    return keys.some((key) => options[key] !== undefined);\\n}\\nfunction getSpringOptions(options) {\\n    let springOptions = {\\n        velocity: springDefaults.velocity,\\n        stiffness: springDefaults.stiffness,\\n        damping: springDefaults.damping,\\n        mass: springDefaults.mass,\\n        isResolvedFromDuration: false,\\n        ...options,\\n    };\\n    // stiffness/damping/mass overrides duration/bounce\\n    if (!isSpringType(options, physicsKeys) &&\\n        isSpringType(options, durationKeys)) {\\n        if (options.visualDuration) {\\n            const visualDuration = options.visualDuration;\\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\\n            const stiffness = root * root;\\n            const damping = 2 *\\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\\n                Math.sqrt(stiffness);\\n            springOptions = {\\n                ...springOptions,\\n                mass: springDefaults.mass,\\n                stiffness,\\n                damping,\\n            };\\n        }\\n        else {\\n            const derived = findSpring(options);\\n            springOptions = {\\n                ...springOptions,\\n                ...derived,\\n                mass: springDefaults.mass,\\n            };\\n            springOptions.isResolvedFromDuration = true;\\n        }\\n    }\\n    return springOptions;\\n}\\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\\n    const options = typeof optionsOrVisualDuration !== \\\"object\\\"\\n        ? {\\n            visualDuration: optionsOrVisualDuration,\\n            keyframes: [0, 1],\\n            bounce,\\n        }\\n        : optionsOrVisualDuration;\\n    let { restSpeed, restDelta } = options;\\n    const origin = options.keyframes[0];\\n    const target = options.keyframes[options.keyframes.length - 1];\\n    /**\\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\\n     * to reduce GC during animation.\\n     */\\n    const state = { done: false, value: origin };\\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\\n        ...options,\\n        velocity: -motionUtils.millisecondsToSeconds(options.velocity || 0),\\n    });\\n    const initialVelocity = velocity || 0.0;\\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\\n    const initialDelta = target - origin;\\n    const undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / mass));\\n    /**\\n     * If we're working on a granular scale, use smaller defaults for determining\\n     * when the spring is finished.\\n     *\\n     * These defaults have been selected emprically based on what strikes a good\\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\\n     */\\n    const isGranularScale = Math.abs(initialDelta) < 5;\\n    restSpeed || (restSpeed = isGranularScale\\n        ? springDefaults.restSpeed.granular\\n        : springDefaults.restSpeed.default);\\n    restDelta || (restDelta = isGranularScale\\n        ? springDefaults.restDelta.granular\\n        : springDefaults.restDelta.default);\\n    let resolveSpring;\\n    if (dampingRatio < 1) {\\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\\n        // Underdamped spring\\n        resolveSpring = (t) => {\\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\\n            return (target -\\n                envelope *\\n                    (((initialVelocity +\\n                        dampingRatio * undampedAngularFreq * initialDelta) /\\n                        angularFreq) *\\n                        Math.sin(angularFreq * t) +\\n                        initialDelta * Math.cos(angularFreq * t)));\\n        };\\n    }\\n    else if (dampingRatio === 1) {\\n        // Critically damped spring\\n        resolveSpring = (t) => target -\\n            Math.exp(-undampedAngularFreq * t) *\\n                (initialDelta +\\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\\n    }\\n    else {\\n        // Overdamped spring\\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\\n        resolveSpring = (t) => {\\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\\n            // When performing sinh or cosh values can hit Infinity so we cap them here\\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\\n            return (target -\\n                (envelope *\\n                    ((initialVelocity +\\n                        dampingRatio * undampedAngularFreq * initialDelta) *\\n                        Math.sinh(freqForT) +\\n                        dampedAngularFreq *\\n                            initialDelta *\\n                            Math.cosh(freqForT))) /\\n                    dampedAngularFreq);\\n        };\\n    }\\n    const generator = {\\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\\n        next: (t) => {\\n            const current = resolveSpring(t);\\n            if (!isResolvedFromDuration) {\\n                let currentVelocity = 0.0;\\n                /**\\n                 * We only need to calculate velocity for under-damped springs\\n                 * as over- and critically-damped springs can't overshoot, so\\n                 * checking only for displacement is enough.\\n                 */\\n                if (dampingRatio < 1) {\\n                    currentVelocity =\\n                        t === 0\\n                            ? motionUtils.secondsToMilliseconds(initialVelocity)\\n                            : calcGeneratorVelocity(resolveSpring, t, current);\\n                }\\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\\n                state.done =\\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\\n            }\\n            else {\\n                state.done = t >= duration;\\n            }\\n            state.value = state.done ? target : current;\\n            return state;\\n        },\\n        toString: () => {\\n            const calculatedDuration = Math.min(motionDom.calcGeneratorDuration(generator), motionDom.maxGeneratorDuration);\\n            const easing = motionDom.generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\\n            return calculatedDuration + \\\"ms \\\" + easing;\\n        },\\n    };\\n    return generator;\\n}\\n\\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\\n    const origin = keyframes[0];\\n    const state = {\\n        done: false,\\n        value: origin,\\n    };\\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\\n    const nearestBoundary = (v) => {\\n        if (min === undefined)\\n            return max;\\n        if (max === undefined)\\n            return min;\\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\\n    };\\n    let amplitude = power * velocity;\\n    const ideal = origin + amplitude;\\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\\n    /**\\n     * If the target has changed we need to re-calculate the amplitude, otherwise\\n     * the animation will start from the wrong position.\\n     */\\n    if (target !== ideal)\\n        amplitude = target - origin;\\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\\n    const calcLatest = (t) => target + calcDelta(t);\\n    const applyFriction = (t) => {\\n        const delta = calcDelta(t);\\n        const latest = calcLatest(t);\\n        state.done = Math.abs(delta) <= restDelta;\\n        state.value = state.done ? target : latest;\\n    };\\n    /**\\n     * Ideally this would resolve for t in a stateless way, we could\\n     * do that by always precalculating the animation but as we know\\n     * this will be done anyway we can assume that spring will\\n     * be discovered during that.\\n     */\\n    let timeReachedBoundary;\\n    let spring$1;\\n    const checkCatchBoundary = (t) => {\\n        if (!isOutOfBounds(state.value))\\n            return;\\n        timeReachedBoundary = t;\\n        spring$1 = spring({\\n            keyframes: [state.value, nearestBoundary(state.value)],\\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\\n            damping: bounceDamping,\\n            stiffness: bounceStiffness,\\n            restDelta,\\n            restSpeed,\\n        });\\n    };\\n    checkCatchBoundary(0);\\n    return {\\n        calculatedDuration: null,\\n        next: (t) => {\\n            /**\\n             * We need to resolve the friction to figure out if we need a\\n             * spring but we don't want to do this twice per frame. So here\\n             * we flag if we updated for this frame and later if we did\\n             * we can skip doing it again.\\n             */\\n            let hasUpdatedFrame = false;\\n            if (!spring$1 && timeReachedBoundary === undefined) {\\n                hasUpdatedFrame = true;\\n                applyFriction(t);\\n                checkCatchBoundary(t);\\n            }\\n            /**\\n             * If we have a spring and the provided t is beyond the moment the friction\\n             * animation crossed the min/max boundary, use the spring.\\n             */\\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\\n                return spring$1.next(t - timeReachedBoundary);\\n            }\\n            else {\\n                !hasUpdatedFrame && applyFriction(t);\\n                return state;\\n            }\\n        },\\n    };\\n}\\n\\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\\n\\nconst isEasingArray = (ease) => {\\n    return Array.isArray(ease) && typeof ease[0] !== \\\"number\\\";\\n};\\n\\nconst easingLookup = {\\n    linear: motionUtils.noop,\\n    easeIn,\\n    easeInOut,\\n    easeOut,\\n    circIn,\\n    circInOut,\\n    circOut,\\n    backIn,\\n    backInOut,\\n    backOut,\\n    anticipate,\\n};\\nconst easingDefinitionToFunction = (definition) => {\\n    if (motionDom.isBezierDefinition(definition)) {\\n        // If cubic bezier definition, create bezier curve\\n        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\\n        const [x1, y1, x2, y2] = definition;\\n        return cubicBezier(x1, y1, x2, y2);\\n    }\\n    else if (typeof definition === \\\"string\\\") {\\n        // Else lookup from table\\n        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\\n        return easingLookup[definition];\\n    }\\n    return definition;\\n};\\n\\nfunction createMixers(output, ease, customMixer) {\\n    const mixers = [];\\n    const mixerFactory = customMixer || mix;\\n    const numMixers = output.length - 1;\\n    for (let i = 0; i < numMixers; i++) {\\n        let mixer = mixerFactory(output[i], output[i + 1]);\\n        if (ease) {\\n            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;\\n            mixer = pipe(easingFunction, mixer);\\n        }\\n        mixers.push(mixer);\\n    }\\n    return mixers;\\n}\\n/**\\n * Create a function that maps from a numerical input array to a generic output array.\\n *\\n * Accepts:\\n *   - Numbers\\n *   - Colors (hex, hsl, hsla, rgb, rgba)\\n *   - Complex (combinations of one or more numbers or strings)\\n *\\n * ```jsx\\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\\n *\\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\\n * ```\\n *\\n * TODO Revist this approach once we've moved to data models for values,\\n * probably not needed to pregenerate mixer functions.\\n *\\n * @public\\n */\\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\\n    const inputLength = input.length;\\n    motionUtils.invariant(inputLength === output.length, \\\"Both input and output ranges must be the same length\\\");\\n    /**\\n     * If we're only provided a single input, we can just make a function\\n     * that returns the output.\\n     */\\n    if (inputLength === 1)\\n        return () => output[0];\\n    if (inputLength === 2 && output[0] === output[1])\\n        return () => output[1];\\n    const isZeroDeltaRange = input[0] === input[1];\\n    // If input runs highest -> lowest, reverse both arrays\\n    if (input[0] > input[inputLength - 1]) {\\n        input = [...input].reverse();\\n        output = [...output].reverse();\\n    }\\n    const mixers = createMixers(output, ease, mixer);\\n    const numMixers = mixers.length;\\n    const interpolator = (v) => {\\n        if (isZeroDeltaRange && v < input[0])\\n            return output[0];\\n        let i = 0;\\n        if (numMixers > 1) {\\n            for (; i < input.length - 2; i++) {\\n                if (v < input[i + 1])\\n                    break;\\n            }\\n        }\\n        const progressInRange = motionUtils.progress(input[i], input[i + 1], v);\\n        return mixers[i](progressInRange);\\n    };\\n    return isClamp\\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\\n        : interpolator;\\n}\\n\\nfunction fillOffset(offset, remaining) {\\n    const min = offset[offset.length - 1];\\n    for (let i = 1; i <= remaining; i++) {\\n        const offsetProgress = motionUtils.progress(0, remaining, i);\\n        offset.push(mixNumber$1(min, 1, offsetProgress));\\n    }\\n}\\n\\nfunction defaultOffset(arr) {\\n    const offset = [0];\\n    fillOffset(offset, arr.length - 1);\\n    return offset;\\n}\\n\\nfunction convertOffsetToTimes(offset, duration) {\\n    return offset.map((o) => o * duration);\\n}\\n\\nfunction defaultEasing(values, easing) {\\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\\n}\\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \\\"easeInOut\\\", }) {\\n    /**\\n     * Easing functions can be externally defined as strings. Here we convert them\\n     * into actual functions.\\n     */\\n    const easingFunctions = isEasingArray(ease)\\n        ? ease.map(easingDefinitionToFunction)\\n        : easingDefinitionToFunction(ease);\\n    /**\\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\\n     * to reduce GC during animation.\\n     */\\n    const state = {\\n        done: false,\\n        value: keyframeValues[0],\\n    };\\n    /**\\n     * Create a times array based on the provided 0-1 offsets\\n     */\\n    const absoluteTimes = convertOffsetToTimes(\\n    // Only use the provided offsets if they're the correct length\\n    // TODO Maybe we should warn here if there's a length mismatch\\n    times && times.length === keyframeValues.length\\n        ? times\\n        : defaultOffset(keyframeValues), duration);\\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\\n        ease: Array.isArray(easingFunctions)\\n            ? easingFunctions\\n            : defaultEasing(keyframeValues, easingFunctions),\\n    });\\n    return {\\n        calculatedDuration: duration,\\n        next: (t) => {\\n            state.value = mapTimeToKeyframe(t);\\n            state.done = t >= duration;\\n            return state;\\n        },\\n    };\\n}\\n\\nconst frameloopDriver = (update) => {\\n    const passTimestamp = ({ timestamp }) => update(timestamp);\\n    return {\\n        start: () => frame.update(passTimestamp, true),\\n        stop: () => cancelFrame(passTimestamp),\\n        /**\\n         * If we're processing this frame we can use the\\n         * framelocked timestamp to keep things in sync.\\n         */\\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\\n    };\\n};\\n\\nconst generators = {\\n    decay: inertia,\\n    inertia,\\n    tween: keyframes,\\n    keyframes: keyframes,\\n    spring,\\n};\\nconst percentToProgress = (percent) => percent / 100;\\n/**\\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\\n * features we expose publically. Mostly the compatibility is to ensure visual identity\\n * between both WAAPI and main thread animations.\\n */\\nclass MainThreadAnimation extends BaseAnimation {\\n    constructor(options) {\\n        super(options);\\n        /**\\n         * The time at which the animation was paused.\\n         */\\n        this.holdTime = null;\\n        /**\\n         * The time at which the animation was cancelled.\\n         */\\n        this.cancelTime = null;\\n        /**\\n         * The current time of the animation.\\n         */\\n        this.currentTime = 0;\\n        /**\\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\\n         */\\n        this.playbackSpeed = 1;\\n        /**\\n         * The state of the animation to apply when the animation is resolved. This\\n         * allows calls to the public API to control the animation before it is resolved,\\n         * without us having to resolve it first.\\n         */\\n        this.pendingPlayState = \\\"running\\\";\\n        /**\\n         * The time at which the animation was started.\\n         */\\n        this.startTime = null;\\n        this.state = \\\"idle\\\";\\n        /**\\n         * This method is bound to the instance to fix a pattern where\\n         * animation.stop is returned as a reference from a useEffect.\\n         */\\n        this.stop = () => {\\n            this.resolver.cancel();\\n            this.isStopped = true;\\n            if (this.state === \\\"idle\\\")\\n                return;\\n            this.teardown();\\n            const { onStop } = this.options;\\n            onStop && onStop();\\n        };\\n        const { name, motionValue, element, keyframes } = this.options;\\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\\n        this.resolver.scheduleResolve();\\n    }\\n    flatten() {\\n        super.flatten();\\n        // If we've already resolved the animation, re-initialise it\\n        if (this._resolved) {\\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\\n        }\\n    }\\n    initPlayback(keyframes$1) {\\n        const { type = \\\"keyframes\\\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\\n        const generatorFactory = motionDom.isGenerator(type)\\n            ? type\\n            : generators[type] || keyframes;\\n        /**\\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\\n         * [0, 100] and then make a function that maps that to the actual keyframes.\\n         *\\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\\n         */\\n        let mapPercentToKeyframes;\\n        let mirroredGenerator;\\n        if (process.env.NODE_ENV !== \\\"production\\\" &&\\n            generatorFactory !== keyframes) {\\n            motionUtils.invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\\n        }\\n        if (generatorFactory !== keyframes &&\\n            typeof keyframes$1[0] !== \\\"number\\\") {\\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\\n            keyframes$1 = [0, 100];\\n        }\\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\\n        /**\\n         * If we have a mirror repeat type we need to create a second generator that outputs the\\n         * mirrored (not reversed) animation and later ping pong between the two generators.\\n         */\\n        if (repeatType === \\\"mirror\\\") {\\n            mirroredGenerator = generatorFactory({\\n                ...this.options,\\n                keyframes: [...keyframes$1].reverse(),\\n                velocity: -velocity,\\n            });\\n        }\\n        /**\\n         * If duration is undefined and we have repeat options,\\n         * we need to calculate a duration from the generator.\\n         *\\n         * We set it to the generator itself to cache the duration.\\n         * Any timeline resolver will need to have already precalculated\\n         * the duration by this step.\\n         */\\n        if (generator.calculatedDuration === null) {\\n            generator.calculatedDuration = motionDom.calcGeneratorDuration(generator);\\n        }\\n        const { calculatedDuration } = generator;\\n        const resolvedDuration = calculatedDuration + repeatDelay;\\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\\n        return {\\n            generator,\\n            mirroredGenerator,\\n            mapPercentToKeyframes,\\n            calculatedDuration,\\n            resolvedDuration,\\n            totalDuration,\\n        };\\n    }\\n    onPostResolved() {\\n        const { autoplay = true } = this.options;\\n        this.play();\\n        if (this.pendingPlayState === \\\"paused\\\" || !autoplay) {\\n            this.pause();\\n        }\\n        else {\\n            this.state = this.pendingPlayState;\\n        }\\n    }\\n    tick(timestamp, sample = false) {\\n        const { resolved } = this;\\n        // If the animations has failed to resolve, return the final keyframe.\\n        if (!resolved) {\\n            const { keyframes } = this.options;\\n            return { done: true, value: keyframes[keyframes.length - 1] };\\n        }\\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\\n        if (this.startTime === null)\\n            return generator.next(0);\\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\\n        /**\\n         * requestAnimationFrame timestamps can come through as lower than\\n         * the startTime as set by performance.now(). Here we prevent this,\\n         * though in the future it could be possible to make setting startTime\\n         * a pending operation that gets resolved here.\\n         */\\n        if (this.speed > 0) {\\n            this.startTime = Math.min(this.startTime, timestamp);\\n        }\\n        else if (this.speed < 0) {\\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\\n        }\\n        // Update currentTime\\n        if (sample) {\\n            this.currentTime = timestamp;\\n        }\\n        else if (this.holdTime !== null) {\\n            this.currentTime = this.holdTime;\\n        }\\n        else {\\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\\n            // example.\\n            this.currentTime =\\n                Math.round(timestamp - this.startTime) * this.speed;\\n        }\\n        // Rebase on delay\\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\\n        const isInDelayPhase = this.speed >= 0\\n            ? timeWithoutDelay < 0\\n            : timeWithoutDelay > totalDuration;\\n        this.currentTime = Math.max(timeWithoutDelay, 0);\\n        // If this animation has finished, set the current time  to the total duration.\\n        if (this.state === \\\"finished\\\" && this.holdTime === null) {\\n            this.currentTime = totalDuration;\\n        }\\n        let elapsed = this.currentTime;\\n        let frameGenerator = generator;\\n        if (repeat) {\\n            /**\\n             * Get the current progress (0-1) of the animation. If t is >\\n             * than duration we'll get values like 2.5 (midway through the\\n             * third iteration)\\n             */\\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\\n            /**\\n             * Get the current iteration (0 indexed). For instance the floor of\\n             * 2.5 is 2.\\n             */\\n            let currentIteration = Math.floor(progress);\\n            /**\\n             * Get the current progress of the iteration by taking the remainder\\n             * so 2.5 is 0.5 through iteration 2\\n             */\\n            let iterationProgress = progress % 1.0;\\n            /**\\n             * If iteration progress is 1 we count that as the end\\n             * of the previous iteration.\\n             */\\n            if (!iterationProgress && progress >= 1) {\\n                iterationProgress = 1;\\n            }\\n            iterationProgress === 1 && currentIteration--;\\n            currentIteration = Math.min(currentIteration, repeat + 1);\\n            /**\\n             * Reverse progress if we're not running in \\\"normal\\\" direction\\n             */\\n            const isOddIteration = Boolean(currentIteration % 2);\\n            if (isOddIteration) {\\n                if (repeatType === \\\"reverse\\\") {\\n                    iterationProgress = 1 - iterationProgress;\\n                    if (repeatDelay) {\\n                        iterationProgress -= repeatDelay / resolvedDuration;\\n                    }\\n                }\\n                else if (repeatType === \\\"mirror\\\") {\\n                    frameGenerator = mirroredGenerator;\\n                }\\n            }\\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\\n        }\\n        /**\\n         * If we're in negative time, set state as the initial keyframe.\\n         * This prevents delay: x, duration: 0 animations from finishing\\n         * instantly.\\n         */\\n        const state = isInDelayPhase\\n            ? { done: false, value: keyframes[0] }\\n            : frameGenerator.next(elapsed);\\n        if (mapPercentToKeyframes) {\\n            state.value = mapPercentToKeyframes(state.value);\\n        }\\n        let { done } = state;\\n        if (!isInDelayPhase && calculatedDuration !== null) {\\n            done =\\n                this.speed >= 0\\n                    ? this.currentTime >= totalDuration\\n                    : this.currentTime <= 0;\\n        }\\n        const isAnimationFinished = this.holdTime === null &&\\n            (this.state === \\\"finished\\\" || (this.state === \\\"running\\\" && done));\\n        if (isAnimationFinished && finalKeyframe !== undefined) {\\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\\n        }\\n        if (onUpdate) {\\n            onUpdate(state.value);\\n        }\\n        if (isAnimationFinished) {\\n            this.finish();\\n        }\\n        return state;\\n    }\\n    get duration() {\\n        const { resolved } = this;\\n        return resolved ? motionUtils.millisecondsToSeconds(resolved.calculatedDuration) : 0;\\n    }\\n    get time() {\\n        return motionUtils.millisecondsToSeconds(this.currentTime);\\n    }\\n    set time(newTime) {\\n        newTime = motionUtils.secondsToMilliseconds(newTime);\\n        this.currentTime = newTime;\\n        if (this.holdTime !== null || this.speed === 0) {\\n            this.holdTime = newTime;\\n        }\\n        else if (this.driver) {\\n            this.startTime = this.driver.now() - newTime / this.speed;\\n        }\\n    }\\n    get speed() {\\n        return this.playbackSpeed;\\n    }\\n    set speed(newSpeed) {\\n        const hasChanged = this.playbackSpeed !== newSpeed;\\n        this.playbackSpeed = newSpeed;\\n        if (hasChanged) {\\n            this.time = motionUtils.millisecondsToSeconds(this.currentTime);\\n        }\\n    }\\n    play() {\\n        if (!this.resolver.isScheduled) {\\n            this.resolver.resume();\\n        }\\n        if (!this._resolved) {\\n            this.pendingPlayState = \\\"running\\\";\\n            return;\\n        }\\n        if (this.isStopped)\\n            return;\\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\\n        if (!this.driver) {\\n            this.driver = driver((timestamp) => this.tick(timestamp));\\n        }\\n        onPlay && onPlay();\\n        const now = this.driver.now();\\n        if (this.holdTime !== null) {\\n            this.startTime = now - this.holdTime;\\n        }\\n        else if (!this.startTime) {\\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\\n        }\\n        else if (this.state === \\\"finished\\\") {\\n            this.startTime = now;\\n        }\\n        if (this.state === \\\"finished\\\") {\\n            this.updateFinishedPromise();\\n        }\\n        this.cancelTime = this.startTime;\\n        this.holdTime = null;\\n        /**\\n         * Set playState to running only after we've used it in\\n         * the previous logic.\\n         */\\n        this.state = \\\"running\\\";\\n        this.driver.start();\\n    }\\n    pause() {\\n        var _a;\\n        if (!this._resolved) {\\n            this.pendingPlayState = \\\"paused\\\";\\n            return;\\n        }\\n        this.state = \\\"paused\\\";\\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\\n    }\\n    complete() {\\n        if (this.state !== \\\"running\\\") {\\n            this.play();\\n        }\\n        this.pendingPlayState = this.state = \\\"finished\\\";\\n        this.holdTime = null;\\n    }\\n    finish() {\\n        this.teardown();\\n        this.state = \\\"finished\\\";\\n        const { onComplete } = this.options;\\n        onComplete && onComplete();\\n    }\\n    cancel() {\\n        if (this.cancelTime !== null) {\\n            this.tick(this.cancelTime);\\n        }\\n        this.teardown();\\n        this.updateFinishedPromise();\\n    }\\n    teardown() {\\n        this.state = \\\"idle\\\";\\n        this.stopDriver();\\n        this.resolveFinishedPromise();\\n        this.updateFinishedPromise();\\n        this.startTime = this.cancelTime = null;\\n        this.resolver.cancel();\\n    }\\n    stopDriver() {\\n        if (!this.driver)\\n            return;\\n        this.driver.stop();\\n        this.driver = undefined;\\n    }\\n    sample(time) {\\n        this.startTime = 0;\\n        return this.tick(time, true);\\n    }\\n}\\n// Legacy interface\\nfunction animateValue(options) {\\n    return new MainThreadAnimation(options);\\n}\\n\\n/**\\n * A list of values that can be hardware-accelerated.\\n */\\nconst acceleratedValues = new Set([\\n    \\\"opacity\\\",\\n    \\\"clipPath\\\",\\n    \\\"filter\\\",\\n    \\\"transform\\\",\\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\\n    // or until we implement support for linear() easing.\\n    // \\\"background-color\\\"\\n]);\\n\\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \\\"loop\\\", ease = \\\"easeInOut\\\", times, } = {}) {\\n    const keyframeOptions = { [valueName]: keyframes };\\n    if (times)\\n        keyframeOptions.offset = times;\\n    const easing = motionDom.mapEasingToNativeEasing(ease, duration);\\n    /**\\n     * If this is an easing array, apply to keyframes, not animation as a whole\\n     */\\n    if (Array.isArray(easing))\\n        keyframeOptions.easing = easing;\\n    const animation = element.animate(keyframeOptions, {\\n        delay,\\n        duration,\\n        easing: !Array.isArray(easing) ? easing : \\\"linear\\\",\\n        fill: \\\"both\\\",\\n        iterations: repeat + 1,\\n        direction: repeatType === \\\"reverse\\\" ? \\\"alternate\\\" : \\\"normal\\\",\\n    });\\n    return animation;\\n}\\n\\nconst supportsWaapi = /*@__PURE__*/ motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, \\\"animate\\\"));\\n\\n/**\\n * 10ms is chosen here as it strikes a balance between smooth\\n * results (more than one keyframe per frame at 60fps) and\\n * keyframe quantity.\\n */\\nconst sampleDelta = 10; //ms\\n/**\\n * Implement a practical max duration for keyframe generation\\n * to prevent infinite loops\\n */\\nconst maxDuration = 20000;\\n/**\\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\\n * handing off.\\n */\\nfunction requiresPregeneratedKeyframes(options) {\\n    return (motionDom.isGenerator(options.type) ||\\n        options.type === \\\"spring\\\" ||\\n        !motionDom.isWaapiSupportedEasing(options.ease));\\n}\\nfunction pregenerateKeyframes(keyframes, options) {\\n    /**\\n     * Create a main-thread animation to pregenerate keyframes.\\n     * We sample this at regular intervals to generate keyframes that we then\\n     * linearly interpolate between.\\n     */\\n    const sampleAnimation = new MainThreadAnimation({\\n        ...options,\\n        keyframes,\\n        repeat: 0,\\n        delay: 0,\\n        isGenerator: true,\\n    });\\n    let state = { done: false, value: keyframes[0] };\\n    const pregeneratedKeyframes = [];\\n    /**\\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\\n     * we're heading for an infinite loop.\\n     */\\n    let t = 0;\\n    while (!state.done && t < maxDuration) {\\n        state = sampleAnimation.sample(t);\\n        pregeneratedKeyframes.push(state.value);\\n        t += sampleDelta;\\n    }\\n    return {\\n        times: undefined,\\n        keyframes: pregeneratedKeyframes,\\n        duration: t - sampleDelta,\\n        ease: \\\"linear\\\",\\n    };\\n}\\nconst unsupportedEasingFunctions = {\\n    anticipate,\\n    backInOut,\\n    circInOut,\\n};\\nfunction isUnsupportedEase(key) {\\n    return key in unsupportedEasingFunctions;\\n}\\nclass AcceleratedAnimation extends BaseAnimation {\\n    constructor(options) {\\n        super(options);\\n        const { name, motionValue, element, keyframes } = this.options;\\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\\n        this.resolver.scheduleResolve();\\n    }\\n    initPlayback(keyframes, finalKeyframe) {\\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\\n        /**\\n         * If element has since been unmounted, return false to indicate\\n         * the animation failed to initialised.\\n         */\\n        if (!motionValue.owner || !motionValue.owner.current) {\\n            return false;\\n        }\\n        /**\\n         * If the user has provided an easing function name that isn't supported\\n         * by WAAPI (like \\\"anticipate\\\"), we need to provide the corressponding\\n         * function. This will later get converted to a linear() easing function.\\n         */\\n        if (typeof ease === \\\"string\\\" &&\\n            motionDom.supportsLinearEasing() &&\\n            isUnsupportedEase(ease)) {\\n            ease = unsupportedEasingFunctions[ease];\\n        }\\n        /**\\n         * If this animation needs pre-generated keyframes then generate.\\n         */\\n        if (requiresPregeneratedKeyframes(this.options)) {\\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\\n            keyframes = pregeneratedAnimation.keyframes;\\n            // If this is a very short animation, ensure we have\\n            // at least two keyframes to animate between as older browsers\\n            // can't animate between a single keyframe.\\n            if (keyframes.length === 1) {\\n                keyframes[1] = keyframes[0];\\n            }\\n            duration = pregeneratedAnimation.duration;\\n            times = pregeneratedAnimation.times;\\n            ease = pregeneratedAnimation.ease;\\n            type = \\\"keyframes\\\";\\n        }\\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\\n        // Override the browser calculated startTime with one synchronised to other JS\\n        // and WAAPI animations starting this event loop.\\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\\n        if (this.pendingTimeline) {\\n            motionDom.attachTimeline(animation, this.pendingTimeline);\\n            this.pendingTimeline = undefined;\\n        }\\n        else {\\n            /**\\n             * Prefer the `onfinish` prop as it's more widely supported than\\n             * the `finished` promise.\\n             *\\n             * Here, we synchronously set the provided MotionValue to the end\\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\\n             * be removed from the element which would then revert to its old styles.\\n             */\\n            animation.onfinish = () => {\\n                const { onComplete } = this.options;\\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\\n                onComplete && onComplete();\\n                this.cancel();\\n                this.resolveFinishedPromise();\\n            };\\n        }\\n        return {\\n            animation,\\n            duration,\\n            times,\\n            type,\\n            ease,\\n            keyframes: keyframes,\\n        };\\n    }\\n    get duration() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return 0;\\n        const { duration } = resolved;\\n        return motionUtils.millisecondsToSeconds(duration);\\n    }\\n    get time() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return 0;\\n        const { animation } = resolved;\\n        return motionUtils.millisecondsToSeconds(animation.currentTime || 0);\\n    }\\n    set time(newTime) {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        const { animation } = resolved;\\n        animation.currentTime = motionUtils.secondsToMilliseconds(newTime);\\n    }\\n    get speed() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return 1;\\n        const { animation } = resolved;\\n        return animation.playbackRate;\\n    }\\n    set speed(newSpeed) {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        const { animation } = resolved;\\n        animation.playbackRate = newSpeed;\\n    }\\n    get state() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return \\\"idle\\\";\\n        const { animation } = resolved;\\n        return animation.playState;\\n    }\\n    get startTime() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return null;\\n        const { animation } = resolved;\\n        // Coerce to number as TypeScript incorrectly types this\\n        // as CSSNumberish\\n        return animation.startTime;\\n    }\\n    /**\\n     * Replace the default DocumentTimeline with another AnimationTimeline.\\n     * Currently used for scroll animations.\\n     */\\n    attachTimeline(timeline) {\\n        if (!this._resolved) {\\n            this.pendingTimeline = timeline;\\n        }\\n        else {\\n            const { resolved } = this;\\n            if (!resolved)\\n                return motionUtils.noop;\\n            const { animation } = resolved;\\n            motionDom.attachTimeline(animation, timeline);\\n        }\\n        return motionUtils.noop;\\n    }\\n    play() {\\n        if (this.isStopped)\\n            return;\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        const { animation } = resolved;\\n        if (animation.playState === \\\"finished\\\") {\\n            this.updateFinishedPromise();\\n        }\\n        animation.play();\\n    }\\n    pause() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        const { animation } = resolved;\\n        animation.pause();\\n    }\\n    stop() {\\n        this.resolver.cancel();\\n        this.isStopped = true;\\n        if (this.state === \\\"idle\\\")\\n            return;\\n        this.resolveFinishedPromise();\\n        this.updateFinishedPromise();\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        const { animation, keyframes, duration, type, ease, times } = resolved;\\n        if (animation.playState === \\\"idle\\\" ||\\n            animation.playState === \\\"finished\\\") {\\n            return;\\n        }\\n        /**\\n         * WAAPI doesn't natively have any interruption capabilities.\\n         *\\n         * Rather than read commited styles back out of the DOM, we can\\n         * create a renderless JS animation and sample it twice to calculate\\n         * its current value, \\\"previous\\\" value, and therefore allow\\n         * Motion to calculate velocity for any subsequent animation.\\n         */\\n        if (this.time) {\\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\\n            const sampleAnimation = new MainThreadAnimation({\\n                ...options,\\n                keyframes,\\n                duration,\\n                type,\\n                ease,\\n                times,\\n                isGenerator: true,\\n            });\\n            const sampleTime = motionUtils.secondsToMilliseconds(this.time);\\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\\n        }\\n        const { onStop } = this.options;\\n        onStop && onStop();\\n        this.cancel();\\n    }\\n    complete() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        resolved.animation.finish();\\n    }\\n    cancel() {\\n        const { resolved } = this;\\n        if (!resolved)\\n            return;\\n        resolved.animation.cancel();\\n    }\\n    static supports(options) {\\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\\n        if (!motionValue ||\\n            !motionValue.owner ||\\n            !(motionValue.owner.current instanceof HTMLElement)) {\\n            return false;\\n        }\\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\\n        return (supportsWaapi() &&\\n            name &&\\n            acceleratedValues.has(name) &&\\n            /**\\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\\n             * no way to read the value from WAAPI every frame.\\n             */\\n            !onUpdate &&\\n            !transformTemplate &&\\n            !repeatDelay &&\\n            repeatType !== \\\"mirror\\\" &&\\n            damping !== 0 &&\\n            type !== \\\"inertia\\\");\\n    }\\n}\\n\\nconst underDampedSpring = {\\n    type: \\\"spring\\\",\\n    stiffness: 500,\\n    damping: 25,\\n    restSpeed: 10,\\n};\\nconst criticallyDampedSpring = (target) => ({\\n    type: \\\"spring\\\",\\n    stiffness: 550,\\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\\n    restSpeed: 10,\\n});\\nconst keyframesTransition = {\\n    type: \\\"keyframes\\\",\\n    duration: 0.8,\\n};\\n/**\\n * Default easing curve is a slightly shallower version of\\n * the default browser easing curve.\\n */\\nconst ease = {\\n    type: \\\"keyframes\\\",\\n    ease: [0.25, 0.1, 0.35, 1],\\n    duration: 0.3,\\n};\\nconst getDefaultTransition = (valueKey, { keyframes }) => {\\n    if (keyframes.length > 2) {\\n        return keyframesTransition;\\n    }\\n    else if (transformProps.has(valueKey)) {\\n        return valueKey.startsWith(\\\"scale\\\")\\n            ? criticallyDampedSpring(keyframes[1])\\n            : underDampedSpring;\\n    }\\n    return ease;\\n};\\n\\n/**\\n * Decide whether a transition is defined on a given Transition.\\n * This filters out orchestration options and returns true\\n * if any options are left.\\n */\\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\\n    return !!Object.keys(transition).length;\\n}\\n\\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\\n    const valueTransition = motionDom.getValueTransition(transition, name) || {};\\n    /**\\n     * Most transition values are currently completely overwritten by value-specific\\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\\n     * delay actually does inherit from the root transition if not value-specific.\\n     */\\n    const delay = valueTransition.delay || transition.delay || 0;\\n    /**\\n     * Elapsed isn't a public transition option but can be passed through from\\n     * optimized appear effects in milliseconds.\\n     */\\n    let { elapsed = 0 } = transition;\\n    elapsed = elapsed - motionUtils.secondsToMilliseconds(delay);\\n    let options = {\\n        keyframes: Array.isArray(target) ? target : [null, target],\\n        ease: \\\"easeOut\\\",\\n        velocity: value.getVelocity(),\\n        ...valueTransition,\\n        delay: -elapsed,\\n        onUpdate: (v) => {\\n            value.set(v);\\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\\n        },\\n        onComplete: () => {\\n            onComplete();\\n            valueTransition.onComplete && valueTransition.onComplete();\\n        },\\n        name,\\n        motionValue: value,\\n        element: isHandoff ? undefined : element,\\n    };\\n    /**\\n     * If there's no transition defined for this value, we can generate\\n     * unqiue transition settings for this value.\\n     */\\n    if (!isTransitionDefined(valueTransition)) {\\n        options = {\\n            ...options,\\n            ...getDefaultTransition(name, options),\\n        };\\n    }\\n    /**\\n     * Both WAAPI and our internal animation functions use durations\\n     * as defined by milliseconds, while our external API defines them\\n     * as seconds.\\n     */\\n    if (options.duration) {\\n        options.duration = motionUtils.secondsToMilliseconds(options.duration);\\n    }\\n    if (options.repeatDelay) {\\n        options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay);\\n    }\\n    if (options.from !== undefined) {\\n        options.keyframes[0] = options.from;\\n    }\\n    let shouldSkip = false;\\n    if (options.type === false ||\\n        (options.duration === 0 && !options.repeatDelay)) {\\n        options.duration = 0;\\n        if (options.delay === 0) {\\n            shouldSkip = true;\\n        }\\n    }\\n    if (instantAnimationState.current ||\\n        MotionGlobalConfig.skipAnimations) {\\n        shouldSkip = true;\\n        options.duration = 0;\\n        options.delay = 0;\\n    }\\n    /**\\n     * If we can or must skip creating the animation, and apply only\\n     * the final keyframe, do so. We also check once keyframes are resolved but\\n     * this early check prevents the need to create an animation at all.\\n     */\\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\\n        if (finalKeyframe !== undefined) {\\n            frame.update(() => {\\n                options.onUpdate(finalKeyframe);\\n                options.onComplete();\\n            });\\n            // We still want to return some animation controls here rather\\n            // than returning undefined\\n            return new motionDom.GroupPlaybackControls([]);\\n        }\\n    }\\n    /**\\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \\\"under\\\" the\\n     * optimised animation.\\n     */\\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\\n        return new AcceleratedAnimation(options);\\n    }\\n    else {\\n        return new MainThreadAnimation(options);\\n    }\\n};\\n\\n/**\\n * Decide whether we should block this animation. Previously, we achieved this\\n * just by checking whether the key was listed in protectedKeys, but this\\n * posed problems if an animation was triggered by afterChildren and protectedKeys\\n * had been set to true in the meantime.\\n */\\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\\n    needsAnimating[key] = false;\\n    return shouldBlock;\\n}\\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\\n    var _a;\\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\\n    if (transitionOverride)\\n        transition = transitionOverride;\\n    const animations = [];\\n    const animationTypeState = type &&\\n        visualElement.animationState &&\\n        visualElement.animationState.getState()[type];\\n    for (const key in target) {\\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\\n        const valueTarget = target[key];\\n        if (valueTarget === undefined ||\\n            (animationTypeState &&\\n                shouldBlockAnimation(animationTypeState, key))) {\\n            continue;\\n        }\\n        const valueTransition = {\\n            delay,\\n            ...motionDom.getValueTransition(transition || {}, key),\\n        };\\n        /**\\n         * If this is the first time a value is being animated, check\\n         * to see if we're handling off from an existing animation.\\n         */\\n        let isHandoff = false;\\n        if (window.MotionHandoffAnimation) {\\n            const appearId = getOptimisedAppearId(visualElement);\\n            if (appearId) {\\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\\n                if (startTime !== null) {\\n                    valueTransition.startTime = startTime;\\n                    isHandoff = true;\\n                }\\n            }\\n        }\\n        addValueToWillChange(visualElement, key);\\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\\n            ? { type: false }\\n            : valueTransition, visualElement, isHandoff));\\n        const animation = value.animation;\\n        if (animation) {\\n            animations.push(animation);\\n        }\\n    }\\n    if (transitionEnd) {\\n        Promise.all(animations).then(() => {\\n            frame.update(() => {\\n                transitionEnd && setTarget(visualElement, transitionEnd);\\n            });\\n        });\\n    }\\n    return animations;\\n}\\n\\nfunction animateVariant(visualElement, variant, options = {}) {\\n    var _a;\\n    const resolved = resolveVariant(visualElement, variant, options.type === \\\"exit\\\"\\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\\n        : undefined);\\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\\n    if (options.transitionOverride) {\\n        transition = options.transitionOverride;\\n    }\\n    /**\\n     * If we have a variant, create a callback that runs it as an animation.\\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\\n     */\\n    const getAnimation = resolved\\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\\n        : () => Promise.resolve();\\n    /**\\n     * If we have children, create a callback that runs all their animations.\\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\\n     */\\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\\n        ? (forwardDelay = 0) => {\\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\\n        }\\n        : () => Promise.resolve();\\n    /**\\n     * If the transition explicitly defines a \\\"when\\\" option, we need to resolve either\\n     * this animation or all children animations before playing the other.\\n     */\\n    const { when } = transition;\\n    if (when) {\\n        const [first, last] = when === \\\"beforeChildren\\\"\\n            ? [getAnimation, getChildAnimations]\\n            : [getChildAnimations, getAnimation];\\n        return first().then(() => last());\\n    }\\n    else {\\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\\n    }\\n}\\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\\n    const animations = [];\\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\\n    const generateStaggerDuration = staggerDirection === 1\\n        ? (i = 0) => i * staggerChildren\\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\\n    Array.from(visualElement.variantChildren)\\n        .sort(sortByTreeOrder)\\n        .forEach((child, i) => {\\n        child.notify(\\\"AnimationStart\\\", variant);\\n        animations.push(animateVariant(child, variant, {\\n            ...options,\\n            delay: delayChildren + generateStaggerDuration(i),\\n        }).then(() => child.notify(\\\"AnimationComplete\\\", variant)));\\n    });\\n    return Promise.all(animations);\\n}\\nfunction sortByTreeOrder(a, b) {\\n    return a.sortNodePosition(b);\\n}\\n\\nfunction animateVisualElement(visualElement, definition, options = {}) {\\n    visualElement.notify(\\\"AnimationStart\\\", definition);\\n    let animation;\\n    if (Array.isArray(definition)) {\\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\\n        animation = Promise.all(animations);\\n    }\\n    else if (typeof definition === \\\"string\\\") {\\n        animation = animateVariant(visualElement, definition, options);\\n    }\\n    else {\\n        const resolvedDefinition = typeof definition === \\\"function\\\"\\n            ? resolveVariant(visualElement, definition, options.custom)\\n            : definition;\\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\\n    }\\n    return animation.then(() => {\\n        visualElement.notify(\\\"AnimationComplete\\\", definition);\\n    });\\n}\\n\\nfunction shallowCompare(next, prev) {\\n    if (!Array.isArray(prev))\\n        return false;\\n    const prevLength = prev.length;\\n    if (prevLength !== next.length)\\n        return false;\\n    for (let i = 0; i < prevLength; i++) {\\n        if (prev[i] !== next[i])\\n            return false;\\n    }\\n    return true;\\n}\\n\\n/**\\n * Decides if the supplied variable is variant label\\n */\\nfunction isVariantLabel(v) {\\n    return typeof v === \\\"string\\\" || Array.isArray(v);\\n}\\n\\nconst variantPriorityOrder = [\\n    \\\"animate\\\",\\n    \\\"whileInView\\\",\\n    \\\"whileFocus\\\",\\n    \\\"whileHover\\\",\\n    \\\"whileTap\\\",\\n    \\\"whileDrag\\\",\\n    \\\"exit\\\",\\n];\\nconst variantProps = [\\\"initial\\\", ...variantPriorityOrder];\\n\\nconst numVariantProps = variantProps.length;\\nfunction getVariantContext(visualElement) {\\n    if (!visualElement)\\n        return undefined;\\n    if (!visualElement.isControllingVariants) {\\n        const context = visualElement.parent\\n            ? getVariantContext(visualElement.parent) || {}\\n            : {};\\n        if (visualElement.props.initial !== undefined) {\\n            context.initial = visualElement.props.initial;\\n        }\\n        return context;\\n    }\\n    const context = {};\\n    for (let i = 0; i < numVariantProps; i++) {\\n        const name = variantProps[i];\\n        const prop = visualElement.props[name];\\n        if (isVariantLabel(prop) || prop === false) {\\n            context[name] = prop;\\n        }\\n    }\\n    return context;\\n}\\n\\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\\nconst numAnimationTypes = variantPriorityOrder.length;\\nfunction animateList(visualElement) {\\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\\n}\\nfunction createAnimationState(visualElement) {\\n    let animate = animateList(visualElement);\\n    let state = createState();\\n    let isInitialRender = true;\\n    /**\\n     * This function will be used to reduce the animation definitions for\\n     * each active animation type into an object of resolved values for it.\\n     */\\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\\n        var _a;\\n        const resolved = resolveVariant(visualElement, definition, type === \\\"exit\\\"\\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\\n            : undefined);\\n        if (resolved) {\\n            const { transition, transitionEnd, ...target } = resolved;\\n            acc = { ...acc, ...target, ...transitionEnd };\\n        }\\n        return acc;\\n    };\\n    /**\\n     * This just allows us to inject mocked animation functions\\n     * @internal\\n     */\\n    function setAnimateFunction(makeAnimator) {\\n        animate = makeAnimator(visualElement);\\n    }\\n    /**\\n     * When we receive new props, we need to:\\n     * 1. Create a list of protected keys for each type. This is a directory of\\n     *    value keys that are currently being \\\"handled\\\" by types of a higher priority\\n     *    so that whenever an animation is played of a given type, these values are\\n     *    protected from being animated.\\n     * 2. Determine if an animation type needs animating.\\n     * 3. Determine if any values have been removed from a type and figure out\\n     *    what to animate those to.\\n     */\\n    function animateChanges(changedActiveType) {\\n        const { props } = visualElement;\\n        const context = getVariantContext(visualElement.parent) || {};\\n        /**\\n         * A list of animations that we'll build into as we iterate through the animation\\n         * types. This will get executed at the end of the function.\\n         */\\n        const animations = [];\\n        /**\\n         * Keep track of which values have been removed. Then, as we hit lower priority\\n         * animation types, we can check if they contain removed values and animate to that.\\n         */\\n        const removedKeys = new Set();\\n        /**\\n         * A dictionary of all encountered keys. This is an object to let us build into and\\n         * copy it without iteration. Each time we hit an animation type we set its protected\\n         * keys - the keys its not allowed to animate - to the latest version of this object.\\n         */\\n        let encounteredKeys = {};\\n        /**\\n         * If a variant has been removed at a given index, and this component is controlling\\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\\n         */\\n        let removedVariantIndex = Infinity;\\n        /**\\n         * Iterate through all animation types in reverse priority order. For each, we want to\\n         * detect which values it's handling and whether or not they've changed (and therefore\\n         * need to be animated). If any values have been removed, we want to detect those in\\n         * lower priority props and flag for animation.\\n         */\\n        for (let i = 0; i < numAnimationTypes; i++) {\\n            const type = reversePriorityOrder[i];\\n            const typeState = state[type];\\n            const prop = props[type] !== undefined\\n                ? props[type]\\n                : context[type];\\n            const propIsVariant = isVariantLabel(prop);\\n            /**\\n             * If this type has *just* changed isActive status, set activeDelta\\n             * to that status. Otherwise set to null.\\n             */\\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\\n            if (activeDelta === false)\\n                removedVariantIndex = i;\\n            /**\\n             * If this prop is an inherited variant, rather than been set directly on the\\n             * component itself, we want to make sure we allow the parent to trigger animations.\\n             *\\n             * TODO: Can probably change this to a !isControllingVariants check\\n             */\\n            let isInherited = prop === context[type] &&\\n                prop !== props[type] &&\\n                propIsVariant;\\n            /**\\n             *\\n             */\\n            if (isInherited &&\\n                isInitialRender &&\\n                visualElement.manuallyAnimateOnMount) {\\n                isInherited = false;\\n            }\\n            /**\\n             * Set all encountered keys so far as the protected keys for this type. This will\\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\\n             */\\n            typeState.protectedKeys = { ...encounteredKeys };\\n            // Check if we can skip analysing this prop early\\n            if (\\n            // If it isn't active and hasn't *just* been set as inactive\\n            (!typeState.isActive && activeDelta === null) ||\\n                // If we didn't and don't have any defined prop for this animation type\\n                (!prop && !typeState.prevProp) ||\\n                // Or if the prop doesn't define an animation\\n                isAnimationControls(prop) ||\\n                typeof prop === \\\"boolean\\\") {\\n                continue;\\n            }\\n            /**\\n             * As we go look through the values defined on this type, if we detect\\n             * a changed value or a value that was removed in a higher priority, we set\\n             * this to true and add this prop to the animation list.\\n             */\\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\\n            let shouldAnimateType = variantDidChange ||\\n                // If we're making this variant active, we want to always make it active\\n                (type === changedActiveType &&\\n                    typeState.isActive &&\\n                    !isInherited &&\\n                    propIsVariant) ||\\n                // If we removed a higher-priority variant (i is in reverse order)\\n                (i > removedVariantIndex && propIsVariant);\\n            let handledRemovedValues = false;\\n            /**\\n             * As animations can be set as variant lists, variants or target objects, we\\n             * coerce everything to an array if it isn't one already\\n             */\\n            const definitionList = Array.isArray(prop) ? prop : [prop];\\n            /**\\n             * Build an object of all the resolved values. We'll use this in the subsequent\\n             * animateChanges calls to determine whether a value has changed.\\n             */\\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\\n            if (activeDelta === false)\\n                resolvedValues = {};\\n            /**\\n             * Now we need to loop through all the keys in the prev prop and this prop,\\n             * and decide:\\n             * 1. If the value has changed, and needs animating\\n             * 2. If it has been removed, and needs adding to the removedKeys set\\n             * 3. If it has been removed in a higher priority type and needs animating\\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\\n             *    needs adding to the type's protectedKeys list.\\n             */\\n            const { prevResolvedValues = {} } = typeState;\\n            const allKeys = {\\n                ...prevResolvedValues,\\n                ...resolvedValues,\\n            };\\n            const markToAnimate = (key) => {\\n                shouldAnimateType = true;\\n                if (removedKeys.has(key)) {\\n                    handledRemovedValues = true;\\n                    removedKeys.delete(key);\\n                }\\n                typeState.needsAnimating[key] = true;\\n                const motionValue = visualElement.getValue(key);\\n                if (motionValue)\\n                    motionValue.liveStyle = false;\\n            };\\n            for (const key in allKeys) {\\n                const next = resolvedValues[key];\\n                const prev = prevResolvedValues[key];\\n                // If we've already handled this we can just skip ahead\\n                if (encounteredKeys.hasOwnProperty(key))\\n                    continue;\\n                /**\\n                 * If the value has changed, we probably want to animate it.\\n                 */\\n                let valueHasChanged = false;\\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\\n                    valueHasChanged = !shallowCompare(next, prev);\\n                }\\n                else {\\n                    valueHasChanged = next !== prev;\\n                }\\n                if (valueHasChanged) {\\n                    if (next !== undefined && next !== null) {\\n                        // If next is defined and doesn't equal prev, it needs animating\\n                        markToAnimate(key);\\n                    }\\n                    else {\\n                        // If it's undefined, it's been removed.\\n                        removedKeys.add(key);\\n                    }\\n                }\\n                else if (next !== undefined && removedKeys.has(key)) {\\n                    /**\\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\\n                     * been removed by a higher priority\\n                     */\\n                    markToAnimate(key);\\n                }\\n                else {\\n                    /**\\n                     * If it hasn't changed, we add it to the list of protected values\\n                     * to ensure it doesn't get animated.\\n                     */\\n                    typeState.protectedKeys[key] = true;\\n                }\\n            }\\n            /**\\n             * Update the typeState so next time animateChanges is called we can compare the\\n             * latest prop and resolvedValues to these.\\n             */\\n            typeState.prevProp = prop;\\n            typeState.prevResolvedValues = resolvedValues;\\n            /**\\n             *\\n             */\\n            if (typeState.isActive) {\\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\\n            }\\n            if (isInitialRender && visualElement.blockInitialAnimation) {\\n                shouldAnimateType = false;\\n            }\\n            /**\\n             * If this is an inherited prop we want to skip this animation\\n             * unless the inherited variants haven't changed on this render.\\n             */\\n            const willAnimateViaParent = isInherited && variantDidChange;\\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\\n            if (shouldAnimateType && needsAnimating) {\\n                animations.push(...definitionList.map((animation) => ({\\n                    animation: animation,\\n                    options: { type },\\n                })));\\n            }\\n        }\\n        /**\\n         * If there are some removed value that haven't been dealt with,\\n         * we need to create a new animation that falls back either to the value\\n         * defined in the style prop, or the last read value.\\n         */\\n        if (removedKeys.size) {\\n            const fallbackAnimation = {};\\n            /**\\n             * If the initial prop contains a transition we can use that, otherwise\\n             * allow the animation function to use the visual element's default.\\n             */\\n            if (typeof props.initial !== \\\"boolean\\\") {\\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\\n                    ? props.initial[0]\\n                    : props.initial);\\n                if (initialTransition && initialTransition.transition) {\\n                    fallbackAnimation.transition = initialTransition.transition;\\n                }\\n            }\\n            removedKeys.forEach((key) => {\\n                const fallbackTarget = visualElement.getBaseTarget(key);\\n                const motionValue = visualElement.getValue(key);\\n                if (motionValue)\\n                    motionValue.liveStyle = true;\\n                // @ts-expect-error - @mattgperry to figure if we should do something here\\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\\n            });\\n            animations.push({ animation: fallbackAnimation });\\n        }\\n        let shouldAnimate = Boolean(animations.length);\\n        if (isInitialRender &&\\n            (props.initial === false || props.initial === props.animate) &&\\n            !visualElement.manuallyAnimateOnMount) {\\n            shouldAnimate = false;\\n        }\\n        isInitialRender = false;\\n        return shouldAnimate ? animate(animations) : Promise.resolve();\\n    }\\n    /**\\n     * Change whether a certain animation type is active.\\n     */\\n    function setActive(type, isActive) {\\n        var _a;\\n        // If the active state hasn't changed, we can safely do nothing here\\n        if (state[type].isActive === isActive)\\n            return Promise.resolve();\\n        // Propagate active change to children\\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\\n        state[type].isActive = isActive;\\n        const animations = animateChanges(type);\\n        for (const key in state) {\\n            state[key].protectedKeys = {};\\n        }\\n        return animations;\\n    }\\n    return {\\n        animateChanges,\\n        setActive,\\n        setAnimateFunction,\\n        getState: () => state,\\n        reset: () => {\\n            state = createState();\\n            isInitialRender = true;\\n        },\\n    };\\n}\\nfunction checkVariantsDidChange(prev, next) {\\n    if (typeof next === \\\"string\\\") {\\n        return next !== prev;\\n    }\\n    else if (Array.isArray(next)) {\\n        return !shallowCompare(next, prev);\\n    }\\n    return false;\\n}\\nfunction createTypeState(isActive = false) {\\n    return {\\n        isActive,\\n        protectedKeys: {},\\n        needsAnimating: {},\\n        prevResolvedValues: {},\\n    };\\n}\\nfunction createState() {\\n    return {\\n        animate: createTypeState(true),\\n        whileInView: createTypeState(),\\n        whileHover: createTypeState(),\\n        whileTap: createTypeState(),\\n        whileDrag: createTypeState(),\\n        whileFocus: createTypeState(),\\n        exit: createTypeState(),\\n    };\\n}\\n\\nclass Feature {\\n    constructor(node) {\\n        this.isMounted = false;\\n        this.node = node;\\n    }\\n    update() { }\\n}\\n\\nclass AnimationFeature extends Feature {\\n    /**\\n     * We dynamically generate the AnimationState manager as it contains a reference\\n     * to the underlying animation library. We only want to load that if we load this,\\n     * so people can optionally code split it out using the `m` component.\\n     */\\n    constructor(node) {\\n        super(node);\\n        node.animationState || (node.animationState = createAnimationState(node));\\n    }\\n    updateAnimationControlsSubscription() {\\n        const { animate } = this.node.getProps();\\n        if (isAnimationControls(animate)) {\\n            this.unmountControls = animate.subscribe(this.node);\\n        }\\n    }\\n    /**\\n     * Subscribe any provided AnimationControls to the component's VisualElement\\n     */\\n    mount() {\\n        this.updateAnimationControlsSubscription();\\n    }\\n    update() {\\n        const { animate } = this.node.getProps();\\n        const { animate: prevAnimate } = this.node.prevProps || {};\\n        if (animate !== prevAnimate) {\\n            this.updateAnimationControlsSubscription();\\n        }\\n    }\\n    unmount() {\\n        var _a;\\n        this.node.animationState.reset();\\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\\n    }\\n}\\n\\nlet id$1 = 0;\\nclass ExitAnimationFeature extends Feature {\\n    constructor() {\\n        super(...arguments);\\n        this.id = id$1++;\\n    }\\n    update() {\\n        if (!this.node.presenceContext)\\n            return;\\n        const { isPresent, onExitComplete } = this.node.presenceContext;\\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\\n        if (!this.node.animationState || isPresent === prevIsPresent) {\\n            return;\\n        }\\n        const exitAnimation = this.node.animationState.setActive(\\\"exit\\\", !isPresent);\\n        if (onExitComplete && !isPresent) {\\n            exitAnimation.then(() => {\\n                onExitComplete(this.id);\\n            });\\n        }\\n    }\\n    mount() {\\n        const { register, onExitComplete } = this.node.presenceContext || {};\\n        if (onExitComplete) {\\n            onExitComplete(this.id);\\n        }\\n        if (register) {\\n            this.unmount = register(this.id);\\n        }\\n    }\\n    unmount() { }\\n}\\n\\nconst animations = {\\n    animation: {\\n        Feature: AnimationFeature,\\n    },\\n    exit: {\\n        Feature: ExitAnimationFeature,\\n    },\\n};\\n\\nconst MotionContext = /* @__PURE__ */ React.createContext({});\\n\\nconst createAxisDelta = () => ({\\n    translate: 0,\\n    scale: 1,\\n    origin: 0,\\n    originPoint: 0,\\n});\\nconst createDelta = () => ({\\n    x: createAxisDelta(),\\n    y: createAxisDelta(),\\n});\\nconst createAxis = () => ({ min: 0, max: 0 });\\nconst createBox = () => ({\\n    x: createAxis(),\\n    y: createAxis(),\\n});\\n\\nconst SCALE_PRECISION = 0.0001;\\nconst SCALE_MIN = 1 - SCALE_PRECISION;\\nconst SCALE_MAX = 1 + SCALE_PRECISION;\\nconst TRANSLATE_PRECISION = 0.01;\\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\\nfunction calcLength(axis) {\\n    return axis.max - axis.min;\\n}\\nfunction isNear(value, target, maxDistance) {\\n    return Math.abs(value - target) <= maxDistance;\\n}\\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\\n    delta.origin = origin;\\n    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);\\n    delta.scale = calcLength(target) / calcLength(source);\\n    delta.translate =\\n        mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;\\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\\n        isNaN(delta.scale)) {\\n        delta.scale = 1.0;\\n    }\\n    if ((delta.translate >= TRANSLATE_MIN &&\\n        delta.translate <= TRANSLATE_MAX) ||\\n        isNaN(delta.translate)) {\\n        delta.translate = 0.0;\\n    }\\n}\\nfunction calcBoxDelta(delta, source, target, origin) {\\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\\n}\\nfunction calcRelativeAxis(target, relative, parent) {\\n    target.min = parent.min + relative.min;\\n    target.max = target.min + calcLength(relative);\\n}\\nfunction calcRelativeBox(target, relative, parent) {\\n    calcRelativeAxis(target.x, relative.x, parent.x);\\n    calcRelativeAxis(target.y, relative.y, parent.y);\\n}\\nfunction calcRelativeAxisPosition(target, layout, parent) {\\n    target.min = layout.min - parent.min;\\n    target.max = target.min + calcLength(layout);\\n}\\nfunction calcRelativePosition(target, layout, parent) {\\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\\n}\\n\\n/**\\n * A list of all valid MotionProps.\\n *\\n * @privateRemarks\\n * This doesn't throw if a `MotionProp` name is missing - it should.\\n */\\nconst validMotionProps = new Set([\\n    \\\"animate\\\",\\n    \\\"exit\\\",\\n    \\\"variants\\\",\\n    \\\"initial\\\",\\n    \\\"style\\\",\\n    \\\"values\\\",\\n    \\\"variants\\\",\\n    \\\"transition\\\",\\n    \\\"transformTemplate\\\",\\n    \\\"custom\\\",\\n    \\\"inherit\\\",\\n    \\\"onBeforeLayoutMeasure\\\",\\n    \\\"onAnimationStart\\\",\\n    \\\"onAnimationComplete\\\",\\n    \\\"onUpdate\\\",\\n    \\\"onDragStart\\\",\\n    \\\"onDrag\\\",\\n    \\\"onDragEnd\\\",\\n    \\\"onMeasureDragConstraints\\\",\\n    \\\"onDirectionLock\\\",\\n    \\\"onDragTransitionEnd\\\",\\n    \\\"_dragX\\\",\\n    \\\"_dragY\\\",\\n    \\\"onHoverStart\\\",\\n    \\\"onHoverEnd\\\",\\n    \\\"onViewportEnter\\\",\\n    \\\"onViewportLeave\\\",\\n    \\\"globalTapTarget\\\",\\n    \\\"ignoreStrict\\\",\\n    \\\"viewport\\\",\\n]);\\n/**\\n * Check whether a prop name is a valid `MotionProp` key.\\n *\\n * @param key - Name of the property to check\\n * @returns `true` is key is a valid `MotionProp`.\\n *\\n * @public\\n */\\nfunction isValidMotionProp(key) {\\n    return (key.startsWith(\\\"while\\\") ||\\n        (key.startsWith(\\\"drag\\\") && key !== \\\"draggable\\\") ||\\n        key.startsWith(\\\"layout\\\") ||\\n        key.startsWith(\\\"onTap\\\") ||\\n        key.startsWith(\\\"onPan\\\") ||\\n        key.startsWith(\\\"onLayout\\\") ||\\n        validMotionProps.has(key));\\n}\\n\\nlet shouldForward = (key) => !isValidMotionProp(key);\\nfunction loadExternalIsValidProp(isValidProp) {\\n    if (!isValidProp)\\n        return;\\n    // Explicitly filter our events\\n    shouldForward = (key) => key.startsWith(\\\"on\\\") ? !isValidMotionProp(key) : isValidProp(key);\\n}\\n/**\\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\\n * of these should be passed to the underlying DOM node.\\n *\\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\\n *\\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\\n * actually required.\\n */\\ntry {\\n    /**\\n     * We attempt to import this package but require won't be defined in esm environments, in that case\\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\\n     * in favour of explicit injection.\\n     */\\n    loadExternalIsValidProp(require(\\\"@emotion/is-prop-valid\\\").default);\\n}\\ncatch (_a) {\\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\\n}\\nfunction filterProps(props, isDom, forwardMotionProps) {\\n    const filteredProps = {};\\n    for (const key in props) {\\n        /**\\n         * values is considered a valid prop by Emotion, so if it's present\\n         * this will be rendered out to the DOM unless explicitly filtered.\\n         *\\n         * We check the type as it could be used with the `feColorMatrix`\\n         * element, which we support.\\n         */\\n        if (key === \\\"values\\\" && typeof props.values === \\\"object\\\")\\n            continue;\\n        if (shouldForward(key) ||\\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\\n            (!isDom && !isValidMotionProp(key)) ||\\n            // If trying to use native HTML drag events, forward drag listeners\\n            (props[\\\"draggable\\\"] &&\\n                key.startsWith(\\\"onDrag\\\"))) {\\n            filteredProps[key] =\\n                props[key];\\n        }\\n    }\\n    return filteredProps;\\n}\\n\\n/**\\n * @public\\n */\\nconst PresenceContext = \\n/* @__PURE__ */ React.createContext(null);\\n\\nfunction isControllingVariants(props) {\\n    return (isAnimationControls(props.animate) ||\\n        variantProps.some((name) => isVariantLabel(props[name])));\\n}\\nfunction isVariantNode(props) {\\n    return Boolean(isControllingVariants(props) || props.variants);\\n}\\n\\n/**\\n * Creates a constant value over the lifecycle of a component.\\n *\\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\\n * you can ensure that initialisers don't execute twice or more.\\n */\\nfunction useConstant(init) {\\n    const ref = React.useRef(null);\\n    if (ref.current === null) {\\n        ref.current = init();\\n    }\\n    return ref.current;\\n}\\n\\n/**\\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\\n *\\n * TODO: Remove and move to library\\n */\\nfunction resolveMotionValue(value) {\\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\\n    return isCustomValue(unwrappedValue)\\n        ? unwrappedValue.toValue()\\n        : unwrappedValue;\\n}\\n\\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\\n    const state = {\\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\\n        renderState: createRenderState(),\\n    };\\n    if (onUpdate) {\\n        /**\\n         * onMount works without the VisualElement because it could be\\n         * called before the VisualElement payload has been hydrated.\\n         * (e.g. if someone is using m components <m.circle />)\\n         */\\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\\n    }\\n    return state;\\n}\\nconst makeUseVisualState = (config) => (props, isStatic) => {\\n    const context = React.useContext(MotionContext);\\n    const presenceContext = React.useContext(PresenceContext);\\n    const make = () => makeState(config, props, context, presenceContext);\\n    return isStatic ? make() : useConstant(make);\\n};\\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\\n    const values = {};\\n    const motionValues = scrapeMotionValues(props, {});\\n    for (const key in motionValues) {\\n        values[key] = resolveMotionValue(motionValues[key]);\\n    }\\n    let { initial, animate } = props;\\n    const isControllingVariants$1 = isControllingVariants(props);\\n    const isVariantNode$1 = isVariantNode(props);\\n    if (context &&\\n        isVariantNode$1 &&\\n        !isControllingVariants$1 &&\\n        props.inherit !== false) {\\n        if (initial === undefined)\\n            initial = context.initial;\\n        if (animate === undefined)\\n            animate = context.animate;\\n    }\\n    let isInitialAnimationBlocked = presenceContext\\n        ? presenceContext.initial === false\\n        : false;\\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\\n    if (variantToSet &&\\n        typeof variantToSet !== \\\"boolean\\\" &&\\n        !isAnimationControls(variantToSet)) {\\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\\n        for (let i = 0; i < list.length; i++) {\\n            const resolved = resolveVariantFromProps(props, list[i]);\\n            if (resolved) {\\n                const { transitionEnd, transition, ...target } = resolved;\\n                for (const key in target) {\\n                    let valueTarget = target[key];\\n                    if (Array.isArray(valueTarget)) {\\n                        /**\\n                         * Take final keyframe if the initial animation is blocked because\\n                         * we want to initialise at the end of that blocked animation.\\n                         */\\n                        const index = isInitialAnimationBlocked\\n                            ? valueTarget.length - 1\\n                            : 0;\\n                        valueTarget = valueTarget[index];\\n                    }\\n                    if (valueTarget !== null) {\\n                        values[key] = valueTarget;\\n                    }\\n                }\\n                for (const key in transitionEnd) {\\n                    values[key] = transitionEnd[key];\\n                }\\n            }\\n        }\\n    }\\n    return values;\\n}\\n\\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\\n    target.addEventListener(eventName, handler, options);\\n    return () => target.removeEventListener(eventName, handler);\\n}\\n\\nfunction extractEventInfo(event) {\\n    return {\\n        point: {\\n            x: event.pageX,\\n            y: event.pageY,\\n        },\\n    };\\n}\\nconst addPointerInfo = (handler) => {\\n    return (event) => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));\\n};\\n\\nfunction addPointerEvent(target, eventName, handler, options) {\\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\\n}\\n\\nconst isBrowser = typeof window !== \\\"undefined\\\";\\n\\nconst useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\\n\\n/**\\n * @public\\n */\\nconst MotionConfigContext = React.createContext({\\n    transformPagePoint: (p) => p,\\n    isStatic: false,\\n    reducedMotion: \\\"never\\\",\\n});\\n\\n/**\\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\\n * to access information about whether it's still present in the React tree.\\n *\\n * ```jsx\\n * import { usePresence } from \\\"framer-motion\\\"\\n *\\n * export const Component = () => {\\n *   const [isPresent, safeToRemove] = usePresence()\\n *\\n *   useEffect(() => {\\n *     !isPresent && setTimeout(safeToRemove, 1000)\\n *   }, [isPresent])\\n *\\n *   return <div />\\n * }\\n * ```\\n *\\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\\n *\\n * @public\\n */\\nfunction usePresence(subscribe = true) {\\n    const context = React.useContext(PresenceContext);\\n    if (context === null)\\n        return [true, null];\\n    const { isPresent, onExitComplete, register } = context;\\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\\n    // either be null or non-null for the lifespan of the component.\\n    const id = React.useId();\\n    React.useEffect(() => {\\n        if (subscribe) {\\n            return register(id);\\n        }\\n    }, [subscribe]);\\n    const safeToRemove = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\\n}\\n/**\\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\\n * There is no `safeToRemove` function.\\n *\\n * ```jsx\\n * import { useIsPresent } from \\\"framer-motion\\\"\\n *\\n * export const Component = () => {\\n *   const isPresent = useIsPresent()\\n *\\n *   useEffect(() => {\\n *     !isPresent && console.log(\\\"I've been removed!\\\")\\n *   }, [isPresent])\\n *\\n *   return <div />\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction useIsPresent() {\\n    return isPresent(React.useContext(PresenceContext));\\n}\\nfunction isPresent(context) {\\n    return context === null ? true : context.isPresent;\\n}\\n\\nfunction animateSingleValue(value, keyframes, options) {\\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\\n    motionValue$1.start(animateMotionValue(\\\"\\\", motionValue$1, keyframes, options));\\n    return motionValue$1.animation;\\n}\\n\\nconst visualElementStore = new WeakMap();\\n\\nfunction isSVGElement(element) {\\n    return element instanceof SVGElement && element.tagName !== \\\"svg\\\";\\n}\\n\\nconst featureProps = {\\n    animation: [\\n        \\\"animate\\\",\\n        \\\"variants\\\",\\n        \\\"whileHover\\\",\\n        \\\"whileTap\\\",\\n        \\\"exit\\\",\\n        \\\"whileInView\\\",\\n        \\\"whileFocus\\\",\\n        \\\"whileDrag\\\",\\n    ],\\n    exit: [\\\"exit\\\"],\\n    drag: [\\\"drag\\\", \\\"dragControls\\\"],\\n    focus: [\\\"whileFocus\\\"],\\n    hover: [\\\"whileHover\\\", \\\"onHoverStart\\\", \\\"onHoverEnd\\\"],\\n    tap: [\\\"whileTap\\\", \\\"onTap\\\", \\\"onTapStart\\\", \\\"onTapCancel\\\"],\\n    pan: [\\\"onPan\\\", \\\"onPanStart\\\", \\\"onPanSessionStart\\\", \\\"onPanEnd\\\"],\\n    inView: [\\\"whileInView\\\", \\\"onViewportEnter\\\", \\\"onViewportLeave\\\"],\\n    layout: [\\\"layout\\\", \\\"layoutId\\\"],\\n};\\nconst featureDefinitions = {};\\nfor (const key in featureProps) {\\n    featureDefinitions[key] = {\\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\\n    };\\n}\\n\\n// Does this device prefer reduced motion? Returns `null` server-side.\\nconst prefersReducedMotion = { current: null };\\nconst hasReducedMotionListener = { current: false };\\n\\nfunction initPrefersReducedMotion() {\\n    hasReducedMotionListener.current = true;\\n    if (!isBrowser)\\n        return;\\n    if (window.matchMedia) {\\n        const motionMediaQuery = window.matchMedia(\\\"(prefers-reduced-motion)\\\");\\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\\n        motionMediaQuery.addListener(setReducedMotionPreferences);\\n        setReducedMotionPreferences();\\n    }\\n    else {\\n        prefersReducedMotion.current = false;\\n    }\\n}\\n\\n/**\\n * A list of all ValueTypes\\n */\\nconst valueTypes = [...dimensionValueTypes, color, complex];\\n/**\\n * Tests a value against the list of ValueTypes\\n */\\nconst findValueType = (v) => valueTypes.find(testValueType(v));\\n\\nfunction updateMotionValuesFromProps(element, next, prev) {\\n    for (const key in next) {\\n        const nextValue = next[key];\\n        const prevValue = prev[key];\\n        if (isMotionValue(nextValue)) {\\n            /**\\n             * If this is a motion value found in props or style, we want to add it\\n             * to our visual element's motion value map.\\n             */\\n            element.addValue(key, nextValue);\\n            /**\\n             * Check the version of the incoming motion value with this version\\n             * and warn against mismatches.\\n             */\\n            if (process.env.NODE_ENV === \\\"development\\\") {\\n                warnOnce(nextValue.version === \\\"12.4.7\\\", `Attempting to mix Motion versions ${nextValue.version} with 12.4.7 may not work as expected.`);\\n            }\\n        }\\n        else if (isMotionValue(prevValue)) {\\n            /**\\n             * If we're swapping from a motion value to a static value,\\n             * create a new motion value from that\\n             */\\n            element.addValue(key, motionValue(nextValue, { owner: element }));\\n        }\\n        else if (prevValue !== nextValue) {\\n            /**\\n             * If this is a flat value that has changed, update the motion value\\n             * or create one if it doesn't exist. We only want to do this if we're\\n             * not handling the value with our animation state.\\n             */\\n            if (element.hasValue(key)) {\\n                const existingValue = element.getValue(key);\\n                if (existingValue.liveStyle === true) {\\n                    existingValue.jump(nextValue);\\n                }\\n                else if (!existingValue.hasAnimated) {\\n                    existingValue.set(nextValue);\\n                }\\n            }\\n            else {\\n                const latestValue = element.getStaticValue(key);\\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\\n            }\\n        }\\n    }\\n    // Handle removed values\\n    for (const key in prev) {\\n        if (next[key] === undefined)\\n            element.removeValue(key);\\n    }\\n    return next;\\n}\\n\\nconst propEventHandlers = [\\n    \\\"AnimationStart\\\",\\n    \\\"AnimationComplete\\\",\\n    \\\"Update\\\",\\n    \\\"BeforeLayoutMeasure\\\",\\n    \\\"LayoutMeasure\\\",\\n    \\\"LayoutAnimationStart\\\",\\n    \\\"LayoutAnimationComplete\\\",\\n];\\n/**\\n * A VisualElement is an imperative abstraction around UI elements such as\\n * HTMLElement, SVGElement, Three.Object3D etc.\\n */\\nclass VisualElement {\\n    /**\\n     * This method takes React props and returns found MotionValues. For example, HTML\\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\\n     *\\n     * This isn't an abstract method as it needs calling in the constructor, but it is\\n     * intended to be one.\\n     */\\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\\n        return {};\\n    }\\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\\n        /**\\n         * A reference to the current underlying Instance, e.g. a HTMLElement\\n         * or Three.Mesh etc.\\n         */\\n        this.current = null;\\n        /**\\n         * A set containing references to this VisualElement's children.\\n         */\\n        this.children = new Set();\\n        /**\\n         * Determine what role this visual element should take in the variant tree.\\n         */\\n        this.isVariantNode = false;\\n        this.isControllingVariants = false;\\n        /**\\n         * Decides whether this VisualElement should animate in reduced motion\\n         * mode.\\n         *\\n         * TODO: This is currently set on every individual VisualElement but feels\\n         * like it could be set globally.\\n         */\\n        this.shouldReduceMotion = null;\\n        /**\\n         * A map of all motion values attached to this visual element. Motion\\n         * values are source of truth for any given animated value. A motion\\n         * value might be provided externally by the component via props.\\n         */\\n        this.values = new Map();\\n        this.KeyframeResolver = KeyframeResolver;\\n        /**\\n         * Cleanup functions for active features (hover/tap/exit etc)\\n         */\\n        this.features = {};\\n        /**\\n         * A map of every subscription that binds the provided or generated\\n         * motion values onChange listeners to this visual element.\\n         */\\n        this.valueSubscriptions = new Map();\\n        /**\\n         * A reference to the previously-provided motion values as returned\\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\\n         * if any motion values need to be removed after props are updated.\\n         */\\n        this.prevMotionValues = {};\\n        /**\\n         * An object containing a SubscriptionManager for each active event.\\n         */\\n        this.events = {};\\n        /**\\n         * An object containing an unsubscribe function for each prop event subscription.\\n         * For example, every \\\"Update\\\" event can have multiple subscribers via\\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\\n         */\\n        this.propEventSubscriptions = {};\\n        this.notifyUpdate = () => this.notify(\\\"Update\\\", this.latestValues);\\n        this.render = () => {\\n            if (!this.current)\\n                return;\\n            this.triggerBuild();\\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\\n        };\\n        this.renderScheduledAt = 0.0;\\n        this.scheduleRender = () => {\\n            const now = time.now();\\n            if (this.renderScheduledAt < now) {\\n                this.renderScheduledAt = now;\\n                frame.render(this.render, false, true);\\n            }\\n        };\\n        const { latestValues, renderState, onUpdate } = visualState;\\n        this.onUpdate = onUpdate;\\n        this.latestValues = latestValues;\\n        this.baseTarget = { ...latestValues };\\n        this.initialValues = props.initial ? { ...latestValues } : {};\\n        this.renderState = renderState;\\n        this.parent = parent;\\n        this.props = props;\\n        this.presenceContext = presenceContext;\\n        this.depth = parent ? parent.depth + 1 : 0;\\n        this.reducedMotionConfig = reducedMotionConfig;\\n        this.options = options;\\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\\n        this.isControllingVariants = isControllingVariants(props);\\n        this.isVariantNode = isVariantNode(props);\\n        if (this.isVariantNode) {\\n            this.variantChildren = new Set();\\n        }\\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\\n        /**\\n         * Any motion values that are provided to the element when created\\n         * aren't yet bound to the element, as this would technically be impure.\\n         * However, we iterate through the motion values and set them to the\\n         * initial values for this component.\\n         *\\n         * TODO: This is impure and we should look at changing this to run on mount.\\n         * Doing so will break some tests but this isn't necessarily a breaking change,\\n         * more a reflection of the test.\\n         */\\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\\n        for (const key in initialMotionValues) {\\n            const value = initialMotionValues[key];\\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\\n                value.set(latestValues[key], false);\\n            }\\n        }\\n    }\\n    mount(instance) {\\n        this.current = instance;\\n        visualElementStore.set(instance, this);\\n        if (this.projection && !this.projection.instance) {\\n            this.projection.mount(instance);\\n        }\\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\\n        }\\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\\n        if (!hasReducedMotionListener.current) {\\n            initPrefersReducedMotion();\\n        }\\n        this.shouldReduceMotion =\\n            this.reducedMotionConfig === \\\"never\\\"\\n                ? false\\n                : this.reducedMotionConfig === \\\"always\\\"\\n                    ? true\\n                    : prefersReducedMotion.current;\\n        if (process.env.NODE_ENV !== \\\"production\\\") {\\n            warnOnce(this.shouldReduceMotion !== true, \\\"You have Reduced Motion enabled on your device. Animations may not appear as expected.\\\");\\n        }\\n        if (this.parent)\\n            this.parent.children.add(this);\\n        this.update(this.props, this.presenceContext);\\n    }\\n    unmount() {\\n        this.projection && this.projection.unmount();\\n        cancelFrame(this.notifyUpdate);\\n        cancelFrame(this.render);\\n        this.valueSubscriptions.forEach((remove) => remove());\\n        this.valueSubscriptions.clear();\\n        this.removeFromVariantTree && this.removeFromVariantTree();\\n        this.parent && this.parent.children.delete(this);\\n        for (const key in this.events) {\\n            this.events[key].clear();\\n        }\\n        for (const key in this.features) {\\n            const feature = this.features[key];\\n            if (feature) {\\n                feature.unmount();\\n                feature.isMounted = false;\\n            }\\n        }\\n        this.current = null;\\n    }\\n    bindToMotionValue(key, value) {\\n        if (this.valueSubscriptions.has(key)) {\\n            this.valueSubscriptions.get(key)();\\n        }\\n        const valueIsTransform = transformProps.has(key);\\n        if (valueIsTransform && this.onBindTransform) {\\n            this.onBindTransform();\\n        }\\n        const removeOnChange = value.on(\\\"change\\\", (latestValue) => {\\n            this.latestValues[key] = latestValue;\\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\\n            if (valueIsTransform && this.projection) {\\n                this.projection.isTransformDirty = true;\\n            }\\n        });\\n        const removeOnRenderRequest = value.on(\\\"renderRequest\\\", this.scheduleRender);\\n        let removeSyncCheck;\\n        if (window.MotionCheckAppearSync) {\\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\\n        }\\n        this.valueSubscriptions.set(key, () => {\\n            removeOnChange();\\n            removeOnRenderRequest();\\n            if (removeSyncCheck)\\n                removeSyncCheck();\\n            if (value.owner)\\n                value.stop();\\n        });\\n    }\\n    sortNodePosition(other) {\\n        /**\\n         * If these nodes aren't even of the same type we can't compare their depth.\\n         */\\n        if (!this.current ||\\n            !this.sortInstanceNodePosition ||\\n            this.type !== other.type) {\\n            return 0;\\n        }\\n        return this.sortInstanceNodePosition(this.current, other.current);\\n    }\\n    updateFeatures() {\\n        let key = \\\"animation\\\";\\n        for (key in featureDefinitions) {\\n            const featureDefinition = featureDefinitions[key];\\n            if (!featureDefinition)\\n                continue;\\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\\n            /**\\n             * If this feature is enabled but not active, make a new instance.\\n             */\\n            if (!this.features[key] &&\\n                FeatureConstructor &&\\n                isEnabled(this.props)) {\\n                this.features[key] = new FeatureConstructor(this);\\n            }\\n            /**\\n             * If we have a feature, mount or update it.\\n             */\\n            if (this.features[key]) {\\n                const feature = this.features[key];\\n                if (feature.isMounted) {\\n                    feature.update();\\n                }\\n                else {\\n                    feature.mount();\\n                    feature.isMounted = true;\\n                }\\n            }\\n        }\\n    }\\n    triggerBuild() {\\n        this.build(this.renderState, this.latestValues, this.props);\\n    }\\n    /**\\n     * Measure the current viewport box with or without transforms.\\n     * Only measures axis-aligned boxes, rotate and skew must be manually\\n     * removed with a re-render to work.\\n     */\\n    measureViewportBox() {\\n        return this.current\\n            ? this.measureInstanceViewportBox(this.current, this.props)\\n            : createBox();\\n    }\\n    getStaticValue(key) {\\n        return this.latestValues[key];\\n    }\\n    setStaticValue(key, value) {\\n        this.latestValues[key] = value;\\n    }\\n    /**\\n     * Update the provided props. Ensure any newly-added motion values are\\n     * added to our map, old ones removed, and listeners updated.\\n     */\\n    update(props, presenceContext) {\\n        if (props.transformTemplate || this.props.transformTemplate) {\\n            this.scheduleRender();\\n        }\\n        this.prevProps = this.props;\\n        this.props = props;\\n        this.prevPresenceContext = this.presenceContext;\\n        this.presenceContext = presenceContext;\\n        /**\\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\\n         */\\n        for (let i = 0; i < propEventHandlers.length; i++) {\\n            const key = propEventHandlers[i];\\n            if (this.propEventSubscriptions[key]) {\\n                this.propEventSubscriptions[key]();\\n                delete this.propEventSubscriptions[key];\\n            }\\n            const listenerName = (\\\"on\\\" + key);\\n            const listener = props[listenerName];\\n            if (listener) {\\n                this.propEventSubscriptions[key] = this.on(key, listener);\\n            }\\n        }\\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\\n        if (this.handleChildMotionValue) {\\n            this.handleChildMotionValue();\\n        }\\n        this.onUpdate && this.onUpdate(this);\\n    }\\n    getProps() {\\n        return this.props;\\n    }\\n    /**\\n     * Returns the variant definition with a given name.\\n     */\\n    getVariant(name) {\\n        return this.props.variants ? this.props.variants[name] : undefined;\\n    }\\n    /**\\n     * Returns the defined default transition on this component.\\n     */\\n    getDefaultTransition() {\\n        return this.props.transition;\\n    }\\n    getTransformPagePoint() {\\n        return this.props.transformPagePoint;\\n    }\\n    getClosestVariantNode() {\\n        return this.isVariantNode\\n            ? this\\n            : this.parent\\n                ? this.parent.getClosestVariantNode()\\n                : undefined;\\n    }\\n    /**\\n     * Add a child visual element to our set of children.\\n     */\\n    addVariantChild(child) {\\n        const closestVariantNode = this.getClosestVariantNode();\\n        if (closestVariantNode) {\\n            closestVariantNode.variantChildren &&\\n                closestVariantNode.variantChildren.add(child);\\n            return () => closestVariantNode.variantChildren.delete(child);\\n        }\\n    }\\n    /**\\n     * Add a motion value and bind it to this visual element.\\n     */\\n    addValue(key, value) {\\n        // Remove existing value if it exists\\n        const existingValue = this.values.get(key);\\n        if (value !== existingValue) {\\n            if (existingValue)\\n                this.removeValue(key);\\n            this.bindToMotionValue(key, value);\\n            this.values.set(key, value);\\n            this.latestValues[key] = value.get();\\n        }\\n    }\\n    /**\\n     * Remove a motion value and unbind any active subscriptions.\\n     */\\n    removeValue(key) {\\n        this.values.delete(key);\\n        const unsubscribe = this.valueSubscriptions.get(key);\\n        if (unsubscribe) {\\n            unsubscribe();\\n            this.valueSubscriptions.delete(key);\\n        }\\n        delete this.latestValues[key];\\n        this.removeValueFromRenderState(key, this.renderState);\\n    }\\n    /**\\n     * Check whether we have a motion value for this key\\n     */\\n    hasValue(key) {\\n        return this.values.has(key);\\n    }\\n    getValue(key, defaultValue) {\\n        if (this.props.values && this.props.values[key]) {\\n            return this.props.values[key];\\n        }\\n        let value = this.values.get(key);\\n        if (value === undefined && defaultValue !== undefined) {\\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\\n            this.addValue(key, value);\\n        }\\n        return value;\\n    }\\n    /**\\n     * If we're trying to animate to a previously unencountered value,\\n     * we need to check for it in our state and as a last resort read it\\n     * directly from the instance (which might have performance implications).\\n     */\\n    readValue(key, target) {\\n        var _a;\\n        let value = this.latestValues[key] !== undefined || !this.current\\n            ? this.latestValues[key]\\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\\n        if (value !== undefined && value !== null) {\\n            if (typeof value === \\\"string\\\" &&\\n                (isNumericalString(value) || isZeroValueString(value))) {\\n                // If this is a number read as a string, ie \\\"0\\\" or \\\"200\\\", convert it to a number\\n                value = parseFloat(value);\\n            }\\n            else if (!findValueType(value) && complex.test(target)) {\\n                value = getAnimatableNone(key, target);\\n            }\\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\\n        }\\n        return isMotionValue(value) ? value.get() : value;\\n    }\\n    /**\\n     * Set the base target to later animate back to. This is currently\\n     * only hydrated on creation and when we first read a value.\\n     */\\n    setBaseTarget(key, value) {\\n        this.baseTarget[key] = value;\\n    }\\n    /**\\n     * Find the base target for a value thats been removed from all animation\\n     * props.\\n     */\\n    getBaseTarget(key) {\\n        var _a;\\n        const { initial } = this.props;\\n        let valueFromInitial;\\n        if (typeof initial === \\\"string\\\" || typeof initial === \\\"object\\\") {\\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\\n            if (variant) {\\n                valueFromInitial = variant[key];\\n            }\\n        }\\n        /**\\n         * If this value still exists in the current initial variant, read that.\\n         */\\n        if (initial && valueFromInitial !== undefined) {\\n            return valueFromInitial;\\n        }\\n        /**\\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\\n         * so we can read the value from an alternative source, try that.\\n         */\\n        const target = this.getBaseTargetFromProps(this.props, key);\\n        if (target !== undefined && !isMotionValue(target))\\n            return target;\\n        /**\\n         * If the value was initially defined on initial, but it doesn't any more,\\n         * return undefined. Otherwise return the value as initially read from the DOM.\\n         */\\n        return this.initialValues[key] !== undefined &&\\n            valueFromInitial === undefined\\n            ? undefined\\n            : this.baseTarget[key];\\n    }\\n    on(eventName, callback) {\\n        if (!this.events[eventName]) {\\n            this.events[eventName] = new SubscriptionManager();\\n        }\\n        return this.events[eventName].add(callback);\\n    }\\n    notify(eventName, ...args) {\\n        if (this.events[eventName]) {\\n            this.events[eventName].notify(...args);\\n        }\\n    }\\n}\\n\\nclass DOMVisualElement extends VisualElement {\\n    constructor() {\\n        super(...arguments);\\n        this.KeyframeResolver = DOMKeyframesResolver;\\n    }\\n    sortInstanceNodePosition(a, b) {\\n        /**\\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\\n         * to true if b preceeds a.\\n         */\\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\\n    }\\n    getBaseTargetFromProps(props, key) {\\n        return props.style\\n            ? props.style[key]\\n            : undefined;\\n    }\\n    removeValueFromRenderState(key, { vars, style }) {\\n        delete vars[key];\\n        delete style[key];\\n    }\\n    handleChildMotionValue() {\\n        if (this.childSubscription) {\\n            this.childSubscription();\\n            delete this.childSubscription;\\n        }\\n        const { children } = this.props;\\n        if (isMotionValue(children)) {\\n            this.childSubscription = children.on(\\\"change\\\", (latest) => {\\n                if (this.current) {\\n                    this.current.textContent = `${latest}`;\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n/**\\n * Provided a value and a ValueType, returns the value as that value type.\\n */\\nconst getValueAsType = (value, type) => {\\n    return type && typeof value === \\\"number\\\"\\n        ? type.transform(value)\\n        : value;\\n};\\n\\nconst translateAlias = {\\n    x: \\\"translateX\\\",\\n    y: \\\"translateY\\\",\\n    z: \\\"translateZ\\\",\\n    transformPerspective: \\\"perspective\\\",\\n};\\nconst numTransforms = transformPropOrder.length;\\n/**\\n * Build a CSS transform style from individual x/y/scale etc properties.\\n *\\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\\n * providing a transformTemplate function.\\n */\\nfunction buildTransform(latestValues, transform, transformTemplate) {\\n    // The transform string we're going to build into.\\n    let transformString = \\\"\\\";\\n    let transformIsDefault = true;\\n    /**\\n     * Loop over all possible transforms in order, adding the ones that\\n     * are present to the transform string.\\n     */\\n    for (let i = 0; i < numTransforms; i++) {\\n        const key = transformPropOrder[i];\\n        const value = latestValues[key];\\n        if (value === undefined)\\n            continue;\\n        let valueIsDefault = true;\\n        if (typeof value === \\\"number\\\") {\\n            valueIsDefault = value === (key.startsWith(\\\"scale\\\") ? 1 : 0);\\n        }\\n        else {\\n            valueIsDefault = parseFloat(value) === 0;\\n        }\\n        if (!valueIsDefault || transformTemplate) {\\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\\n            if (!valueIsDefault) {\\n                transformIsDefault = false;\\n                const transformName = translateAlias[key] || key;\\n                transformString += `${transformName}(${valueAsType}) `;\\n            }\\n            if (transformTemplate) {\\n                transform[key] = valueAsType;\\n            }\\n        }\\n    }\\n    transformString = transformString.trim();\\n    // If we have a custom `transform` template, pass our transform values and\\n    // generated transformString to that before returning\\n    if (transformTemplate) {\\n        transformString = transformTemplate(transform, transformIsDefault ? \\\"\\\" : transformString);\\n    }\\n    else if (transformIsDefault) {\\n        transformString = \\\"none\\\";\\n    }\\n    return transformString;\\n}\\n\\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\\n    const { style, vars, transformOrigin } = state;\\n    // Track whether we encounter any transform or transformOrigin values.\\n    let hasTransform = false;\\n    let hasTransformOrigin = false;\\n    /**\\n     * Loop over all our latest animated values and decide whether to handle them\\n     * as a style or CSS variable.\\n     *\\n     * Transforms and transform origins are kept separately for further processing.\\n     */\\n    for (const key in latestValues) {\\n        const value = latestValues[key];\\n        if (transformProps.has(key)) {\\n            // If this is a transform, flag to enable further transform processing\\n            hasTransform = true;\\n            continue;\\n        }\\n        else if (isCSSVariableName(key)) {\\n            vars[key] = value;\\n            continue;\\n        }\\n        else {\\n            // Convert the value to its default value type, ie 0 -> \\\"0px\\\"\\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\\n            if (key.startsWith(\\\"origin\\\")) {\\n                // If this is a transform origin, flag and enable further transform-origin processing\\n                hasTransformOrigin = true;\\n                transformOrigin[key] =\\n                    valueAsType;\\n            }\\n            else {\\n                style[key] = valueAsType;\\n            }\\n        }\\n    }\\n    if (!latestValues.transform) {\\n        if (hasTransform || transformTemplate) {\\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\\n        }\\n        else if (style.transform) {\\n            /**\\n             * If we have previously created a transform but currently don't have any,\\n             * reset transform style to none.\\n             */\\n            style.transform = \\\"none\\\";\\n        }\\n    }\\n    /**\\n     * Build a transformOrigin style. Uses the same defaults as the browser for\\n     * undefined origins.\\n     */\\n    if (hasTransformOrigin) {\\n        const { originX = \\\"50%\\\", originY = \\\"50%\\\", originZ = 0, } = transformOrigin;\\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\\n    }\\n}\\n\\nconst dashKeys = {\\n    offset: \\\"stroke-dashoffset\\\",\\n    array: \\\"stroke-dasharray\\\",\\n};\\nconst camelKeys = {\\n    offset: \\\"strokeDashoffset\\\",\\n    array: \\\"strokeDasharray\\\",\\n};\\n/**\\n * Build SVG path properties. Uses the path's measured length to convert\\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\\n * and stroke-dasharray attributes.\\n *\\n * This function is mutative to reduce per-frame GC.\\n */\\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\\n    // Normalise path length by setting SVG attribute pathLength to 1\\n    attrs.pathLength = 1;\\n    // We use dash case when setting attributes directly to the DOM node and camel case\\n    // when defining props on a React component.\\n    const keys = useDashCase ? dashKeys : camelKeys;\\n    // Build the dash offset\\n    attrs[keys.offset] = px.transform(-offset);\\n    // Build the dash array\\n    const pathLength = px.transform(length);\\n    const pathSpacing = px.transform(spacing);\\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\\n}\\n\\nfunction calcOrigin$1(origin, offset, size) {\\n    return typeof origin === \\\"string\\\"\\n        ? origin\\n        : px.transform(offset + size * origin);\\n}\\n/**\\n * The SVG transform origin defaults are different to CSS and is less intuitive,\\n * so we use the measured dimensions of the SVG to reconcile these.\\n */\\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\\n    const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\\n    const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\\n    return `${pxOriginX} ${pxOriginY}`;\\n}\\n\\n/**\\n * Build SVG visual attrbutes, like cx and style.transform\\n */\\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \\n// This is object creation, which we try to avoid per-frame.\\n...latest }, isSVGTag, transformTemplate) {\\n    buildHTMLStyles(state, latest, transformTemplate);\\n    /**\\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\\n     * as normal HTML tags.\\n     */\\n    if (isSVGTag) {\\n        if (state.style.viewBox) {\\n            state.attrs.viewBox = state.style.viewBox;\\n        }\\n        return;\\n    }\\n    state.attrs = state.style;\\n    state.style = {};\\n    const { attrs, style, dimensions } = state;\\n    /**\\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\\n     * and copy it into style.\\n     */\\n    if (attrs.transform) {\\n        if (dimensions)\\n            style.transform = attrs.transform;\\n        delete attrs.transform;\\n    }\\n    // Parse transformOrigin\\n    if (dimensions &&\\n        (originX !== undefined || originY !== undefined || style.transform)) {\\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\\n    }\\n    // Render attrX/attrY/attrScale as attributes\\n    if (attrX !== undefined)\\n        attrs.x = attrX;\\n    if (attrY !== undefined)\\n        attrs.y = attrY;\\n    if (attrScale !== undefined)\\n        attrs.scale = attrScale;\\n    // Build SVG path if one has been defined\\n    if (pathLength !== undefined) {\\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\\n    }\\n}\\n\\n/**\\n * A set of attribute names that are always read/written as camel case.\\n */\\nconst camelCaseAttributes = new Set([\\n    \\\"baseFrequency\\\",\\n    \\\"diffuseConstant\\\",\\n    \\\"kernelMatrix\\\",\\n    \\\"kernelUnitLength\\\",\\n    \\\"keySplines\\\",\\n    \\\"keyTimes\\\",\\n    \\\"limitingConeAngle\\\",\\n    \\\"markerHeight\\\",\\n    \\\"markerWidth\\\",\\n    \\\"numOctaves\\\",\\n    \\\"targetX\\\",\\n    \\\"targetY\\\",\\n    \\\"surfaceScale\\\",\\n    \\\"specularConstant\\\",\\n    \\\"specularExponent\\\",\\n    \\\"stdDeviation\\\",\\n    \\\"tableValues\\\",\\n    \\\"viewBox\\\",\\n    \\\"gradientTransform\\\",\\n    \\\"pathLength\\\",\\n    \\\"startOffset\\\",\\n    \\\"textLength\\\",\\n    \\\"lengthAdjust\\\",\\n]);\\n\\nconst isSVGTag = (tag) => typeof tag === \\\"string\\\" && tag.toLowerCase() === \\\"svg\\\";\\n\\nfunction updateSVGDimensions(instance, renderState) {\\n    try {\\n        renderState.dimensions =\\n            typeof instance.getBBox === \\\"function\\\"\\n                ? instance.getBBox()\\n                : instance.getBoundingClientRect();\\n    }\\n    catch (e) {\\n        // Most likely trying to measure an unrendered element under Firefox\\n        renderState.dimensions = {\\n            x: 0,\\n            y: 0,\\n            width: 0,\\n            height: 0,\\n        };\\n    }\\n}\\n\\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\\n    // Loop over any CSS variables and assign those.\\n    for (const key in vars) {\\n        element.style.setProperty(key, vars[key]);\\n    }\\n}\\n\\nfunction renderSVG(element, renderState, _styleProp, projection) {\\n    renderHTML(element, renderState, undefined, projection);\\n    for (const key in renderState.attrs) {\\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\\n    }\\n}\\n\\nconst scaleCorrectors = {};\\nfunction addScaleCorrector(correctors) {\\n    for (const key in correctors) {\\n        scaleCorrectors[key] = correctors[key];\\n        if (isCSSVariableName(key)) {\\n            scaleCorrectors[key].isCSSVariable = true;\\n        }\\n    }\\n}\\n\\nfunction isForcedMotionValue(key, { layout, layoutId }) {\\n    return (transformProps.has(key) ||\\n        key.startsWith(\\\"origin\\\") ||\\n        ((layout || layoutId !== undefined) &&\\n            (!!scaleCorrectors[key] || key === \\\"opacity\\\")));\\n}\\n\\nfunction scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {\\n    var _a;\\n    const { style } = props;\\n    const newValues = {};\\n    for (const key in style) {\\n        if (isMotionValue(style[key]) ||\\n            (prevProps.style &&\\n                isMotionValue(prevProps.style[key])) ||\\n            isForcedMotionValue(key, props) ||\\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\\n            newValues[key] = style[key];\\n        }\\n    }\\n    return newValues;\\n}\\n\\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\\n    for (const key in props) {\\n        if (isMotionValue(props[key]) ||\\n            isMotionValue(prevProps[key])) {\\n            const targetKey = transformPropOrder.indexOf(key) !== -1\\n                ? \\\"attr\\\" + key.charAt(0).toUpperCase() + key.substring(1)\\n                : key;\\n            newValues[targetKey] = props[key];\\n        }\\n    }\\n    return newValues;\\n}\\n\\nclass SVGVisualElement extends DOMVisualElement {\\n    constructor() {\\n        super(...arguments);\\n        this.type = \\\"svg\\\";\\n        this.isSVGTag = false;\\n        this.measureInstanceViewportBox = createBox;\\n        this.updateDimensions = () => {\\n            if (this.current && !this.renderState.dimensions) {\\n                updateSVGDimensions(this.current, this.renderState);\\n            }\\n        };\\n    }\\n    getBaseTargetFromProps(props, key) {\\n        return props[key];\\n    }\\n    readValueFromInstance(instance, key) {\\n        if (transformProps.has(key)) {\\n            const defaultType = getDefaultValueType(key);\\n            return defaultType ? defaultType.default || 0 : 0;\\n        }\\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\\n        return instance.getAttribute(key);\\n    }\\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\\n    }\\n    onBindTransform() {\\n        if (this.current && !this.renderState.dimensions) {\\n            frame.postRender(this.updateDimensions);\\n        }\\n    }\\n    build(renderState, latestValues, props) {\\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\\n    }\\n    renderInstance(instance, renderState, styleProp, projection) {\\n        renderSVG(instance, renderState, styleProp, projection);\\n    }\\n    mount(instance) {\\n        this.isSVGTag = isSVGTag(instance.tagName);\\n        super.mount(instance);\\n    }\\n}\\n\\n/**\\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\\n * it's easier to consider each axis individually. This function returns a bounding box\\n * as a map of single-axis min/max values.\\n */\\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\\n    return {\\n        x: { min: left, max: right },\\n        y: { min: top, max: bottom },\\n    };\\n}\\nfunction convertBoxToBoundingBox({ x, y }) {\\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\\n}\\n/**\\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\\n * when measuring DOM elements and DOM event points.\\n */\\nfunction transformBoxPoints(point, transformPoint) {\\n    if (!transformPoint)\\n        return point;\\n    const topLeft = transformPoint({ x: point.left, y: point.top });\\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\\n    return {\\n        top: topLeft.y,\\n        left: topLeft.x,\\n        bottom: bottomRight.y,\\n        right: bottomRight.x,\\n    };\\n}\\n\\nfunction isIdentityScale(scale) {\\n    return scale === undefined || scale === 1;\\n}\\nfunction hasScale({ scale, scaleX, scaleY }) {\\n    return (!isIdentityScale(scale) ||\\n        !isIdentityScale(scaleX) ||\\n        !isIdentityScale(scaleY));\\n}\\nfunction hasTransform(values) {\\n    return (hasScale(values) ||\\n        has2DTranslate(values) ||\\n        values.z ||\\n        values.rotate ||\\n        values.rotateX ||\\n        values.rotateY ||\\n        values.skewX ||\\n        values.skewY);\\n}\\nfunction has2DTranslate(values) {\\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\\n}\\nfunction is2DTranslate(value) {\\n    return value && value !== \\\"0%\\\";\\n}\\n\\n/**\\n * Scales a point based on a factor and an originPoint\\n */\\nfunction scalePoint(point, scale, originPoint) {\\n    const distanceFromOrigin = point - originPoint;\\n    const scaled = scale * distanceFromOrigin;\\n    return originPoint + scaled;\\n}\\n/**\\n * Applies a translate/scale delta to a point\\n */\\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\\n    if (boxScale !== undefined) {\\n        point = scalePoint(point, boxScale, originPoint);\\n    }\\n    return scalePoint(point, scale, originPoint) + translate;\\n}\\n/**\\n * Applies a translate/scale delta to an axis\\n */\\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\\n}\\n/**\\n * Applies a translate/scale delta to a box\\n */\\nfunction applyBoxDelta(box, { x, y }) {\\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\\n}\\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\\n/**\\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\\n *\\n * This is the final nested loop within updateLayoutDelta for future refactoring\\n */\\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\\n    const treeLength = treePath.length;\\n    if (!treeLength)\\n        return;\\n    // Reset the treeScale\\n    treeScale.x = treeScale.y = 1;\\n    let node;\\n    let delta;\\n    for (let i = 0; i < treeLength; i++) {\\n        node = treePath[i];\\n        delta = node.projectionDelta;\\n        /**\\n         * TODO: Prefer to remove this, but currently we have motion components with\\n         * display: contents in Framer.\\n         */\\n        const { visualElement } = node.options;\\n        if (visualElement &&\\n            visualElement.props.style &&\\n            visualElement.props.style.display === \\\"contents\\\") {\\n            continue;\\n        }\\n        if (isSharedTransition &&\\n            node.options.layoutScroll &&\\n            node.scroll &&\\n            node !== node.root) {\\n            transformBox(box, {\\n                x: -node.scroll.offset.x,\\n                y: -node.scroll.offset.y,\\n            });\\n        }\\n        if (delta) {\\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\\n            treeScale.x *= delta.x.scale;\\n            treeScale.y *= delta.y.scale;\\n            // Apply each ancestor's calculated delta into this component's recorded layout box\\n            applyBoxDelta(box, delta);\\n        }\\n        if (isSharedTransition && hasTransform(node.latestValues)) {\\n            transformBox(box, node.latestValues);\\n        }\\n    }\\n    /**\\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\\n     * This will help reduce useless scales getting rendered.\\n     */\\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\\n        treeScale.x = 1.0;\\n    }\\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\\n        treeScale.y = 1.0;\\n    }\\n}\\nfunction translateAxis(axis, distance) {\\n    axis.min = axis.min + distance;\\n    axis.max = axis.max + distance;\\n}\\n/**\\n * Apply a transform to an axis from the latest resolved motion values.\\n * This function basically acts as a bridge between a flat motion value map\\n * and applyAxisDelta\\n */\\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\\n    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);\\n    // Apply the axis delta to the final axis\\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\\n}\\n/**\\n * Apply a transform to a box from the latest resolved motion values.\\n */\\nfunction transformBox(box, transform) {\\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\\n}\\n\\nfunction measureViewportBox(instance, transformPoint) {\\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\\n}\\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\\n    const viewportBox = measureViewportBox(element, transformPagePoint);\\n    const { scroll } = rootProjectionNode;\\n    if (scroll) {\\n        translateAxis(viewportBox.x, scroll.offset.x);\\n        translateAxis(viewportBox.y, scroll.offset.y);\\n    }\\n    return viewportBox;\\n}\\n\\nfunction getComputedStyle(element) {\\n    return window.getComputedStyle(element);\\n}\\nclass HTMLVisualElement extends DOMVisualElement {\\n    constructor() {\\n        super(...arguments);\\n        this.type = \\\"html\\\";\\n        this.renderInstance = renderHTML;\\n    }\\n    readValueFromInstance(instance, key) {\\n        if (transformProps.has(key)) {\\n            const defaultType = getDefaultValueType(key);\\n            return defaultType ? defaultType.default || 0 : 0;\\n        }\\n        else {\\n            const computedStyle = getComputedStyle(instance);\\n            const value = (isCSSVariableName(key)\\n                ? computedStyle.getPropertyValue(key)\\n                : computedStyle[key]) || 0;\\n            return typeof value === \\\"string\\\" ? value.trim() : value;\\n        }\\n    }\\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\\n        return measureViewportBox(instance, transformPagePoint);\\n    }\\n    build(renderState, latestValues, props) {\\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\\n    }\\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\\n        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\\n    }\\n}\\n\\n/**\\n * Timeout defined in ms\\n */\\nfunction delay(callback, timeout) {\\n    const start = time.now();\\n    const checkElapsed = ({ timestamp }) => {\\n        const elapsed = timestamp - start;\\n        if (elapsed >= timeout) {\\n            cancelFrame(checkElapsed);\\n            callback(elapsed - timeout);\\n        }\\n    };\\n    frame.read(checkElapsed, true);\\n    return () => cancelFrame(checkElapsed);\\n}\\n\\nconst distance = (a, b) => Math.abs(a - b);\\nfunction distance2D(a, b) {\\n    // Multi-dimensional\\n    const xDelta = distance(a.x, b.x);\\n    const yDelta = distance(a.y, b.y);\\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\\n}\\n\\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\\n\\nconst compareByDepth = (a, b) => a.depth - b.depth;\\n\\nclass FlatTree {\\n    constructor() {\\n        this.children = [];\\n        this.isDirty = false;\\n    }\\n    add(child) {\\n        addUniqueItem(this.children, child);\\n        this.isDirty = true;\\n    }\\n    remove(child) {\\n        removeItem(this.children, child);\\n        this.isDirty = true;\\n    }\\n    forEach(callback) {\\n        this.isDirty && this.children.sort(compareByDepth);\\n        this.isDirty = false;\\n        this.children.forEach(callback);\\n    }\\n}\\n\\nconst borders = [\\\"TopLeft\\\", \\\"TopRight\\\", \\\"BottomLeft\\\", \\\"BottomRight\\\"];\\nconst numBorders = borders.length;\\nconst asNumber = (value) => typeof value === \\\"string\\\" ? parseFloat(value) : value;\\nconst isPx = (value) => typeof value === \\\"number\\\" || px.test(value);\\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\\n    if (shouldCrossfadeOpacity) {\\n        target.opacity = mixNumber$1(0, \\n        // TODO Reinstate this if only child\\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\\n        target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\\n    }\\n    else if (isOnlyMember) {\\n        target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\\n    }\\n    /**\\n     * Mix border radius\\n     */\\n    for (let i = 0; i < numBorders; i++) {\\n        const borderLabel = `border${borders[i]}Radius`;\\n        let followRadius = getRadius(follow, borderLabel);\\n        let leadRadius = getRadius(lead, borderLabel);\\n        if (followRadius === undefined && leadRadius === undefined)\\n            continue;\\n        followRadius || (followRadius = 0);\\n        leadRadius || (leadRadius = 0);\\n        const canMix = followRadius === 0 ||\\n            leadRadius === 0 ||\\n            isPx(followRadius) === isPx(leadRadius);\\n        if (canMix) {\\n            target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);\\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\\n                target[borderLabel] += \\\"%\\\";\\n            }\\n        }\\n        else {\\n            target[borderLabel] = leadRadius;\\n        }\\n    }\\n    /**\\n     * Mix rotation\\n     */\\n    if (follow.rotate || lead.rotate) {\\n        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);\\n    }\\n}\\nfunction getRadius(values, radiusName) {\\n    return values[radiusName] !== undefined\\n        ? values[radiusName]\\n        : values.borderRadius;\\n}\\n// /**\\n//  * We only want to mix the background color if there's a follow element\\n//  * that we're not crossfading opacity between. For instance with switch\\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\\n//  * element being animated but also cuts down on the number of paints triggered\\n//  * for elements where opacity is doing that work for us.\\n//  */\\n// if (\\n//     !hasFollowElement &&\\n//     latestLeadValues.backgroundColor &&\\n//     latestFollowValues.backgroundColor\\n// ) {\\n//     /**\\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\\n//      * We could probably create a mixer that runs at the start of the animation but\\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\\n//      */\\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\\n//         latestFollowValues.backgroundColor as string,\\n//         latestLeadValues.backgroundColor as string\\n//     )(p)\\n// }\\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, motionUtils.noop);\\nfunction compress(min, max, easing) {\\n    return (p) => {\\n        // Could replace ifs with clamp\\n        if (p < min)\\n            return 0;\\n        if (p > max)\\n            return 1;\\n        return easing(motionUtils.progress(min, max, p));\\n    };\\n}\\n\\n/**\\n * Reset an axis to the provided origin box.\\n *\\n * This is a mutative operation.\\n */\\nfunction copyAxisInto(axis, originAxis) {\\n    axis.min = originAxis.min;\\n    axis.max = originAxis.max;\\n}\\n/**\\n * Reset a box to the provided origin box.\\n *\\n * This is a mutative operation.\\n */\\nfunction copyBoxInto(box, originBox) {\\n    copyAxisInto(box.x, originBox.x);\\n    copyAxisInto(box.y, originBox.y);\\n}\\n/**\\n * Reset a delta to the provided origin box.\\n *\\n * This is a mutative operation.\\n */\\nfunction copyAxisDeltaInto(delta, originDelta) {\\n    delta.translate = originDelta.translate;\\n    delta.scale = originDelta.scale;\\n    delta.originPoint = originDelta.originPoint;\\n    delta.origin = originDelta.origin;\\n}\\n\\n/**\\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\\n */\\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\\n    point -= translate;\\n    point = scalePoint(point, 1 / scale, originPoint);\\n    if (boxScale !== undefined) {\\n        point = scalePoint(point, 1 / boxScale, originPoint);\\n    }\\n    return point;\\n}\\n/**\\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\\n */\\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\\n    if (percent.test(translate)) {\\n        translate = parseFloat(translate);\\n        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);\\n        translate = relativeProgress - sourceAxis.min;\\n    }\\n    if (typeof translate !== \\\"number\\\")\\n        return;\\n    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);\\n    if (axis === originAxis)\\n        originPoint -= translate;\\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\\n}\\n/**\\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\\n * and acts as a bridge between motion values and removeAxisDelta\\n */\\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\\n}\\n/**\\n * The names of the motion values we want to apply as translation, scale and origin.\\n */\\nconst xKeys = [\\\"x\\\", \\\"scaleX\\\", \\\"originX\\\"];\\nconst yKeys = [\\\"y\\\", \\\"scaleY\\\", \\\"originY\\\"];\\n/**\\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\\n * and acts as a bridge between motion values and removeAxisDelta\\n */\\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\\n}\\n\\nfunction isAxisDeltaZero(delta) {\\n    return delta.translate === 0 && delta.scale === 1;\\n}\\nfunction isDeltaZero(delta) {\\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\\n}\\nfunction axisEquals(a, b) {\\n    return a.min === b.min && a.max === b.max;\\n}\\nfunction boxEquals(a, b) {\\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\\n}\\nfunction axisEqualsRounded(a, b) {\\n    return (Math.round(a.min) === Math.round(b.min) &&\\n        Math.round(a.max) === Math.round(b.max));\\n}\\nfunction boxEqualsRounded(a, b) {\\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\\n}\\nfunction aspectRatio(box) {\\n    return calcLength(box.x) / calcLength(box.y);\\n}\\nfunction axisDeltaEquals(a, b) {\\n    return (a.translate === b.translate &&\\n        a.scale === b.scale &&\\n        a.originPoint === b.originPoint);\\n}\\n\\nclass NodeStack {\\n    constructor() {\\n        this.members = [];\\n    }\\n    add(node) {\\n        addUniqueItem(this.members, node);\\n        node.scheduleRender();\\n    }\\n    remove(node) {\\n        removeItem(this.members, node);\\n        if (node === this.prevLead) {\\n            this.prevLead = undefined;\\n        }\\n        if (node === this.lead) {\\n            const prevLead = this.members[this.members.length - 1];\\n            if (prevLead) {\\n                this.promote(prevLead);\\n            }\\n        }\\n    }\\n    relegate(node) {\\n        const indexOfNode = this.members.findIndex((member) => node === member);\\n        if (indexOfNode === 0)\\n            return false;\\n        /**\\n         * Find the next projection node that is present\\n         */\\n        let prevLead;\\n        for (let i = indexOfNode; i >= 0; i--) {\\n            const member = this.members[i];\\n            if (member.isPresent !== false) {\\n                prevLead = member;\\n                break;\\n            }\\n        }\\n        if (prevLead) {\\n            this.promote(prevLead);\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n    promote(node, preserveFollowOpacity) {\\n        const prevLead = this.lead;\\n        if (node === prevLead)\\n            return;\\n        this.prevLead = prevLead;\\n        this.lead = node;\\n        node.show();\\n        if (prevLead) {\\n            prevLead.instance && prevLead.scheduleRender();\\n            node.scheduleRender();\\n            node.resumeFrom = prevLead;\\n            if (preserveFollowOpacity) {\\n                node.resumeFrom.preserveOpacity = true;\\n            }\\n            if (prevLead.snapshot) {\\n                node.snapshot = prevLead.snapshot;\\n                node.snapshot.latestValues =\\n                    prevLead.animationValues || prevLead.latestValues;\\n            }\\n            if (node.root && node.root.isUpdating) {\\n                node.isLayoutDirty = true;\\n            }\\n            const { crossfade } = node.options;\\n            if (crossfade === false) {\\n                prevLead.hide();\\n            }\\n            /**\\n             * TODO:\\n             *   - Test border radius when previous node was deleted\\n             *   - boxShadow mixing\\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\\n             * ---\\n             *   - Crossfade opacity of root nodes\\n             *   - layoutId changes after animation\\n             *   - layoutId changes mid animation\\n             */\\n        }\\n    }\\n    exitAnimationComplete() {\\n        this.members.forEach((node) => {\\n            const { options, resumingFrom } = node;\\n            options.onExitComplete && options.onExitComplete();\\n            if (resumingFrom) {\\n                resumingFrom.options.onExitComplete &&\\n                    resumingFrom.options.onExitComplete();\\n            }\\n        });\\n    }\\n    scheduleRender() {\\n        this.members.forEach((node) => {\\n            node.instance && node.scheduleRender(false);\\n        });\\n    }\\n    /**\\n     * Clear any leads that have been removed this render to prevent them from being\\n     * used in future animations and to prevent memory leaks\\n     */\\n    removeLeadSnapshot() {\\n        if (this.lead && this.lead.snapshot) {\\n            this.lead.snapshot = undefined;\\n        }\\n    }\\n}\\n\\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\\n    let transform = \\\"\\\";\\n    /**\\n     * The translations we use to calculate are always relative to the viewport coordinate space.\\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\\n     */\\n    const xTranslate = delta.x.translate / treeScale.x;\\n    const yTranslate = delta.y.translate / treeScale.y;\\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\\n    if (xTranslate || yTranslate || zTranslate) {\\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\\n    }\\n    /**\\n     * Apply scale correction for the tree transform.\\n     * This will apply scale to the screen-orientated axes.\\n     */\\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\\n    }\\n    if (latestTransform) {\\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\\n        if (transformPerspective)\\n            transform = `perspective(${transformPerspective}px) ${transform}`;\\n        if (rotate)\\n            transform += `rotate(${rotate}deg) `;\\n        if (rotateX)\\n            transform += `rotateX(${rotateX}deg) `;\\n        if (rotateY)\\n            transform += `rotateY(${rotateY}deg) `;\\n        if (skewX)\\n            transform += `skewX(${skewX}deg) `;\\n        if (skewY)\\n            transform += `skewY(${skewY}deg) `;\\n    }\\n    /**\\n     * Apply scale to match the size of the element to the size we want it.\\n     * This will apply scale to the element-orientated axes.\\n     */\\n    const elementScaleX = delta.x.scale * treeScale.x;\\n    const elementScaleY = delta.y.scale * treeScale.y;\\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\\n    }\\n    return transform || \\\"none\\\";\\n}\\n\\nfunction eachAxis(callback) {\\n    return [callback(\\\"x\\\"), callback(\\\"y\\\")];\\n}\\n\\n/**\\n * This should only ever be modified on the client otherwise it'll\\n * persist through server requests. If we need instanced states we\\n * could lazy-init via root.\\n */\\nconst globalProjectionState = {\\n    /**\\n     * Global flag as to whether the tree has animated since the last time\\n     * we resized the window\\n     */\\n    hasAnimatedSinceResize: true,\\n    /**\\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\\n     * update will be given a `data-projection-id` attribute.\\n     */\\n    hasEverUpdated: false,\\n};\\n\\nconst transformAxes = [\\\"\\\", \\\"X\\\", \\\"Y\\\", \\\"Z\\\"];\\nconst hiddenVisibility = { visibility: \\\"hidden\\\" };\\n/**\\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\\n * which has a noticeable difference in spring animations\\n */\\nconst animationTarget = 1000;\\nlet id = 0;\\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\\n    const { latestValues } = visualElement;\\n    // Record the distorting transform and then temporarily set it to 0\\n    if (latestValues[key]) {\\n        values[key] = latestValues[key];\\n        visualElement.setStaticValue(key, 0);\\n        if (sharedAnimationValues) {\\n            sharedAnimationValues[key] = 0;\\n        }\\n    }\\n}\\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\\n    projectionNode.hasCheckedOptimisedAppear = true;\\n    if (projectionNode.root === projectionNode)\\n        return;\\n    const { visualElement } = projectionNode.options;\\n    if (!visualElement)\\n        return;\\n    const appearId = getOptimisedAppearId(visualElement);\\n    if (window.MotionHasOptimisedAnimation(appearId, \\\"transform\\\")) {\\n        const { layout, layoutId } = projectionNode.options;\\n        window.MotionCancelOptimisedAnimation(appearId, \\\"transform\\\", frame, !(layout || layoutId));\\n    }\\n    const { parent } = projectionNode;\\n    if (parent && !parent.hasCheckedOptimisedAppear) {\\n        cancelTreeOptimisedTransformAnimations(parent);\\n    }\\n}\\nfunction createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\\n    return class ProjectionNode {\\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\\n            /**\\n             * A unique ID generated for every projection node.\\n             */\\n            this.id = id++;\\n            /**\\n             * An id that represents a unique session instigated by startUpdate.\\n             */\\n            this.animationId = 0;\\n            /**\\n             * A Set containing all this component's children. This is used to iterate\\n             * through the children.\\n             *\\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\\n             */\\n            this.children = new Set();\\n            /**\\n             * Options for the node. We use this to configure what kind of layout animations\\n             * we should perform (if any).\\n             */\\n            this.options = {};\\n            /**\\n             * We use this to detect when its safe to shut down part of a projection tree.\\n             * We have to keep projecting children for scale correction and relative projection\\n             * until all their parents stop performing layout animations.\\n             */\\n            this.isTreeAnimating = false;\\n            this.isAnimationBlocked = false;\\n            /**\\n             * Flag to true if we think this layout has been changed. We can't always know this,\\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\\n             * and if one node is dirtied, they all are.\\n             */\\n            this.isLayoutDirty = false;\\n            /**\\n             * Flag to true if we think the projection calculations for this node needs\\n             * recalculating as a result of an updated transform or layout animation.\\n             */\\n            this.isProjectionDirty = false;\\n            /**\\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\\n             */\\n            this.isSharedProjectionDirty = false;\\n            /**\\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\\n             * respected by shared nodes.\\n             */\\n            this.isTransformDirty = false;\\n            /**\\n             * Block layout updates for instant layout transitions throughout the tree.\\n             */\\n            this.updateManuallyBlocked = false;\\n            this.updateBlockedByResize = false;\\n            /**\\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\\n             * call.\\n             */\\n            this.isUpdating = false;\\n            /**\\n             * If this is an SVG element we currently disable projection transforms\\n             */\\n            this.isSVG = false;\\n            /**\\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\\n             * its projection styles.\\n             */\\n            this.needsReset = false;\\n            /**\\n             * Flags whether this node should have its transform reset prior to measuring.\\n             */\\n            this.shouldResetTransform = false;\\n            /**\\n             * Store whether this node has been checked for optimised appear animations. As\\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\\n             * this makes sure we only check each path once, stopping at nodes that\\n             * have already been checked.\\n             */\\n            this.hasCheckedOptimisedAppear = false;\\n            /**\\n             * An object representing the calculated contextual/accumulated/tree scale.\\n             * This will be used to scale calculcated projection transforms, as these are\\n             * calculated in screen-space but need to be scaled for elements to layoutly\\n             * make it to their calculated destinations.\\n             *\\n             * TODO: Lazy-init\\n             */\\n            this.treeScale = { x: 1, y: 1 };\\n            /**\\n             *\\n             */\\n            this.eventHandlers = new Map();\\n            this.hasTreeAnimated = false;\\n            // Note: Currently only running on root node\\n            this.updateScheduled = false;\\n            this.scheduleUpdate = () => this.update();\\n            this.projectionUpdateScheduled = false;\\n            this.checkUpdateFailed = () => {\\n                if (this.isUpdating) {\\n                    this.isUpdating = false;\\n                    this.clearAllSnapshots();\\n                }\\n            };\\n            /**\\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\\n             * the next step.\\n             */\\n            this.updateProjection = () => {\\n                this.projectionUpdateScheduled = false;\\n                this.nodes.forEach(propagateDirtyNodes);\\n                this.nodes.forEach(resolveTargetDelta);\\n                this.nodes.forEach(calcProjection);\\n                this.nodes.forEach(cleanDirtyNodes);\\n            };\\n            /**\\n             * Frame calculations\\n             */\\n            this.resolvedRelativeTargetAt = 0.0;\\n            this.hasProjected = false;\\n            this.isVisible = true;\\n            this.animationProgress = 0;\\n            /**\\n             * Shared layout\\n             */\\n            // TODO Only running on root node\\n            this.sharedNodes = new Map();\\n            this.latestValues = latestValues;\\n            this.root = parent ? parent.root || parent : this;\\n            this.path = parent ? [...parent.path, parent] : [];\\n            this.parent = parent;\\n            this.depth = parent ? parent.depth + 1 : 0;\\n            for (let i = 0; i < this.path.length; i++) {\\n                this.path[i].shouldResetTransform = true;\\n            }\\n            if (this.root === this)\\n                this.nodes = new FlatTree();\\n        }\\n        addEventListener(name, handler) {\\n            if (!this.eventHandlers.has(name)) {\\n                this.eventHandlers.set(name, new SubscriptionManager());\\n            }\\n            return this.eventHandlers.get(name).add(handler);\\n        }\\n        notifyListeners(name, ...args) {\\n            const subscriptionManager = this.eventHandlers.get(name);\\n            subscriptionManager && subscriptionManager.notify(...args);\\n        }\\n        hasListeners(name) {\\n            return this.eventHandlers.has(name);\\n        }\\n        /**\\n         * Lifecycles\\n         */\\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\\n            if (this.instance)\\n                return;\\n            this.isSVG = isSVGElement(instance);\\n            this.instance = instance;\\n            const { layoutId, layout, visualElement } = this.options;\\n            if (visualElement && !visualElement.current) {\\n                visualElement.mount(instance);\\n            }\\n            this.root.nodes.add(this);\\n            this.parent && this.parent.children.add(this);\\n            if (isLayoutDirty && (layout || layoutId)) {\\n                this.isLayoutDirty = true;\\n            }\\n            if (attachResizeListener) {\\n                let cancelDelay;\\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\\n                attachResizeListener(instance, () => {\\n                    this.root.updateBlockedByResize = true;\\n                    cancelDelay && cancelDelay();\\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\\n                    if (globalProjectionState.hasAnimatedSinceResize) {\\n                        globalProjectionState.hasAnimatedSinceResize = false;\\n                        this.nodes.forEach(finishAnimation);\\n                    }\\n                });\\n            }\\n            if (layoutId) {\\n                this.root.registerSharedNode(layoutId, this);\\n            }\\n            // Only register the handler if it requires layout animation\\n            if (this.options.animate !== false &&\\n                visualElement &&\\n                (layoutId || layout)) {\\n                this.addEventListener(\\\"didUpdate\\\", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\\n                    if (this.isTreeAnimationBlocked()) {\\n                        this.target = undefined;\\n                        this.relativeTarget = undefined;\\n                        return;\\n                    }\\n                    // TODO: Check here if an animation exists\\n                    const layoutTransition = this.options.transition ||\\n                        visualElement.getDefaultTransition() ||\\n                        defaultLayoutTransition;\\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\\n                    /**\\n                     * The target layout of the element might stay the same,\\n                     * but its position relative to its parent has changed.\\n                     */\\n                    const hasTargetChanged = !this.targetLayout ||\\n                        !boxEqualsRounded(this.targetLayout, newLayout);\\n                    /*\\n                     * Note: Disabled to fix relative animations always triggering new\\n                     * layout animations. If this causes further issues, we can try\\n                     * a different approach to detecting relative target changes.\\n                     */\\n                    // || hasRelativeLayoutChanged\\n                    /**\\n                     * If the layout hasn't seemed to have changed, it might be that the\\n                     * element is visually in the same place in the document but its position\\n                     * relative to its parent has indeed changed. So here we check for that.\\n                     */\\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\\n                    if (this.options.layoutRoot ||\\n                        this.resumeFrom ||\\n                        hasOnlyRelativeTargetChanged ||\\n                        (hasLayoutChanged &&\\n                            (hasTargetChanged || !this.currentAnimation))) {\\n                        if (this.resumeFrom) {\\n                            this.resumingFrom = this.resumeFrom;\\n                            this.resumingFrom.resumingFrom = undefined;\\n                        }\\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\\n                        const animationOptions = {\\n                            ...motionDom.getValueTransition(layoutTransition, \\\"layout\\\"),\\n                            onPlay: onLayoutAnimationStart,\\n                            onComplete: onLayoutAnimationComplete,\\n                        };\\n                        if (visualElement.shouldReduceMotion ||\\n                            this.options.layoutRoot) {\\n                            animationOptions.delay = 0;\\n                            animationOptions.type = false;\\n                        }\\n                        this.startAnimation(animationOptions);\\n                    }\\n                    else {\\n                        /**\\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\\n                         * finish it immediately. Otherwise it will be animating from a location\\n                         * that was probably never commited to screen and look like a jumpy box.\\n                         */\\n                        if (!hasLayoutChanged) {\\n                            finishAnimation(this);\\n                        }\\n                        if (this.isLead() && this.options.onExitComplete) {\\n                            this.options.onExitComplete();\\n                        }\\n                    }\\n                    this.targetLayout = newLayout;\\n                });\\n            }\\n        }\\n        unmount() {\\n            this.options.layoutId && this.willUpdate();\\n            this.root.nodes.remove(this);\\n            const stack = this.getStack();\\n            stack && stack.remove(this);\\n            this.parent && this.parent.children.delete(this);\\n            this.instance = undefined;\\n            cancelFrame(this.updateProjection);\\n        }\\n        // only on the root\\n        blockUpdate() {\\n            this.updateManuallyBlocked = true;\\n        }\\n        unblockUpdate() {\\n            this.updateManuallyBlocked = false;\\n        }\\n        isUpdateBlocked() {\\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\\n        }\\n        isTreeAnimationBlocked() {\\n            return (this.isAnimationBlocked ||\\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\\n                false);\\n        }\\n        // Note: currently only running on root node\\n        startUpdate() {\\n            if (this.isUpdateBlocked())\\n                return;\\n            this.isUpdating = true;\\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\\n            this.animationId++;\\n        }\\n        getTransformTemplate() {\\n            const { visualElement } = this.options;\\n            return visualElement && visualElement.getProps().transformTemplate;\\n        }\\n        willUpdate(shouldNotifyListeners = true) {\\n            this.root.hasTreeAnimated = true;\\n            if (this.root.isUpdateBlocked()) {\\n                this.options.onExitComplete && this.options.onExitComplete();\\n                return;\\n            }\\n            /**\\n             * If we're running optimised appear animations then these must be\\n             * cancelled before measuring the DOM. This is so we can measure\\n             * the true layout of the element rather than the WAAPI animation\\n             * which will be unaffected by the resetSkewAndRotate step.\\n             *\\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\\n             * between other snapshot reads which will cause unnecessary style recalculations.\\n             * This has to happen here though, as we don't yet know which nodes will need\\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\\n             * if a layout animation measurement is actually going to be affected by them.\\n             */\\n            if (window.MotionCancelOptimisedAnimation &&\\n                !this.hasCheckedOptimisedAppear) {\\n                cancelTreeOptimisedTransformAnimations(this);\\n            }\\n            !this.root.isUpdating && this.root.startUpdate();\\n            if (this.isLayoutDirty)\\n                return;\\n            this.isLayoutDirty = true;\\n            for (let i = 0; i < this.path.length; i++) {\\n                const node = this.path[i];\\n                node.shouldResetTransform = true;\\n                node.updateScroll(\\\"snapshot\\\");\\n                if (node.options.layoutRoot) {\\n                    node.willUpdate(false);\\n                }\\n            }\\n            const { layoutId, layout } = this.options;\\n            if (layoutId === undefined && !layout)\\n                return;\\n            const transformTemplate = this.getTransformTemplate();\\n            this.prevTransformTemplateValue = transformTemplate\\n                ? transformTemplate(this.latestValues, \\\"\\\")\\n                : undefined;\\n            this.updateSnapshot();\\n            shouldNotifyListeners && this.notifyListeners(\\\"willUpdate\\\");\\n        }\\n        update() {\\n            this.updateScheduled = false;\\n            const updateWasBlocked = this.isUpdateBlocked();\\n            // When doing an instant transition, we skip the layout update,\\n            // but should still clean up the measurements so that the next\\n            // snapshot could be taken correctly.\\n            if (updateWasBlocked) {\\n                this.unblockUpdate();\\n                this.clearAllSnapshots();\\n                this.nodes.forEach(clearMeasurements);\\n                return;\\n            }\\n            if (!this.isUpdating) {\\n                this.nodes.forEach(clearIsLayoutDirty);\\n            }\\n            this.isUpdating = false;\\n            /**\\n             * Write\\n             */\\n            this.nodes.forEach(resetTransformStyle);\\n            /**\\n             * Read ==================\\n             */\\n            // Update layout measurements of updated children\\n            this.nodes.forEach(updateLayout);\\n            /**\\n             * Write\\n             */\\n            // Notify listeners that the layout is updated\\n            this.nodes.forEach(notifyLayoutUpdate);\\n            this.clearAllSnapshots();\\n            /**\\n             * Manually flush any pending updates. Ideally\\n             * we could leave this to the following requestAnimationFrame but this seems\\n             * to leave a flash of incorrectly styled content.\\n             */\\n            const now = time.now();\\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\\n            frameData.timestamp = now;\\n            frameData.isProcessing = true;\\n            frameSteps.update.process(frameData);\\n            frameSteps.preRender.process(frameData);\\n            frameSteps.render.process(frameData);\\n            frameData.isProcessing = false;\\n        }\\n        didUpdate() {\\n            if (!this.updateScheduled) {\\n                this.updateScheduled = true;\\n                microtask.read(this.scheduleUpdate);\\n            }\\n        }\\n        clearAllSnapshots() {\\n            this.nodes.forEach(clearSnapshot);\\n            this.sharedNodes.forEach(removeLeadSnapshots);\\n        }\\n        scheduleUpdateProjection() {\\n            if (!this.projectionUpdateScheduled) {\\n                this.projectionUpdateScheduled = true;\\n                frame.preRender(this.updateProjection, false, true);\\n            }\\n        }\\n        scheduleCheckAfterUnmount() {\\n            /**\\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\\n             * we manually call didUpdate to give a chance to the siblings to animate.\\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\\n             */\\n            frame.postRender(() => {\\n                if (this.isLayoutDirty) {\\n                    this.root.didUpdate();\\n                }\\n                else {\\n                    this.root.checkUpdateFailed();\\n                }\\n            });\\n        }\\n        /**\\n         * Update measurements\\n         */\\n        updateSnapshot() {\\n            if (this.snapshot || !this.instance)\\n                return;\\n            this.snapshot = this.measure();\\n            if (this.snapshot &&\\n                !calcLength(this.snapshot.measuredBox.x) &&\\n                !calcLength(this.snapshot.measuredBox.y)) {\\n                this.snapshot = undefined;\\n            }\\n        }\\n        updateLayout() {\\n            if (!this.instance)\\n                return;\\n            // TODO: Incorporate into a forwarded scroll offset\\n            this.updateScroll();\\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\\n                !this.isLayoutDirty) {\\n                return;\\n            }\\n            /**\\n             * When a node is mounted, it simply resumes from the prevLead's\\n             * snapshot instead of taking a new one, but the ancestors scroll\\n             * might have updated while the prevLead is unmounted. We need to\\n             * update the scroll again to make sure the layout we measure is\\n             * up to date.\\n             */\\n            if (this.resumeFrom && !this.resumeFrom.instance) {\\n                for (let i = 0; i < this.path.length; i++) {\\n                    const node = this.path[i];\\n                    node.updateScroll();\\n                }\\n            }\\n            const prevLayout = this.layout;\\n            this.layout = this.measure(false);\\n            this.layoutCorrected = createBox();\\n            this.isLayoutDirty = false;\\n            this.projectionDelta = undefined;\\n            this.notifyListeners(\\\"measure\\\", this.layout.layoutBox);\\n            const { visualElement } = this.options;\\n            visualElement &&\\n                visualElement.notify(\\\"LayoutMeasure\\\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\\n        }\\n        updateScroll(phase = \\\"measure\\\") {\\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\\n            if (this.scroll &&\\n                this.scroll.animationId === this.root.animationId &&\\n                this.scroll.phase === phase) {\\n                needsMeasurement = false;\\n            }\\n            if (needsMeasurement) {\\n                const isRoot = checkIsScrollRoot(this.instance);\\n                this.scroll = {\\n                    animationId: this.root.animationId,\\n                    phase,\\n                    isRoot,\\n                    offset: measureScroll(this.instance),\\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\\n                };\\n            }\\n        }\\n        resetTransform() {\\n            if (!resetTransform)\\n                return;\\n            const isResetRequested = this.isLayoutDirty ||\\n                this.shouldResetTransform ||\\n                this.options.alwaysMeasureLayout;\\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\\n            const transformTemplate = this.getTransformTemplate();\\n            const transformTemplateValue = transformTemplate\\n                ? transformTemplate(this.latestValues, \\\"\\\")\\n                : undefined;\\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\\n            if (isResetRequested &&\\n                (hasProjection ||\\n                    hasTransform(this.latestValues) ||\\n                    transformTemplateHasChanged)) {\\n                resetTransform(this.instance, transformTemplateValue);\\n                this.shouldResetTransform = false;\\n                this.scheduleRender();\\n            }\\n        }\\n        measure(removeTransform = true) {\\n            const pageBox = this.measurePageBox();\\n            let layoutBox = this.removeElementScroll(pageBox);\\n            /**\\n             * Measurements taken during the pre-render stage\\n             * still have transforms applied so we remove them\\n             * via calculation.\\n             */\\n            if (removeTransform) {\\n                layoutBox = this.removeTransform(layoutBox);\\n            }\\n            roundBox(layoutBox);\\n            return {\\n                animationId: this.root.animationId,\\n                measuredBox: pageBox,\\n                layoutBox,\\n                latestValues: {},\\n                source: this.id,\\n            };\\n        }\\n        measurePageBox() {\\n            var _a;\\n            const { visualElement } = this.options;\\n            if (!visualElement)\\n                return createBox();\\n            const box = visualElement.measureViewportBox();\\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\\n            if (!wasInScrollRoot) {\\n                // Remove viewport scroll to give page-relative coordinates\\n                const { scroll } = this.root;\\n                if (scroll) {\\n                    translateAxis(box.x, scroll.offset.x);\\n                    translateAxis(box.y, scroll.offset.y);\\n                }\\n            }\\n            return box;\\n        }\\n        removeElementScroll(box) {\\n            var _a;\\n            const boxWithoutScroll = createBox();\\n            copyBoxInto(boxWithoutScroll, box);\\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\\n                return boxWithoutScroll;\\n            }\\n            /**\\n             * Performance TODO: Keep a cumulative scroll offset down the tree\\n             * rather than loop back up the path.\\n             */\\n            for (let i = 0; i < this.path.length; i++) {\\n                const node = this.path[i];\\n                const { scroll, options } = node;\\n                if (node !== this.root && scroll && options.layoutScroll) {\\n                    /**\\n                     * If this is a new scroll root, we want to remove all previous scrolls\\n                     * from the viewport box.\\n                     */\\n                    if (scroll.wasRoot) {\\n                        copyBoxInto(boxWithoutScroll, box);\\n                    }\\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\\n                }\\n            }\\n            return boxWithoutScroll;\\n        }\\n        applyTransform(box, transformOnly = false) {\\n            const withTransforms = createBox();\\n            copyBoxInto(withTransforms, box);\\n            for (let i = 0; i < this.path.length; i++) {\\n                const node = this.path[i];\\n                if (!transformOnly &&\\n                    node.options.layoutScroll &&\\n                    node.scroll &&\\n                    node !== node.root) {\\n                    transformBox(withTransforms, {\\n                        x: -node.scroll.offset.x,\\n                        y: -node.scroll.offset.y,\\n                    });\\n                }\\n                if (!hasTransform(node.latestValues))\\n                    continue;\\n                transformBox(withTransforms, node.latestValues);\\n            }\\n            if (hasTransform(this.latestValues)) {\\n                transformBox(withTransforms, this.latestValues);\\n            }\\n            return withTransforms;\\n        }\\n        removeTransform(box) {\\n            const boxWithoutTransform = createBox();\\n            copyBoxInto(boxWithoutTransform, box);\\n            for (let i = 0; i < this.path.length; i++) {\\n                const node = this.path[i];\\n                if (!node.instance)\\n                    continue;\\n                if (!hasTransform(node.latestValues))\\n                    continue;\\n                hasScale(node.latestValues) && node.updateSnapshot();\\n                const sourceBox = createBox();\\n                const nodeBox = node.measurePageBox();\\n                copyBoxInto(sourceBox, nodeBox);\\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\\n            }\\n            if (hasTransform(this.latestValues)) {\\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\\n            }\\n            return boxWithoutTransform;\\n        }\\n        setTargetDelta(delta) {\\n            this.targetDelta = delta;\\n            this.root.scheduleUpdateProjection();\\n            this.isProjectionDirty = true;\\n        }\\n        setOptions(options) {\\n            this.options = {\\n                ...this.options,\\n                ...options,\\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\\n            };\\n        }\\n        clearMeasurements() {\\n            this.scroll = undefined;\\n            this.layout = undefined;\\n            this.snapshot = undefined;\\n            this.prevTransformTemplateValue = undefined;\\n            this.targetDelta = undefined;\\n            this.target = undefined;\\n            this.isLayoutDirty = false;\\n        }\\n        forceRelativeParentToResolveTarget() {\\n            if (!this.relativeParent)\\n                return;\\n            /**\\n             * If the parent target isn't up-to-date, force it to update.\\n             * This is an unfortunate de-optimisation as it means any updating relative\\n             * projection will cause all the relative parents to recalculate back\\n             * up the tree.\\n             */\\n            if (this.relativeParent.resolvedRelativeTargetAt !==\\n                frameData.timestamp) {\\n                this.relativeParent.resolveTargetDelta(true);\\n            }\\n        }\\n        resolveTargetDelta(forceRecalculation = false) {\\n            var _a;\\n            /**\\n             * Once the dirty status of nodes has been spread through the tree, we also\\n             * need to check if we have a shared node of a different depth that has itself\\n             * been dirtied.\\n             */\\n            const lead = this.getLead();\\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\\n            /**\\n             * We don't use transform for this step of processing so we don't\\n             * need to check whether any nodes have changed transform.\\n             */\\n            const canSkip = !(forceRecalculation ||\\n                (isShared && this.isSharedProjectionDirty) ||\\n                this.isProjectionDirty ||\\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\\n                this.attemptToResolveRelativeTarget ||\\n                this.root.updateBlockedByResize);\\n            if (canSkip)\\n                return;\\n            const { layout, layoutId } = this.options;\\n            /**\\n             * If we have no layout, we can't perform projection, so early return\\n             */\\n            if (!this.layout || !(layout || layoutId))\\n                return;\\n            this.resolvedRelativeTargetAt = frameData.timestamp;\\n            /**\\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\\n             * a relativeParent. This will allow a component to perform scale correction\\n             * even if no animation has started.\\n             */\\n            if (!this.targetDelta && !this.relativeTarget) {\\n                const relativeParent = this.getClosestProjectingParent();\\n                if (relativeParent &&\\n                    relativeParent.layout &&\\n                    this.animationProgress !== 1) {\\n                    this.relativeParent = relativeParent;\\n                    this.forceRelativeParentToResolveTarget();\\n                    this.relativeTarget = createBox();\\n                    this.relativeTargetOrigin = createBox();\\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\\n                }\\n                else {\\n                    this.relativeParent = this.relativeTarget = undefined;\\n                }\\n            }\\n            /**\\n             * If we have no relative target or no target delta our target isn't valid\\n             * for this frame.\\n             */\\n            if (!this.relativeTarget && !this.targetDelta)\\n                return;\\n            /**\\n             * Lazy-init target data structure\\n             */\\n            if (!this.target) {\\n                this.target = createBox();\\n                this.targetWithTransforms = createBox();\\n            }\\n            /**\\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\\n             */\\n            if (this.relativeTarget &&\\n                this.relativeTargetOrigin &&\\n                this.relativeParent &&\\n                this.relativeParent.target) {\\n                this.forceRelativeParentToResolveTarget();\\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\\n                /**\\n                 * If we've only got a targetDelta, resolve it into a target\\n                 */\\n            }\\n            else if (this.targetDelta) {\\n                if (Boolean(this.resumingFrom)) {\\n                    // TODO: This is creating a new object every frame\\n                    this.target = this.applyTransform(this.layout.layoutBox);\\n                }\\n                else {\\n                    copyBoxInto(this.target, this.layout.layoutBox);\\n                }\\n                applyBoxDelta(this.target, this.targetDelta);\\n            }\\n            else {\\n                /**\\n                 * If no target, use own layout as target\\n                 */\\n                copyBoxInto(this.target, this.layout.layoutBox);\\n            }\\n            /**\\n             * If we've been told to attempt to resolve a relative target, do so.\\n             */\\n            if (this.attemptToResolveRelativeTarget) {\\n                this.attemptToResolveRelativeTarget = false;\\n                const relativeParent = this.getClosestProjectingParent();\\n                if (relativeParent &&\\n                    Boolean(relativeParent.resumingFrom) ===\\n                        Boolean(this.resumingFrom) &&\\n                    !relativeParent.options.layoutScroll &&\\n                    relativeParent.target &&\\n                    this.animationProgress !== 1) {\\n                    this.relativeParent = relativeParent;\\n                    this.forceRelativeParentToResolveTarget();\\n                    this.relativeTarget = createBox();\\n                    this.relativeTargetOrigin = createBox();\\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\\n                }\\n                else {\\n                    this.relativeParent = this.relativeTarget = undefined;\\n                }\\n            }\\n        }\\n        getClosestProjectingParent() {\\n            if (!this.parent ||\\n                hasScale(this.parent.latestValues) ||\\n                has2DTranslate(this.parent.latestValues)) {\\n                return undefined;\\n            }\\n            if (this.parent.isProjecting()) {\\n                return this.parent;\\n            }\\n            else {\\n                return this.parent.getClosestProjectingParent();\\n            }\\n        }\\n        isProjecting() {\\n            return Boolean((this.relativeTarget ||\\n                this.targetDelta ||\\n                this.options.layoutRoot) &&\\n                this.layout);\\n        }\\n        calcProjection() {\\n            var _a;\\n            const lead = this.getLead();\\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\\n            let canSkip = true;\\n            /**\\n             * If this is a normal layout animation and neither this node nor its nearest projecting\\n             * is dirty then we can't skip.\\n             */\\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\\n                canSkip = false;\\n            }\\n            /**\\n             * If this is a shared layout animation and this node's shared projection is dirty then\\n             * we can't skip.\\n             */\\n            if (isShared &&\\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\\n                canSkip = false;\\n            }\\n            /**\\n             * If we have resolved the target this frame we must recalculate the\\n             * projection to ensure it visually represents the internal calculations.\\n             */\\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\\n                canSkip = false;\\n            }\\n            if (canSkip)\\n                return;\\n            const { layout, layoutId } = this.options;\\n            /**\\n             * If this section of the tree isn't animating we can\\n             * delete our target sources for the following frame.\\n             */\\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\\n                this.currentAnimation ||\\n                this.pendingAnimation);\\n            if (!this.isTreeAnimating) {\\n                this.targetDelta = this.relativeTarget = undefined;\\n            }\\n            if (!this.layout || !(layout || layoutId))\\n                return;\\n            /**\\n             * Reset the corrected box with the latest values from box, as we're then going\\n             * to perform mutative operations on it.\\n             */\\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\\n            /**\\n             * Record previous tree scales before updating.\\n             */\\n            const prevTreeScaleX = this.treeScale.x;\\n            const prevTreeScaleY = this.treeScale.y;\\n            /**\\n             * Apply all the parent deltas to this box to produce the corrected box. This\\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\\n             */\\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\\n            /**\\n             * If this layer needs to perform scale correction but doesn't have a target,\\n             * use the layout as the target.\\n             */\\n            if (lead.layout &&\\n                !lead.target &&\\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\\n                lead.target = lead.layout.layoutBox;\\n                lead.targetWithTransforms = createBox();\\n            }\\n            const { target } = lead;\\n            if (!target) {\\n                /**\\n                 * If we don't have a target to project into, but we were previously\\n                 * projecting, we want to remove the stored transform and schedule\\n                 * a render to ensure the elements reflect the removed transform.\\n                 */\\n                if (this.prevProjectionDelta) {\\n                    this.createProjectionDeltas();\\n                    this.scheduleRender();\\n                }\\n                return;\\n            }\\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\\n                this.createProjectionDeltas();\\n            }\\n            else {\\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\\n            }\\n            /**\\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\\n             * to allow people to choose whether these styles are corrected based on just the\\n             * layout reprojection or the final bounding box.\\n             */\\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\\n            if (this.treeScale.x !== prevTreeScaleX ||\\n                this.treeScale.y !== prevTreeScaleY ||\\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\\n                this.hasProjected = true;\\n                this.scheduleRender();\\n                this.notifyListeners(\\\"projectionUpdate\\\", target);\\n            }\\n        }\\n        hide() {\\n            this.isVisible = false;\\n            // TODO: Schedule render\\n        }\\n        show() {\\n            this.isVisible = true;\\n            // TODO: Schedule render\\n        }\\n        scheduleRender(notifyAll = true) {\\n            var _a;\\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\\n            if (notifyAll) {\\n                const stack = this.getStack();\\n                stack && stack.scheduleRender();\\n            }\\n            if (this.resumingFrom && !this.resumingFrom.instance) {\\n                this.resumingFrom = undefined;\\n            }\\n        }\\n        createProjectionDeltas() {\\n            this.prevProjectionDelta = createDelta();\\n            this.projectionDelta = createDelta();\\n            this.projectionDeltaWithTransform = createDelta();\\n        }\\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\\n            const snapshot = this.snapshot;\\n            const snapshotLatestValues = snapshot\\n                ? snapshot.latestValues\\n                : {};\\n            const mixedValues = { ...this.latestValues };\\n            const targetDelta = createDelta();\\n            if (!this.relativeParent ||\\n                !this.relativeParent.options.layoutRoot) {\\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\\n            }\\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\\n            const relativeLayout = createBox();\\n            const snapshotSource = snapshot ? snapshot.source : undefined;\\n            const layoutSource = this.layout ? this.layout.source : undefined;\\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\\n            const stack = this.getStack();\\n            const isOnlyMember = !stack || stack.members.length <= 1;\\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\\n                !isOnlyMember &&\\n                this.options.crossfade === true &&\\n                !this.path.some(hasOpacityCrossfade));\\n            this.animationProgress = 0;\\n            let prevRelativeTarget;\\n            this.mixTargetDelta = (latest) => {\\n                const progress = latest / 1000;\\n                mixAxisDelta(targetDelta.x, delta.x, progress);\\n                mixAxisDelta(targetDelta.y, delta.y, progress);\\n                this.setTargetDelta(targetDelta);\\n                if (this.relativeTarget &&\\n                    this.relativeTargetOrigin &&\\n                    this.layout &&\\n                    this.relativeParent &&\\n                    this.relativeParent.layout) {\\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\\n                    /**\\n                     * If this is an unchanged relative target we can consider the\\n                     * projection not dirty.\\n                     */\\n                    if (prevRelativeTarget &&\\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\\n                        this.isProjectionDirty = false;\\n                    }\\n                    if (!prevRelativeTarget)\\n                        prevRelativeTarget = createBox();\\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\\n                }\\n                if (isSharedLayoutAnimation) {\\n                    this.animationValues = mixedValues;\\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\\n                }\\n                this.root.scheduleUpdateProjection();\\n                this.scheduleRender();\\n                this.animationProgress = progress;\\n            };\\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\\n        }\\n        startAnimation(options) {\\n            this.notifyListeners(\\\"animationStart\\\");\\n            this.currentAnimation && this.currentAnimation.stop();\\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\\n                this.resumingFrom.currentAnimation.stop();\\n            }\\n            if (this.pendingAnimation) {\\n                cancelFrame(this.pendingAnimation);\\n                this.pendingAnimation = undefined;\\n            }\\n            /**\\n             * Start the animation in the next frame to have a frame with progress 0,\\n             * where the target is the same as when the animation started, so we can\\n             * calculate the relative positions correctly for instant transitions.\\n             */\\n            this.pendingAnimation = frame.update(() => {\\n                globalProjectionState.hasAnimatedSinceResize = true;\\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\\n                    ...options,\\n                    onUpdate: (latest) => {\\n                        this.mixTargetDelta(latest);\\n                        options.onUpdate && options.onUpdate(latest);\\n                    },\\n                    onStop: () => {\\n                    },\\n                    onComplete: () => {\\n                        options.onComplete && options.onComplete();\\n                        this.completeAnimation();\\n                    },\\n                });\\n                if (this.resumingFrom) {\\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\\n                }\\n                this.pendingAnimation = undefined;\\n            });\\n        }\\n        completeAnimation() {\\n            if (this.resumingFrom) {\\n                this.resumingFrom.currentAnimation = undefined;\\n                this.resumingFrom.preserveOpacity = undefined;\\n            }\\n            const stack = this.getStack();\\n            stack && stack.exitAnimationComplete();\\n            this.resumingFrom =\\n                this.currentAnimation =\\n                    this.animationValues =\\n                        undefined;\\n            this.notifyListeners(\\\"animationComplete\\\");\\n        }\\n        finishAnimation() {\\n            if (this.currentAnimation) {\\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\\n                this.currentAnimation.stop();\\n            }\\n            this.completeAnimation();\\n        }\\n        applyTransformsToTarget() {\\n            const lead = this.getLead();\\n            let { targetWithTransforms, target, layout, latestValues } = lead;\\n            if (!targetWithTransforms || !target || !layout)\\n                return;\\n            /**\\n             * If we're only animating position, and this element isn't the lead element,\\n             * then instead of projecting into the lead box we instead want to calculate\\n             * a new target that aligns the two boxes but maintains the layout shape.\\n             */\\n            if (this !== lead &&\\n                this.layout &&\\n                layout &&\\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\\n                target = this.target || createBox();\\n                const xLength = calcLength(this.layout.layoutBox.x);\\n                target.x.min = lead.target.x.min;\\n                target.x.max = target.x.min + xLength;\\n                const yLength = calcLength(this.layout.layoutBox.y);\\n                target.y.min = lead.target.y.min;\\n                target.y.max = target.y.min + yLength;\\n            }\\n            copyBoxInto(targetWithTransforms, target);\\n            /**\\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\\n             * This is the final box that we will then project into by calculating a transform delta and\\n             * applying it to the corrected box.\\n             */\\n            transformBox(targetWithTransforms, latestValues);\\n            /**\\n             * Update the delta between the corrected box and the final target box, after\\n             * user-set transforms are applied to it. This will be used by the renderer to\\n             * create a transform style that will reproject the element from its layout layout\\n             * into the desired bounding box.\\n             */\\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\\n        }\\n        registerSharedNode(layoutId, node) {\\n            if (!this.sharedNodes.has(layoutId)) {\\n                this.sharedNodes.set(layoutId, new NodeStack());\\n            }\\n            const stack = this.sharedNodes.get(layoutId);\\n            stack.add(node);\\n            const config = node.options.initialPromotionConfig;\\n            node.promote({\\n                transition: config ? config.transition : undefined,\\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\\n                    ? config.shouldPreserveFollowOpacity(node)\\n                    : undefined,\\n            });\\n        }\\n        isLead() {\\n            const stack = this.getStack();\\n            return stack ? stack.lead === this : true;\\n        }\\n        getLead() {\\n            var _a;\\n            const { layoutId } = this.options;\\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\\n        }\\n        getPrevLead() {\\n            var _a;\\n            const { layoutId } = this.options;\\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\\n        }\\n        getStack() {\\n            const { layoutId } = this.options;\\n            if (layoutId)\\n                return this.root.sharedNodes.get(layoutId);\\n        }\\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\\n            const stack = this.getStack();\\n            if (stack)\\n                stack.promote(this, preserveFollowOpacity);\\n            if (needsReset) {\\n                this.projectionDelta = undefined;\\n                this.needsReset = true;\\n            }\\n            if (transition)\\n                this.setOptions({ transition });\\n        }\\n        relegate() {\\n            const stack = this.getStack();\\n            if (stack) {\\n                return stack.relegate(this);\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        resetSkewAndRotation() {\\n            const { visualElement } = this.options;\\n            if (!visualElement)\\n                return;\\n            // If there's no detected skew or rotation values, we can early return without a forced render.\\n            let hasDistortingTransform = false;\\n            /**\\n             * An unrolled check for rotation values. Most elements don't have any rotation and\\n             * skipping the nested loop and new object creation is 50% faster.\\n             */\\n            const { latestValues } = visualElement;\\n            if (latestValues.z ||\\n                latestValues.rotate ||\\n                latestValues.rotateX ||\\n                latestValues.rotateY ||\\n                latestValues.rotateZ ||\\n                latestValues.skewX ||\\n                latestValues.skewY) {\\n                hasDistortingTransform = true;\\n            }\\n            // If there's no distorting values, we don't need to do any more.\\n            if (!hasDistortingTransform)\\n                return;\\n            const resetValues = {};\\n            if (latestValues.z) {\\n                resetDistortingTransform(\\\"z\\\", visualElement, resetValues, this.animationValues);\\n            }\\n            // Check the skew and rotate value of all axes and reset to 0\\n            for (let i = 0; i < transformAxes.length; i++) {\\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\\n            }\\n            // Force a render of this element to apply the transform with all skews and rotations\\n            // set to 0.\\n            visualElement.render();\\n            // Put back all the values we reset\\n            for (const key in resetValues) {\\n                visualElement.setStaticValue(key, resetValues[key]);\\n                if (this.animationValues) {\\n                    this.animationValues[key] = resetValues[key];\\n                }\\n            }\\n            // Schedule a render for the next frame. This ensures we won't visually\\n            // see the element with the reset rotate value applied.\\n            visualElement.scheduleRender();\\n        }\\n        getProjectionStyles(styleProp) {\\n            var _a, _b;\\n            if (!this.instance || this.isSVG)\\n                return undefined;\\n            if (!this.isVisible) {\\n                return hiddenVisibility;\\n            }\\n            const styles = {\\n                visibility: \\\"\\\",\\n            };\\n            const transformTemplate = this.getTransformTemplate();\\n            if (this.needsReset) {\\n                this.needsReset = false;\\n                styles.opacity = \\\"\\\";\\n                styles.pointerEvents =\\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \\\"\\\";\\n                styles.transform = transformTemplate\\n                    ? transformTemplate(this.latestValues, \\\"\\\")\\n                    : \\\"none\\\";\\n                return styles;\\n            }\\n            const lead = this.getLead();\\n            if (!this.projectionDelta || !this.layout || !lead.target) {\\n                const emptyStyles = {};\\n                if (this.options.layoutId) {\\n                    emptyStyles.opacity =\\n                        this.latestValues.opacity !== undefined\\n                            ? this.latestValues.opacity\\n                            : 1;\\n                    emptyStyles.pointerEvents =\\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \\\"\\\";\\n                }\\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\\n                    emptyStyles.transform = transformTemplate\\n                        ? transformTemplate({}, \\\"\\\")\\n                        : \\\"none\\\";\\n                    this.hasProjected = false;\\n                }\\n                return emptyStyles;\\n            }\\n            const valuesToRender = lead.animationValues || lead.latestValues;\\n            this.applyTransformsToTarget();\\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\\n            if (transformTemplate) {\\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\\n            }\\n            const { x, y } = this.projectionDelta;\\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\\n            if (lead.animationValues) {\\n                /**\\n                 * If the lead component is animating, assign this either the entering/leaving\\n                 * opacity\\n                 */\\n                styles.opacity =\\n                    lead === this\\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\\n                        : this.preserveOpacity\\n                            ? this.latestValues.opacity\\n                            : valuesToRender.opacityExit;\\n            }\\n            else {\\n                /**\\n                 * Or we're not animating at all, set the lead component to its layout\\n                 * opacity and other components to hidden.\\n                 */\\n                styles.opacity =\\n                    lead === this\\n                        ? valuesToRender.opacity !== undefined\\n                            ? valuesToRender.opacity\\n                            : \\\"\\\"\\n                        : valuesToRender.opacityExit !== undefined\\n                            ? valuesToRender.opacityExit\\n                            : 0;\\n            }\\n            /**\\n             * Apply scale correction\\n             */\\n            for (const key in scaleCorrectors) {\\n                if (valuesToRender[key] === undefined)\\n                    continue;\\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\\n                /**\\n                 * Only apply scale correction to the value if we have an\\n                 * active projection transform. Otherwise these values become\\n                 * vulnerable to distortion if the element changes size without\\n                 * a corresponding layout animation.\\n                 */\\n                const corrected = styles.transform === \\\"none\\\"\\n                    ? valuesToRender[key]\\n                    : correct(valuesToRender[key], lead);\\n                if (applyTo) {\\n                    const num = applyTo.length;\\n                    for (let i = 0; i < num; i++) {\\n                        styles[applyTo[i]] = corrected;\\n                    }\\n                }\\n                else {\\n                    // If this is a CSS variable, set it directly on the instance.\\n                    // Replacing this function from creating styles to setting them\\n                    // would be a good place to remove per frame object creation\\n                    if (isCSSVariable) {\\n                        this.options.visualElement.renderState.vars[key] = corrected;\\n                    }\\n                    else {\\n                        styles[key] = corrected;\\n                    }\\n                }\\n            }\\n            /**\\n             * Disable pointer events on follow components. This is to ensure\\n             * that if a follow component covers a lead component it doesn't block\\n             * pointer events on the lead.\\n             */\\n            if (this.options.layoutId) {\\n                styles.pointerEvents =\\n                    lead === this\\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \\\"\\\"\\n                        : \\\"none\\\";\\n            }\\n            return styles;\\n        }\\n        clearSnapshot() {\\n            this.resumeFrom = this.snapshot = undefined;\\n        }\\n        // Only run on root\\n        resetTree() {\\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\\n            this.root.nodes.forEach(clearMeasurements);\\n            this.root.sharedNodes.clear();\\n        }\\n    };\\n}\\nfunction updateLayout(node) {\\n    node.updateLayout();\\n}\\nfunction notifyLayoutUpdate(node) {\\n    var _a;\\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\\n    if (node.isLead() &&\\n        node.layout &&\\n        snapshot &&\\n        node.hasListeners(\\\"didUpdate\\\")) {\\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\\n        const { animationType } = node.options;\\n        const isShared = snapshot.source !== node.layout.source;\\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\\n        // animations for instance if layout=\\\"size\\\" and an element has only changed position\\n        if (animationType === \\\"size\\\") {\\n            eachAxis((axis) => {\\n                const axisSnapshot = isShared\\n                    ? snapshot.measuredBox[axis]\\n                    : snapshot.layoutBox[axis];\\n                const length = calcLength(axisSnapshot);\\n                axisSnapshot.min = layout[axis].min;\\n                axisSnapshot.max = axisSnapshot.min + length;\\n            });\\n        }\\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\\n            eachAxis((axis) => {\\n                const axisSnapshot = isShared\\n                    ? snapshot.measuredBox[axis]\\n                    : snapshot.layoutBox[axis];\\n                const length = calcLength(layout[axis]);\\n                axisSnapshot.max = axisSnapshot.min + length;\\n                /**\\n                 * Ensure relative target gets resized and rerendererd\\n                 */\\n                if (node.relativeTarget && !node.currentAnimation) {\\n                    node.isProjectionDirty = true;\\n                    node.relativeTarget[axis].max =\\n                        node.relativeTarget[axis].min + length;\\n                }\\n            });\\n        }\\n        const layoutDelta = createDelta();\\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\\n        const visualDelta = createDelta();\\n        if (isShared) {\\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\\n        }\\n        else {\\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\\n        }\\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\\n        let hasRelativeLayoutChanged = false;\\n        if (!node.resumeFrom) {\\n            const relativeParent = node.getClosestProjectingParent();\\n            /**\\n             * If the relativeParent is itself resuming from a different element then\\n             * the relative snapshot is not relavent\\n             */\\n            if (relativeParent && !relativeParent.resumeFrom) {\\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\\n                if (parentSnapshot && parentLayout) {\\n                    const relativeSnapshot = createBox();\\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\\n                    const relativeLayout = createBox();\\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\\n                        hasRelativeLayoutChanged = true;\\n                    }\\n                    if (relativeParent.options.layoutRoot) {\\n                        node.relativeTarget = relativeLayout;\\n                        node.relativeTargetOrigin = relativeSnapshot;\\n                        node.relativeParent = relativeParent;\\n                    }\\n                }\\n            }\\n        }\\n        node.notifyListeners(\\\"didUpdate\\\", {\\n            layout,\\n            snapshot,\\n            delta: visualDelta,\\n            layoutDelta,\\n            hasLayoutChanged,\\n            hasRelativeLayoutChanged,\\n        });\\n    }\\n    else if (node.isLead()) {\\n        const { onExitComplete } = node.options;\\n        onExitComplete && onExitComplete();\\n    }\\n    /**\\n     * Clearing transition\\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\\n     * and why we need it at all\\n     */\\n    node.options.transition = undefined;\\n}\\nfunction propagateDirtyNodes(node) {\\n    if (!node.parent)\\n        return;\\n    /**\\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\\n     * no performance impact but it will allow the next child that *is* projecting\\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\\n     * correcting.\\n     */\\n    if (!node.isProjecting()) {\\n        node.isProjectionDirty = node.parent.isProjectionDirty;\\n    }\\n    /**\\n     * Propagate isSharedProjectionDirty and isTransformDirty\\n     * throughout the whole tree. A future revision can take another look at\\n     * this but for safety we still recalcualte shared nodes.\\n     */\\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\\n        node.parent.isProjectionDirty ||\\n        node.parent.isSharedProjectionDirty));\\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\\n}\\nfunction cleanDirtyNodes(node) {\\n    node.isProjectionDirty =\\n        node.isSharedProjectionDirty =\\n            node.isTransformDirty =\\n                false;\\n}\\nfunction clearSnapshot(node) {\\n    node.clearSnapshot();\\n}\\nfunction clearMeasurements(node) {\\n    node.clearMeasurements();\\n}\\nfunction clearIsLayoutDirty(node) {\\n    node.isLayoutDirty = false;\\n}\\nfunction resetTransformStyle(node) {\\n    const { visualElement } = node.options;\\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\\n        visualElement.notify(\\\"BeforeLayoutMeasure\\\");\\n    }\\n    node.resetTransform();\\n}\\nfunction finishAnimation(node) {\\n    node.finishAnimation();\\n    node.targetDelta = node.relativeTarget = node.target = undefined;\\n    node.isProjectionDirty = true;\\n}\\nfunction resolveTargetDelta(node) {\\n    node.resolveTargetDelta();\\n}\\nfunction calcProjection(node) {\\n    node.calcProjection();\\n}\\nfunction resetSkewAndRotation(node) {\\n    node.resetSkewAndRotation();\\n}\\nfunction removeLeadSnapshots(stack) {\\n    stack.removeLeadSnapshot();\\n}\\nfunction mixAxisDelta(output, delta, p) {\\n    output.translate = mixNumber$1(delta.translate, 0, p);\\n    output.scale = mixNumber$1(delta.scale, 1, p);\\n    output.origin = delta.origin;\\n    output.originPoint = delta.originPoint;\\n}\\nfunction mixAxis(output, from, to, p) {\\n    output.min = mixNumber$1(from.min, to.min, p);\\n    output.max = mixNumber$1(from.max, to.max, p);\\n}\\nfunction mixBox(output, from, to, p) {\\n    mixAxis(output.x, from.x, to.x, p);\\n    mixAxis(output.y, from.y, to.y, p);\\n}\\nfunction hasOpacityCrossfade(node) {\\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\\n}\\nconst defaultLayoutTransition = {\\n    duration: 0.45,\\n    ease: [0.4, 0, 0.1, 1],\\n};\\nconst userAgentContains = (string) => typeof navigator !== \\\"undefined\\\" &&\\n    navigator.userAgent &&\\n    navigator.userAgent.toLowerCase().includes(string);\\n/**\\n * Measured bounding boxes must be rounded in Safari and\\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\\n * can appear to jump.\\n */\\nconst roundPoint = userAgentContains(\\\"applewebkit/\\\") && !userAgentContains(\\\"chrome/\\\")\\n    ? Math.round\\n    : motionUtils.noop;\\nfunction roundAxis(axis) {\\n    // Round to the nearest .5 pixels to support subpixel layouts\\n    axis.min = roundPoint(axis.min);\\n    axis.max = roundPoint(axis.max);\\n}\\nfunction roundBox(box) {\\n    roundAxis(box.x);\\n    roundAxis(box.y);\\n}\\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\\n    return (animationType === \\\"position\\\" ||\\n        (animationType === \\\"preserve-aspect\\\" &&\\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\\n}\\nfunction checkNodeWasScrollRoot(node) {\\n    var _a;\\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\\n}\\n\\nconst DocumentProjectionNode = createProjectionNode$1({\\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \\\"resize\\\", notify),\\n    measureScroll: () => ({\\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\\n        y: document.documentElement.scrollTop || document.body.scrollTop,\\n    }),\\n    checkIsScrollRoot: () => true,\\n});\\n\\nconst rootProjectionNode = {\\n    current: undefined,\\n};\\nconst HTMLProjectionNode = createProjectionNode$1({\\n    measureScroll: (instance) => ({\\n        x: instance.scrollLeft,\\n        y: instance.scrollTop,\\n    }),\\n    defaultParent: () => {\\n        if (!rootProjectionNode.current) {\\n            const documentNode = new DocumentProjectionNode({});\\n            documentNode.mount(window);\\n            documentNode.setOptions({ layoutScroll: true });\\n            rootProjectionNode.current = documentNode;\\n        }\\n        return rootProjectionNode.current;\\n    },\\n    resetTransform: (instance, value) => {\\n        instance.style.transform = value !== undefined ? value : \\\"none\\\";\\n    },\\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \\\"fixed\\\"),\\n});\\n\\nfunction pixelsToPercent(pixels, axis) {\\n    if (axis.max === axis.min)\\n        return 0;\\n    return (pixels / (axis.max - axis.min)) * 100;\\n}\\n/**\\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\\n * borderRadius in both states. If we animate between the two in pixels that will trigger\\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\\n */\\nconst correctBorderRadius = {\\n    correct: (latest, node) => {\\n        if (!node.target)\\n            return latest;\\n        /**\\n         * If latest is a string, if it's a percentage we can return immediately as it's\\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\\n         */\\n        if (typeof latest === \\\"string\\\") {\\n            if (px.test(latest)) {\\n                latest = parseFloat(latest);\\n            }\\n            else {\\n                return latest;\\n            }\\n        }\\n        /**\\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\\n         * pixel value as a percentage of each axis\\n         */\\n        const x = pixelsToPercent(latest, node.target.x);\\n        const y = pixelsToPercent(latest, node.target.y);\\n        return `${x}% ${y}%`;\\n    },\\n};\\n\\nconst correctBoxShadow = {\\n    correct: (latest, { treeScale, projectionDelta }) => {\\n        const original = latest;\\n        const shadow = complex.parse(latest);\\n        // TODO: Doesn't support multiple shadows\\n        if (shadow.length > 5)\\n            return original;\\n        const template = complex.createTransformer(latest);\\n        const offset = typeof shadow[0] !== \\\"number\\\" ? 1 : 0;\\n        // Calculate the overall context scale\\n        const xScale = projectionDelta.x.scale * treeScale.x;\\n        const yScale = projectionDelta.y.scale * treeScale.y;\\n        shadow[0 + offset] /= xScale;\\n        shadow[1 + offset] /= yScale;\\n        /**\\n         * Ideally we'd correct x and y scales individually, but because blur and\\n         * spread apply to both we have to take a scale average and apply that instead.\\n         * We could potentially improve the outcome of this by incorporating the ratio between\\n         * the two scales.\\n         */\\n        const averageScale = mixNumber$1(xScale, yScale, 0.5);\\n        // Blur\\n        if (typeof shadow[2 + offset] === \\\"number\\\")\\n            shadow[2 + offset] /= averageScale;\\n        // Spread\\n        if (typeof shadow[3 + offset] === \\\"number\\\")\\n            shadow[3 + offset] /= averageScale;\\n        return template(shadow);\\n    },\\n};\\n\\nconst LazyContext = React.createContext({ strict: false });\\n\\nfunction loadFeatures(features) {\\n    for (const key in features) {\\n        featureDefinitions[key] = {\\n            ...featureDefinitions[key],\\n            ...features[key],\\n        };\\n    }\\n}\\n\\nfunction isRefObject(ref) {\\n    return (ref &&\\n        typeof ref === \\\"object\\\" &&\\n        Object.prototype.hasOwnProperty.call(ref, \\\"current\\\"));\\n}\\n\\n/**\\n * @internal\\n */\\nclass PanSession {\\n    constructor(event, handlers, { transformPagePoint, dragSnapToOrigin = false } = {}) {\\n        /**\\n         * @internal\\n         */\\n        this.startEvent = null;\\n        /**\\n         * @internal\\n         */\\n        this.lastMoveEvent = null;\\n        /**\\n         * @internal\\n         */\\n        this.lastMoveEventInfo = null;\\n        /**\\n         * @internal\\n         */\\n        this.handlers = {};\\n        this.updatePoint = () => {\\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\\n                return;\\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\\n            const isPanStarted = this.startEvent !== null;\\n            // Only start panning if the offset is larger than 3 pixels. If we make it\\n            // any larger than this we'll want to reset the pointer history\\n            // on the first update to avoid visual snapping to the cursoe.\\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\\n            if (!isPanStarted && !isDistancePastThreshold)\\n                return;\\n            const { point } = info;\\n            const { timestamp } = frameData;\\n            this.history.push({ ...point, timestamp });\\n            const { onStart, onMove } = this.handlers;\\n            if (!isPanStarted) {\\n                onStart && onStart(this.lastMoveEvent, info);\\n                this.startEvent = this.lastMoveEvent;\\n            }\\n            onMove && onMove(this.lastMoveEvent, info);\\n        };\\n        this.handlePointerMove = (event, info) => {\\n            if (event.target instanceof Element &&\\n                event.target.hasPointerCapture &&\\n                event.pointerId !== undefined) {\\n                try {\\n                    if (!event.target.hasPointerCapture(event.pointerId)) {\\n                        return;\\n                    }\\n                }\\n                catch (e) { }\\n            }\\n            this.lastMoveEvent = event;\\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\\n            // Throttle mouse move event to once per frame\\n            frame.update(this.updatePoint, true);\\n        };\\n        this.handlePointerUp = (event, info) => {\\n            motionDom.capturePointer(event, \\\"release\\\");\\n            this.end();\\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\\n            if (this.dragSnapToOrigin)\\n                resumeAnimation && resumeAnimation();\\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\\n                return;\\n            const panInfo = getPanInfo(event.type === \\\"pointercancel\\\" ||\\n                event.type === \\\"lostpointercapture\\\"\\n                ? this.lastMoveEventInfo\\n                : transformPoint(info, this.transformPagePoint), this.history);\\n            if (this.startEvent && onEnd) {\\n                onEnd(event, panInfo);\\n            }\\n            onSessionEnd && onSessionEnd(event, panInfo);\\n        };\\n        // If we have more than one touch, don't start detecting this gesture\\n        if (!motionDom.isPrimaryPointer(event))\\n            return;\\n        this.dragSnapToOrigin = dragSnapToOrigin;\\n        this.handlers = handlers;\\n        this.transformPagePoint = transformPagePoint;\\n        const info = extractEventInfo(event);\\n        const initialInfo = transformPoint(info, this.transformPagePoint);\\n        const { point } = initialInfo;\\n        const { timestamp } = frameData;\\n        this.history = [{ ...point, timestamp }];\\n        const { onSessionStart } = handlers;\\n        onSessionStart &&\\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\\n        motionDom.capturePointer(event, \\\"set\\\");\\n        this.removeListeners = pipe(addPointerEvent(event.currentTarget, \\\"pointermove\\\", this.handlePointerMove), addPointerEvent(event.currentTarget, \\\"pointerup\\\", this.handlePointerUp), addPointerEvent(event.currentTarget, \\\"pointercancel\\\", this.handlePointerUp), addPointerEvent(event.currentTarget, \\\"lostpointercapture\\\", this.handlePointerUp));\\n    }\\n    updateHandlers(handlers) {\\n        this.handlers = handlers;\\n    }\\n    end() {\\n        this.removeListeners && this.removeListeners();\\n        cancelFrame(this.updatePoint);\\n    }\\n}\\nfunction transformPoint(info, transformPagePoint) {\\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\\n}\\nfunction subtractPoint(a, b) {\\n    return { x: a.x - b.x, y: a.y - b.y };\\n}\\nfunction getPanInfo({ point }, history) {\\n    return {\\n        point,\\n        delta: subtractPoint(point, lastDevicePoint(history)),\\n        offset: subtractPoint(point, startDevicePoint(history)),\\n        velocity: getVelocity(history, 0.1),\\n    };\\n}\\nfunction startDevicePoint(history) {\\n    return history[0];\\n}\\nfunction lastDevicePoint(history) {\\n    return history[history.length - 1];\\n}\\nfunction getVelocity(history, timeDelta) {\\n    if (history.length < 2) {\\n        return { x: 0, y: 0 };\\n    }\\n    let i = history.length - 1;\\n    let timestampedPoint = null;\\n    const lastPoint = lastDevicePoint(history);\\n    while (i >= 0) {\\n        timestampedPoint = history[i];\\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\\n            motionUtils.secondsToMilliseconds(timeDelta)) {\\n            break;\\n        }\\n        i--;\\n    }\\n    if (!timestampedPoint) {\\n        return { x: 0, y: 0 };\\n    }\\n    const time = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\\n    if (time === 0) {\\n        return { x: 0, y: 0 };\\n    }\\n    const currentVelocity = {\\n        x: (lastPoint.x - timestampedPoint.x) / time,\\n        y: (lastPoint.y - timestampedPoint.y) / time,\\n    };\\n    if (currentVelocity.x === Infinity) {\\n        currentVelocity.x = 0;\\n    }\\n    if (currentVelocity.y === Infinity) {\\n        currentVelocity.y = 0;\\n    }\\n    return currentVelocity;\\n}\\n\\n/**\\n * Apply constraints to a point. These constraints are both physical along an\\n * axis, and an elastic factor that determines how much to constrain the point\\n * by if it does lie outside the defined parameters.\\n */\\nfunction applyConstraints(point, { min, max }, elastic) {\\n    if (min !== undefined && point < min) {\\n        // If we have a min point defined, and this is outside of that, constrain\\n        point = elastic\\n            ? mixNumber$1(min, point, elastic.min)\\n            : Math.max(point, min);\\n    }\\n    else if (max !== undefined && point > max) {\\n        // If we have a max point defined, and this is outside of that, constrain\\n        point = elastic\\n            ? mixNumber$1(max, point, elastic.max)\\n            : Math.min(point, max);\\n    }\\n    return point;\\n}\\n/**\\n * Calculate constraints in terms of the viewport when defined relatively to the\\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\\n */\\nfunction calcRelativeAxisConstraints(axis, min, max) {\\n    return {\\n        min: min !== undefined ? axis.min + min : undefined,\\n        max: max !== undefined\\n            ? axis.max + max - (axis.max - axis.min)\\n            : undefined,\\n    };\\n}\\n/**\\n * Calculate constraints in terms of the viewport when\\n * defined relatively to the measured bounding box.\\n */\\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\\n    return {\\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\\n    };\\n}\\n/**\\n * Calculate viewport constraints when defined as another viewport-relative axis\\n */\\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\\n    let min = constraintsAxis.min - layoutAxis.min;\\n    let max = constraintsAxis.max - layoutAxis.max;\\n    // If the constraints axis is actually smaller than the layout axis then we can\\n    // flip the constraints\\n    if (constraintsAxis.max - constraintsAxis.min <\\n        layoutAxis.max - layoutAxis.min) {\\n        [min, max] = [max, min];\\n    }\\n    return { min, max };\\n}\\n/**\\n * Calculate viewport constraints when defined as another viewport-relative box\\n */\\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\\n    return {\\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\\n    };\\n}\\n/**\\n * Calculate a transform origin relative to the source axis, between 0-1, that results\\n * in an asthetically pleasing scale/transform needed to project from source to target.\\n */\\nfunction calcOrigin(source, target) {\\n    let origin = 0.5;\\n    const sourceLength = calcLength(source);\\n    const targetLength = calcLength(target);\\n    if (targetLength > sourceLength) {\\n        origin = motionUtils.progress(target.min, target.max - sourceLength, source.min);\\n    }\\n    else if (sourceLength > targetLength) {\\n        origin = motionUtils.progress(source.min, source.max - targetLength, target.min);\\n    }\\n    return clamp(0, 1, origin);\\n}\\n/**\\n * Rebase the calculated viewport constraints relative to the layout.min point.\\n */\\nfunction rebaseAxisConstraints(layout, constraints) {\\n    const relativeConstraints = {};\\n    if (constraints.min !== undefined) {\\n        relativeConstraints.min = constraints.min - layout.min;\\n    }\\n    if (constraints.max !== undefined) {\\n        relativeConstraints.max = constraints.max - layout.min;\\n    }\\n    return relativeConstraints;\\n}\\nconst defaultElastic = 0.35;\\n/**\\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\\n */\\nfunction resolveDragElastic(dragElastic = defaultElastic) {\\n    if (dragElastic === false) {\\n        dragElastic = 0;\\n    }\\n    else if (dragElastic === true) {\\n        dragElastic = defaultElastic;\\n    }\\n    return {\\n        x: resolveAxisElastic(dragElastic, \\\"left\\\", \\\"right\\\"),\\n        y: resolveAxisElastic(dragElastic, \\\"top\\\", \\\"bottom\\\"),\\n    };\\n}\\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\\n    return {\\n        min: resolvePointElastic(dragElastic, minLabel),\\n        max: resolvePointElastic(dragElastic, maxLabel),\\n    };\\n}\\nfunction resolvePointElastic(dragElastic, label) {\\n    return typeof dragElastic === \\\"number\\\"\\n        ? dragElastic\\n        : dragElastic[label] || 0;\\n}\\n\\nconst elementDragControls = new WeakMap();\\n/**\\n *\\n */\\n// let latestPointerEvent: PointerEvent\\nclass VisualElementDragControls {\\n    constructor(visualElement) {\\n        this.openDragLock = null;\\n        this.isDragging = false;\\n        this.currentDirection = null;\\n        this.originPoint = { x: 0, y: 0 };\\n        /**\\n         * The permitted boundaries of travel, in pixels.\\n         */\\n        this.constraints = false;\\n        this.hasMutatedConstraints = false;\\n        /**\\n         * The per-axis resolved elastic values.\\n         */\\n        this.elastic = createBox();\\n        this.visualElement = visualElement;\\n    }\\n    start(originEvent, { snapToCursor = false } = {}) {\\n        /**\\n         * Don't start dragging if this component is exiting\\n         */\\n        const { presenceContext } = this.visualElement;\\n        if (presenceContext && presenceContext.isPresent === false)\\n            return;\\n        const onSessionStart = (event) => {\\n            const { dragSnapToOrigin } = this.getProps();\\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\\n            // the component.\\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\\n            if (snapToCursor) {\\n                this.snapToCursor(extractEventInfo(event).point);\\n            }\\n        };\\n        const onStart = (event, info) => {\\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\\n            const { drag, dragPropagation, onDragStart } = this.getProps();\\n            if (drag && !dragPropagation) {\\n                if (this.openDragLock)\\n                    this.openDragLock();\\n                this.openDragLock = motionDom.setDragLock(drag);\\n                // If we don 't have the lock, don't start dragging\\n                if (!this.openDragLock)\\n                    return;\\n            }\\n            this.isDragging = true;\\n            this.currentDirection = null;\\n            this.resolveConstraints();\\n            if (this.visualElement.projection) {\\n                this.visualElement.projection.isAnimationBlocked = true;\\n                this.visualElement.projection.target = undefined;\\n            }\\n            /**\\n             * Record gesture origin\\n             */\\n            eachAxis((axis) => {\\n                let current = this.getAxisMotionValue(axis).get() || 0;\\n                /**\\n                 * If the MotionValue is a percentage value convert to px\\n                 */\\n                if (percent.test(current)) {\\n                    const { projection } = this.visualElement;\\n                    if (projection && projection.layout) {\\n                        const measuredAxis = projection.layout.layoutBox[axis];\\n                        if (measuredAxis) {\\n                            const length = calcLength(measuredAxis);\\n                            current = length * (parseFloat(current) / 100);\\n                        }\\n                    }\\n                }\\n                this.originPoint[axis] = current;\\n            });\\n            // Fire onDragStart event\\n            if (onDragStart) {\\n                frame.postRender(() => onDragStart(event, info));\\n            }\\n            addValueToWillChange(this.visualElement, \\\"transform\\\");\\n            const { animationState } = this.visualElement;\\n            animationState && animationState.setActive(\\\"whileDrag\\\", true);\\n        };\\n        const onMove = (event, info) => {\\n            // latestPointerEvent = event\\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\\n            // If we didn't successfully receive the gesture lock, early return.\\n            if (!dragPropagation && !this.openDragLock)\\n                return;\\n            const { offset } = info;\\n            // Attempt to detect drag direction if directionLock is true\\n            if (dragDirectionLock && this.currentDirection === null) {\\n                this.currentDirection = getCurrentDirection(offset);\\n                // If we've successfully set a direction, notify listener\\n                if (this.currentDirection !== null) {\\n                    onDirectionLock && onDirectionLock(this.currentDirection);\\n                }\\n                return;\\n            }\\n            // Update each point with the latest position\\n            this.updateAxis(\\\"x\\\", info.point, offset);\\n            this.updateAxis(\\\"y\\\", info.point, offset);\\n            /**\\n             * Ideally we would leave the renderer to fire naturally at the end of\\n             * this frame but if the element is about to change layout as the result\\n             * of a re-render we want to ensure the browser can read the latest\\n             * bounding box to ensure the pointer and element don't fall out of sync.\\n             */\\n            this.visualElement.render();\\n            /**\\n             * This must fire after the render call as it might trigger a state\\n             * change which itself might trigger a layout update.\\n             */\\n            onDrag && onDrag(event, info);\\n        };\\n        const onSessionEnd = (event, info) => this.stop(event, info);\\n        const resumeAnimation = () => eachAxis((axis) => {\\n            var _a;\\n            return this.getAnimationState(axis) === \\\"paused\\\" &&\\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\\n        });\\n        const { dragSnapToOrigin } = this.getProps();\\n        this.panSession = new PanSession(originEvent, {\\n            onSessionStart,\\n            onStart,\\n            onMove,\\n            onSessionEnd,\\n            resumeAnimation,\\n        }, {\\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\\n            dragSnapToOrigin,\\n        });\\n    }\\n    stop(event, info) {\\n        const isDragging = this.isDragging;\\n        this.cancel();\\n        if (!isDragging)\\n            return;\\n        const { velocity } = info;\\n        this.startAnimation(velocity);\\n        const { onDragEnd } = this.getProps();\\n        if (onDragEnd) {\\n            frame.postRender(() => onDragEnd(event, info));\\n        }\\n    }\\n    cancel() {\\n        this.isDragging = false;\\n        const { projection, animationState } = this.visualElement;\\n        if (projection) {\\n            projection.isAnimationBlocked = false;\\n        }\\n        this.panSession && this.panSession.end();\\n        this.panSession = undefined;\\n        const { dragPropagation } = this.getProps();\\n        if (!dragPropagation && this.openDragLock) {\\n            this.openDragLock();\\n            this.openDragLock = null;\\n        }\\n        animationState && animationState.setActive(\\\"whileDrag\\\", false);\\n    }\\n    updateAxis(axis, _point, offset) {\\n        const { drag } = this.getProps();\\n        // If we're not dragging this axis, do an early return.\\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\\n            return;\\n        const axisValue = this.getAxisMotionValue(axis);\\n        let next = this.originPoint[axis] + offset[axis];\\n        // Apply constraints\\n        if (this.constraints && this.constraints[axis]) {\\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\\n        }\\n        axisValue.set(next);\\n    }\\n    resolveConstraints() {\\n        var _a;\\n        const { dragConstraints, dragElastic } = this.getProps();\\n        const layout = this.visualElement.projection &&\\n            !this.visualElement.projection.layout\\n            ? this.visualElement.projection.measure(false)\\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\\n        const prevConstraints = this.constraints;\\n        if (dragConstraints && isRefObject(dragConstraints)) {\\n            if (!this.constraints) {\\n                this.constraints = this.resolveRefConstraints();\\n            }\\n        }\\n        else {\\n            if (dragConstraints && layout) {\\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\\n            }\\n            else {\\n                this.constraints = false;\\n            }\\n        }\\n        this.elastic = resolveDragElastic(dragElastic);\\n        /**\\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\\n         * from viewport-relative to component-relative.\\n         */\\n        if (prevConstraints !== this.constraints &&\\n            layout &&\\n            this.constraints &&\\n            !this.hasMutatedConstraints) {\\n            eachAxis((axis) => {\\n                if (this.constraints !== false &&\\n                    this.getAxisMotionValue(axis)) {\\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\\n                }\\n            });\\n        }\\n    }\\n    resolveRefConstraints() {\\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\\n        if (!constraints || !isRefObject(constraints))\\n            return false;\\n        const constraintsElement = constraints.current;\\n        motionUtils.invariant(constraintsElement !== null, \\\"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\\\");\\n        const { projection } = this.visualElement;\\n        // TODO\\n        if (!projection || !projection.layout)\\n            return false;\\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\\n        /**\\n         * If there's an onMeasureDragConstraints listener we call it and\\n         * if different constraints are returned, set constraints to that\\n         */\\n        if (onMeasureDragConstraints) {\\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\\n            this.hasMutatedConstraints = !!userConstraints;\\n            if (userConstraints) {\\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\\n            }\\n        }\\n        return measuredConstraints;\\n    }\\n    startAnimation(velocity) {\\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\\n        const constraints = this.constraints || {};\\n        const momentumAnimations = eachAxis((axis) => {\\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\\n                return;\\n            }\\n            let transition = (constraints && constraints[axis]) || {};\\n            if (dragSnapToOrigin)\\n                transition = { min: 0, max: 0 };\\n            /**\\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\\n             * using the value of `dragElastic`.\\n             */\\n            const bounceStiffness = dragElastic ? 200 : 1000000;\\n            const bounceDamping = dragElastic ? 40 : 10000000;\\n            const inertia = {\\n                type: \\\"inertia\\\",\\n                velocity: dragMomentum ? velocity[axis] : 0,\\n                bounceStiffness,\\n                bounceDamping,\\n                timeConstant: 750,\\n                restDelta: 1,\\n                restSpeed: 10,\\n                ...dragTransition,\\n                ...transition,\\n            };\\n            // If we're not animating on an externally-provided `MotionValue` we can use the\\n            // component's animation controls which will handle interactions with whileHover (etc),\\n            // otherwise we just have to animate the `MotionValue` itself.\\n            return this.startAxisValueAnimation(axis, inertia);\\n        });\\n        // Run all animations and then resolve the new drag constraints.\\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\\n    }\\n    startAxisValueAnimation(axis, transition) {\\n        const axisValue = this.getAxisMotionValue(axis);\\n        addValueToWillChange(this.visualElement, axis);\\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\\n    }\\n    stopAnimation() {\\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\\n    }\\n    pauseAnimation() {\\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\\n    }\\n    getAnimationState(axis) {\\n        var _a;\\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\\n    }\\n    /**\\n     * Drag works differently depending on which props are provided.\\n     *\\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\\n     * - Otherwise, we apply the delta to the x/y motion values.\\n     */\\n    getAxisMotionValue(axis) {\\n        const dragKey = `_drag${axis.toUpperCase()}`;\\n        const props = this.visualElement.getProps();\\n        const externalMotionValue = props[dragKey];\\n        return externalMotionValue\\n            ? externalMotionValue\\n            : this.visualElement.getValue(axis, (props.initial\\n                ? props.initial[axis]\\n                : undefined) || 0);\\n    }\\n    snapToCursor(point) {\\n        eachAxis((axis) => {\\n            const { drag } = this.getProps();\\n            // If we're not dragging this axis, do an early return.\\n            if (!shouldDrag(axis, drag, this.currentDirection))\\n                return;\\n            const { projection } = this.visualElement;\\n            const axisValue = this.getAxisMotionValue(axis);\\n            if (projection && projection.layout) {\\n                const { min, max } = projection.layout.layoutBox[axis];\\n                axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));\\n            }\\n        });\\n    }\\n    /**\\n     * When the viewport resizes we want to check if the measured constraints\\n     * have changed and, if so, reposition the element within those new constraints\\n     * relative to where it was before the resize.\\n     */\\n    scalePositionWithinConstraints() {\\n        if (!this.visualElement.current)\\n            return;\\n        const { drag, dragConstraints } = this.getProps();\\n        const { projection } = this.visualElement;\\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\\n            return;\\n        /**\\n         * Stop current animations as there can be visual glitching if we try to do\\n         * this mid-animation\\n         */\\n        this.stopAnimation();\\n        /**\\n         * Record the relative position of the dragged element relative to the\\n         * constraints box and save as a progress value.\\n         */\\n        const boxProgress = { x: 0, y: 0 };\\n        eachAxis((axis) => {\\n            const axisValue = this.getAxisMotionValue(axis);\\n            if (axisValue && this.constraints !== false) {\\n                const latest = axisValue.get();\\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\\n            }\\n        });\\n        /**\\n         * Update the layout of this element and resolve the latest drag constraints\\n         */\\n        const { transformTemplate } = this.visualElement.getProps();\\n        this.visualElement.current.style.transform = transformTemplate\\n            ? transformTemplate({}, \\\"\\\")\\n            : \\\"none\\\";\\n        projection.root && projection.root.updateScroll();\\n        projection.updateLayout();\\n        this.resolveConstraints();\\n        /**\\n         * For each axis, calculate the current progress of the layout axis\\n         * within the new constraints.\\n         */\\n        eachAxis((axis) => {\\n            if (!shouldDrag(axis, drag, null))\\n                return;\\n            /**\\n             * Calculate a new transform based on the previous box progress\\n             */\\n            const axisValue = this.getAxisMotionValue(axis);\\n            const { min, max } = this.constraints[axis];\\n            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));\\n        });\\n    }\\n    addListeners() {\\n        if (!this.visualElement.current)\\n            return;\\n        elementDragControls.set(this.visualElement, this);\\n        const element = this.visualElement.current;\\n        /**\\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\\n         */\\n        const stopPointerListener = addPointerEvent(element, \\\"pointerdown\\\", (event) => {\\n            const { drag, dragListener = true } = this.getProps();\\n            drag && dragListener && this.start(event);\\n        });\\n        const measureDragConstraints = () => {\\n            const { dragConstraints } = this.getProps();\\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\\n                this.constraints = this.resolveRefConstraints();\\n            }\\n        };\\n        const { projection } = this.visualElement;\\n        const stopMeasureLayoutListener = projection.addEventListener(\\\"measure\\\", measureDragConstraints);\\n        if (projection && !projection.layout) {\\n            projection.root && projection.root.updateScroll();\\n            projection.updateLayout();\\n        }\\n        frame.read(measureDragConstraints);\\n        /**\\n         * Attach a window resize listener to scale the draggable target within its defined\\n         * constraints as the window resizes.\\n         */\\n        const stopResizeListener = addDomEvent(window, \\\"resize\\\", () => this.scalePositionWithinConstraints());\\n        /**\\n         * If the element's layout changes, calculate the delta and apply that to\\n         * the drag gesture's origin point.\\n         */\\n        const stopLayoutUpdateListener = projection.addEventListener(\\\"didUpdate\\\", (({ delta, hasLayoutChanged }) => {\\n            if (this.isDragging && hasLayoutChanged) {\\n                eachAxis((axis) => {\\n                    const motionValue = this.getAxisMotionValue(axis);\\n                    if (!motionValue)\\n                        return;\\n                    this.originPoint[axis] += delta[axis].translate;\\n                    motionValue.set(motionValue.get() + delta[axis].translate);\\n                });\\n                this.visualElement.render();\\n            }\\n        }));\\n        return () => {\\n            stopResizeListener();\\n            stopPointerListener();\\n            stopMeasureLayoutListener();\\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\\n        };\\n    }\\n    getProps() {\\n        const props = this.visualElement.getProps();\\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\\n        return {\\n            ...props,\\n            drag,\\n            dragDirectionLock,\\n            dragPropagation,\\n            dragConstraints,\\n            dragElastic,\\n            dragMomentum,\\n        };\\n    }\\n}\\nfunction shouldDrag(direction, drag, currentDirection) {\\n    return ((drag === true || drag === direction) &&\\n        (currentDirection === null || currentDirection === direction));\\n}\\n/**\\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\\n * than the provided threshold, return `null`.\\n *\\n * @param offset - The x/y offset from origin.\\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\\n */\\nfunction getCurrentDirection(offset, lockThreshold = 10) {\\n    let direction = null;\\n    if (Math.abs(offset.y) > lockThreshold) {\\n        direction = \\\"y\\\";\\n    }\\n    else if (Math.abs(offset.x) > lockThreshold) {\\n        direction = \\\"x\\\";\\n    }\\n    return direction;\\n}\\n\\nclass DragGesture extends Feature {\\n    constructor(node) {\\n        super(node);\\n        this.removeGroupControls = motionUtils.noop;\\n        this.removeListeners = motionUtils.noop;\\n        this.controls = new VisualElementDragControls(node);\\n    }\\n    mount() {\\n        // If we've been provided a DragControls for manual control over the drag gesture,\\n        // subscribe this component to it on mount.\\n        const { dragControls } = this.node.getProps();\\n        if (dragControls) {\\n            this.removeGroupControls = dragControls.subscribe(this.controls);\\n        }\\n        this.removeListeners = this.controls.addListeners() || motionUtils.noop;\\n    }\\n    unmount() {\\n        this.removeGroupControls();\\n        this.removeListeners();\\n    }\\n}\\n\\nconst asyncHandler = (handler) => (event, info) => {\\n    if (handler) {\\n        frame.postRender(() => handler(event, info));\\n    }\\n};\\nclass PanGesture extends Feature {\\n    constructor() {\\n        super(...arguments);\\n        this.removePointerDownListener = motionUtils.noop;\\n    }\\n    onPointerDown(pointerDownEvent) {\\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\\n            transformPagePoint: this.node.getTransformPagePoint(),\\n        });\\n    }\\n    createPanHandlers() {\\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\\n        return {\\n            onSessionStart: asyncHandler(onPanSessionStart),\\n            onStart: asyncHandler(onPanStart),\\n            onMove: onPan,\\n            onEnd: (event, info) => {\\n                delete this.session;\\n                if (onPanEnd) {\\n                    frame.postRender(() => onPanEnd(event, info));\\n                }\\n            },\\n        };\\n    }\\n    mount() {\\n        this.removePointerDownListener = addPointerEvent(this.node.current, \\\"pointerdown\\\", (event) => this.onPointerDown(event));\\n    }\\n    update() {\\n        this.session && this.session.updateHandlers(this.createPanHandlers());\\n    }\\n    unmount() {\\n        this.removePointerDownListener();\\n        this.session && this.session.end();\\n    }\\n}\\n\\n/**\\n * Internal, exported only for usage in Framer\\n */\\nconst SwitchLayoutGroupContext = React.createContext({});\\n\\nclass MeasureLayoutWithContext extends React.Component {\\n    /**\\n     * This only mounts projection nodes for components that\\n     * need measuring, we might want to do it for all components\\n     * in order to incorporate transforms\\n     */\\n    componentDidMount() {\\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\\n        const { projection } = visualElement;\\n        addScaleCorrector(defaultScaleCorrectors);\\n        if (projection) {\\n            if (layoutGroup.group)\\n                layoutGroup.group.add(projection);\\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\\n                switchLayoutGroup.register(projection);\\n            }\\n            projection.root.didUpdate();\\n            projection.addEventListener(\\\"animationComplete\\\", () => {\\n                this.safeToRemove();\\n            });\\n            projection.setOptions({\\n                ...projection.options,\\n                onExitComplete: () => this.safeToRemove(),\\n            });\\n        }\\n        globalProjectionState.hasEverUpdated = true;\\n    }\\n    getSnapshotBeforeUpdate(prevProps) {\\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\\n        const projection = visualElement.projection;\\n        if (!projection)\\n            return null;\\n        /**\\n         * TODO: We use this data in relegate to determine whether to\\n         * promote a previous element. There's no guarantee its presence data\\n         * will have updated by this point - if a bug like this arises it will\\n         * have to be that we markForRelegation and then find a new lead some other way,\\n         * perhaps in didUpdate\\n         */\\n        projection.isPresent = isPresent;\\n        if (drag ||\\n            prevProps.layoutDependency !== layoutDependency ||\\n            layoutDependency === undefined) {\\n            projection.willUpdate();\\n        }\\n        else {\\n            this.safeToRemove();\\n        }\\n        if (prevProps.isPresent !== isPresent) {\\n            if (isPresent) {\\n                projection.promote();\\n            }\\n            else if (!projection.relegate()) {\\n                /**\\n                 * If there's another stack member taking over from this one,\\n                 * it's in charge of the exit animation and therefore should\\n                 * be in charge of the safe to remove. Otherwise we call it here.\\n                 */\\n                frame.postRender(() => {\\n                    const stack = projection.getStack();\\n                    if (!stack || !stack.members.length) {\\n                        this.safeToRemove();\\n                    }\\n                });\\n            }\\n        }\\n        return null;\\n    }\\n    componentDidUpdate() {\\n        const { projection } = this.props.visualElement;\\n        if (projection) {\\n            projection.root.didUpdate();\\n            microtask.postRender(() => {\\n                if (!projection.currentAnimation && projection.isLead()) {\\n                    this.safeToRemove();\\n                }\\n            });\\n        }\\n    }\\n    componentWillUnmount() {\\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\\n        const { projection } = visualElement;\\n        if (projection) {\\n            projection.scheduleCheckAfterUnmount();\\n            if (layoutGroup && layoutGroup.group)\\n                layoutGroup.group.remove(projection);\\n            if (promoteContext && promoteContext.deregister)\\n                promoteContext.deregister(projection);\\n        }\\n    }\\n    safeToRemove() {\\n        const { safeToRemove } = this.props;\\n        safeToRemove && safeToRemove();\\n    }\\n    render() {\\n        return null;\\n    }\\n}\\nfunction MeasureLayout(props) {\\n    const [isPresent, safeToRemove] = usePresence();\\n    const layoutGroup = React.useContext(LayoutGroupContext);\\n    return (jsxRuntime.jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: React.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\\n}\\nconst defaultScaleCorrectors = {\\n    borderRadius: {\\n        ...correctBorderRadius,\\n        applyTo: [\\n            \\\"borderTopLeftRadius\\\",\\n            \\\"borderTopRightRadius\\\",\\n            \\\"borderBottomLeftRadius\\\",\\n            \\\"borderBottomRightRadius\\\",\\n        ],\\n    },\\n    borderTopLeftRadius: correctBorderRadius,\\n    borderTopRightRadius: correctBorderRadius,\\n    borderBottomLeftRadius: correctBorderRadius,\\n    borderBottomRightRadius: correctBorderRadius,\\n    boxShadow: correctBoxShadow,\\n};\\n\\nconst drag = {\\n    pan: {\\n        Feature: PanGesture,\\n    },\\n    drag: {\\n        Feature: DragGesture,\\n        ProjectionNode: HTMLProjectionNode,\\n        MeasureLayout,\\n    },\\n};\\n\\nfunction handleHoverEvent(node, event, lifecycle) {\\n    const { props } = node;\\n    if (node.animationState && props.whileHover) {\\n        node.animationState.setActive(\\\"whileHover\\\", lifecycle === \\\"Start\\\");\\n    }\\n    const eventName = (\\\"onHover\\\" + lifecycle);\\n    const callback = props[eventName];\\n    if (callback) {\\n        frame.postRender(() => callback(event, extractEventInfo(event)));\\n    }\\n}\\nclass HoverGesture extends Feature {\\n    mount() {\\n        const { current } = this.node;\\n        if (!current)\\n            return;\\n        this.unmount = motionDom.hover(current, (_element, startEvent) => {\\n            handleHoverEvent(this.node, startEvent, \\\"Start\\\");\\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \\\"End\\\");\\n        });\\n    }\\n    unmount() { }\\n}\\n\\nclass FocusGesture extends Feature {\\n    constructor() {\\n        super(...arguments);\\n        this.isActive = false;\\n    }\\n    onFocus() {\\n        let isFocusVisible = false;\\n        /**\\n         * If this element doesn't match focus-visible then don't\\n         * apply whileHover. But, if matches throws that focus-visible\\n         * is not a valid selector then in that browser outline styles will be applied\\n         * to the element by default and we want to match that behaviour with whileFocus.\\n         */\\n        try {\\n            isFocusVisible = this.node.current.matches(\\\":focus-visible\\\");\\n        }\\n        catch (e) {\\n            isFocusVisible = true;\\n        }\\n        if (!isFocusVisible || !this.node.animationState)\\n            return;\\n        this.node.animationState.setActive(\\\"whileFocus\\\", true);\\n        this.isActive = true;\\n    }\\n    onBlur() {\\n        if (!this.isActive || !this.node.animationState)\\n            return;\\n        this.node.animationState.setActive(\\\"whileFocus\\\", false);\\n        this.isActive = false;\\n    }\\n    mount() {\\n        this.unmount = pipe(addDomEvent(this.node.current, \\\"focus\\\", () => this.onFocus()), addDomEvent(this.node.current, \\\"blur\\\", () => this.onBlur()));\\n    }\\n    unmount() { }\\n}\\n\\nfunction handlePressEvent(node, event, lifecycle) {\\n    const { props } = node;\\n    if (node.current instanceof HTMLButtonElement && node.current.disabled) {\\n        return;\\n    }\\n    if (node.animationState && props.whileTap) {\\n        node.animationState.setActive(\\\"whileTap\\\", lifecycle === \\\"Start\\\");\\n    }\\n    const eventName = (\\\"onTap\\\" + (lifecycle === \\\"End\\\" ? \\\"\\\" : lifecycle));\\n    const callback = props[eventName];\\n    if (callback) {\\n        frame.postRender(() => callback(event, extractEventInfo(event)));\\n    }\\n}\\nclass PressGesture extends Feature {\\n    mount() {\\n        const { current } = this.node;\\n        if (!current)\\n            return;\\n        this.unmount = motionDom.press(current, (_element, startEvent) => {\\n            handlePressEvent(this.node, startEvent, \\\"Start\\\");\\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \\\"End\\\" : \\\"Cancel\\\");\\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\\n    }\\n    unmount() { }\\n}\\n\\n/**\\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\\n * element, so even though these handlers might all be triggered by different\\n * observers, we can keep them in the same map.\\n */\\nconst observerCallbacks = new WeakMap();\\n/**\\n * Multiple observers can be created for multiple element/document roots. Each with\\n * different settings. So here we store dictionaries of observers to each root,\\n * using serialised settings (threshold/margin) as lookup keys.\\n */\\nconst observers = new WeakMap();\\nconst fireObserverCallback = (entry) => {\\n    const callback = observerCallbacks.get(entry.target);\\n    callback && callback(entry);\\n};\\nconst fireAllObserverCallbacks = (entries) => {\\n    entries.forEach(fireObserverCallback);\\n};\\nfunction initIntersectionObserver({ root, ...options }) {\\n    const lookupRoot = root || document;\\n    /**\\n     * If we don't have an observer lookup map for this root, create one.\\n     */\\n    if (!observers.has(lookupRoot)) {\\n        observers.set(lookupRoot, {});\\n    }\\n    const rootObservers = observers.get(lookupRoot);\\n    const key = JSON.stringify(options);\\n    /**\\n     * If we don't have an observer for this combination of root and settings,\\n     * create one.\\n     */\\n    if (!rootObservers[key]) {\\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\\n    }\\n    return rootObservers[key];\\n}\\nfunction observeIntersection(element, options, callback) {\\n    const rootInteresectionObserver = initIntersectionObserver(options);\\n    observerCallbacks.set(element, callback);\\n    rootInteresectionObserver.observe(element);\\n    return () => {\\n        observerCallbacks.delete(element);\\n        rootInteresectionObserver.unobserve(element);\\n    };\\n}\\n\\nconst thresholdNames = {\\n    some: 0,\\n    all: 1,\\n};\\nclass InViewFeature extends Feature {\\n    constructor() {\\n        super(...arguments);\\n        this.hasEnteredView = false;\\n        this.isInView = false;\\n    }\\n    startObserver() {\\n        this.unmount();\\n        const { viewport = {} } = this.node.getProps();\\n        const { root, margin: rootMargin, amount = \\\"some\\\", once } = viewport;\\n        const options = {\\n            root: root ? root.current : undefined,\\n            rootMargin,\\n            threshold: typeof amount === \\\"number\\\" ? amount : thresholdNames[amount],\\n        };\\n        const onIntersectionUpdate = (entry) => {\\n            const { isIntersecting } = entry;\\n            /**\\n             * If there's been no change in the viewport state, early return.\\n             */\\n            if (this.isInView === isIntersecting)\\n                return;\\n            this.isInView = isIntersecting;\\n            /**\\n             * Handle hasEnteredView. If this is only meant to run once, and\\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\\n             */\\n            if (once && !isIntersecting && this.hasEnteredView) {\\n                return;\\n            }\\n            else if (isIntersecting) {\\n                this.hasEnteredView = true;\\n            }\\n            if (this.node.animationState) {\\n                this.node.animationState.setActive(\\\"whileInView\\\", isIntersecting);\\n            }\\n            /**\\n             * Use the latest committed props rather than the ones in scope\\n             * when this observer is created\\n             */\\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\\n            callback && callback(entry);\\n        };\\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\\n    }\\n    mount() {\\n        this.startObserver();\\n    }\\n    update() {\\n        if (typeof IntersectionObserver === \\\"undefined\\\")\\n            return;\\n        const { props, prevProps } = this.node;\\n        const hasOptionsChanged = [\\\"amount\\\", \\\"margin\\\", \\\"root\\\"].some(hasViewportOptionChanged(props, prevProps));\\n        if (hasOptionsChanged) {\\n            this.startObserver();\\n        }\\n    }\\n    unmount() { }\\n}\\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\\n    return (name) => viewport[name] !== prevViewport[name];\\n}\\n\\nconst gestureAnimations = {\\n    inView: {\\n        Feature: InViewFeature,\\n    },\\n    tap: {\\n        Feature: PressGesture,\\n    },\\n    focus: {\\n        Feature: FocusGesture,\\n    },\\n    hover: {\\n        Feature: HoverGesture,\\n    },\\n};\\n\\nconst layout = {\\n    layout: {\\n        ProjectionNode: HTMLProjectionNode,\\n        MeasureLayout,\\n    },\\n};\\n\\nfunction getCurrentTreeVariants(props, context) {\\n    if (isControllingVariants(props)) {\\n        const { initial, animate } = props;\\n        return {\\n            initial: initial === false || isVariantLabel(initial)\\n                ? initial\\n                : undefined,\\n            animate: isVariantLabel(animate) ? animate : undefined,\\n        };\\n    }\\n    return props.inherit !== false ? context : {};\\n}\\n\\nfunction useCreateMotionContext(props) {\\n    const { initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));\\n    return React.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\\n}\\nfunction variantLabelsAsDependency(prop) {\\n    return Array.isArray(prop) ? prop.join(\\\" \\\") : prop;\\n}\\n\\nconst motionComponentSymbol = Symbol.for(\\\"motionComponentSymbol\\\");\\n\\n/**\\n * Creates a ref function that, when called, hydrates the provided\\n * external ref and VisualElement.\\n */\\nfunction useMotionRef(visualState, visualElement, externalRef) {\\n    return React.useCallback((instance) => {\\n        if (instance) {\\n            visualState.onMount && visualState.onMount(instance);\\n        }\\n        if (visualElement) {\\n            if (instance) {\\n                visualElement.mount(instance);\\n            }\\n            else {\\n                visualElement.unmount();\\n            }\\n        }\\n        if (externalRef) {\\n            if (typeof externalRef === \\\"function\\\") {\\n                externalRef(instance);\\n            }\\n            else if (isRefObject(externalRef)) {\\n                externalRef.current = instance;\\n            }\\n        }\\n    }, \\n    /**\\n     * Only pass a new ref callback to React if we've received a visual element\\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\\n     * or other dependencies change.\\n     */\\n    [visualElement]);\\n}\\n\\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\\n    var _a, _b;\\n    const { visualElement: parent } = React.useContext(MotionContext);\\n    const lazyContext = React.useContext(LazyContext);\\n    const presenceContext = React.useContext(PresenceContext);\\n    const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;\\n    const visualElementRef = React.useRef(null);\\n    /**\\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\\n     */\\n    createVisualElement = createVisualElement || lazyContext.renderer;\\n    if (!visualElementRef.current && createVisualElement) {\\n        visualElementRef.current = createVisualElement(Component, {\\n            visualState,\\n            parent,\\n            props,\\n            presenceContext,\\n            blockInitialAnimation: presenceContext\\n                ? presenceContext.initial === false\\n                : false,\\n            reducedMotionConfig,\\n        });\\n    }\\n    const visualElement = visualElementRef.current;\\n    /**\\n     * Load Motion gesture and animation features. These are rendered as renderless\\n     * components so each feature can optionally make use of React lifecycle methods.\\n     */\\n    const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);\\n    if (visualElement &&\\n        !visualElement.projection &&\\n        ProjectionNodeConstructor &&\\n        (visualElement.type === \\\"html\\\" || visualElement.type === \\\"svg\\\")) {\\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\\n    }\\n    const isMounted = React.useRef(false);\\n    React.useInsertionEffect(() => {\\n        /**\\n         * Check the component has already mounted before calling\\n         * `update` unnecessarily. This ensures we skip the initial update.\\n         */\\n        if (visualElement && isMounted.current) {\\n            visualElement.update(props, presenceContext);\\n        }\\n    });\\n    /**\\n     * Cache this value as we want to know whether HandoffAppearAnimations\\n     * was present on initial render - it will be deleted after this.\\n     */\\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\\n    const wantsHandoff = React.useRef(Boolean(optimisedAppearId) &&\\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\\n    useIsomorphicLayoutEffect(() => {\\n        if (!visualElement)\\n            return;\\n        isMounted.current = true;\\n        window.MotionIsMounted = true;\\n        visualElement.updateFeatures();\\n        microtask.render(visualElement.render);\\n        /**\\n         * Ideally this function would always run in a useEffect.\\n         *\\n         * However, if we have optimised appear animations to handoff from,\\n         * it needs to happen synchronously to ensure there's no flash of\\n         * incorrect styles in the event of a hydration error.\\n         *\\n         * So if we detect a situtation where optimised appear animations\\n         * are running, we use useLayoutEffect to trigger animations.\\n         */\\n        if (wantsHandoff.current && visualElement.animationState) {\\n            visualElement.animationState.animateChanges();\\n        }\\n    });\\n    React.useEffect(() => {\\n        if (!visualElement)\\n            return;\\n        if (!wantsHandoff.current && visualElement.animationState) {\\n            visualElement.animationState.animateChanges();\\n        }\\n        if (wantsHandoff.current) {\\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\\n            queueMicrotask(() => {\\n                var _a;\\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\\n            });\\n            wantsHandoff.current = false;\\n        }\\n    });\\n    return visualElement;\\n}\\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\\\"data-framer-portal-id\\\"]\\n        ? undefined\\n        : getClosestProjectingNode(visualElement.parent));\\n    visualElement.projection.setOptions({\\n        layoutId,\\n        layout,\\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\\n        visualElement,\\n        /**\\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\\n         * to update by the time layout animations run.\\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\\n         * ensuring it gets called if there's no potential layout animations.\\n         *\\n         */\\n        animationType: typeof layout === \\\"string\\\" ? layout : \\\"both\\\",\\n        initialPromotionConfig,\\n        layoutScroll,\\n        layoutRoot,\\n    });\\n}\\nfunction getClosestProjectingNode(visualElement) {\\n    if (!visualElement)\\n        return undefined;\\n    return visualElement.options.allowProjection !== false\\n        ? visualElement.projection\\n        : getClosestProjectingNode(visualElement.parent);\\n}\\n\\n/**\\n * Create a `motion` component.\\n *\\n * This function accepts a Component argument, which can be either a string (ie \\\"div\\\"\\n * for `motion.div`), or an actual React component.\\n *\\n * Alongside this is a config option which provides a way of rendering the provided\\n * component \\\"offline\\\", or outside the React render cycle.\\n */\\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\\n    var _a, _b;\\n    preloadedFeatures && loadFeatures(preloadedFeatures);\\n    function MotionComponent(props, externalRef) {\\n        /**\\n         * If we need to measure the element we load this functionality in a\\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\\n         */\\n        let MeasureLayout;\\n        const configAndProps = {\\n            ...React.useContext(MotionConfigContext),\\n            ...props,\\n            layoutId: useLayoutId(props),\\n        };\\n        const { isStatic } = configAndProps;\\n        const context = useCreateMotionContext(props);\\n        const visualState = useVisualState(props, isStatic);\\n        if (!isStatic && isBrowser) {\\n            useStrictMode(configAndProps, preloadedFeatures);\\n            const layoutProjection = getProjectionFunctionality(configAndProps);\\n            MeasureLayout = layoutProjection.MeasureLayout;\\n            /**\\n             * Create a VisualElement for this component. A VisualElement provides a common\\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\\n             * providing a way of rendering to these APIs outside of the React render loop\\n             * for more performant animations and interactions\\n             */\\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\\n        }\\n        /**\\n         * The mount order and hierarchy is specific to ensure our element ref\\n         * is hydrated by the time features fire their effects.\\n         */\\n        return (jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsxRuntime.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\\n    }\\n    MotionComponent.displayName = `motion.${typeof Component === \\\"string\\\"\\n        ? Component\\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : \\\"\\\"})`}`;\\n    const ForwardRefMotionComponent = React.forwardRef(MotionComponent);\\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\\n    return ForwardRefMotionComponent;\\n}\\nfunction useLayoutId({ layoutId }) {\\n    const layoutGroupId = React.useContext(LayoutGroupContext).id;\\n    return layoutGroupId && layoutId !== undefined\\n        ? layoutGroupId + \\\"-\\\" + layoutId\\n        : layoutId;\\n}\\nfunction useStrictMode(configAndProps, preloadedFeatures) {\\n    const isStrict = React.useContext(LazyContext).strict;\\n    /**\\n     * If we're in development mode, check to make sure we're not rendering a motion component\\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\\n     */\\n    if (process.env.NODE_ENV !== \\\"production\\\" &&\\n        preloadedFeatures &&\\n        isStrict) {\\n        const strictMessage = \\\"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\\\";\\n        configAndProps.ignoreStrict\\n            ? motionUtils.warning(false, strictMessage)\\n            : motionUtils.invariant(false, strictMessage);\\n    }\\n}\\nfunction getProjectionFunctionality(props) {\\n    const { drag, layout } = featureDefinitions;\\n    if (!drag && !layout)\\n        return {};\\n    const combined = { ...drag, ...layout };\\n    return {\\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\\n            ? combined.MeasureLayout\\n            : undefined,\\n        ProjectionNode: combined.ProjectionNode,\\n    };\\n}\\n\\nconst createHtmlRenderState = () => ({\\n    style: {},\\n    transform: {},\\n    transformOrigin: {},\\n    vars: {},\\n});\\n\\nfunction copyRawValuesOnly(target, source, props) {\\n    for (const key in source) {\\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\\n            target[key] = source[key];\\n        }\\n    }\\n}\\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\\n    return React.useMemo(() => {\\n        const state = createHtmlRenderState();\\n        buildHTMLStyles(state, visualState, transformTemplate);\\n        return Object.assign({}, state.vars, state.style);\\n    }, [visualState]);\\n}\\nfunction useStyle(props, visualState) {\\n    const styleProp = props.style || {};\\n    const style = {};\\n    /**\\n     * Copy non-Motion Values straight into style\\n     */\\n    copyRawValuesOnly(style, styleProp, props);\\n    Object.assign(style, useInitialMotionValues(props, visualState));\\n    return style;\\n}\\nfunction useHTMLProps(props, visualState) {\\n    // The `any` isn't ideal but it is the type of createElement props argument\\n    const htmlProps = {};\\n    const style = useStyle(props, visualState);\\n    if (props.drag && props.dragListener !== false) {\\n        // Disable the ghost element when a user drags\\n        htmlProps.draggable = false;\\n        // Disable text selection\\n        style.userSelect =\\n            style.WebkitUserSelect =\\n                style.WebkitTouchCallout =\\n                    \\\"none\\\";\\n        // Disable scrolling on the draggable direction\\n        style.touchAction =\\n            props.drag === true\\n                ? \\\"none\\\"\\n                : `pan-${props.drag === \\\"x\\\" ? \\\"y\\\" : \\\"x\\\"}`;\\n    }\\n    if (props.tabIndex === undefined &&\\n        (props.onTap || props.onTapStart || props.whileTap)) {\\n        htmlProps.tabIndex = 0;\\n    }\\n    htmlProps.style = style;\\n    return htmlProps;\\n}\\n\\n/**\\n * We keep these listed separately as we use the lowercase tag names as part\\n * of the runtime bundle to detect SVG components\\n */\\nconst lowercaseSVGElements = [\\n    \\\"animate\\\",\\n    \\\"circle\\\",\\n    \\\"defs\\\",\\n    \\\"desc\\\",\\n    \\\"ellipse\\\",\\n    \\\"g\\\",\\n    \\\"image\\\",\\n    \\\"line\\\",\\n    \\\"filter\\\",\\n    \\\"marker\\\",\\n    \\\"mask\\\",\\n    \\\"metadata\\\",\\n    \\\"path\\\",\\n    \\\"pattern\\\",\\n    \\\"polygon\\\",\\n    \\\"polyline\\\",\\n    \\\"rect\\\",\\n    \\\"stop\\\",\\n    \\\"switch\\\",\\n    \\\"symbol\\\",\\n    \\\"svg\\\",\\n    \\\"text\\\",\\n    \\\"tspan\\\",\\n    \\\"use\\\",\\n    \\\"view\\\",\\n];\\n\\nfunction isSVGComponent(Component) {\\n    if (\\n    /**\\n     * If it's not a string, it's a custom React component. Currently we only support\\n     * HTML custom React components.\\n     */\\n    typeof Component !== \\\"string\\\" ||\\n        /**\\n         * If it contains a dash, the element is a custom HTML webcomponent.\\n         */\\n        Component.includes(\\\"-\\\")) {\\n        return false;\\n    }\\n    else if (\\n    /**\\n     * If it's in our list of lowercase SVG tags, it's an SVG component\\n     */\\n    lowercaseSVGElements.indexOf(Component) > -1 ||\\n        /**\\n         * If it contains a capital letter, it's an SVG component\\n         */\\n        /[A-Z]/u.test(Component)) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nconst createSvgRenderState = () => ({\\n    ...createHtmlRenderState(),\\n    attrs: {},\\n});\\n\\nfunction useSVGProps(props, visualState, _isStatic, Component) {\\n    const visualProps = React.useMemo(() => {\\n        const state = createSvgRenderState();\\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\\n        return {\\n            ...state.attrs,\\n            style: { ...state.style },\\n        };\\n    }, [visualState]);\\n    if (props.style) {\\n        const rawStyles = {};\\n        copyRawValuesOnly(rawStyles, props.style, props);\\n        visualProps.style = { ...rawStyles, ...visualProps.style };\\n    }\\n    return visualProps;\\n}\\n\\nfunction createUseRender(forwardMotionProps = false) {\\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\\n        const useVisualProps = isSVGComponent(Component)\\n            ? useSVGProps\\n            : useHTMLProps;\\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\\n        const filteredProps = filterProps(props, typeof Component === \\\"string\\\", forwardMotionProps);\\n        const elementProps = Component !== React.Fragment\\n            ? { ...filteredProps, ...visualProps, ref }\\n            : {};\\n        /**\\n         * If component has been handed a motion value as its child,\\n         * memoise its initial value and render that. Subsequent updates\\n         * will be handled by the onChange handler\\n         */\\n        const { children } = props;\\n        const renderedChildren = React.useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\\n        return React.createElement(Component, {\\n            ...elementProps,\\n            children: renderedChildren,\\n        });\\n    };\\n    return useRender;\\n}\\n\\nconst htmlMotionConfig = {\\n    useVisualState: makeUseVisualState({\\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\\n        createRenderState: createHtmlRenderState,\\n    }),\\n};\\n\\nconst layoutProps = [\\\"x\\\", \\\"y\\\", \\\"width\\\", \\\"height\\\", \\\"cx\\\", \\\"cy\\\", \\\"r\\\"];\\nconst svgMotionConfig = {\\n    useVisualState: makeUseVisualState({\\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\\n        createRenderState: createSvgRenderState,\\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\\n            if (!current)\\n                return;\\n            let hasTransform = !!props.drag;\\n            if (!hasTransform) {\\n                for (const key in latestValues) {\\n                    if (transformProps.has(key)) {\\n                        hasTransform = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!hasTransform)\\n                return;\\n            let needsMeasure = !prevProps;\\n            if (prevProps) {\\n                /**\\n                 * Check the layout props for changes, if any are found we need to\\n                 * measure the element again.\\n                 */\\n                for (let i = 0; i < layoutProps.length; i++) {\\n                    const key = layoutProps[i];\\n                    if (props[key] !==\\n                        prevProps[key]) {\\n                        needsMeasure = true;\\n                    }\\n                }\\n            }\\n            if (!needsMeasure)\\n                return;\\n            frame.read(() => {\\n                updateSVGDimensions(current, renderState);\\n                frame.render(() => {\\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\\n                    renderSVG(current, renderState);\\n                });\\n            });\\n        },\\n    }),\\n};\\n\\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\\n        const baseConfig = isSVGComponent(Component)\\n            ? svgMotionConfig\\n            : htmlMotionConfig;\\n        const config = {\\n            ...baseConfig,\\n            preloadedFeatures,\\n            useRender: createUseRender(forwardMotionProps),\\n            createVisualElement,\\n            Component,\\n        };\\n        return createRendererMotionComponent(config);\\n    };\\n}\\n\\nconst createDomVisualElement = (Component, options) => {\\n    return isSVGComponent(Component)\\n        ? new SVGVisualElement(options)\\n        : new HTMLVisualElement(options, {\\n            allowProjection: Component !== React.Fragment,\\n        });\\n};\\n\\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\\n    ...animations,\\n    ...gestureAnimations,\\n    ...drag,\\n    ...layout,\\n}, createDomVisualElement);\\n\\nexports.AcceleratedAnimation = AcceleratedAnimation;\\nexports.FlatTree = FlatTree;\\nexports.HTMLVisualElement = HTMLVisualElement;\\nexports.LayoutGroupContext = LayoutGroupContext;\\nexports.LazyContext = LazyContext;\\nexports.MotionConfigContext = MotionConfigContext;\\nexports.MotionContext = MotionContext;\\nexports.MotionGlobalConfig = MotionGlobalConfig;\\nexports.MotionValue = MotionValue;\\nexports.PresenceContext = PresenceContext;\\nexports.SVGVisualElement = SVGVisualElement;\\nexports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\\nexports.VisualElement = VisualElement;\\nexports.acceleratedValues = acceleratedValues;\\nexports.addDomEvent = addDomEvent;\\nexports.addPointerEvent = addPointerEvent;\\nexports.addPointerInfo = addPointerInfo;\\nexports.addScaleCorrector = addScaleCorrector;\\nexports.addUniqueItem = addUniqueItem;\\nexports.animateSingleValue = animateSingleValue;\\nexports.animateTarget = animateTarget;\\nexports.animateValue = animateValue;\\nexports.animateVisualElement = animateVisualElement;\\nexports.animations = animations;\\nexports.anticipate = anticipate;\\nexports.backIn = backIn;\\nexports.backInOut = backInOut;\\nexports.backOut = backOut;\\nexports.browserNumberValueTypes = browserNumberValueTypes;\\nexports.buildTransform = buildTransform;\\nexports.calcLength = calcLength;\\nexports.camelToDash = camelToDash;\\nexports.cancelFrame = cancelFrame;\\nexports.circIn = circIn;\\nexports.circInOut = circInOut;\\nexports.circOut = circOut;\\nexports.clamp = clamp;\\nexports.collectMotionValues = collectMotionValues;\\nexports.color = color;\\nexports.complex = complex;\\nexports.createBox = createBox;\\nexports.createDomVisualElement = createDomVisualElement;\\nexports.createMotionComponent = createMotionComponent;\\nexports.createMotionComponentFactory = createMotionComponentFactory;\\nexports.createRendererMotionComponent = createRendererMotionComponent;\\nexports.cubicBezier = cubicBezier;\\nexports.defaultOffset = defaultOffset;\\nexports.delay = delay;\\nexports.distance = distance;\\nexports.distance2D = distance2D;\\nexports.drag = drag;\\nexports.easeIn = easeIn;\\nexports.easeInOut = easeInOut;\\nexports.easeOut = easeOut;\\nexports.easingDefinitionToFunction = easingDefinitionToFunction;\\nexports.fillOffset = fillOffset;\\nexports.filterProps = filterProps;\\nexports.findSpring = findSpring;\\nexports.frame = frame;\\nexports.frameData = frameData;\\nexports.frameSteps = frameSteps;\\nexports.gestureAnimations = gestureAnimations;\\nexports.getFinalKeyframe = getFinalKeyframe;\\nexports.getOptimisedAppearId = getOptimisedAppearId;\\nexports.hasReducedMotionListener = hasReducedMotionListener;\\nexports.inertia = inertia;\\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\\nexports.instantAnimationState = instantAnimationState;\\nexports.interpolate = interpolate;\\nexports.isBrowser = isBrowser;\\nexports.isEasingArray = isEasingArray;\\nexports.isMotionValue = isMotionValue;\\nexports.isSVGElement = isSVGElement;\\nexports.isValidMotionProp = isValidMotionProp;\\nexports.keyframes = keyframes;\\nexports.layout = layout;\\nexports.loadExternalIsValidProp = loadExternalIsValidProp;\\nexports.loadFeatures = loadFeatures;\\nexports.makeUseVisualState = makeUseVisualState;\\nexports.mirrorEasing = mirrorEasing;\\nexports.mix = mix;\\nexports.mixNumber = mixNumber$1;\\nexports.motionComponentSymbol = motionComponentSymbol;\\nexports.motionValue = motionValue;\\nexports.moveItem = moveItem;\\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\\nexports.optimizedAppearDataId = optimizedAppearDataId;\\nexports.pipe = pipe;\\nexports.prefersReducedMotion = prefersReducedMotion;\\nexports.px = px;\\nexports.removeItem = removeItem;\\nexports.resolveMotionValue = resolveMotionValue;\\nexports.reverseEasing = reverseEasing;\\nexports.rootProjectionNode = rootProjectionNode;\\nexports.setTarget = setTarget;\\nexports.spring = spring;\\nexports.startWaapiAnimation = startWaapiAnimation;\\nexports.stepsOrder = stepsOrder;\\nexports.supportsWaapi = supportsWaapi;\\nexports.time = time;\\nexports.transformProps = transformProps;\\nexports.useConstant = useConstant;\\nexports.useIsPresent = useIsPresent;\\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\\nexports.usePresence = usePresence;\\nexports.velocityPerSecond = velocityPerSecond;\\nexports.visualElementStore = visualElementStore;\\nexports.warnOnce = warnOnce;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isAnimationControls\",\"v\",\"start\",\"getValueState\",\"visualElement\",\"state\",\"values\",\"forEach\",\"value\",\"key\",\"get\",\"getVelocity\",\"resolveVariantFromProps\",\"props\",\"definition\",\"custom\",\"current\",\"velocity\",\"undefined\",\"variants\",\"resolveVariant\",\"getProps\",\"createRenderStep\",\"runNextFrame\",\"stepName\",\"triggerCallback\",\"callback\",\"toKeepAlive\",\"has\",\"step\",\"schedule\",\"numCalls\",\"latestFrameData\",\"thisFrame\",\"Set\",\"nextFrame\",\"isProcessing\",\"flushNextFrame\",\"WeakSet\",\"delta\",\"timestamp\",\"keepAlive\",\"immediate\",\"queue\",\"add\",\"cancel\",\"delete\",\"process\",\"frameData\",\"statsBuffer\",\"frameloop\",\"push\",\"clear\",\"createRenderBatcher\",\"scheduleNextBatch\",\"allowKeepAlive\",\"useDefaultElapsed\",\"flagRunNextFrame\",\"steps\",\"stepsOrder\",\"reduce\",\"acc\",\"read\",\"resolveKeyframes\",\"update\",\"preRender\",\"render\",\"postRender\",\"processBatch\",\"MotionGlobalConfig\",\"useManualTiming\",\"performance\",\"now\",\"Math\",\"max\",\"min\",\"maxElapsed\",\"i\",\"length\",\"clearTime\",\"addUniqueItem\",\"arr\",\"item\",\"indexOf\",\"removeItem\",\"index\",\"splice\",\"velocityPerSecond\",\"frameDuration\",\"warnOnce\",\"condition\",\"message\",\"element\",\"warned\",\"console\",\"warn\",\"motionValue\",\"init\",\"options\",\"MotionValue\",\"setTarget\",\"resolved\",\"transitionEnd\",\"transition\",\"target\",\"Array\",\"isArray\",\"hasValue\",\"getValue\",\"set\",\"addValue\",\"addValueToWillChange\",\"willChange\",\"getOptimisedAppearId\",\"optimizedAppearDataAttribute\",\"cubicBezier\",\"mX1\",\"mY1\",\"mX2\",\"mY2\",\"motionUtils\",\"noop\",\"t\",\"currentX\",\"currentT\",\"lowerBound\",\"upperBound\",\"x\",\"subdivisionPrecision\",\"abs\",\"subdivisionMaxIterations\",\"a2\",\"a1\",\"analyseComplexValue\",\"indexes\",\"color\",\"number\",\"var\",\"types\",\"split\",\"toString\",\"originalValue\",\"replace\",\"tokenised\",\"complexRegex\",\"parsedValue\",\"test\",\"COLOR_TOKEN\",\"parse\",\"startsWith\",\"VAR_FUNCTION_TOKEN\",\"VAR_TOKEN\",\"NUMBER_TOKEN\",\"parseFloat\",\"SPLIT_TOKEN\",\"parseComplexValue\",\"createTransformer\",\"source\",\"numSections\",\"output\",\"type\",\"round\",\"transform\",\"applyDefaultFilter\",\"name\",\"slice\",\"match\",\"floatRegex\",\"unit\",\"defaultValue\",\"maxDefaults\",\"getAnimatableNone\",\"defaultValueType\",\"defaultValueTypes\",\"filter\",\"complex\",\"removeNonTranslationalTransform\",\"removedTransforms\",\"nonTranslationalTransformKeys\",\"measureAllKeyframes\",\"anyNeedsMeasurement\",\"resolversToMeasure\",\"from\",\"toResolve\",\"resolver\",\"needsMeasurement\",\"elementsToMeasure\",\"map\",\"transformsToRestore\",\"Map\",\"measureInitialState\",\"restore\",\"_a\",\"measureEndState\",\"suspendedScrollY\",\"window\",\"scrollTo\",\"isScheduled\",\"complete\",\"readAllKeyframes\",\"readKeyframes\",\"getVariableValue\",\"depth\",\"invariant\",\"maxDepth\",\"splitCSSVariableRegex\",\"exec\",\"token1\",\"token2\",\"fallback\",\"token\",\"getComputedStyle\",\"getPropertyValue\",\"trimmed\",\"trim\",\"isCSSVariableToken\",\"getFinalKeyframe\",\"keyframes\",\"repeat\",\"repeatType\",\"finalKeyframe\",\"resolvedKeyframes\",\"isNotNull\",\"hueToRgb\",\"p\",\"q\",\"hslaToRgba\",\"hue\",\"saturation\",\"lightness\",\"alpha\",\"red\",\"green\",\"blue\",\"mixImmediate\",\"a\",\"b\",\"asRGBA\",\"getColorType\",\"warning\",\"model\",\"hsla\",\"mixVisibility\",\"origin\",\"invisibleValues\",\"mixNumber\",\"getMixer\",\"mixColor\",\"mixComplex\",\"mixArray\",\"mixObject\",\"numValues\",\"blendValue\",\"mix\",\"to\",\"mixer\",\"calcGeneratorVelocity\",\"resolveValue\",\"prevT\",\"velocitySampleDuration\",\"findSpring\",\"duration\",\"springDefaults\",\"bounce\",\"mass\",\"envelope\",\"secondsToMilliseconds\",\"maxDuration\",\"dampingRatio\",\"clamp\",\"minDamping\",\"maxDamping\",\"minDuration\",\"millisecondsToSeconds\",\"undampedFreq\",\"exponentialDecay\",\"safeMin\",\"sqrt\",\"exp\",\"c\",\"derivative\",\"d\",\"e\",\"pow\",\"f\",\"g\",\"factor\",\"approximateRoot\",\"isNaN\",\"stiffness\",\"damping\",\"initialGuess\",\"rootIterations\",\"result\",\"isSpringType\",\"keys\",\"some\",\"getSpringOptions\",\"springOptions\",\"isResolvedFromDuration\",\"physicsKeys\",\"durationKeys\",\"visualDuration\",\"root\",\"PI\",\"derived\",\"spring\",\"optionsOrVisualDuration\",\"restSpeed\",\"restDelta\",\"done\",\"initialVelocity\",\"initialDelta\",\"undampedAngularFreq\",\"isGranularScale\",\"granular\",\"default\",\"resolveSpring\",\"angularFreq\",\"sin\",\"cos\",\"dampedAngularFreq\",\"freqForT\",\"sinh\",\"cosh\",\"generator\",\"calculatedDuration\",\"next\",\"currentVelocity\",\"isBelowDisplacementThreshold\",\"motionDom\",\"calcGeneratorDuration\",\"maxGeneratorDuration\",\"easing\",\"generateLinearEasing\",\"progress\",\"inertia\",\"power\",\"timeConstant\",\"bounceDamping\",\"bounceStiffness\",\"modifyTarget\",\"amplitude\",\"ideal\",\"calcLatest\",\"applyFriction\",\"latest\",\"timeReachedBoundary\",\"spring$1\",\"checkCatchBoundary\",\"hasUpdatedFrame\",\"createMixers\",\"ease\",\"customMixer\",\"mixers\",\"mixerFactory\",\"numMixers\",\"easingFunction\",\"combineFunctions\",\"interpolate\",\"input\",\"isClamp\",\"inputLength\",\"isZeroDeltaRange\",\"reverse\",\"interpolator\",\"progressInRange\",\"fillOffset\",\"offset\",\"remaining\",\"offsetProgress\",\"defaultOffset\",\"convertOffsetToTimes\",\"o\",\"defaultEasing\",\"easeInOut\",\"keyframeValues\",\"times\",\"easingFunctions\",\"isEasingArray\",\"easingDefinitionToFunction\",\"absoluteTimes\",\"mapTimeToKeyframe\",\"startWaapiAnimation\",\"valueName\",\"delay\",\"keyframeOptions\",\"mapEasingToNativeEasing\",\"animate\",\"animation\",\"fill\",\"iterations\",\"direction\",\"requiresPregeneratedKeyframes\",\"isGenerator\",\"isWaapiSupportedEasing\",\"pregenerateKeyframes\",\"sampleAnimation\",\"MainThreadAnimation\",\"pregeneratedKeyframes\",\"sample\",\"sampleDelta\",\"isTransitionDefined\",\"when\",\"_delay\",\"delayChildren\",\"staggerChildren\",\"staggerDirection\",\"repeatDelay\",\"elapsed\",\"Object\",\"shouldBlockAnimation\",\"protectedKeys\",\"needsAnimating\",\"shouldBlock\",\"hasOwnProperty\",\"animateTarget\",\"targetAndTransition\",\"transitionOverride\",\"getDefaultTransition\",\"animations\",\"animationTypeState\",\"animationState\",\"getState\",\"latestValues\",\"valueTarget\",\"valueTransition\",\"getValueTransition\",\"isHandoff\",\"MotionHandoffAnimation\",\"appearId\",\"startTime\",\"frame\",\"animateMotionValue\",\"shouldReduceMotion\",\"positionalKeys\",\"Promise\",\"all\",\"then\",\"animateVariant\",\"variant\",\"presenceContext\",\"getAnimation\",\"resolve\",\"getChildAnimations\",\"variantChildren\",\"size\",\"forwardDelay\",\"animateChildren\",\"first\",\"last\",\"maxStaggerDuration\",\"generateStaggerDuration\",\"sort\",\"sortByTreeOrder\",\"child\",\"notify\",\"sortNodePosition\",\"animateVisualElement\",\"resolvedDefinition\",\"shallowCompare\",\"prev\",\"prevLength\",\"isVariantLabel\",\"getVariantContext\",\"isControllingVariants\",\"context\",\"parent\",\"initial\",\"numVariantProps\",\"variantProps\",\"prop\",\"animateList\",\"createAnimationState\",\"animateChanges\",\"changedActiveType\",\"removedKeys\",\"encounteredKeys\",\"removedVariantIndex\",\"Infinity\",\"numAnimationTypes\",\"reversePriorityOrder\",\"typeState\",\"propIsVariant\",\"activeDelta\",\"isActive\",\"isInherited\",\"isInitialRender\",\"manuallyAnimateOnMount\",\"prevProp\",\"variantDidChange\",\"checkVariantsDidChange\",\"shouldAnimateType\",\"handledRemovedValues\",\"definitionList\",\"resolvedValues\",\"buildResolvedTypeValues\",\"prevResolvedValues\",\"allKeys\",\"markToAnimate\",\"liveStyle\",\"valueHasChanged\",\"blockInitialAnimation\",\"fallbackAnimation\",\"initialTransition\",\"fallbackTarget\",\"getBaseTarget\",\"shouldAnimate\",\"createState\",\"setActive\",\"setAnimateFunction\",\"makeAnimator\",\"reset\",\"createTypeState\",\"whileInView\",\"whileHover\",\"whileTap\",\"whileDrag\",\"whileFocus\",\"exit\",\"calcLength\",\"axis\",\"calcAxisDelta\",\"originPoint\",\"mixNumber$1\",\"scale\",\"translate\",\"SCALE_MIN\",\"SCALE_MAX\",\"TRANSLATE_MIN\",\"TRANSLATE_MAX\",\"calcBoxDelta\",\"originX\",\"y\",\"originY\",\"calcRelativePosition\",\"layout\",\"isValidMotionProp\",\"validMotionProps\",\"loadExternalIsValidProp\",\"isValidProp\",\"shouldForward\",\"filterProps\",\"isDom\",\"forwardMotionProps\",\"filteredProps\",\"isVariantNode\",\"useConstant\",\"ref\",\"React\",\"useRef\",\"resolveMotionValue\",\"unwrappedValue\",\"toValue\",\"makeState\",\"scrapeMotionValuesFromProps\",\"createRenderState\",\"onUpdate\",\"makeLatestValues\",\"renderState\",\"onMount\",\"instance\",\"state.onMount\",\"state.onUpdate\",\"scrapeMotionValues\",\"motionValues\",\"isControllingVariants$1\",\"isVariantNode$1\",\"inherit\",\"variantToSet\",\"isInitialAnimationBlocked\",\"list\",\"addDomEvent\",\"eventName\",\"handler\",\"passive\",\"addEventListener\",\"removeEventListener\",\"extractEventInfo\",\"event\",\"point\",\"pageX\",\"pageY\",\"addPointerEvent\",\"addPointerInfo\",\"usePresence\",\"subscribe\",\"useContext\",\"PresenceContext\",\"isPresent\",\"onExitComplete\",\"register\",\"id\",\"useId\",\"useEffect\",\"safeToRemove\",\"useCallback\",\"animateSingleValue\",\"motionValue$1\",\"isSVGElement\",\"SVGElement\",\"tagName\",\"initPrefersReducedMotion\",\"hasReducedMotionListener\",\"isBrowser\",\"matchMedia\",\"motionMediaQuery\",\"addListener\",\"setReducedMotionPreferences\",\"prefersReducedMotion\",\"matches\",\"buildTransform\",\"transformTemplate\",\"transformString\",\"transformIsDefault\",\"numTransforms\",\"transformPropOrder\",\"valueIsDefault\",\"valueAsType\",\"getValueAsType\",\"numberValueTypes\",\"translateAlias\",\"buildHTMLStyles\",\"style\",\"vars\",\"transformOrigin\",\"hasTransform\",\"hasTransformOrigin\",\"transformProps\",\"isCSSVariableName\",\"originZ\",\"buildSVGPath\",\"attrs\",\"spacing\",\"useDashCase\",\"pathLength\",\"dashKeys\",\"camelKeys\",\"px\",\"pathSpacing\",\"array\",\"buildSVGAttrs\",\"attrX\",\"attrY\",\"attrScale\",\"pathOffset\",\"isSVGTag\",\"viewBox\",\"dimensions\",\"width\",\"pxOriginY\",\"height\",\"pxOriginX\",\"updateSVGDimensions\",\"getBBox\",\"getBoundingClientRect\",\"renderHTML\",\"styleProp\",\"projection\",\"assign\",\"getProjectionStyles\",\"setProperty\",\"renderSVG\",\"_styleProp\",\"setAttribute\",\"camelCaseAttributes\",\"camelToDash\",\"addScaleCorrector\",\"correctors\",\"scaleCorrectors\",\"isCSSVariable\",\"isForcedMotionValue\",\"layoutId\",\"scrapeMotionValuesFromProps$1\",\"prevProps\",\"newValues\",\"isMotionValue\",\"targetKey\",\"charAt\",\"toUpperCase\",\"substring\",\"convertBoundingBoxToBox\",\"top\",\"left\",\"right\",\"bottom\",\"convertBoxToBoundingBox\",\"transformBoxPoints\",\"transformPoint\",\"topLeft\",\"bottomRight\",\"hasScale\",\"scaleX\",\"scaleY\",\"has2DTranslate\",\"z\",\"rotate\",\"rotateX\",\"rotateY\",\"skewX\",\"skewY\",\"is2DTranslate\",\"applyPointDelta\",\"boxScale\",\"applyAxisDelta\",\"applyBoxDelta\",\"box\",\"applyTreeDeltas\",\"treeScale\",\"treePath\",\"isSharedTransition\",\"treeLength\",\"node\",\"projectionDelta\",\"display\",\"layoutScroll\",\"scroll\",\"transformBox\",\"TREE_SCALE_SNAP_MAX\",\"TREE_SCALE_SNAP_MIN\",\"translateAxis\",\"distance\",\"transformAxis\",\"axisTranslate\",\"axisScale\",\"axisOrigin\",\"timeout\",\"time\",\"checkElapsed\",\"cancelFrame\",\"distance2D\",\"xDelta\",\"yDelta\",\"compress\",\"copyBoxInto\",\"originBox\",\"originAxis\",\"copyAxisDeltaInto\",\"originDelta\",\"removePointDelta\",\"removeAxisDelta\",\"sourceAxis\",\"percent\",\"relativeProgress\",\"removeAxisTransforms\",\"transforms\",\"scaleKey\",\"originKey\",\"removeBoxTransforms\",\"sourceBox\",\"xKeys\",\"yKeys\",\"isAxisDeltaZero\",\"axisEquals\",\"axisEqualsRounded\",\"aspectRatio\",\"axisDeltaEquals\",\"eachAxis\",\"resetDistortingTransform\",\"sharedAnimationValues\",\"setStaticValue\",\"cancelTreeOptimisedTransformAnimations\",\"projectionNode\",\"hasCheckedOptimisedAppear\",\"MotionHasOptimisedAnimation\",\"MotionCancelOptimisedAnimation\",\"createProjectionNode$1\",\"attachResizeListener\",\"defaultParent\",\"measureScroll\",\"checkIsScrollRoot\",\"resetTransform\",\"constructor\",\"animationId\",\"children\",\"shouldResetTransform\",\"needsReset\",\"isSVG\",\"isUpdating\",\"updateBlockedByResize\",\"updateManuallyBlocked\",\"isTransformDirty\",\"isSharedProjectionDirty\",\"isProjectionDirty\",\"isLayoutDirty\",\"isAnimationBlocked\",\"isTreeAnimating\",\"eventHandlers\",\"updateScheduled\",\"hasTreeAnimated\",\"scheduleUpdate\",\"this.scheduleUpdate\",\"projectionUpdateScheduled\",\"checkUpdateFailed\",\"this.checkUpdateFailed\",\"clearAllSnapshots\",\"updateProjection\",\"this.updateProjection\",\"nodes\",\"propagateDirtyNodes\",\"resolveTargetDelta\",\"calcProjection\",\"cleanDirtyNodes\",\"resolvedRelativeTargetAt\",\"hasProjected\",\"isVisible\",\"animationProgress\",\"sharedNodes\",\"path\",\"FlatTree\",\"SubscriptionManager\",\"notifyListeners\",\"args\",\"subscriptionManager\",\"hasListeners\",\"mount\",\"cancelDelay\",\"resizeUnblockUpdate\",\"globalProjectionState\",\"hasAnimatedSinceResize\",\"finishAnimation\",\"registerSharedNode\",\"hasLayoutChanged\",\"hasRelativeLayoutChanged\",\"newLayout\",\"isTreeAnimationBlocked\",\"relativeTarget\",\"layoutTransition\",\"defaultLayoutTransition\",\"onLayoutAnimationStart\",\"onLayoutAnimationComplete\",\"hasOnlyRelativeTargetChanged\",\"layoutRoot\",\"resumeFrom\",\"hasTargetChanged\",\"currentAnimation\",\"resumingFrom\",\"setAnimationOrigin\",\"animationOptions\",\"onPlay\",\"onComplete\",\"startAnimation\",\"isLead\",\"targetLayout\",\"unmount\",\"willUpdate\",\"remove\",\"stack\",\"getStack\",\"blockUpdate\",\"unblockUpdate\",\"isUpdateBlocked\",\"startUpdate\",\"resetSkewAndRotation\",\"getTransformTemplate\",\"shouldNotifyListeners\",\"updateScroll\",\"prevTransformTemplateValue\",\"updateSnapshot\",\"updateWasBlocked\",\"clearMeasurements\",\"clearIsLayoutDirty\",\"resetTransformStyle\",\"updateLayout\",\"notifyLayoutUpdate\",\"frameSteps\",\"didUpdate\",\"microtask\",\"clearSnapshot\",\"removeLeadSnapshots\",\"scheduleUpdateProjection\",\"scheduleCheckAfterUnmount\",\"snapshot\",\"measure\",\"measuredBox\",\"alwaysMeasureLayout\",\"prevLayout\",\"layoutCorrected\",\"createBox\",\"layoutBox\",\"phase\",\"isRoot\",\"wasRoot\",\"isResetRequested\",\"transformTemplateValue\",\"transformTemplateHasChanged\",\"hasProjection\",\"scheduleRender\",\"removeTransform\",\"pageBox\",\"measurePageBox\",\"removeElementScroll\",\"roundAxis\",\"measureViewportBox\",\"checkNodeWasScrollRoot\",\"boxWithoutScroll\",\"applyTransform\",\"transformOnly\",\"withTransforms\",\"boxWithoutTransform\",\"nodeBox\",\"setTargetDelta\",\"targetDelta\",\"setOptions\",\"crossfade\",\"forceRelativeParentToResolveTarget\",\"relativeParent\",\"forceRecalculation\",\"lead\",\"getLead\",\"isShared\",\"attemptToResolveRelativeTarget\",\"getClosestProjectingParent\",\"relativeTargetOrigin\",\"targetWithTransforms\",\"relative\",\"isProjecting\",\"canSkip\",\"pendingAnimation\",\"prevTreeScaleX\",\"prevTreeScaleY\",\"prevProjectionDelta\",\"createProjectionDeltas\",\"hide\",\"show\",\"notifyAll\",\"createAxisDelta\",\"projectionDeltaWithTransform\",\"snapshotLatestValues\",\"mixedValues\",\"relativeLayout\",\"isSharedLayoutAnimation\",\"snapshotSource\",\"layoutSource\",\"isOnlyMember\",\"members\",\"shouldCrossfadeOpacity\",\"hasOpacityCrossfade\",\"prevRelativeTarget\",\"mixTargetDelta\",\"this.mixTargetDelta\",\"mixAxisDelta\",\"animationValues\",\"opacity\",\"easeCrossfadeIn\",\"opacityExit\",\"easeCrossfadeOut\",\"numBorders\",\"borderLabel\",\"borders\",\"followRadius\",\"borderRadius\",\"leadRadius\",\"canMix\",\"asNumber\",\"stop\",\"animationTarget\",\"onStop\",\"completeAnimation\",\"preserveOpacity\",\"exitAnimationComplete\",\"applyTransformsToTarget\",\"shouldAnimatePositionOnly\",\"animationType\",\"xLength\",\"yLength\",\"NodeStack\",\"config\",\"initialPromotionConfig\",\"promote\",\"preserveFollowOpacity\",\"shouldPreserveFollowOpacity\",\"getPrevLead\",\"prevLead\",\"relegate\",\"hasDistortingTransform\",\"rotateZ\",\"resetValues\",\"transformAxes\",\"_b\",\"hiddenVisibility\",\"styles\",\"visibility\",\"pointerEvents\",\"emptyStyles\",\"valuesToRender\",\"xTranslate\",\"yTranslate\",\"zTranslate\",\"transformPerspective\",\"elementScaleX\",\"elementScaleY\",\"correct\",\"applyTo\",\"corrected\",\"num\",\"resetTree\",\"measuredLayout\",\"axisSnapshot\",\"layoutDelta\",\"visualDelta\",\"parentSnapshot\",\"parentLayout\",\"relativeSnapshot\",\"onBeforeLayoutMeasure\",\"removeLeadSnapshot\",\"roundPoint\",\"maxDistance\",\"pixelsToPercent\",\"pixels\",\"loadFeatures\",\"features\",\"featureDefinitions\",\"isRefObject\",\"prototype\",\"call\",\"info\",\"transformPagePoint\",\"subtractPoint\",\"getPanInfo\",\"history\",\"timeDelta\",\"timestampedPoint\",\"lastPoint\",\"applyConstraints\",\"elastic\",\"calcRelativeAxisConstraints\",\"calcRelativeConstraints\",\"calcViewportAxisConstraints\",\"layoutAxis\",\"constraintsAxis\",\"resolveDragElastic\",\"dragElastic\",\"defaultElastic\",\"resolvePointElastic\",\"minLabel\",\"maxLabel\",\"label\",\"shouldDrag\",\"drag\",\"currentDirection\",\"getCurrentDirection\",\"lockThreshold\",\"MeasureLayout\",\"layoutGroup\",\"LayoutGroupContext\",\"jsxRuntime\",\"jsx\",\"MeasureLayoutWithContext\",\"switchLayoutGroup\",\"SwitchLayoutGroupContext\",\"handleHoverEvent\",\"lifecycle\",\"handlePressEvent\",\"HTMLButtonElement\",\"disabled\",\"initIntersectionObserver\",\"lookupRoot\",\"document\",\"observers\",\"rootObservers\",\"JSON\",\"stringify\",\"IntersectionObserver\",\"fireAllObserverCallbacks\",\"observeIntersection\",\"rootInteresectionObserver\",\"observerCallbacks\",\"observe\",\"unobserve\",\"hasViewportOptionChanged\",\"viewport\",\"prevViewport\",\"getCurrentTreeVariants\",\"useCreateMotionContext\",\"MotionContext\",\"useMemo\",\"join\",\"useMotionRef\",\"visualState\",\"externalRef\",\"useVisualElement\",\"Component\",\"createVisualElement\",\"ProjectionNodeConstructor\",\"lazyContext\",\"LazyContext\",\"reducedMotionConfig\",\"MotionConfigContext\",\"reducedMotion\",\"visualElementRef\",\"renderer\",\"initialLayoutGroupConfig\",\"createProjectionNode\",\"isMounted\",\"useInsertionEffect\",\"optimisedAppearId\",\"wantsHandoff\",\"MotionHandoffIsComplete\",\"useIsomorphicLayoutEffect\",\"MotionIsMounted\",\"updateFeatures\",\"queueMicrotask\",\"MotionHandoffMarkAsComplete\",\"dragConstraints\",\"getClosestProjectingNode\",\"allowProjection\",\"createRendererMotionComponent\",\"preloadedFeatures\",\"useRender\",\"useVisualState\",\"MotionComponent\",\"configAndProps\",\"useLayoutId\",\"isStatic\",\"isStrict\",\"strict\",\"ignoreStrict\",\"strictMessage\",\"combined\",\"isEnabled\",\"ProjectionNode\",\"layoutProjection\",\"jsxs\",\"Provider\",\"displayName\",\"ForwardRefMotionComponent\",\"forwardRef\",\"motionComponentSymbol\",\"layoutGroupId\",\"copyRawValuesOnly\",\"useInitialMotionValues\",\"createHtmlRenderState\",\"useHTMLProps\",\"htmlProps\",\"dragListener\",\"draggable\",\"userSelect\",\"WebkitUserSelect\",\"WebkitTouchCallout\",\"touchAction\",\"tabIndex\",\"onTap\",\"onTapStart\",\"isSVGComponent\",\"includes\",\"lowercaseSVGElements\",\"useSVGProps\",\"_isStatic\",\"visualProps\",\"createSvgRenderState\",\"rawStyles\",\"createUseRender\",\"useVisualProps\",\"elementProps\",\"Fragment\",\"renderedChildren\",\"createElement\",\"createMotionComponentFactory\",\"createMotionComponent\",\"baseConfig\",\"svgMotionConfig\",\"htmlMotionConfig\",\"createContext\",\"skipAnimations\",\"addProjectionMetrics\",\"requestAnimationFrame\",\"newTime\",\"subscriptions\",\"numSubscriptions\",\"getSize\",\"collectMotionValues\",\"version\",\"canTrackVelocity\",\"events\",\"updateAndNotify\",\"this.updateAndNotify\",\"currentTime\",\"updatedAt\",\"setPrevFrameValue\",\"setCurrent\",\"change\",\"renderRequest\",\"hasAnimated\",\"owner\",\"prevFrameValue\",\"prevUpdatedAt\",\"onChange\",\"subscription\",\"on\",\"unsubscribe\",\"clearListeners\",\"eventManagers\",\"attach\",\"passiveEffect\",\"stopPassiveEffect\",\"setWithVelocity\",\"jump\",\"endAnimation\",\"getPrevious\",\"MAX_VELOCITY_DELTA\",\"animationStart\",\"animationComplete\",\"clearAnimation\",\"animationCancel\",\"isAnimating\",\"destroy\",\"str\",\"toLowerCase\",\"optimizedAppearDataId\",\"instantAnimationState\",\"mirrorEasing\",\"reverseEasing\",\"backOut\",\"backIn\",\"backInOut\",\"anticipate\",\"circIn\",\"acos\",\"circOut\",\"circInOut\",\"singleColorRegex\",\"isColorString\",\"testProp\",\"splitColor\",\"aName\",\"bName\",\"cName\",\"rgbUnit\",\"rgba\",\"alpha$1\",\"hex\",\"parseHex\",\"r\",\"parseInt\",\"createUnitType\",\"endsWith\",\"degrees\",\"vh\",\"vw\",\"progressPercentage\",\"colorRegex\",\"convertNumbersToZero\",\"getAnimatableNone$1\",\"parsed\",\"transformer\",\"functionRegex\",\"functions\",\"browserNumberValueTypes\",\"borderWidth\",\"borderTopWidth\",\"borderRightWidth\",\"borderBottomWidth\",\"borderLeftWidth\",\"radius\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomRightRadius\",\"borderBottomLeftRadius\",\"maxWidth\",\"maxHeight\",\"padding\",\"paddingTop\",\"paddingRight\",\"paddingBottom\",\"paddingLeft\",\"margin\",\"marginTop\",\"marginRight\",\"marginBottom\",\"marginLeft\",\"backgroundPositionX\",\"backgroundPositionY\",\"int\",\"scaleZ\",\"skew\",\"translateX\",\"translateY\",\"translateZ\",\"perspective\",\"zIndex\",\"fillOpacity\",\"strokeOpacity\",\"numOctaves\",\"backgroundColor\",\"outlineColor\",\"stroke\",\"borderColor\",\"borderTopColor\",\"borderRightColor\",\"borderBottomColor\",\"borderLeftColor\",\"WebkitFilter\",\"invalidTemplates\",\"getTranslateFromMatrix\",\"pos2\",\"pos3\",\"_bbox\",\"matrix3d\",\"matrix\",\"transformKeys\",\"positionalValues\",\"KeyframeResolver\",\"unresolvedKeyframes\",\"isAsync\",\"isComplete\",\"scheduleResolve\",\"currentValue\",\"valueAsRead\",\"readValue\",\"setFinalKeyframe\",\"renderEndStyles\",\"resume\",\"checkStringStartsWith\",\"startsAsVariableToken\",\"startsWithToken\",\"singleCssVariableRegex\",\"testValueType\",\"dimensionValueTypes\",\"auto\",\"DOMKeyframesResolver\",\"keyframe\",\"resolveNoneKeyframes\",\"originType\",\"find\",\"targetType\",\"noneKeyframeIndexes\",\"animatableTemplate\",\"noneIndex\",\"pageYOffset\",\"measuredOrigin\",\"measureKeyframe\",\"finalKeyframeIndex\",\"unsetTransformName\",\"unsetTransformValue\",\"isAnimatable\",\"BaseAnimation\",\"autoplay\",\"hasAttemptedResolve\",\"isStopped\",\"createdAt\",\"updateFinishedPromise\",\"calcStartTime\",\"resolvedAt\",\"MAX_RESOLVE_DELAY\",\"_resolved\",\"onKeyframesResolved\",\"originKeyframe\",\"targetKeyframe\",\"isOriginAnimatable\",\"isTargetAnimatable\",\"resolveFinishedPromise\",\"resolvedAnimation\",\"initPlayback\",\"onPostResolved\",\"reject\",\"currentFinishedPromise\",\"flatten\",\"mixLinearColor\",\"fromExpo\",\"expo\",\"colorTypes\",\"fromRGBA\",\"toRGBA\",\"blended\",\"template\",\"originStats\",\"targetStats\",\"orderedOrigin\",\"pointers\",\"originValue\",\"originIndex\",\"transformers\",\"easeIn\",\"easeOut\",\"easingLookup\",\"linear\",\"isBezierDefinition\",\"x1\",\"y1\",\"x2\",\"y2\",\"frameloopDriver\",\"passTimestamp\",\"generators\",\"decay\",\"tween\",\"percentToProgress\",\"cancelTime\",\"holdTime\",\"playbackSpeed\",\"pendingPlayState\",\"this.stop\",\"teardown\",\"onResolved\",\"keyframes$1\",\"generatorFactory\",\"mapPercentToKeyframes\",\"mirroredGenerator\",\"resolvedDuration\",\"totalDuration\",\"play\",\"pause\",\"tick\",\"speed\",\"timeWithoutDelay\",\"isInDelayPhase\",\"frameGenerator\",\"currentIteration\",\"floor\",\"iterationProgress\",\"isAnimationFinished\",\"finish\",\"driver\",\"newSpeed\",\"hasChanged\",\"stopDriver\",\"acceleratedValues\",\"supportsWaapi\",\"memo\",\"Element\",\"unsupportedEasingFunctions\",\"AcceleratedAnimation\",\"supportsLinearEasing\",\"pregeneratedAnimation\",\"pendingTimeline\",\"attachTimeline\",\"onfinish\",\"animation.onfinish\",\"playbackRate\",\"playState\",\"timeline\",\"sampleTime\",\"supports\",\"HTMLElement\",\"underDampedSpring\",\"keyframesTransition\",\"valueKey\",\"shouldSkip\",\"GroupPlaybackControls\",\"variantPriorityOrder\",\"Feature\",\"AnimationFeature\",\"updateAnimationControlsSubscription\",\"unmountControls\",\"prevAnimate\",\"id$1\",\"ExitAnimationFeature\",\"arguments\",\"prevIsPresent\",\"prevPresenceContext\",\"exitAnimation\",\"makeUseVisualState\",\"make\",\"isPrimaryPointer\",\"useLayoutEffect\",\"visualElementStore\",\"WeakMap\",\"featureProps\",\"focus\",\"hover\",\"tap\",\"pan\",\"inView\",\"valueTypes\",\"propEventHandlers\",\"VisualElement\",\"_props\",\"_prevProps\",\"_visualElement\",\"valueSubscriptions\",\"prevMotionValues\",\"propEventSubscriptions\",\"notifyUpdate\",\"this.notifyUpdate\",\"this.render\",\"triggerBuild\",\"renderInstance\",\"renderScheduledAt\",\"this.scheduleRender\",\"baseTarget\",\"initialValues\",\"initialMotionValues\",\"removeFromVariantTree\",\"addVariantChild\",\"bindToMotionValue\",\"feature\",\"valueIsTransform\",\"onBindTransform\",\"removeOnChange\",\"latestValue\",\"removeOnRenderRequest\",\"removeSyncCheck\",\"MotionCheckAppearSync\",\"other\",\"sortInstanceNodePosition\",\"featureDefinition\",\"FeatureConstructor\",\"build\",\"measureInstanceViewportBox\",\"getStaticValue\",\"listener\",\"nextValue\",\"prevValue\",\"existingValue\",\"removeValue\",\"handleChildMotionValue\",\"getVariant\",\"getTransformPagePoint\",\"getClosestVariantNode\",\"closestVariantNode\",\"removeValueFromRenderState\",\"getBaseTargetFromProps\",\"readValueFromInstance\",\"setBaseTarget\",\"valueFromInitial\",\"DOMVisualElement\",\"compareDocumentPosition\",\"childSubscription\",\"textContent\",\"tag\",\"SVGVisualElement\",\"updateDimensions\",\"this.updateDimensions\",\"defaultType\",\"getAttribute\",\"HTMLVisualElement\",\"computedStyle\",\"compareByDepth\",\"isDirty\",\"indexOfNode\",\"findIndex\",\"member\",\"hasEverUpdated\",\"userAgentContains\",\"string\",\"navigator\",\"userAgent\",\"DocumentProjectionNode\",\"documentElement\",\"scrollLeft\",\"body\",\"scrollTop\",\"rootProjectionNode\",\"HTMLProjectionNode\",\"documentNode\",\"position\",\"correctBorderRadius\",\"PanSession\",\"handlers\",\"dragSnapToOrigin\",\"lastMoveEventInfo\",\"lastMoveEvent\",\"startEvent\",\"updatePoint\",\"this.updatePoint\",\"isPanStarted\",\"isDistancePastThreshold\",\"onStart\",\"onMove\",\"handlePointerMove\",\"this.handlePointerMove\",\"hasPointerCapture\",\"pointerId\",\"handlePointerUp\",\"this.handlePointerUp\",\"capturePointer\",\"end\",\"onEnd\",\"onSessionEnd\",\"resumeAnimation\",\"panInfo\",\"initialInfo\",\"onSessionStart\",\"removeListeners\",\"currentTarget\",\"updateHandlers\",\"elementDragControls\",\"VisualElementDragControls\",\"openDragLock\",\"isDragging\",\"hasMutatedConstraints\",\"constraints\",\"originEvent\",\"snapToCursor\",\"panSession\",\"pauseAnimation\",\"stopAnimation\",\"dragPropagation\",\"onDragStart\",\"setDragLock\",\"resolveConstraints\",\"getAxisMotionValue\",\"measuredAxis\",\"dragDirectionLock\",\"onDirectionLock\",\"onDrag\",\"updateAxis\",\"getAnimationState\",\"onDragEnd\",\"_point\",\"axisValue\",\"prevConstraints\",\"resolveRefConstraints\",\"relativeConstraints\",\"onMeasureDragConstraints\",\"constraintsElement\",\"viewportBox\",\"measuredConstraints\",\"userConstraints\",\"dragMomentum\",\"dragTransition\",\"onDragTransitionEnd\",\"momentumAnimations\",\"startAxisValueAnimation\",\"dragKey\",\"externalMotionValue\",\"scalePositionWithinConstraints\",\"boxProgress\",\"sourceLength\",\"targetLength\",\"addListeners\",\"stopPointerListener\",\"measureDragConstraints\",\"stopMeasureLayoutListener\",\"stopResizeListener\",\"stopLayoutUpdateListener\",\"DragGesture\",\"removeGroupControls\",\"controls\",\"dragControls\",\"asyncHandler\",\"PanGesture\",\"removePointerDownListener\",\"onPointerDown\",\"pointerDownEvent\",\"session\",\"createPanHandlers\",\"onPanSessionStart\",\"onPanStart\",\"onPan\",\"onPanEnd\",\"componentDidMount\",\"defaultScaleCorrectors\",\"group\",\"getSnapshotBeforeUpdate\",\"layoutDependency\",\"componentDidUpdate\",\"componentWillUnmount\",\"promoteContext\",\"deregister\",\"boxShadow\",\"correctBoxShadow\",\"shadow\",\"xScale\",\"yScale\",\"averageScale\",\"HoverGesture\",\"_element\",\"endEvent\",\"FocusGesture\",\"onFocus\",\"isFocusVisible\",\"onBlur\",\"PressGesture\",\"press\",\"success\",\"useGlobalTarget\",\"globalTapTarget\",\"fireObserverCallback\",\"entry\",\"entries\",\"thresholdNames\",\"InViewFeature\",\"isInView\",\"hasEnteredView\",\"startObserver\",\"rootMargin\",\"amount\",\"once\",\"threshold\",\"onIntersectionUpdate\",\"isIntersecting\",\"onViewportEnter\",\"onViewportLeave\",\"hasOptionsChanged\",\"gestureAnimations\",\"Symbol\",\"for\",\"layoutProps\",\"needsMeasure\",\"createDomVisualElement\",\"animateValue\",\"moveItem\",\"fromIndex\",\"toIndex\",\"startIndex\",\"endIndex\",\"pipe\",\"useIsPresent\"]\n}\n"]