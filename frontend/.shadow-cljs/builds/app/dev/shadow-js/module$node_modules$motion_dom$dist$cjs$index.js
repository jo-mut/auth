["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/motion-dom/dist/cjs/index.js"],"~:js","shadow$provide.module$node_modules$motion_dom$dist$cjs$index = function(global, require, module, exports) {\n  function getValueTransition(transition, key) {\n    return transition ? transition[key] || transition[\"default\"] || transition : void 0;\n  }\n  function calcGeneratorDuration(generator) {\n    let duration = 0, state = generator.next(duration);\n    for (; !state.done && 20000 > duration;) {\n      duration += 50, state = generator.next(duration);\n    }\n    return 20000 <= duration ? Infinity : duration;\n  }\n  function createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({...options, keyframes:[0, scale]}), duration = Math.min(calcGeneratorDuration(generator), 20000);\n    return {type:\"keyframes\", ease:progress => generator.next(duration * progress).value / scale, duration:motionUtils.millisecondsToSeconds(duration)};\n  }\n  function isGenerator(type) {\n    return \"function\" === typeof type;\n  }\n  function attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n  }\n  function isWaapiSupportedEasing(easing) {\n    return !!(\"function\" === typeof easing && supportsLinearEasing() || !easing || \"string\" === typeof easing && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n  }\n  function mapEasingToNativeEasing(easing, duration) {\n    if (easing) {\n      return \"function\" === typeof easing && supportsLinearEasing() ? generateLinearEasing(easing, duration) : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(segmentEasing => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];\n    }\n  }\n  function isDragActive() {\n    return isDragging.x || isDragging.y;\n  }\n  function resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof EventTarget) {\n      return [elementOrSelector];\n    }\n    if (\"string\" === typeof elementOrSelector) {\n      let root = document;\n      scope && (root = scope.current);\n      return (scope = null !== (_a = null === selectorCache || void 0 === selectorCache ? void 0 : selectorCache[elementOrSelector]) && void 0 !== _a ? _a : root.querySelectorAll(elementOrSelector)) ? Array.from(scope) : [];\n    }\n    return Array.from(elementOrSelector);\n  }\n  function setupGesture(elementOrSelector, options) {\n    elementOrSelector = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    return [elementOrSelector, {passive:!0, ...options, signal:gestureAbortController.signal}, () => gestureAbortController.abort()];\n  }\n  function capturePointer(event, action) {\n    action = `${action}PointerCapture`;\n    if (event.target instanceof Element && action in event.target && void 0 !== event.pointerId) {\n      try {\n        event.target[action](event.pointerId);\n      } catch (e) {\n      }\n    }\n  }\n  function isElementKeyboardAccessible(element) {\n    return focusableElements.has(element.tagName) || -1 !== element.tabIndex;\n  }\n  function filterEvents(callback) {\n    return event => {\n      \"Enter\" === event.key && callback(event);\n    };\n  }\n  function firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, {isPrimary:!0, bubbles:!0}));\n  }\n  function applyGeneratorOptions(options) {\n    if (isGenerator(options.type)) {\n      var _a = createGeneratorEasing(options, 100, options.type);\n      options.ease = supportsLinearEasing() ? _a.ease : \"easeOut\";\n      options.duration = motionUtils.secondsToMilliseconds(_a.duration);\n      options.type = \"keyframes\";\n    } else {\n      options.duration = motionUtils.secondsToMilliseconds(null !== (_a = options.duration) && void 0 !== _a ? _a : 0.3), options.ease = options.ease || \"easeOut\";\n    }\n  }\n  function getLayerName(pseudoElement) {\n    return (pseudoElement = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\\((.*?)\\)/)) ? {layer:pseudoElement[2], type:pseudoElement[1]} : null;\n  }\n  function filterViewAnimations(animation) {\n    var _a;\n    ({effect:animation} = animation);\n    return animation ? animation.target === document.documentElement && (null === (_a = animation.pseudoElement) || void 0 === _a ? void 0 : _a.startsWith(\"::view-transition\")) : !1;\n  }\n  function hasTarget(target, targets) {\n    return targets.has(target) && 0 < Object.keys(targets.get(target)).length;\n  }\n  function startViewAnimation(update, defaultOptions, targets) {\n    if (!document.startViewTransition) {\n      return new Promise(async resolve => {\n        await update();\n        resolve(new BaseGroupPlaybackControls([]));\n      });\n    }\n    hasTarget(\"root\", targets) || css.set(\":root\", {\"view-transition-name\":\"none\"});\n    css.set(\"::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)\", {\"animation-timing-function\":\"linear !important\"});\n    css.commit();\n    const transition = document.startViewTransition(async() => {\n      await update();\n    });\n    transition.finished.finally(() => {\n      css.remove();\n    });\n    return new Promise(resolve => {\n      transition.ready.then(() => {\n        var _a, generatedViewAnimations = document.getAnimations().filter(filterViewAnimations);\n        const animations = [];\n        targets.forEach((definition, target) => {\n          for (const key of definitionNames) {\n            if (!definition[key]) {\n              continue;\n            }\n            const {keyframes, options} = definition[key];\n            for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n              if (!valueKeyframes) {\n                continue;\n              }\n              var valueOptions = {...getValueTransition(defaultOptions, valueName), ...getValueTransition(options, valueName)};\n              const type = \"layout\" === key ? \"group\" : \"enter\" === key || \"new\" === key ? \"new\" : \"exit\" === key || \"old\" === key ? \"old\" : \"group\";\n              \"opacity\" !== valueName || Array.isArray(valueKeyframes) || (valueKeyframes = [\"new\" === type ? 0 : 1, valueKeyframes]);\n              \"function\" === typeof valueOptions.delay && (valueOptions.delay = valueOptions.delay(0, 1));\n              valueOptions = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\n              animations.push(valueOptions);\n            }\n          }\n        });\n        for (const animation of generatedViewAnimations) {\n          if (\"finished\" !== animation.playState && ({effect:generatedViewAnimations} = animation, generatedViewAnimations && generatedViewAnimations instanceof KeyframeEffect)) {\n            var {pseudoElement} = generatedViewAnimations;\n            if (pseudoElement && (pseudoElement = getLayerName(pseudoElement))) {\n              var targetDefinition = targets.get(pseudoElement.layer);\n              targetDefinition ? hasOpacity(targetDefinition, \"enter\") && hasOpacity(targetDefinition, \"exit\") && generatedViewAnimations.getKeyframes().some(keyframe => keyframe.mixBlendMode) ? animations.push(new NativeAnimationControls(animation)) : animation.cancel() : (pseudoElement = {...getValueTransition(defaultOptions, \"group\" === pseudoElement.type ? \"layout\" : \"\")}, applyGeneratorOptions(pseudoElement), targetDefinition = mapEasingToNativeEasing(pseudoElement.ease, pseudoElement.duration), \n              generatedViewAnimations.updateTiming({delay:motionUtils.secondsToMilliseconds(null !== (_a = pseudoElement.delay) && void 0 !== _a ? _a : 0), duration:pseudoElement.duration, easing:targetDefinition}), animations.push(new NativeAnimationControls(animation)));\n            }\n          }\n        }\n        resolve(new BaseGroupPlaybackControls(animations));\n      });\n    });\n  }\n  function hasOpacity(target, key) {\n    var _a;\n    return null === (_a = null === target || void 0 === target ? void 0 : target[key]) || void 0 === _a ? void 0 : _a.keyframes.opacity;\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  var motionUtils = require(\"module$node_modules$motion_utils$dist$cjs$index\");\n  const supportsScrollTimeline = motionUtils.memo(() => void 0 !== window.ScrollTimeline);\n  class BaseGroupPlaybackControls {\n    constructor(animations) {\n      this.stop = () => this.runAll(\"stop\");\n      this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n      return Promise.all(this.animations.map(animation => \"finished\" in animation ? animation.finished : animation));\n    }\n    getAll(propName) {\n      return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n      for (let i = 0; i < this.animations.length; i++) {\n        this.animations[i][propName] = newValue;\n      }\n    }\n    attachTimeline(timeline, fallback) {\n      const subscriptions = this.animations.map(animation => {\n        if (supportsScrollTimeline() && animation.attachTimeline) {\n          return animation.attachTimeline(timeline);\n        }\n        if (\"function\" === typeof fallback) {\n          return fallback(animation);\n        }\n      });\n      return () => {\n        subscriptions.forEach((cancel, i) => {\n          cancel && cancel();\n          this.animations[i].stop();\n        });\n      };\n    }\n    get time() {\n      return this.getAll(\"time\");\n    }\n    set time(time) {\n      this.setAll(\"time\", time);\n    }\n    get speed() {\n      return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n      this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n      return this.getAll(\"startTime\");\n    }\n    get duration() {\n      let max = 0;\n      for (let i = 0; i < this.animations.length; i++) {\n        max = Math.max(max, this.animations[i].duration);\n      }\n      return max;\n    }\n    runAll(methodName) {\n      this.animations.forEach(controls => controls[methodName]());\n    }\n    flatten() {\n      this.runAll(\"flatten\");\n    }\n    play() {\n      this.runAll(\"play\");\n    }\n    pause() {\n      this.runAll(\"pause\");\n    }\n    cancel() {\n      this.runAll(\"cancel\");\n    }\n    complete() {\n      this.runAll(\"complete\");\n    }\n  }\n  class GroupPlaybackControls extends BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n      return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n  }\n  class NativeAnimationControls {\n    constructor(animation) {\n      this.animation = animation;\n    }\n    get duration() {\n      var _a, _b, _c;\n      const durationInMs = (null === (_b = null === (_a = this.animation) || void 0 === _a ? void 0 : _a.effect) || void 0 === _b ? void 0 : _b.getComputedTiming().duration) || (null === (_c = this.options) || void 0 === _c ? void 0 : _c.duration) || 300;\n      return motionUtils.millisecondsToSeconds(Number(durationInMs));\n    }\n    get time() {\n      var _a;\n      return this.animation ? motionUtils.millisecondsToSeconds((null === (_a = this.animation) || void 0 === _a ? void 0 : _a.currentTime) || 0) : 0;\n    }\n    set time(newTime) {\n      this.animation && (this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime));\n    }\n    get speed() {\n      return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n      this.animation && (this.animation.playbackRate = newSpeed);\n    }\n    get state() {\n      return this.animation ? this.animation.playState : \"finished\";\n    }\n    get startTime() {\n      return this.animation ? this.animation.startTime : null;\n    }\n    get finished() {\n      return this.animation ? this.animation.finished : Promise.resolve();\n    }\n    play() {\n      this.animation && this.animation.play();\n    }\n    pause() {\n      this.animation && this.animation.pause();\n    }\n    stop() {\n      this.animation && \"idle\" !== this.state && \"finished\" !== this.state && (this.animation.commitStyles && this.animation.commitStyles(), this.cancel());\n    }\n    flatten() {\n      var _a;\n      this.animation && (null === (_a = this.animation.effect) || void 0 === _a || _a.updateTiming({easing:\"linear\"}));\n    }\n    attachTimeline(timeline) {\n      this.animation && attachTimeline(this.animation, timeline);\n      return motionUtils.noop;\n    }\n    complete() {\n      this.animation && this.animation.finish();\n    }\n    cancel() {\n      try {\n        this.animation && this.animation.cancel();\n      } catch (e) {\n      }\n    }\n  }\n  const isBezierDefinition = easing => Array.isArray(easing) && \"number\" === typeof easing[0], supportsFlags = {linearEasing:void 0}, supportsLinearEasing = function(callback, supportsFlag) {\n    const memoized = motionUtils.memo(callback);\n    return () => {\n      var _a;\n      return null !== (_a = supportsFlags[supportsFlag]) && void 0 !== _a ? _a : memoized();\n    };\n  }(() => {\n    try {\n      document.createElement(\"div\").animate({opacity:0}, {easing:\"linear(0, 1)\"});\n    } catch (e) {\n      return !1;\n    }\n    return !0;\n  }, \"linearEasing\"), generateLinearEasing = (easing, duration, resolution = 10) => {\n    let points = \"\";\n    duration = Math.max(Math.round(duration / resolution), 2);\n    for (resolution = 0; resolution < duration; resolution++) {\n      points += easing(motionUtils.progress(0, duration - 1, resolution)) + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n  }, cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`, supportedWaapiEasing = {linear:\"linear\", ease:\"ease\", easeIn:\"ease-in\", easeOut:\"ease-out\", easeInOut:\"ease-in-out\", circIn:cubicBezierAsString([0, 0.65, 0.55, 1]), circOut:cubicBezierAsString([0.55, 0, 1, 0.45]), backIn:cubicBezierAsString([0.31, 0.01, 0.66, -0.59]), backOut:cubicBezierAsString([0.33, 1.53, 0.69, 0.99])}, isDragging = {x:!1, y:!1}, isNodeOrChild = (parent, child) => child ? parent === child ? !0 : \n  isNodeOrChild(parent, child.parentElement) : !1, isPrimaryPointer = event => \"mouse\" === event.pointerType ? \"number\" !== typeof event.button || 0 >= event.button : !1 !== event.isPrimary, focusableElements = new Set([\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"A\"]), isPressing = new WeakSet(), enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (element) {\n      var handleKeydown = filterEvents(() => {\n        if (!isPressing.has(element)) {\n          firePointerEvent(element, \"down\");\n          var handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n          });\n          element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n          element.addEventListener(\"blur\", () => firePointerEvent(element, \"cancel\"), eventOptions);\n        }\n      });\n      element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n      element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n    }\n  };\n  class PseudoAnimation extends NativeAnimationControls {\n    constructor(target, pseudoElement, valueName, keyframes, options) {\n      var _a;\n      const nativeKeyframes = {}, nativeOptions = {fill:\"both\", easing:\"linear\", composite:\"replace\"};\n      nativeOptions.delay = motionUtils.secondsToMilliseconds(null !== (_a = options.delay) && void 0 !== _a ? _a : 0);\n      applyGeneratorOptions(options);\n      nativeOptions.duration = options.duration;\n      const {ease, times} = options;\n      times && (nativeKeyframes.offset = times);\n      nativeKeyframes[valueName] = keyframes;\n      valueName = mapEasingToNativeEasing(ease, options.duration);\n      Array.isArray(valueName) ? nativeKeyframes.easing = valueName : nativeOptions.easing = valueName;\n      super(target.animate(nativeKeyframes, {pseudoElement, ...nativeOptions}));\n    }\n  }\n  let pendingRules = {}, style = null;\n  const css = {set:(selector, values) => {\n    pendingRules[selector] = values;\n  }, commit:() => {\n    style || (style = document.createElement(\"style\"), style.id = \"motion-view\");\n    let cssText = \"\";\n    for (const selector in pendingRules) {\n      const rule = pendingRules[selector];\n      cssText += `${selector} {\\n`;\n      for (const [property, value] of Object.entries(rule)) {\n        cssText += `  ${property}: ${value};\\n`;\n      }\n      cssText += \"}\\n\";\n    }\n    style.textContent = cssText;\n    document.head.appendChild(style);\n    pendingRules = {};\n  }, remove:() => {\n    style && style.parentElement && style.parentElement.removeChild(style);\n  }}, definitionNames = [\"layout\", \"enter\", \"exit\", \"new\", \"old\"];\n  class ViewTransitionBuilder {\n    constructor(update, options = {}) {\n      this.currentTarget = \"root\";\n      this.targets = new Map();\n      this.notifyReady = motionUtils.noop;\n      this.readyPromise = new Promise(resolve => {\n        this.notifyReady = resolve;\n      });\n      queueMicrotask(() => {\n        startViewAnimation(update, options, this.targets).then(animation => this.notifyReady(animation));\n      });\n    }\n    get(selector) {\n      this.currentTarget = selector;\n      return this;\n    }\n    layout(keyframes, options) {\n      this.updateTarget(\"layout\", keyframes, options);\n      return this;\n    }\n    new(keyframes, options) {\n      this.updateTarget(\"new\", keyframes, options);\n      return this;\n    }\n    old(keyframes, options) {\n      this.updateTarget(\"old\", keyframes, options);\n      return this;\n    }\n    enter(keyframes, options) {\n      this.updateTarget(\"enter\", keyframes, options);\n      return this;\n    }\n    exit(keyframes, options) {\n      this.updateTarget(\"exit\", keyframes, options);\n      return this;\n    }\n    crossfade(options) {\n      this.updateTarget(\"enter\", {opacity:1}, options);\n      this.updateTarget(\"exit\", {opacity:0}, options);\n      return this;\n    }\n    updateTarget(target, keyframes, options = {}) {\n      const {currentTarget, targets} = this;\n      targets.has(currentTarget) || targets.set(currentTarget, {});\n      targets.get(currentTarget)[target] = {keyframes, options};\n    }\n    then(resolve, reject) {\n      return this.readyPromise.then(resolve, reject);\n    }\n  }\n  exports.GroupPlaybackControls = GroupPlaybackControls;\n  exports.NativeAnimationControls = NativeAnimationControls;\n  exports.ViewTransitionBuilder = ViewTransitionBuilder;\n  exports.attachTimeline = attachTimeline;\n  exports.calcGeneratorDuration = calcGeneratorDuration;\n  exports.capturePointer = capturePointer;\n  exports.createGeneratorEasing = createGeneratorEasing;\n  exports.cubicBezierAsString = cubicBezierAsString;\n  exports.generateLinearEasing = generateLinearEasing;\n  exports.getValueTransition = getValueTransition;\n  exports.hover = function(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options), onPointerEnter = enterEvent => {\n      if (\"touch\" !== enterEvent.pointerType && !isDragActive()) {\n        var {target} = enterEvent, onHoverEnd = onHoverStart(target, enterEvent);\n        if (\"function\" === typeof onHoverEnd && target) {\n          var onPointerLeave = leaveEvent => {\n            \"touch\" === leaveEvent.pointerType || isDragActive() || (onHoverEnd(leaveEvent), target.removeEventListener(\"pointerleave\", onPointerLeave));\n          };\n          target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n        }\n      }\n    };\n    elements.forEach(element => {\n      element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n  };\n  exports.isBezierDefinition = isBezierDefinition;\n  exports.isDragActive = isDragActive;\n  exports.isDragging = isDragging;\n  exports.isGenerator = isGenerator;\n  exports.isNodeOrChild = isNodeOrChild;\n  exports.isPrimaryPointer = isPrimaryPointer;\n  exports.isWaapiSupportedEasing = isWaapiSupportedEasing;\n  exports.mapEasingToNativeEasing = mapEasingToNativeEasing;\n  exports.maxGeneratorDuration = 20000;\n  exports.press = function(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options), startPress = startEvent => {\n      const target = startEvent.currentTarget;\n      if (target && isPrimaryPointer(startEvent) && !isDragActive() && !isPressing.has(target)) {\n        isPressing.add(target);\n        capturePointer(startEvent, \"set\");\n        var onPressEnd = onPressStart(target, startEvent), onPointerEnd = (endEvent, success) => {\n          target.removeEventListener(\"pointerup\", onPointerUp);\n          target.removeEventListener(\"pointercancel\", onPointerCancel);\n          capturePointer(endEvent, \"release\");\n          isPrimaryPointer(endEvent) && !isDragActive() && isPressing.has(target) && (isPressing.delete(target), \"function\" === typeof onPressEnd && onPressEnd(endEvent, {success}));\n        }, onPointerUp = upEvent => {\n          if (upEvent.isTrusted) {\n            var JSCompiler_temp = target instanceof Element ? target.getBoundingClientRect() : {left:0, top:0, right:window.innerWidth, bottom:window.innerHeight};\n            JSCompiler_temp = upEvent.clientX < JSCompiler_temp.left || upEvent.clientX > JSCompiler_temp.right || upEvent.clientY < JSCompiler_temp.top || upEvent.clientY > JSCompiler_temp.bottom;\n          } else {\n            JSCompiler_temp = !1;\n          }\n          JSCompiler_temp ? onPointerEnd(upEvent, !1) : onPointerEnd(upEvent, !(target instanceof Element) || isNodeOrChild(target, upEvent.target));\n        }, onPointerCancel = cancelEvent => {\n          onPointerEnd(cancelEvent, !1);\n        };\n        target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n        target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n      }\n    };\n    targets.forEach(target => {\n      target = options.useGlobalTarget ? window : target;\n      let canAddKeyboardAccessibility = !1;\n      target instanceof HTMLElement && (canAddKeyboardAccessibility = !0, isElementKeyboardAccessible(target) || null !== target.getAttribute(\"tabindex\") || (target.tabIndex = 0));\n      target.addEventListener(\"pointerdown\", startPress, eventOptions);\n      canAddKeyboardAccessibility && target.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n  };\n  exports.resolveElements = resolveElements;\n  exports.setDragLock = function(axis) {\n    if (\"x\" === axis || \"y\" === axis) {\n      if (isDragging[axis]) {\n        return null;\n      }\n      isDragging[axis] = !0;\n      return () => {\n        isDragging[axis] = !1;\n      };\n    }\n    if (isDragging.x || isDragging.y) {\n      return null;\n    }\n    isDragging.x = isDragging.y = !0;\n    return () => {\n      isDragging.x = isDragging.y = !1;\n    };\n  };\n  exports.supportedWaapiEasing = supportedWaapiEasing;\n  exports.supportsFlags = supportsFlags;\n  exports.supportsLinearEasing = supportsLinearEasing;\n  exports.supportsScrollTimeline = supportsScrollTimeline;\n  exports.view = function(update, defaultOptions = {}) {\n    return new ViewTransitionBuilder(update, defaultOptions);\n  };\n};\n","~:source","shadow$provide[\"module$node_modules$motion_dom$dist$cjs$index\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar motionUtils = require('motion-utils');\n\nconst supportsScrollTimeline = motionUtils.memo(() => window.ScrollTimeline !== undefined);\n\nclass BaseGroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        // Support for new finished Promise and legacy thennable API\n        return Promise.all(this.animations.map((animation) => \"finished\" in animation ? animation.finished : animation));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            }\n            else if (typeof fallback === \"function\") {\n                return fallback(animation);\n            }\n        });\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    flatten() {\n        this.runAll(\"flatten\");\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\n/**\n * TODO: This is a temporary class to support the legacy\n * thennable API\n */\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n}\n\nfunction getValueTransition(transition, key) {\n    return transition\n        ? transition[key] ||\n            transition[\"default\"] ||\n            transition\n        : undefined;\n}\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: motionUtils.millisecondsToSeconds(duration),\n    };\n}\n\nfunction isGenerator(type) {\n    return typeof type === \"function\";\n}\n\nfunction attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\n\nclass NativeAnimationControls {\n    constructor(animation) {\n        this.animation = animation;\n    }\n    get duration() {\n        var _a, _b, _c;\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\n            300;\n        return motionUtils.millisecondsToSeconds(Number(durationInMs));\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return motionUtils.millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : \"finished\";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    get finished() {\n        return this.animation ? this.animation.finished : Promise.resolve();\n    }\n    play() {\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation ||\n            this.state === \"idle\" ||\n            this.state === \"finished\") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    flatten() {\n        var _a;\n        if (!this.animation)\n            return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: \"linear\" });\n    }\n    attachTimeline(timeline) {\n        if (this.animation)\n            attachTimeline(this.animation, timeline);\n        return motionUtils.noop;\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        try {\n            this.animation && this.animation.cancel();\n        }\n        catch (e) { }\n    }\n}\n\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {\n    linearEasing: undefined,\n};\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = motionUtils.memo(callback);\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\n}\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nconst generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(motionUtils.progress(0, numPoints - 1, i)) + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean((typeof easing === \"function\" && supportsLinearEasing()) ||\n        !easing ||\n        (typeof easing === \"string\" &&\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nconst isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     \"Scope provided, but no element detected.\"\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nfunction isValidHover(event) {\n    return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = (enterEvent) => {\n        if (!isValidHover(enterEvent))\n            return;\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(target, enterEvent);\n        if (typeof onHoverEnd !== \"function\" || !target)\n            return;\n        const onPointerLeave = (leaveEvent) => {\n            if (!isValidHover(leaveEvent))\n                return;\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nfunction capturePointer(event, action) {\n    const actionName = `${action}PointerCapture`;\n    if (event.target instanceof Element &&\n        actionName in event.target &&\n        event.pointerId !== undefined) {\n        try {\n            event.target[actionName](event.pointerId);\n        }\n        catch (e) { }\n    }\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nconst isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nconst focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\nconst isPressing = new WeakSet();\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n    const startPress = (startEvent) => {\n        const target = startEvent.currentTarget;\n        if (!target || !isValidPressEvent(startEvent) || isPressing.has(target))\n            return;\n        isPressing.add(target);\n        capturePointer(startEvent, \"set\");\n        const onPressEnd = onPressStart(target, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            target.removeEventListener(\"pointerup\", onPointerUp);\n            target.removeEventListener(\"pointercancel\", onPointerCancel);\n            capturePointer(endEvent, \"release\");\n            if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n                return;\n            }\n            isPressing.delete(target);\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            const isOutside = !upEvent.isTrusted\n                ? false\n                : checkOutside(upEvent, target instanceof Element\n                    ? target.getBoundingClientRect()\n                    : {\n                        left: 0,\n                        top: 0,\n                        right: window.innerWidth,\n                        bottom: window.innerHeight,\n                    });\n            if (isOutside) {\n                onPointerEnd(upEvent, false);\n            }\n            else {\n                onPointerEnd(upEvent, !(target instanceof Element) ||\n                    isNodeOrChild(target, upEvent.target));\n            }\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n        target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n    };\n    targets.forEach((target) => {\n        target = options.useGlobalTarget ? window : target;\n        let canAddKeyboardAccessibility = false;\n        if (target instanceof HTMLElement) {\n            canAddKeyboardAccessibility = true;\n            if (!isElementKeyboardAccessible(target) &&\n                target.getAttribute(\"tabindex\") === null) {\n                target.tabIndex = 0;\n            }\n        }\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        if (canAddKeyboardAccessibility) {\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n        }\n    });\n    return cancelEvents;\n}\nfunction checkOutside(event, rect) {\n    return (event.clientX < rect.left ||\n        event.clientX > rect.right ||\n        event.clientY < rect.top ||\n        event.clientY > rect.bottom);\n}\n\nconst defaultEasing = \"easeOut\";\nfunction applyGeneratorOptions(options) {\n    var _a;\n    if (isGenerator(options.type)) {\n        const generatorOptions = createGeneratorEasing(options, 100, options.type);\n        options.ease = supportsLinearEasing()\n            ? generatorOptions.ease\n            : defaultEasing;\n        options.duration = motionUtils.secondsToMilliseconds(generatorOptions.duration);\n        options.type = \"keyframes\";\n    }\n    else {\n        options.duration = motionUtils.secondsToMilliseconds((_a = options.duration) !== null && _a !== void 0 ? _a : 0.3);\n        options.ease = options.ease || defaultEasing;\n    }\n}\n// TODO: Reuse for NativeAnimation\nfunction convertMotionOptionsToNative(valueName, keyframes, options) {\n    var _a;\n    const nativeKeyframes = {};\n    const nativeOptions = {\n        fill: \"both\",\n        easing: \"linear\",\n        composite: \"replace\",\n    };\n    nativeOptions.delay = motionUtils.secondsToMilliseconds((_a = options.delay) !== null && _a !== void 0 ? _a : 0);\n    applyGeneratorOptions(options);\n    nativeOptions.duration = options.duration;\n    const { ease, times } = options;\n    if (times)\n        nativeKeyframes.offset = times;\n    nativeKeyframes[valueName] = keyframes;\n    const easing = mapEasingToNativeEasing(ease, options.duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing)) {\n        nativeKeyframes.easing = easing;\n    }\n    else {\n        nativeOptions.easing = easing;\n    }\n    return {\n        keyframes: nativeKeyframes,\n        options: nativeOptions,\n    };\n}\n\nclass PseudoAnimation extends NativeAnimationControls {\n    constructor(target, pseudoElement, valueName, keyframes, options) {\n        const animationOptions = convertMotionOptionsToNative(valueName, keyframes, options);\n        const animation = target.animate(animationOptions.keyframes, {\n            pseudoElement,\n            ...animationOptions.options,\n        });\n        super(animation);\n    }\n}\n\nfunction chooseLayerType(valueName) {\n    if (valueName === \"layout\")\n        return \"group\";\n    if (valueName === \"enter\" || valueName === \"new\")\n        return \"new\";\n    if (valueName === \"exit\" || valueName === \"old\")\n        return \"old\";\n    return \"group\";\n}\n\nlet pendingRules = {};\nlet style = null;\nconst css = {\n    set: (selector, values) => {\n        pendingRules[selector] = values;\n    },\n    commit: () => {\n        if (!style) {\n            style = document.createElement(\"style\");\n            style.id = \"motion-view\";\n        }\n        let cssText = \"\";\n        for (const selector in pendingRules) {\n            const rule = pendingRules[selector];\n            cssText += `${selector} {\\n`;\n            for (const [property, value] of Object.entries(rule)) {\n                cssText += `  ${property}: ${value};\\n`;\n            }\n            cssText += \"}\\n\";\n        }\n        style.textContent = cssText;\n        document.head.appendChild(style);\n        pendingRules = {};\n    },\n    remove: () => {\n        if (style && style.parentElement) {\n            style.parentElement.removeChild(style);\n        }\n    },\n};\n\nfunction getLayerName(pseudoElement) {\n    const match = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\\((.*?)\\)/);\n    if (!match)\n        return null;\n    return { layer: match[2], type: match[1] };\n}\n\nfunction filterViewAnimations(animation) {\n    var _a;\n    const { effect } = animation;\n    if (!effect)\n        return false;\n    return (effect.target === document.documentElement &&\n        ((_a = effect.pseudoElement) === null || _a === void 0 ? void 0 : _a.startsWith(\"::view-transition\")));\n}\nfunction getViewAnimations() {\n    return document.getAnimations().filter(filterViewAnimations);\n}\n\nfunction hasTarget(target, targets) {\n    return targets.has(target) && Object.keys(targets.get(target)).length > 0;\n}\n\nconst definitionNames = [\"layout\", \"enter\", \"exit\", \"new\", \"old\"];\nfunction startViewAnimation(update, defaultOptions, targets) {\n    if (!document.startViewTransition) {\n        return new Promise(async (resolve) => {\n            await update();\n            resolve(new BaseGroupPlaybackControls([]));\n        });\n    }\n    // TODO: Go over existing targets and ensure they all have ids\n    /**\n     * If we don't have any animations defined for the root target,\n     * remove it from being captured.\n     */\n    if (!hasTarget(\"root\", targets)) {\n        css.set(\":root\", {\n            \"view-transition-name\": \"none\",\n        });\n    }\n    /**\n     * Set the timing curve to linear for all view transition layers.\n     * This gets baked into the keyframes, which can't be changed\n     * without breaking the generated animation.\n     *\n     * This allows us to set easing via updateTiming - which can be changed.\n     */\n    css.set(\"::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)\", { \"animation-timing-function\": \"linear !important\" });\n    css.commit(); // Write\n    const transition = document.startViewTransition(async () => {\n        await update();\n        // TODO: Go over new targets and ensure they all have ids\n    });\n    transition.finished.finally(() => {\n        css.remove(); // Write\n    });\n    return new Promise((resolve) => {\n        transition.ready.then(() => {\n            var _a;\n            const generatedViewAnimations = getViewAnimations();\n            const animations = [];\n            /**\n             * Create animations for our definitions\n             */\n            targets.forEach((definition, target) => {\n                // TODO: If target is not \"root\", resolve elements\n                // and iterate over each\n                for (const key of definitionNames) {\n                    if (!definition[key])\n                        continue;\n                    const { keyframes, options } = definition[key];\n                    for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n                        if (!valueKeyframes)\n                            continue;\n                        const valueOptions = {\n                            ...getValueTransition(defaultOptions, valueName),\n                            ...getValueTransition(options, valueName),\n                        };\n                        const type = chooseLayerType(key);\n                        /**\n                         * If this is an opacity animation, and keyframes are not an array,\n                         * we need to convert them into an array and set an initial value.\n                         */\n                        if (valueName === \"opacity\" &&\n                            !Array.isArray(valueKeyframes)) {\n                            const initialValue = type === \"new\" ? 0 : 1;\n                            valueKeyframes = [initialValue, valueKeyframes];\n                        }\n                        /**\n                         * Resolve stagger function if provided.\n                         */\n                        if (typeof valueOptions.delay === \"function\") {\n                            valueOptions.delay = valueOptions.delay(0, 1);\n                        }\n                        const animation = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\n                        animations.push(animation);\n                    }\n                }\n            });\n            /**\n             * Handle browser generated animations\n             */\n            for (const animation of generatedViewAnimations) {\n                if (animation.playState === \"finished\")\n                    continue;\n                const { effect } = animation;\n                if (!effect || !(effect instanceof KeyframeEffect))\n                    continue;\n                const { pseudoElement } = effect;\n                if (!pseudoElement)\n                    continue;\n                const name = getLayerName(pseudoElement);\n                if (!name)\n                    continue;\n                const targetDefinition = targets.get(name.layer);\n                if (!targetDefinition) {\n                    /**\n                     * If transition name is group then update the timing of the animation\n                     * whereas if it's old or new then we could possibly replace it using\n                     * the above method.\n                     */\n                    const transitionName = name.type === \"group\" ? \"layout\" : \"\";\n                    const animationTransition = {\n                        ...getValueTransition(defaultOptions, transitionName),\n                    };\n                    applyGeneratorOptions(animationTransition);\n                    const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\n                    effect.updateTiming({\n                        delay: motionUtils.secondsToMilliseconds((_a = animationTransition.delay) !== null && _a !== void 0 ? _a : 0),\n                        duration: animationTransition.duration,\n                        easing,\n                    });\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else if (hasOpacity(targetDefinition, \"enter\") &&\n                    hasOpacity(targetDefinition, \"exit\") &&\n                    effect\n                        .getKeyframes()\n                        .some((keyframe) => keyframe.mixBlendMode)) {\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else {\n                    animation.cancel();\n                }\n            }\n            resolve(new BaseGroupPlaybackControls(animations));\n        });\n    });\n}\nfunction hasOpacity(target, key) {\n    var _a;\n    return (_a = target === null || target === void 0 ? void 0 : target[key]) === null || _a === void 0 ? void 0 : _a.keyframes.opacity;\n}\n\n/**\n * TODO:\n * - Create view transition on next tick\n * - Replace animations with Motion animations\n * - Return GroupAnimation on next tick\n */\nclass ViewTransitionBuilder {\n    constructor(update, options = {}) {\n        this.currentTarget = \"root\";\n        this.targets = new Map();\n        this.notifyReady = motionUtils.noop;\n        this.readyPromise = new Promise((resolve) => {\n            this.notifyReady = resolve;\n        });\n        queueMicrotask(() => {\n            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));\n        });\n    }\n    get(selector) {\n        this.currentTarget = selector;\n        return this;\n    }\n    layout(keyframes, options) {\n        this.updateTarget(\"layout\", keyframes, options);\n        return this;\n    }\n    new(keyframes, options) {\n        this.updateTarget(\"new\", keyframes, options);\n        return this;\n    }\n    old(keyframes, options) {\n        this.updateTarget(\"old\", keyframes, options);\n        return this;\n    }\n    enter(keyframes, options) {\n        this.updateTarget(\"enter\", keyframes, options);\n        return this;\n    }\n    exit(keyframes, options) {\n        this.updateTarget(\"exit\", keyframes, options);\n        return this;\n    }\n    crossfade(options) {\n        this.updateTarget(\"enter\", { opacity: 1 }, options);\n        this.updateTarget(\"exit\", { opacity: 0 }, options);\n        return this;\n    }\n    updateTarget(target, keyframes, options = {}) {\n        const { currentTarget, targets } = this;\n        if (!targets.has(currentTarget)) {\n            targets.set(currentTarget, {});\n        }\n        const targetData = targets.get(currentTarget);\n        targetData[target] = { keyframes, options };\n    }\n    then(resolve, reject) {\n        return this.readyPromise.then(resolve, reject);\n    }\n}\nfunction view(update, defaultOptions = {}) {\n    return new ViewTransitionBuilder(update, defaultOptions);\n}\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexports.GroupPlaybackControls = GroupPlaybackControls;\nexports.NativeAnimationControls = NativeAnimationControls;\nexports.ViewTransitionBuilder = ViewTransitionBuilder;\nexports.attachTimeline = attachTimeline;\nexports.calcGeneratorDuration = calcGeneratorDuration;\nexports.capturePointer = capturePointer;\nexports.createGeneratorEasing = createGeneratorEasing;\nexports.cubicBezierAsString = cubicBezierAsString;\nexports.generateLinearEasing = generateLinearEasing;\nexports.getValueTransition = getValueTransition;\nexports.hover = hover;\nexports.isBezierDefinition = isBezierDefinition;\nexports.isDragActive = isDragActive;\nexports.isDragging = isDragging;\nexports.isGenerator = isGenerator;\nexports.isNodeOrChild = isNodeOrChild;\nexports.isPrimaryPointer = isPrimaryPointer;\nexports.isWaapiSupportedEasing = isWaapiSupportedEasing;\nexports.mapEasingToNativeEasing = mapEasingToNativeEasing;\nexports.maxGeneratorDuration = maxGeneratorDuration;\nexports.press = press;\nexports.resolveElements = resolveElements;\nexports.setDragLock = setDragLock;\nexports.supportedWaapiEasing = supportedWaapiEasing;\nexports.supportsFlags = supportsFlags;\nexports.supportsLinearEasing = supportsLinearEasing;\nexports.supportsScrollTimeline = supportsScrollTimeline;\nexports.view = view;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$motion_utils$dist$cjs$index"]],"~:properties",["^5",["stop","success","linearEasing","backOut","easeIn","easing","NativeAnimationControls","right","passive","isDragging","supportsScrollTimeline","top","currentTarget","circOut","offset","supportsFlags","tabIndex","timeline","currentTime","ease","GroupPlaybackControls","circIn","textContent","x","__esModule","notifyReady","composite","setDragLock","resolveElements","id","press","mapEasingToNativeEasing","cubicBezierAsString","playbackRate","pseudoElement","signal","isPrimaryPointer","animation","commit","value","supportedWaapiEasing","linear","isWaapiSupportedEasing","fill","remove","isBezierDefinition","targets","readyPromise","isNodeOrChild","isGenerator","bubbles","animations","calcGeneratorDuration","duration","delay","ViewTransitionBuilder","type","y","maxGeneratorDuration","generateLinearEasing","getValueTransition","isDragActive","easeInOut","bottom","set","keyframes","layer","easeOut","onfinish","hover","options","createGeneratorEasing","capturePointer","view","attachTimeline","backIn","isPrimary","opacity","supportsLinearEasing","left"]],"~:compiled-at",1740925089077,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$motion_dom$dist$cjs$index.js\",\n\"lineCount\":510,\n\"mappings\":\"AAAAA,cAAA,CAAA,6CAAA,GAAkE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAkG1GC,UAASA,mBAAkB,CAACC,UAAD,EAAaC,GAAb,CAAkB;AACzC,WAAOD,UAAA,GACDA,UAAA,CAAWC,GAAX,CADC,IAECD,UAAA,CAAW,SAAX,CAFD,IAGCA,UAHD,GAIDE,IAAAA,EAJN;AADyC;AAa7CC,UAASA,sBAAqB,CAACC,SAAD,CAAY;AACtC,QAAIC,WAAW,CAAf,EAEIC,QAAQF,SAAUG,CAAAA,IAAV,CAAeF,QAAf,CAFZ;AAGA,SAAA,EAAO,CAACC,KAAME,CAAAA,IAAd,IALyBC,KAKzB,GAAsBJ,QAAtB,CAAA;AACIA,cACA,IAJaK,EAIb,EAAAJ,KAAA,GAAQF,SAAUG,CAAAA,IAAV,CAAeF,QAAf,CAAR;AAFJ;AAIA,WATyBI,KASlB,IAAAJ,QAAA,GAAmCM,QAAnC,GAA8CN,QAArD;AARsC;AAc1CO,UAASA,sBAAqB,CAACC,OAAD,EAAUC,KAAA,GAAQ,GAAlB,EAAuBC,eAAvB,CAAwC;AAClE,UAAMX,YAAYW,eAAA,CAAgB,CAAE,GAAGF,OAAL,EAAcG,UAAW,CAAC,CAAD,EAAIF,KAAJ,CAAzB,CAAhB,CAAlB,EACMT,WAAWY,IAAKC,CAAAA,GAAL,CAASf,qBAAA,CAAsBC,SAAtB,CAAT,EAjBQK,KAiBR,CADjB;AAEA,WAAO,CACHU,KAAM,WADH,EAEHC,KAAOC,QAADD,IACKhB,SAAUG,CAAAA,IAAV,CAAeF,QAAf,GAA0BgB,QAA1B,CAAoCC,CAAAA,KADzCF,GACiDN,KAHpD,EAKHT,SAAUkB,WAAYC,CAAAA,qBAAZ,CAAkCnB,QAAlC,CALP,CAAP;AAHkE;AAYtEoB,UAASA,YAAW,CAACN,IAAD,CAAO;AACvB,WAAuB,UAAvB,KAAO,MAAOA,KAAd;AADuB;AAI3BO,UAASA,eAAc,CAACC,SAAD,EAAYC,QAAZ,CAAsB;AACzCD,aAAUC,CAAAA,QAAV,GAAqBA,QAArB;AACAD,aAAUE,CAAAA,QAAV,GAAqB,IAArB;AAFyC;AA0H7CC,UAASA,uBAAsB,CAACC,MAAD,CAAS;AACpC,WAAO,CAAA,EAA2B,UAA3B,KAAS,MAAOA,OAAhB,IAAyCC,oBAAA,EAAzC,IACH,CAACD,MADE,IAEgB,QAFhB,KAEF,MAAOA,OAFL,KAGEA,MAHF,IAGYE,oBAHZ,IAGoCD,oBAAA,EAHpC,KAIHE,kBAAA,CAAmBH,MAAnB,CAJG,IAKFI,KAAMC,CAAAA,OAAN,CAAcL,MAAd,CALE,IAKuBA,MAAOM,CAAAA,KAAP,CAAaP,sBAAb,CALvB,CAAP;AADoC;AAoBxCQ,UAASA,wBAAuB,CAACP,MAAD,EAAS1B,QAAT,CAAmB;AAC/C,QAAK0B,MAAL;AAGK,aAAsB,UAAtB,KAAI,MAAOA,OAAX,IAAoCC,oBAAA,EAApC,GACMO,oBAAA,CAAqBR,MAArB,EAA6B1B,QAA7B,CADN,GAGI6B,kBAAA,CAAmBH,MAAnB,CAAJ,GACMS,mBAAA,CAAoBT,MAApB,CADN,GAGII,KAAMC,CAAAA,OAAN,CAAcL,MAAd,CAAJ,GACMA,MAAOU,CAAAA,GAAP,CAAYC,aAAD,IAAmBJ,uBAAA,CAAwBI,aAAxB,EAAuCrC,QAAvC,CAAnB,IACd4B,oBAAqBU,CAAAA,OADlB,CADN,GAKMV,oBAAA,CAAqBF,MAArB,CAXN;AAHL;AAD+C;AAuBnDa,UAASA,aAAY,EAAG;AACpB,WAAOC,UAAWC,CAAAA,CAAlB,IAAuBD,UAAWE,CAAAA,CAAlC;AADoB;AAIxBC,UAASA,gBAAe,CAACC,iBAAD,EAAoBC,KAApB,EAA2BC,aAA3B,CAA0C;AAC9D,QAAIC,EAAJ;AACA,QAAIH,iBAAJ,YAAiCI,WAAjC;AACI,aAAO,CAACJ,iBAAD,CAAP;AADJ;AAGK,QAAiC,QAAjC,KAAI,MAAOA,kBAAX,CAA2C;AAC5C,UAAIK,OAAOC,QAAX;AACIL,WAAJ,KAMII,IANJ,GAMWJ,KAAMM,CAAAA,OANjB;AASA,aAAO,CADDC,KACC,GADoH,IAA1G,MAACL,EAAD,GAAwB,IAAlB,KAAAD,aAAA,IAA4C,IAAK,EAAjD,KAA0BA,aAA1B,GAAqD,IAAK,EAA1D,GAA8DA,aAAA,CAAcF,iBAAd,CAApE,KAAyH,IAAK,EAA9H,KAAkHG,EAAlH,GAAkIA,EAAlI,GAAuIE,IAAKI,CAAAA,gBAAL,CAAsBT,iBAAtB,CACjJ,IAAWd,KAAMwB,CAAAA,IAAN,CAAWF,KAAX,CAAX,GAAkC,EAAzC;AAX4C;AAahD,WAAOtB,KAAMwB,CAAAA,IAAN,CAAWV,iBAAX,CAAP;AAlB8D;AAqBlEW,UAASA,aAAY,CAACX,iBAAD,EAAoBpC,OAApB,CAA6B;AACxC4C,qBAAAA,GAAWT,eAAA,CAAgBC,iBAAhB,CAAXQ;AACN,UAAMI,yBAAyB,IAAIC,eAAJ,EAA/B;AAOA,WAAO,CAACL,iBAAD,EANcM,CACjBC,QAAS,CAAA,CADQD,EAEjB,GAAGlD,OAFckD,EAGjBE,OAAQJ,sBAAuBI,CAAAA,MAHdF,CAMd,EADQ,EAAAG,IAAML,sBAAuBM,CAAAA,KAAvB,EACd,CAAP;AAT8C;AA6ClDC,UAASA,eAAc,CAACC,KAAD,EAAQC,MAAR,CAAgB;AAC7BC,UAAAA,GAAc,GAAED,MAAF,gBAAdC;AACN,QAAIF,KAAMG,CAAAA,MAAV,YAA4BC,OAA5B,IACIF,MADJ,IACkBF,KAAMG,CAAAA,MADxB,IAEwBtE,IAAAA,EAFxB,KAEImE,KAAMK,CAAAA,SAFV;AAGI,SAAI;AACAL,aAAMG,CAAAA,MAAN,CAAaD,MAAb,CAAA,CAAyBF,KAAMK,CAAAA,SAA/B,CAAA;AADA,OAGJ,QAAOC,CAAP,CAAU;;AANd;AAFmC;AAuDvCC,UAASA,4BAA2B,CAACC,OAAD,CAAU;AAC1C,WAAQC,iBAAkBC,CAAAA,GAAlB,CAAsBF,OAAQG,CAAAA,OAA9B,CAAR,IACyB,CAAC,CAD1B,KACIH,OAAQI,CAAAA,QADZ;AAD0C;AAU9CC,UAASA,aAAY,CAACC,QAAD,CAAW;AAC5B,WAAQd,KAAD,IAAW;AACI,aAAlB,KAAIA,KAAMpE,CAAAA,GAAV,IAEAkF,QAAA,CAASd,KAAT,CAFA;AADc,KAAlB;AAD4B;AAOhCe,UAASA,iBAAgB,CAACZ,MAAD,EAASrD,IAAT,CAAe;AACpCqD,UAAOa,CAAAA,aAAP,CAAqB,IAAIC,YAAJ,CAAiB,SAAjB,GAA6BnE,IAA7B,EAAmC,CAAEoE,UAAW,CAAA,CAAb,EAAmBC,QAAS,CAAA,CAA5B,CAAnC,CAArB,CAAA;AADoC;AA2HxCC,UAASA,sBAAqB,CAAC5E,OAAD,CAAU;AAEpC,QAAIY,WAAA,CAAYZ,OAAQM,CAAAA,IAApB,CAAJ,CAA+B;AACrBuE,UAAAA,KAAmB9E,qBAAA,CAAsBC,OAAtB,EAA+B,GAA/B,EAAoCA,OAAQM,CAAAA,IAA5C,CAAnBuE;AACN7E,aAAQO,CAAAA,IAAR,GAAeY,oBAAA,EAAA,GACT0D,EAAiBtE,CAAAA,IADR,GALDuE,SAKd;AAGA9E,aAAQR,CAAAA,QAAR,GAAmBkB,WAAYqE,CAAAA,qBAAZ,CAAkCF,EAAiBrF,CAAAA,QAAnD,CAAnB;AACAQ,aAAQM,CAAAA,IAAR,GAAe,WAAf;AAN2B,KAA/B;AASIN,aAAQR,CAAAA,QACR,GADmBkB,WAAYqE,CAAAA,qBAAZ,CAA8D,IAA5B,MAACxC,EAAD,GAAMvC,OAAQR,CAAAA,QAAd,KAA2C,IAAK,EAAhD,KAAoC+C,EAApC,GAAoDA,EAApD,GAAyD,GAA3F,CACnB,EAAAvC,OAAQO,CAAAA,IAAR,GAAeP,OAAQO,CAAAA,IAAvB,IAbcuE,SAad;AAVJ;AAFoC;AAmGxCE,UAASA,aAAY,CAACC,aAAD,CAAgB;AAEjC,WAAA,CADMC,aACN,GADcD,aAAcC,CAAAA,KAAd,CAAoB,uDAApB,CACd,IAEO,CAAEC,MAAOD,aAAA,CAAM,CAAN,CAAT,EAAmB5E,KAAM4E,aAAA,CAAM,CAAN,CAAzB,CAFP,GACW,IADX;AAFiC;AAOrCE,UAASA,qBAAoB,CAACtE,SAAD,CAAY;AACrC,QAAIyB,EAAJ;AACA,KAAM,CAAE,OAAA8C,SAAF,CAAN,GAAmBvE,SAAnB;AACA,WAAKuE,SAAL,GAEQA,SAAO1B,CAAAA,MAFf,KAE0BjB,QAAS4C,CAAAA,eAFnC,KAGqC,IAAhC,MAAC/C,EAAD,GAAM8C,SAAOJ,CAAAA,aAAb,KAA+C,IAAK,EAApD,KAAwC1C,EAAxC,GAAwD,IAAK,EAA7D,GAAiEA,EAAGgD,CAAAA,UAAH,CAAc,mBAAd,CAHtE,IACW,CAAA,CADX;AAHqC;AAYzCC,UAASA,UAAS,CAAC7B,MAAD,EAAS8B,OAAT,CAAkB;AAChC,WAAOA,OAAQvB,CAAAA,GAAR,CAAYP,MAAZ,CAAP,IAAwE,CAAxE,GAA8B+B,MAAOC,CAAAA,IAAP,CAAYF,OAAQG,CAAAA,GAAR,CAAYjC,MAAZ,CAAZ,CAAiCkC,CAAAA,MAA/D;AADgC;AAKpCC,UAASA,mBAAkB,CAACC,MAAD,EAASC,cAAT,EAAyBP,OAAzB,CAAkC;AACzD,QAAI,CAAC/C,QAASuD,CAAAA,mBAAd;AACI,aAAO,IAAIC,OAAJ,CAAY,KAAOC,QAAP,IAAmB;AAClC,cAAMJ,MAAA,EAAN;AACAI,eAAA,CAAQ,IAAIC,yBAAJ,CAA8B,EAA9B,CAAR,CAAA;AAFkC,OAA/B,CAAP;AADJ;AAWKZ,aAAA,CAAU,MAAV,EAAkBC,OAAlB,CAAL,IACIY,GAAIC,CAAAA,GAAJ,CAAQ,OAAR,EAAiB,CACb,uBAAwB,MADX,CAAjB,CADJ;AAYAD,OAAIC,CAAAA,GAAJ,CAAQ,gFAAR,EAA0F,CAAE,4BAA6B,mBAA/B,CAA1F,CAAA;AACAD,OAAIE,CAAAA,MAAJ,EAAA;AACA,UAAMpH,aAAauD,QAASuD,CAAAA,mBAAT,CAA6B,KAAM,EAAN,IAAY;AACxD,YAAMF,MAAA,EAAN;AADwD,KAAzC,CAAnB;AAIA5G,cAAWqH,CAAAA,QAASC,CAAAA,OAApB,CAA4B,EAAA,IAAM;AAC9BJ,SAAIK,CAAAA,MAAJ,EAAA;AAD8B,KAAlC,CAAA;AAGA,WAAO,IAAIR,OAAJ,CAAaC,OAAD,IAAa;AAC5BhH,gBAAWwH,CAAAA,KAAMC,CAAAA,IAAjB,CAAsB,EAAA,IAAM;AACxB,YAAIrE,EAAJ,EACMsE,0BA5CPnE,QAASoE,CAAAA,aAAT,EAAyBC,CAAAA,MAAzB,CAAgC3B,oBAAhC,CA2CC;AAEA,cAAM4B,aAAa,EAAnB;AAIAvB,eAAQwB,CAAAA,OAAR,CAAgB,CAACC,UAAD,EAAavD,MAAb,CAAA,IAAwB;AAGpC,eAAK,MAAMvE,GAAX,IAAkB+H,eAAlB,CAAmC;AAC/B,gBAAI,CAACD,UAAA,CAAW9H,GAAX,CAAL;AACI;AADJ;AAEA,kBAAM,CAAEe,SAAF,EAAaH,OAAb,CAAA,GAAyBkH,UAAA,CAAW9H,GAAX,CAA/B;AACA,iBAAK,IAAI,CAACgI,SAAD,EAAYC,cAAZ,CAAT,IAAwC3B,MAAO4B,CAAAA,OAAP,CAAenH,SAAf,CAAxC,CAAmE;AAC/D,kBAAI,CAACkH,cAAL;AACI;AADJ;AAEA,kBAAME,eAAe,CACjB,GAAGrI,kBAAA,CAAmB8G,cAAnB,EAAmCoB,SAAnC,CADc,EAEjB,GAAGlI,kBAAA,CAAmBc,OAAnB,EAA4BoH,SAA5B,CAFc,CAArB;AAIA,oBAAM9G,OAvHR,QAAlB,KAuHiDlB,GAvHjD,GACW,OADX,GAEkB,OAAlB,KAqHiDA,GArHjD,IAA2C,KAA3C,KAqHiDA,GArHjD,GACW,KADX,GAEkB,MAAlB,KAmHiDA,GAnHjD,IAA0C,KAA1C,KAmHiDA,GAnHjD,GACW,KADX,GAEO,OAiHa;AAKkB,uBAAlB,KAAIgI,SAAJ,IACK9F,KAAMC,CAAAA,OAAN,CAAc8F,cAAd,CADL,KAGIA,cAHJ,GAGqB,CADa,KAATG,KAAAlH,IAAAkH,GAAiB,CAAjBA,GAAqB,CACzB,EAAeH,cAAf,CAHrB;AAQkC,wBAAlC,KAAI,MAAOE,aAAaE,CAAAA,KAAxB,KACIF,YAAaE,CAAAA,KADjB,GACyBF,YAAaE,CAAAA,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CADzB;AAGM3G,0BAAAA,GAAY,IAAI4G,eAAJ,CAAoBhF,QAAS4C,CAAAA,eAA7B,EAA+C,qBAAoBhF,IAApB,IAA4BqD,MAA5B,GAA/C,EAAsFyD,SAAtF,EAAiGC,cAAjG,EAAiHE,YAAjH,CAAZzG;AACNkG,wBAAWW,CAAAA,IAAX,CAAgB7G,YAAhB,CAAA;AAxB+D;AAJpC;AAHC,SAAxC,CAAA;AAsCA,aAAK,MAAMA,SAAX,IAAwB+F,uBAAxB;AACI,cAA4B,UAA5B,KAAI/F,SAAU8G,CAAAA,SAAd,KAEM,CAAE,OAAAvC,uBAAF,CACF,GADevE,SACf,EAACuE,uBAAD,IAAaA,uBAAb,YAA+BwC,cAHnC,EAGA;AAEA,gBAAM,CAAE5C,aAAF,CAAA,GAAoBI,uBAA1B;AACA,gBAAKJ,aAAL,KAEM6C,aAFN,GAEa9C,YAAA,CAAaC,aAAb,CAFb,EAGA;AAEA,kBAAM8C,mBAAmBtC,OAAQG,CAAAA,GAAR,CAAYkC,aAAK3C,CAAAA,KAAjB,CAAzB;AACK4C,8BAAL,GAmBSC,UAAA,CAAWD,gBAAX,EAA6B,OAA7B,CAAJ,IACDC,UAAA,CAAWD,gBAAX,EAA6B,MAA7B,CADC,IAED1C,uBACK4C,CAAAA,YADL,EAEKC,CAAAA,IAFL,CAEWC,QAAD,IAAcA,QAASC,CAAAA,YAFjC,CAFC,GAKDpB,UAAWW,CAAAA,IAAX,CAAgB,IAAIU,uBAAJ,CAA4BvH,SAA5B,CAAhB,CALC,GAQDA,SAAUuC,CAAAA,MAAV,EA3BJ,IAOUiF,aAUN,GAV4B,CACxB,GAAGpJ,kBAAA,CAAmB8G,cAAnB,EAF8B,OAAduC,KAAAT,aAAKxH,CAAAA,IAALiI,GAAwB,QAAxBA,GAAmC,EAEnD,CADqB,CAU5B,EAPA3D,qBAAA,CAAsB0D,aAAtB,CAOA,EANMpH,gBAMN,GANeO,uBAAA,CAAwB6G,aAAoB/H,CAAAA,IAA5C,EAAkD+H,aAAoB9I,CAAAA,QAAtE,CAMf;AALA6F,qCAAOmD,CAAAA,YAAP,CAAoB,CAChBf,MAAO/G,WAAYqE,CAAAA,qBAAZ,CAAuE,IAArC,MAACxC,EAAD,GAAM+F,aAAoBb,CAAAA,KAA1B,KAAoD,IAAK,EAAzD,KAA6ClF,EAA7C,GAA6DA,EAA7D,GAAkE,CAApG,CADS,EAEhB/C,SAAU8I,aAAoB9I,CAAAA,QAFd,EAGhB0B,OAAAA,gBAHgB,CAApB,CAKA,EAAA8F,UAAWW,CAAAA,IAAX,CAAgB,IAAIU,uBAAJ,CAA4BvH,SAA5B,CAAhB,CAjBJ,CAAA;AAHA;AANA;AAJJ;AA2CAqF,eAAA,CAAQ,IAAIC,yBAAJ,CAA8BY,UAA9B,CAAR,CAAA;AAxFwB,OAA5B,CAAA;AAD4B,KAAzB,CAAP;AAjCyD;AA8H7DgB,UAASA,WAAU,CAACrE,MAAD,EAASvE,GAAT,CAAc;AAC7B,QAAImD,EAAJ;AACA,WAA8E,IAAvE,MAACA,EAAD,GAAiB,IAAX,KAAAoB,MAAA,IAA8B,IAAK,EAAnC,KAAmBA,MAAnB,GAAuC,IAAK,EAA5C,GAAgDA,MAAA,CAAOvE,GAAP,CAAtD,KAAsF,IAAK,EAA3F,KAA+EmD,EAA/E,GAA+F,IAAK,EAApG,GAAwGA,EAAGpC,CAAAA,SAAUsI,CAAAA,OAA5H;AAF6B;AAjzBjC/C,QAAOgD,CAAAA,cAAP,CAAsBzJ,OAAtB,EAA+B,YAA/B,EAA6C,CAAEwB,MAAO,CAAA,CAAT,CAA7C,CAAA;AAEA,MAAIC,cAAc3B,OAAA,CAAQ,iDAAR,CAAlB;AAEA,QAAM4J,yBAAyBjI,WAAYkI,CAAAA,IAAZ,CAAiB,EAAA,IAAgCvJ,IAAAA,EAAhC,KAAMwJ,MAAOC,CAAAA,cAA9B,CAA/B;AAEA,OAAM1C,0BAAN;AACI2C,eAAW,CAAC/B,UAAD,CAAa;AAEpB,UAAKgC,CAAAA,IAAL,GAAY,EAAAC,IAAM,IAAKC,CAAAA,MAAL,CAAY,MAAZ,CAAlB;AACA,UAAKlC,CAAAA,UAAL,GAAkBA,UAAWD,CAAAA,MAAX,CAAkBoC,OAAlB,CAAlB;AAHoB;AAKpB,gBAAW,EAAA;AAEX,aAAOjD,OAAQkD,CAAAA,GAAR,CAAY,IAAKpC,CAAAA,UAAWpF,CAAAA,GAAhB,CAAqBd,SAAD,IAAe,UAAA,IAAcA,SAAd,GAA0BA,SAAU0F,CAAAA,QAApC,GAA+C1F,SAAlF,CAAZ,CAAP;AAFW;AAOfuI,UAAM,CAACC,QAAD,CAAW;AACb,aAAO,IAAKtC,CAAAA,UAAL,CAAgB,CAAhB,CAAA,CAAmBsC,QAAnB,CAAP;AADa;AAGjBC,UAAM,CAACD,QAAD,EAAWE,QAAX,CAAqB;AACvB,WAAK,IAAIC,IAAI,CAAb,EAAgBA,CAAhB,GAAoB,IAAKzC,CAAAA,UAAWnB,CAAAA,MAApC,EAA4C4D,CAAA,EAA5C;AACI,YAAKzC,CAAAA,UAAL,CAAgByC,CAAhB,CAAA,CAAmBH,QAAnB,CAAA,GAA+BE,QAA/B;AADJ;AADuB;AAK3B3I,kBAAc,CAACE,QAAD,EAAW2I,QAAX,CAAqB;AAC/B,YAAMC,gBAAgB,IAAK3C,CAAAA,UAAWpF,CAAAA,GAAhB,CAAqBd,SAAD,IAAe;AACrD,YAAI6H,sBAAA,EAAJ,IAAgC7H,SAAUD,CAAAA,cAA1C;AACI,iBAAOC,SAAUD,CAAAA,cAAV,CAAyBE,QAAzB,CAAP;AADJ;AAGK,YAAwB,UAAxB,KAAI,MAAO2I,SAAX;AACD,iBAAOA,QAAA,CAAS5I,SAAT,CAAP;AADC;AAJgD,OAAnC,CAAtB;AAQA,aAAO,EAAA,IAAM;AACT6I,qBAAc1C,CAAAA,OAAd,CAAsB,CAAC5D,MAAD,EAASoG,CAAT,CAAA,IAAe;AACjCpG,gBAAA,IAAUA,MAAA,EAAV;AACA,cAAK2D,CAAAA,UAAL,CAAgByC,CAAhB,CAAmBT,CAAAA,IAAnB,EAAA;AAFiC,SAArC,CAAA;AADS,OAAb;AAT+B;AAgB/B,YAAO,EAAA;AACP,aAAO,IAAKK,CAAAA,MAAL,CAAY,MAAZ,CAAP;AADO;AAGP,YAAI,CAACO,IAAD,CAAO;AACX,UAAKL,CAAAA,MAAL,CAAY,MAAZ,EAAoBK,IAApB,CAAA;AADW;AAGX,aAAQ,EAAA;AACR,aAAO,IAAKP,CAAAA,MAAL,CAAY,OAAZ,CAAP;AADQ;AAGR,aAAK,CAACQ,KAAD,CAAQ;AACb,UAAKN,CAAAA,MAAL,CAAY,OAAZ,EAAqBM,KAArB,CAAA;AADa;AAGb,iBAAY,EAAA;AACZ,aAAO,IAAKR,CAAAA,MAAL,CAAY,WAAZ,CAAP;AADY;AAGZ,gBAAW,EAAA;AACX,UAAIS,MAAM,CAAV;AACA,WAAK,IAAIL,IAAI,CAAb,EAAgBA,CAAhB,GAAoB,IAAKzC,CAAAA,UAAWnB,CAAAA,MAApC,EAA4C4D,CAAA,EAA5C;AACIK,WAAA,GAAM1J,IAAK0J,CAAAA,GAAL,CAASA,GAAT,EAAc,IAAK9C,CAAAA,UAAL,CAAgByC,CAAhB,CAAmBjK,CAAAA,QAAjC,CAAN;AADJ;AAGA,aAAOsK,GAAP;AALW;AAOfZ,UAAM,CAACa,UAAD,CAAa;AACf,UAAK/C,CAAAA,UAAWC,CAAAA,OAAhB,CAAyB+C,QAAD,IAAcA,QAAA,CAASD,UAAT,CAAA,EAAtC,CAAA;AADe;AAGnBE,WAAO,EAAG;AACN,UAAKf,CAAAA,MAAL,CAAY,SAAZ,CAAA;AADM;AAGVgB,QAAI,EAAG;AACH,UAAKhB,CAAAA,MAAL,CAAY,MAAZ,CAAA;AADG;AAGPiB,SAAK,EAAG;AACJ,UAAKjB,CAAAA,MAAL,CAAY,OAAZ,CAAA;AADI;AAGR7F,UAAM,EAAG;AACL,UAAK6F,CAAAA,MAAL,CAAY,QAAZ,CAAA;AADK;AAGTkB,YAAQ,EAAG;AACP,UAAKlB,CAAAA,MAAL,CAAY,UAAZ,CAAA;AADO;AA1Ef;AAmFA,OAAMmB,sBAAN,QAAoCjE,0BAApC;AACIQ,QAAI,CAAC0D,SAAD,EAAYC,QAAZ,CAAsB;AACtB,aAAOrE,OAAQkD,CAAAA,GAAR,CAAY,IAAKpC,CAAAA,UAAjB,CAA6BJ,CAAAA,IAA7B,CAAkC0D,SAAlC,CAA6CE,CAAAA,KAA7C,CAAmDD,QAAnD,CAAP;AADsB;AAD9B;AAsDA,OAAMlC,wBAAN;AACIU,eAAW,CAACjI,SAAD,CAAY;AACnB,UAAKA,CAAAA,SAAL,GAAiBA,SAAjB;AADmB;AAGnB,gBAAW,EAAA;AAAA,UACPyB,EADO,EACHkI,EADG,EACCC,EADD;AAEX,YAAMC,gBAAgG,IAAhF,MAACF,EAAD,GAAgC,IAA1B,MAAClI,EAAD,GAAM,IAAKzB,CAAAA,SAAX,KAAyC,IAAK,EAA9C,KAAkCyB,EAAlC,GAAkD,IAAK,EAAvD,GAA2DA,EAAG8C,CAAAA,MAApE,KAA+F,IAAK,EAApG,KAAwFoF,EAAxF,GAAwG,IAAK,EAA7G,GAAiHA,EAAGG,CAAAA,iBAAH,EAAuBpL,CAAAA,QAAxJmL,MACuB,IAAxB,MAACD,EAAD,GAAM,IAAK1K,CAAAA,OAAX,KAAuC,IAAK,EAA5C,KAAgC0K,EAAhC,GAAgD,IAAK,EAArD,GAAyDA,EAAGlL,CAAAA,QAD3DmL,KAEF,GAFJ;AAGA,aAAOjK,WAAYC,CAAAA,qBAAZ,CAAkCkK,MAAA,CAAOF,YAAP,CAAlC,CAAP;AALW;AAOX,YAAO,EAAA;AACP,UAAIpI,EAAJ;AACA,aAAI,IAAKzB,CAAAA,SAAT,GACWJ,WAAYC,CAAAA,qBAAZ,EAA6D,IAA1B,MAAC4B,EAAD,GAAM,IAAKzB,CAAAA,SAAX,KAAyC,IAAK,EAA9C,KAAkCyB,EAAlC,GAAkD,IAAK,EAAvD,GAA2DA,EAAGuI,CAAAA,WAAjG,KAAiH,CAAjH,CADX,GAGO,CAHP;AAFO;AAOP,YAAI,CAACC,OAAD,CAAU;AACV,UAAKjK,CAAAA,SAAT,KACI,IAAKA,CAAAA,SAAUgK,CAAAA,WADnB,GACiCpK,WAAYqE,CAAAA,qBAAZ,CAAkCgG,OAAlC,CADjC;AADc;AAKd,aAAQ,EAAA;AACR,aAAO,IAAKjK,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAUkK,CAAAA,YAAhC,GAA+C,CAAtD;AADQ;AAGR,aAAK,CAACC,QAAD,CAAW;AACZ,UAAKnK,CAAAA,SAAT,KACI,IAAKA,CAAAA,SAAUkK,CAAAA,YADnB,GACkCC,QADlC;AADgB;AAKhB,aAAQ,EAAA;AACR,aAAO,IAAKnK,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAU8G,CAAAA,SAAhC,GAA4C,UAAnD;AADQ;AAGR,iBAAY,EAAA;AACZ,aAAO,IAAK9G,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAUoK,CAAAA,SAAhC,GAA4C,IAAnD;AADY;AAGZ,gBAAW,EAAA;AACX,aAAO,IAAKpK,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAU0F,CAAAA,QAAhC,GAA2CN,OAAQC,CAAAA,OAAR,EAAlD;AADW;AAGf+D,QAAI,EAAG;AACH,UAAKpJ,CAAAA,SAAL,IAAkB,IAAKA,CAAAA,SAAUoJ,CAAAA,IAAf,EAAlB;AADG;AAGPC,SAAK,EAAG;AACJ,UAAKrJ,CAAAA,SAAL,IAAkB,IAAKA,CAAAA,SAAUqJ,CAAAA,KAAf,EAAlB;AADI;AAGRnB,QAAI,EAAG;AACE,UAAKlI,CAAAA,SAAV,IACmB,MADnB,KACI,IAAKrB,CAAAA,KADT,IAEmB,UAFnB,KAEI,IAAKA,CAAAA,KAFT,KAKI,IAAKqB,CAAAA,SAAUqK,CAAAA,YAGnB,IAFI,IAAKrK,CAAAA,SAAUqK,CAAAA,YAAf,EAEJ,EAAA,IAAK9H,CAAAA,MAAL,EARA;AADG;AAWP4G,WAAO,EAAG;AACN,UAAI1H,EAAJ;AACK,UAAKzB,CAAAA,SAAV,KAEiC,IAFjC,MAECyB,EAFD,GAEM,IAAKzB,CAAAA,SAAUuE,CAAAA,MAFrB,KAEgD,IAAK,EAFrD,KAEyC9C,EAFzC,IAEkEA,EAAGiG,CAAAA,YAAH,CAAgB,CAAEtH,OAAQ,QAAV,CAAhB,CAFlE;AAFM;AAMVL,kBAAc,CAACE,QAAD,CAAW;AACjB,UAAKD,CAAAA,SAAT,IACID,cAAA,CAAe,IAAKC,CAAAA,SAApB,EAA+BC,QAA/B,CADJ;AAEA,aAAOL,WAAY0K,CAAAA,IAAnB;AAHqB;AAKzBhB,YAAQ,EAAG;AACP,UAAKtJ,CAAAA,SAAL,IAAkB,IAAKA,CAAAA,SAAUuK,CAAAA,MAAf,EAAlB;AADO;AAGXhI,UAAM,EAAG;AACL,SAAI;AACA,YAAKvC,CAAAA,SAAL,IAAkB,IAAKA,CAAAA,SAAUuC,CAAAA,MAAf,EAAlB;AADA,OAGJ,QAAOS,CAAP,CAAU;;AAJL;AAvEb;AA+EA,QAAMzC,qBAAsBH,MAADG,IAAYC,KAAMC,CAAAA,OAAN,CAAcL,MAAd,CAAZG,IAA0D,QAA1DA,KAAqC,MAAOH,OAAA,CAAO,CAAP,CAAvE,EAMMoK,gBAAgB,CAClBC,aAAclM,IAAAA,EADI,CANtB,EAeM8B,uBALNqK,QAAqB,CAAClH,QAAD,EAAWmH,YAAX,CAAyB;AAC1C,UAAMC,WAAWhL,WAAYkI,CAAAA,IAAZ,CAAiBtE,QAAjB,CAAjB;AACA,WAAO,EAAA,IAAM;AAAE,UAAI/B,EAAJ;AAAQ,aAA8C,IAAvC,MAACA,EAAD,GAAM+I,aAAA,CAAcG,YAAd,CAAN,KAAsD,IAAK,EAA3D,KAA+ClJ,EAA/C,GAA+DA,EAA/D,GAAoEmJ,QAAA,EAA3E;AAAV,KAAb;AAF0C,GAKH,CAAa,EAAA,IAAM;AAC1D,OAAI;AACAhJ,cACKiJ,CAAAA,aADL,CACmB,KADnB,CAEKC,CAAAA,OAFL,CAEa,CAAEnD,QAAS,CAAX,CAFb,EAE6B,CAAEvH,OAAQ,cAAV,CAF7B,CAAA;AADA,KAKJ,QAAO4C,CAAP,CAAU;AACN,aAAO,CAAA,CAAP;AADM;AAGV,WAAO,CAAA,CAAP;AAT0D,GAAnB,EAUxC,cAVwC,CAf3C,EA2BMpC,uBAAuB,CAACR,MAAD,EAAS1B,QAAT,EAC7BqM,UAAA,GAAa,EADgB,CAAAnK,IAExB;AACD,QAAIoK,SAAS,EAAb;AACMC,YAAAA,GAAY3L,IAAK0J,CAAAA,GAAL,CAAS1J,IAAK4L,CAAAA,KAAL,CAAWxM,QAAX,GAAsBqM,UAAtB,CAAT,EAA4C,CAA5C,CAAZE;AACN,SAAStC,UAAT,GAAa,CAAb,EAAgBA,UAAhB,GAAoBsC,QAApB,EAA+BtC,UAAA,EAA/B;AACIqC,YAAA,IAAU5K,MAAA,CAAOR,WAAYF,CAAAA,QAAZ,CAAqB,CAArB,EAAwBuL,QAAxB,GAAoC,CAApC,EAAuCtC,UAAvC,CAAP,CAAV,GAA8D,IAA9D;AADJ;AAGA,WAAQ,UAASqC,MAAOG,CAAAA,SAAP,CAAiB,CAAjB,EAAoBH,MAAOjG,CAAAA,MAA3B,GAAoC,CAApC,CAAT,GAAR;AANC,GA7BL,EA8CMlE,sBAAsB,CAAC,CAACuK,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV,CAAD,CAAA1K,IAAmB,gBAAeuK,CAAf,KAAqBC,CAArB,KAA2BC,CAA3B,KAAiCC,CAAjC,GA9C/C,EA+CMjL,uBAAuB,CACzBkL,OAAQ,QADiB,EAEzB/L,KAAM,MAFmB,EAGzBgM,OAAQ,SAHiB,EAIzBzK,QAAS,UAJgB,EAKzB0K,UAAW,aALc,EAMzBC,OAAsB9K,mBAAA,CAAoB,CAAC,CAAD,EAAI,IAAJ,EAAU,IAAV,EAAgB,CAAhB,CAApB,CANG,EAOzB+K,QAAuB/K,mBAAA,CAAoB,CAAC,IAAD,EAAO,CAAP,EAAU,CAAV,EAAa,IAAb,CAApB,CAPE,EAQzBgL,OAAsBhL,mBAAA,CAAoB,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,CAAC,IAApB,CAApB,CARG,EASzBiL,QAAuBjL,mBAAA,CAAoB,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAApB,CATE,CA/C7B,EA6EMK,aAAa,CACfC,EAAG,CAAA,CADY,EAEfC,EAAG,CAAA,CAFY,CA7EnB,EA0KM2K,gBAAgB,CAACC,MAAD,EAASC,KAAT,CAAAF,IACbE,KAAL,GAGSD,MAAJ,KAAeC,KAAf,GACM,CAAA,CADN;AAIMF,eAAA,CAAcC,MAAd,EAAsBC,KAAMC,CAAAA,aAA5B,CAPX,GACW,CAAA,CA5Kf,EAsLMC,mBAAoBzJ,KAADyJ,IACK,OAA1B,KAAIzJ,KAAM0J,CAAAA,WAAV,GACmC,QADnC,KACW,MAAO1J,MAAM2J,CAAAA,MADxB,IAC+D,CAD/D,IAC+C3J,KAAM2J,CAAAA,MADrD,GAY+B,CAAA,CAZ/B,KAYW3J,KAAMkB,CAAAA,SAnMrB,EAuMMT,oBAAoB,IAAImJ,GAAJ,CAAQ,CAC9B,QAD8B,EAE9B,OAF8B,EAG9B,QAH8B,EAI9B,UAJ8B,EAK9B,GAL8B,CAAR,CAvM1B,EAmNMC,aAAa,IAAIC,OAAJ,EAnNnB,EAkOMC,sBAAsB,CAACC,UAAD,EAAatK,YAAb,CAAAqK,IAA8B;AACtD,UAAMvJ,UAAUwJ,UAAWC,CAAAA,aAA3B;AACA,QAAKzJ,OAAL,CAAA;AAEA,UAAM0J,gBAAgBrJ,YAAA,CAAa,EAAA,IAAM;AACrC,YAAI,CAAAgJ,UAAWnJ,CAAAA,GAAX,CAAeF,OAAf,CAAJ,CAAA;AAEAO,0BAAA,CAAiBP,OAAjB,EAA0B,MAA1B,CAAA;AACA,cAAM2J,cAActJ,YAAA,CAAa,EAAA,IAAM;AACnCE,4BAAA,CAAiBP,OAAjB,EAA0B,IAA1B,CAAA;AADmC,WAAnB,CAApB;AAIAA,iBAAQ4J,CAAAA,gBAAR,CAAyB,OAAzB,EAAkCD,WAAlC,EAA+CzK,YAA/C,CAAA;AACAc,iBAAQ4J,CAAAA,gBAAR,CAAyB,MAAzB,EAFmB,EAAAC,IAAMtJ,gBAAA,CAAiBP,OAAjB,EAA0B,QAA1B,CAEzB,EAA6Cd,YAA7C,CAAA;AARA;AADqC,OAAnB,CAAtB;AAWAc,aAAQ4J,CAAAA,gBAAR,CAAyB,SAAzB,EAAoCF,aAApC,EAAmDxK,YAAnD,CAAA;AAIAc,aAAQ4J,CAAAA,gBAAR,CAAyB,MAAzB,EAAiC,EAAA,IAAM5J,OAAQ8J,CAAAA,mBAAR,CAA4B,SAA5B,EAAuCJ,aAAvC,CAAvC,EAA8FxK,YAA9F,CAAA;AAjBA;AAFsD,GAlO1D;AAyYA,OAAMwE,gBAAN,QAA8BW,wBAA9B;AACIU,eAAW,CAACpF,MAAD,EAASsB,aAAT,EAAwBmC,SAAxB,EAAmCjH,SAAnC,EAA8CH,OAA9C,CAAuD;AA/BlE,UAAIuC,EAAJ;AACA,YAAMwL,kBAAkB,EAAxB,EACMC,gBAAgB,CAClBC,KAAM,MADY,EAElB/M,OAAQ,QAFU,EAGlBgN,UAAW,SAHO,CADtB;AAMAF,mBAAcvG,CAAAA,KAAd,GAAsB/G,WAAYqE,CAAAA,qBAAZ,CAA2D,IAAzB,MAACxC,EAAD,GAyBwBvC,OAzBVyH,CAAAA,KAAd,KAAwC,IAAK,EAA7C,KAAiClF,EAAjC,GAAiDA,EAAjD,GAAsD,CAAxF,CAAtB;AACAqC,2BAAA,CAwBgF5E,OAxBhF,CAAA;AACAgO,mBAAcxO,CAAAA,QAAd,GAuBgFQ,OAvB/CR,CAAAA,QAAjC;AACA,YAAM,CAAEe,IAAF,EAAQ4N,KAAR,CAAA,GAsB0EnO,OAtBhF;AACImO,WAAJ,KACIJ,eAAgBK,CAAAA,MADpB,GAC6BD,KAD7B;AAEAJ,qBAAA,CAmB0D3G,SAnB1D,CAAA,GAmBqEjH,SAnBrE;AACMe,eAAAA,GAASO,uBAAA,CAAwBlB,IAAxB,EAkBiEP,OAlB3BR,CAAAA,QAAtC,CAAT0B;AAIFI,WAAMC,CAAAA,OAAN,CAAcL,SAAd,CAAJ,GACI6M,eAAgB7M,CAAAA,MADpB,GAC6BA,SAD7B,GAII8M,aAAc9M,CAAAA,MAJlB,GAI2BA,SAJ3B;AAmBI,WAAA,CAJkByC,MAAOiI,CAAAA,OAAP9K,CARPiN,eAQOjN,EAA2C,CACzDmE,aADyD,EAEzD,GATK+I,aAOoD,CAA3ClN,CAIlB,CAAA;AAN8D;AADtE;AAqBA,MAAIuN,eAAe,EAAnB,EACIC,QAAQ,IADZ;AAEA,QAAMjI,MAAM,CACRC,IAAK,CAACiI,QAAD,EAAWC,MAAX,CAAAlI,IAAsB;AACvB+H,gBAAA,CAAaE,QAAb,CAAA,GAAyBC,MAAzB;AADuB,GADnB,EAIRjI,OAAQ,EAAAA,IAAM;AACL+H,SAAL,KACIA,KACA,GADQ5L,QAASiJ,CAAAA,aAAT,CAAuB,OAAvB,CACR,EAAA2C,KAAMG,CAAAA,EAAN,GAAW,aAFf;AAIA,QAAIC,UAAU,EAAd;AACA,SAAK,MAAMH,QAAX,GAAuBF,aAAvB,CAAqC;AACjC,YAAMM,OAAON,YAAA,CAAaE,QAAb,CAAb;AACAG,aAAA,IAAY,GAAEH,QAAF,MAAZ;AACA,WAAK,MAAM,CAACK,QAAD,EAAWnO,KAAX,CAAX,IAAgCiF,MAAO4B,CAAAA,OAAP,CAAeqH,IAAf,CAAhC;AACID,eAAA,IAAY,KAAIE,QAAJ,KAAiBnO,KAAjB,KAAZ;AADJ;AAGAiO,aAAA,IAAW,KAAX;AANiC;AAQrCJ,SAAMO,CAAAA,WAAN,GAAoBH,OAApB;AACAhM,YAASoM,CAAAA,IAAKC,CAAAA,WAAd,CAA0BT,KAA1B,CAAA;AACAD,gBAAA,GAAe,EAAf;AAhBU,GAJN,EAsBR3H,OAAQ,EAAAA,IAAM;AACN4H,SAAJ,IAAaA,KAAMtB,CAAAA,aAAnB,IACIsB,KAAMtB,CAAAA,aAAcgC,CAAAA,WAApB,CAAgCV,KAAhC,CADJ;AADU,GAtBN,CAAZ,EAoDMnH,kBAAkB,CAAC,QAAD,EAAW,OAAX,EAAoB,MAApB,EAA4B,KAA5B,EAAmC,KAAnC,CApDxB;AA8LA,OAAM8H,sBAAN;AACIlG,eAAW,CAAChD,MAAD,EAAS/F,OAAA,GAAU,EAAnB,CAAuB;AAC9B,UAAKyN,CAAAA,aAAL,GAAqB,MAArB;AACA,UAAKhI,CAAAA,OAAL,GAAe,IAAIyJ,GAAJ,EAAf;AACA,UAAKC,CAAAA,WAAL,GAAmBzO,WAAY0K,CAAAA,IAA/B;AACA,UAAKgE,CAAAA,YAAL,GAAoB,IAAIlJ,OAAJ,CAAaC,OAAD,IAAa;AACzC,YAAKgJ,CAAAA,WAAL,GAAmBhJ,OAAnB;AADyC,OAAzB,CAApB;AAGAkJ,oBAAA,CAAe,EAAA,IAAM;AACjBvJ,0BAAA,CAAmBC,MAAnB,EAA2B/F,OAA3B,EAAoC,IAAKyF,CAAAA,OAAzC,CAAkDmB,CAAAA,IAAlD,CAAwD9F,SAAD,IAAe,IAAKqO,CAAAA,WAAL,CAAiBrO,SAAjB,CAAtE,CAAA;AADiB,OAArB,CAAA;AAP8B;AAWlC8E,OAAG,CAAC2I,QAAD,CAAW;AACV,UAAKd,CAAAA,aAAL,GAAqBc,QAArB;AACA,aAAO,IAAP;AAFU;AAIde,UAAM,CAACnP,SAAD,EAAYH,OAAZ,CAAqB;AACvB,UAAKuP,CAAAA,YAAL,CAAkB,QAAlB,EAA4BpP,SAA5B,EAAuCH,OAAvC,CAAA;AACA,aAAO,IAAP;AAFuB;AAI3BwP,OAAG,CAACrP,SAAD,EAAYH,OAAZ,CAAqB;AACpB,UAAKuP,CAAAA,YAAL,CAAkB,KAAlB,EAAyBpP,SAAzB,EAAoCH,OAApC,CAAA;AACA,aAAO,IAAP;AAFoB;AAIxByP,OAAG,CAACtP,SAAD,EAAYH,OAAZ,CAAqB;AACpB,UAAKuP,CAAAA,YAAL,CAAkB,KAAlB,EAAyBpP,SAAzB,EAAoCH,OAApC,CAAA;AACA,aAAO,IAAP;AAFoB;AAIxB0P,SAAK,CAACvP,SAAD,EAAYH,OAAZ,CAAqB;AACtB,UAAKuP,CAAAA,YAAL,CAAkB,OAAlB,EAA2BpP,SAA3B,EAAsCH,OAAtC,CAAA;AACA,aAAO,IAAP;AAFsB;AAI1B2P,QAAI,CAACxP,SAAD,EAAYH,OAAZ,CAAqB;AACrB,UAAKuP,CAAAA,YAAL,CAAkB,MAAlB,EAA0BpP,SAA1B,EAAqCH,OAArC,CAAA;AACA,aAAO,IAAP;AAFqB;AAIzB4P,aAAS,CAAC5P,OAAD,CAAU;AACf,UAAKuP,CAAAA,YAAL,CAAkB,OAAlB,EAA2B,CAAE9G,QAAS,CAAX,CAA3B,EAA2CzI,OAA3C,CAAA;AACA,UAAKuP,CAAAA,YAAL,CAAkB,MAAlB,EAA0B,CAAE9G,QAAS,CAAX,CAA1B,EAA0CzI,OAA1C,CAAA;AACA,aAAO,IAAP;AAHe;AAKnBuP,gBAAY,CAAC5L,MAAD,EAASxD,SAAT,EAAoBH,OAAA,GAAU,EAA9B,CAAkC;AAC1C,YAAM,CAAEyN,aAAF,EAAiBhI,OAAjB,CAAA,GAA6B,IAAnC;AACKA,aAAQvB,CAAAA,GAAR,CAAYuJ,aAAZ,CAAL,IACIhI,OAAQa,CAAAA,GAAR,CAAYmH,aAAZ,EAA2B,EAA3B,CADJ;AAGmBhI,aAAQG,CAAAA,GAARiK,CAAYpC,aAAZoC,CACnB,CAAWlM,MAAX,CAAA,GAAqB,CAAExD,SAAF,EAAaH,OAAb,CAArB;AAN0C;AAQ9C4G,QAAI,CAACT,OAAD,EAAU2J,MAAV,CAAkB;AAClB,aAAO,IAAKV,CAAAA,YAAaxI,CAAAA,IAAlB,CAAuBT,OAAvB,EAAgC2J,MAAhC,CAAP;AADkB;AAjD1B;AAkFA7Q,SAAQoL,CAAAA,qBAAR,GAAgCA,qBAAhC;AACApL,SAAQoJ,CAAAA,uBAAR,GAAkCA,uBAAlC;AACApJ,SAAQgQ,CAAAA,qBAAR,GAAgCA,qBAAhC;AACAhQ,SAAQ4B,CAAAA,cAAR,GAAyBA,cAAzB;AACA5B,SAAQK,CAAAA,qBAAR,GAAgCA,qBAAhC;AACAL,SAAQsE,CAAAA,cAAR,GAAyBA,cAAzB;AACAtE,SAAQc,CAAAA,qBAAR,GAAgCA,qBAAhC;AACAd,SAAQ0C,CAAAA,mBAAR,GAA8BA,mBAA9B;AACA1C,SAAQyC,CAAAA,oBAAR,GAA+BA,oBAA/B;AACAzC,SAAQC,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAD,SAAQ8Q,CAAAA,KAAR,GA1jBAA,QAAc,CAAC3N,iBAAD,EAAoB4N,YAApB,EAAkChQ,OAAA,GAAU,EAA5C,CAAgD;AAC1D,UAAM,CAAC4C,QAAD,EAAWM,YAAX,EAAyBG,MAAzB,CAAA,GAAmCN,YAAA,CAAaX,iBAAb,EAAgCpC,OAAhC,CAAzC,EACMiQ,iBAAkBC,UAADD,IAAgB;AACnC,UAZ2B,OAY3B,KAAkBC,UAZPhD,CAAAA,WAYX,IAZsC,CAAAnL,YAAA,EAYtC,CAAA;AAEA,YAAM,CAAE4B,MAAF,CAAA,GAAauM,UAAnB,EACMC,aAAaH,YAAA,CAAarM,MAAb,EAAqBuM,UAArB,CADnB;AAEA,YAA0B,UAA1B,KAAI,MAAOC,WAAX,IAAyCxM,MAAzC,CAAA;AAEA,cAAMyM,iBAAkBC,UAADD,IAAgB;AAlBZ,mBAmBvB,KAAkBC,UAnBXnD,CAAAA,WAmBP,IAnBkCnL,YAAA,EAmBlC,KAEAoO,UAAA,CAAWE,UAAX,CACA,EAAA1M,MAAOmK,CAAAA,mBAAP,CAA2B,cAA3B,EAA2CsC,cAA3C,CAHA;AADmC,WAAvC;AAMAzM,gBAAOiK,CAAAA,gBAAP,CAAwB,cAAxB,EAAwCwC,cAAxC,EAAwDlN,YAAxD,CAAA;AARA;AAJA;AADmC,KADvC;AAgBAN,YAASqE,CAAAA,OAAT,CAAkBjD,OAAD,IAAa;AAC1BA,aAAQ4J,CAAAA,gBAAR,CAAyB,cAAzB,EAAyCqC,cAAzC,EAAyD/M,YAAzD,CAAA;AAD0B,KAA9B,CAAA;AAGA,WAAOG,MAAP;AApB0D,GA0jB9D;AACApE,SAAQoC,CAAAA,kBAAR,GAA6BA,kBAA7B;AACApC,SAAQ8C,CAAAA,YAAR,GAAuBA,YAAvB;AACA9C,SAAQ+C,CAAAA,UAAR,GAAqBA,UAArB;AACA/C,SAAQ2B,CAAAA,WAAR,GAAsBA,WAAtB;AACA3B,SAAQ4N,CAAAA,aAAR,GAAwBA,aAAxB;AACA5N,SAAQgO,CAAAA,gBAAR,GAA2BA,gBAA3B;AACAhO,SAAQgC,CAAAA,sBAAR,GAAiCA,sBAAjC;AACAhC,SAAQwC,CAAAA,uBAAR,GAAkCA,uBAAlC;AACAxC,SAAQW,CAAAA,oBAAR,GAtzB6BA,KAszB7B;AACAX,SAAQqR,CAAAA,KAAR,GAlbAA,QAAc,CAACC,gBAAD,EAAmBC,YAAnB,EAAiCxQ,OAAA,GAAU,EAA3C,CAA+C;AACzD,UAAM,CAACyF,OAAD,EAAUvC,YAAV,EAAwBuN,YAAxB,CAAA,GAAwC1N,YAAA,CAAawN,gBAAb,EAA+BvQ,OAA/B,CAA9C,EACM0Q,aAAcC,UAADD,IAAgB;AAC/B,YAAM/M,SAASgN,UAAWlD,CAAAA,aAA1B;AACA,UAAK9J,MAAL,IAzBGsJ,gBAAA,CAyB+B0D,UAzB/B,CAyBH,IAzB+B,CAAA5O,YAAA,EAyB/B,IAAiD,CAAAsL,UAAWnJ,CAAAA,GAAX,CAAeP,MAAf,CAAjD,CAAA;AAEA0J,kBAAWuD,CAAAA,GAAX,CAAejN,MAAf,CAAA;AACAJ,sBAAA,CAAeoN,UAAf,EAA2B,KAA3B,CAAA;AACA,YAAME,aAAaL,YAAA,CAAa7M,MAAb,EAAqBgN,UAArB,CAAnB,EACMG,eAAe,CAACC,QAAD,EAAWC,OAAX,CAAAF,IAAuB;AACxCnN,gBAAOmK,CAAAA,mBAAP,CAA2B,WAA3B,EAAwCmD,WAAxC,CAAA;AACAtN,gBAAOmK,CAAAA,mBAAP,CAA2B,eAA3B,EAA4CoD,eAA5C,CAAA;AACA3N,wBAAA,CAAewN,QAAf,EAAyB,SAAzB,CAAA;AAjCD9D,0BAAA,CAkCwB8D,QAlCxB,CAkCC,IAlC2B,CAAAhP,YAAA,EAkC3B,IAAqCsL,UAAWnJ,CAAAA,GAAX,CAAeP,MAAf,CAArC,KAGA0J,UAAW8D,CAAAA,MAAX,CAAkBxN,MAAlB,CACA,EAA0B,UAA1B,KAAI,MAAOkN,WAAX,IACIA,UAAA,CAAWE,QAAX,EAAqB,CAAEC,OAAF,CAArB,CALJ;AAJwC,SAD5C,EAaMC,cAAeG,OAADH,IAAa;AACX,cAACG,OAAQC,CAAAA,SAAT,CAAA;AAEZ,gBAAA,kBAAA,MAAA,YAAA,OAAA,GAAA,MAAA,CAAA,qBAAA,EAAA,GAAA,CAAA,KAAA,CAAA,EAAA,IAAA,CAAA,EAAA,MAAA,MAAA,CAAA,UAAA,EAAA,OAAA,MAAA,CAAA,WAAA,CAAA;AAyCd,2BAAA,GAzCc7N,OAyCA8N,CAAAA,OAAd,GAAwBC,eAAKC,CAAAA,IAA7B,IAzCchO,OA0CJ8N,CAAAA,OADV,GACoBC,eAAKE,CAAAA,KADzB,IAzCcjO,OA2CJkO,CAAAA,OAFV,GAEoBH,eAAKI,CAAAA,GAFzB,IAzCcnO,OA4CJkO,CAAAA,OAHV,GAGoBH,eAAKK,CAAAA,MAHzB;AA3C0B,WAAA;AACZ,2BAAA,GAAA,CAAA,CAAA;AADY;AAAAC,yBAUlB,GACIf,YAAA,CAAaM,OAAb,EAAsB,CAAA,CAAtB,CADJ,GAIIN,YAAA,CAAaM,OAAb,EAAsB,EAAEzN,MAAF,YAAoBC,OAApB,CAAtB,IACIiJ,aAAA,CAAclJ,MAAd,EAAsByN,OAAQzN,CAAAA,MAA9B,CADJ,CAJJ;AAX6B,SAbjC,EAgCMuN,kBAAmBY,WAADZ,IAAiB;AACrCJ,sBAAA,CAAagB,WAAb,EAA0B,CAAA,CAA1B,CAAA;AADqC,SAhCzC;AAmCAnO,cAAOiK,CAAAA,gBAAP,CAAwB,WAAxB,EAAqCqD,WAArC,EAAkD/N,YAAlD,CAAA;AACAS,cAAOiK,CAAAA,gBAAP,CAAwB,eAAxB,EAAyCsD,eAAzC,EAA0DhO,YAA1D,CAAA;AACAS,cAAOiK,CAAAA,gBAAP,CAAwB,oBAAxB,EAA8CsD,eAA9C,EAA+DhO,YAA/D,CAAA;AAzCA;AAF+B,KADnC;AA8CAuC,WAAQwB,CAAAA,OAAR,CAAiBtD,MAAD,IAAY;AACxBA,YAAA,GAAS3D,OAAQ+R,CAAAA,eAAR,GAA0BlJ,MAA1B,GAAmClF,MAA5C;AACA,UAAIqO,8BAA8B,CAAA,CAAlC;AACIrO,YAAJ,YAAsBsO,WAAtB,KACID,2BACA,GAD8B,CAAA,CAC9B,EAAKjO,2BAAA,CAA4BJ,MAA5B,CAAL,IACwC,IADxC,KACIA,MAAOuO,CAAAA,YAAP,CAAoB,UAApB,CADJ,KAEIvO,MAAOS,CAAAA,QAFX,GAEsB,CAFtB,CAFJ;AAOAT,YAAOiK,CAAAA,gBAAP,CAAwB,aAAxB,EAAuC8C,UAAvC,EAAmDxN,YAAnD,CAAA;AACI8O,iCAAJ,IACIrO,MAAOiK,CAAAA,gBAAP,CAAwB,OAAxB,EAAkCpK,KAAD,IAAW+J,mBAAA,CAAoB/J,KAApB,EAA2BN,YAA3B,CAA5C,EAAsFA,YAAtF,CADJ;AAXwB,KAA5B,CAAA;AAeA,WAAOuN,YAAP;AA9DyD,GAkb7D;AACAxR,SAAQkD,CAAAA,eAAR,GAA0BA,eAA1B;AACAlD,SAAQkT,CAAAA,WAAR,GA/CAA,QAAoB,CAACC,IAAD,CAAO;AACvB,QAAa,GAAb,KAAIA,IAAJ,IAA6B,GAA7B,KAAoBA,IAApB,CAAkC;AAC9B,UAAIpQ,UAAA,CAAWoQ,IAAX,CAAJ;AACI,eAAO,IAAP;AADJ;AAIIpQ,gBAAA,CAAWoQ,IAAX,CAAA,GAAmB,CAAA,CAAnB;AACA,aAAO,EAAA,IAAM;AACTpQ,kBAAA,CAAWoQ,IAAX,CAAA,GAAmB,CAAA,CAAnB;AADS,OAAb;AAN0B;AAY9B,QAAIpQ,UAAWC,CAAAA,CAAf,IAAoBD,UAAWE,CAAAA,CAA/B;AACI,aAAO,IAAP;AADJ;AAIIF,cAAWC,CAAAA,CAAX,GAAeD,UAAWE,CAAAA,CAA1B,GAA8B,CAAA,CAA9B;AACA,WAAO,EAAA,IAAM;AACTF,gBAAWC,CAAAA,CAAX,GAAeD,UAAWE,CAAAA,CAA1B,GAA8B,CAAA,CAA9B;AADS,KAAb;AAlBe,GA+C3B;AACAjD,SAAQmC,CAAAA,oBAAR,GAA+BA,oBAA/B;AACAnC,SAAQqM,CAAAA,aAAR,GAAwBA,aAAxB;AACArM,SAAQkC,CAAAA,oBAAR,GAA+BA,oBAA/B;AACAlC,SAAQ0J,CAAAA,sBAAR,GAAiCA,sBAAjC;AACA1J,SAAQoT,CAAAA,IAAR,GAxDAA,QAAa,CAACtM,MAAD,EAASC,cAAA,GAAiB,EAA1B,CAA8B;AACvC,WAAO,IAAIiJ,qBAAJ,CAA0BlJ,MAA1B,EAAkCC,cAAlC,CAAP;AADuC,GAwD3C;AA56B0G,CAA1G;;\",\n\"sources\":[\"node_modules/motion-dom/dist/cjs/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$motion_dom$dist$cjs$index\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar motionUtils = require('motion-utils');\\n\\nconst supportsScrollTimeline = motionUtils.memo(() => window.ScrollTimeline !== undefined);\\n\\nclass BaseGroupPlaybackControls {\\n    constructor(animations) {\\n        // Bound to accomodate common `return animation.stop` pattern\\n        this.stop = () => this.runAll(\\\"stop\\\");\\n        this.animations = animations.filter(Boolean);\\n    }\\n    get finished() {\\n        // Support for new finished Promise and legacy thennable API\\n        return Promise.all(this.animations.map((animation) => \\\"finished\\\" in animation ? animation.finished : animation));\\n    }\\n    /**\\n     * TODO: Filter out cancelled or stopped animations before returning\\n     */\\n    getAll(propName) {\\n        return this.animations[0][propName];\\n    }\\n    setAll(propName, newValue) {\\n        for (let i = 0; i < this.animations.length; i++) {\\n            this.animations[i][propName] = newValue;\\n        }\\n    }\\n    attachTimeline(timeline, fallback) {\\n        const subscriptions = this.animations.map((animation) => {\\n            if (supportsScrollTimeline() && animation.attachTimeline) {\\n                return animation.attachTimeline(timeline);\\n            }\\n            else if (typeof fallback === \\\"function\\\") {\\n                return fallback(animation);\\n            }\\n        });\\n        return () => {\\n            subscriptions.forEach((cancel, i) => {\\n                cancel && cancel();\\n                this.animations[i].stop();\\n            });\\n        };\\n    }\\n    get time() {\\n        return this.getAll(\\\"time\\\");\\n    }\\n    set time(time) {\\n        this.setAll(\\\"time\\\", time);\\n    }\\n    get speed() {\\n        return this.getAll(\\\"speed\\\");\\n    }\\n    set speed(speed) {\\n        this.setAll(\\\"speed\\\", speed);\\n    }\\n    get startTime() {\\n        return this.getAll(\\\"startTime\\\");\\n    }\\n    get duration() {\\n        let max = 0;\\n        for (let i = 0; i < this.animations.length; i++) {\\n            max = Math.max(max, this.animations[i].duration);\\n        }\\n        return max;\\n    }\\n    runAll(methodName) {\\n        this.animations.forEach((controls) => controls[methodName]());\\n    }\\n    flatten() {\\n        this.runAll(\\\"flatten\\\");\\n    }\\n    play() {\\n        this.runAll(\\\"play\\\");\\n    }\\n    pause() {\\n        this.runAll(\\\"pause\\\");\\n    }\\n    cancel() {\\n        this.runAll(\\\"cancel\\\");\\n    }\\n    complete() {\\n        this.runAll(\\\"complete\\\");\\n    }\\n}\\n\\n/**\\n * TODO: This is a temporary class to support the legacy\\n * thennable API\\n */\\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\\n    then(onResolve, onReject) {\\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\\n    }\\n}\\n\\nfunction getValueTransition(transition, key) {\\n    return transition\\n        ? transition[key] ||\\n            transition[\\\"default\\\"] ||\\n            transition\\n        : undefined;\\n}\\n\\n/**\\n * Implement a practical max duration for keyframe generation\\n * to prevent infinite loops\\n */\\nconst maxGeneratorDuration = 20000;\\nfunction calcGeneratorDuration(generator) {\\n    let duration = 0;\\n    const timeStep = 50;\\n    let state = generator.next(duration);\\n    while (!state.done && duration < maxGeneratorDuration) {\\n        duration += timeStep;\\n        state = generator.next(duration);\\n    }\\n    return duration >= maxGeneratorDuration ? Infinity : duration;\\n}\\n\\n/**\\n * Create a progress => progress easing function from a generator.\\n */\\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\\n    return {\\n        type: \\\"keyframes\\\",\\n        ease: (progress) => {\\n            return generator.next(duration * progress).value / scale;\\n        },\\n        duration: motionUtils.millisecondsToSeconds(duration),\\n    };\\n}\\n\\nfunction isGenerator(type) {\\n    return typeof type === \\\"function\\\";\\n}\\n\\nfunction attachTimeline(animation, timeline) {\\n    animation.timeline = timeline;\\n    animation.onfinish = null;\\n}\\n\\nclass NativeAnimationControls {\\n    constructor(animation) {\\n        this.animation = animation;\\n    }\\n    get duration() {\\n        var _a, _b, _c;\\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\\n            300;\\n        return motionUtils.millisecondsToSeconds(Number(durationInMs));\\n    }\\n    get time() {\\n        var _a;\\n        if (this.animation) {\\n            return motionUtils.millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\\n        }\\n        return 0;\\n    }\\n    set time(newTime) {\\n        if (this.animation) {\\n            this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime);\\n        }\\n    }\\n    get speed() {\\n        return this.animation ? this.animation.playbackRate : 1;\\n    }\\n    set speed(newSpeed) {\\n        if (this.animation) {\\n            this.animation.playbackRate = newSpeed;\\n        }\\n    }\\n    get state() {\\n        return this.animation ? this.animation.playState : \\\"finished\\\";\\n    }\\n    get startTime() {\\n        return this.animation ? this.animation.startTime : null;\\n    }\\n    get finished() {\\n        return this.animation ? this.animation.finished : Promise.resolve();\\n    }\\n    play() {\\n        this.animation && this.animation.play();\\n    }\\n    pause() {\\n        this.animation && this.animation.pause();\\n    }\\n    stop() {\\n        if (!this.animation ||\\n            this.state === \\\"idle\\\" ||\\n            this.state === \\\"finished\\\") {\\n            return;\\n        }\\n        if (this.animation.commitStyles) {\\n            this.animation.commitStyles();\\n        }\\n        this.cancel();\\n    }\\n    flatten() {\\n        var _a;\\n        if (!this.animation)\\n            return;\\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: \\\"linear\\\" });\\n    }\\n    attachTimeline(timeline) {\\n        if (this.animation)\\n            attachTimeline(this.animation, timeline);\\n        return motionUtils.noop;\\n    }\\n    complete() {\\n        this.animation && this.animation.finish();\\n    }\\n    cancel() {\\n        try {\\n            this.animation && this.animation.cancel();\\n        }\\n        catch (e) { }\\n    }\\n}\\n\\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \\\"number\\\";\\n\\n/**\\n * Add the ability for test suites to manually set support flags\\n * to better test more environments.\\n */\\nconst supportsFlags = {\\n    linearEasing: undefined,\\n};\\n\\nfunction memoSupports(callback, supportsFlag) {\\n    const memoized = motionUtils.memo(callback);\\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\\n}\\n\\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\\n    try {\\n        document\\n            .createElement(\\\"div\\\")\\n            .animate({ opacity: 0 }, { easing: \\\"linear(0, 1)\\\" });\\n    }\\n    catch (e) {\\n        return false;\\n    }\\n    return true;\\n}, \\\"linearEasing\\\");\\n\\nconst generateLinearEasing = (easing, duration, // as milliseconds\\nresolution = 10 // as milliseconds\\n) => {\\n    let points = \\\"\\\";\\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\\n    for (let i = 0; i < numPoints; i++) {\\n        points += easing(motionUtils.progress(0, numPoints - 1, i)) + \\\", \\\";\\n    }\\n    return `linear(${points.substring(0, points.length - 2)})`;\\n};\\n\\nfunction isWaapiSupportedEasing(easing) {\\n    return Boolean((typeof easing === \\\"function\\\" && supportsLinearEasing()) ||\\n        !easing ||\\n        (typeof easing === \\\"string\\\" &&\\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\\n        isBezierDefinition(easing) ||\\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\\n}\\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\\nconst supportedWaapiEasing = {\\n    linear: \\\"linear\\\",\\n    ease: \\\"ease\\\",\\n    easeIn: \\\"ease-in\\\",\\n    easeOut: \\\"ease-out\\\",\\n    easeInOut: \\\"ease-in-out\\\",\\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\\n};\\nfunction mapEasingToNativeEasing(easing, duration) {\\n    if (!easing) {\\n        return undefined;\\n    }\\n    else if (typeof easing === \\\"function\\\" && supportsLinearEasing()) {\\n        return generateLinearEasing(easing, duration);\\n    }\\n    else if (isBezierDefinition(easing)) {\\n        return cubicBezierAsString(easing);\\n    }\\n    else if (Array.isArray(easing)) {\\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\\n            supportedWaapiEasing.easeOut);\\n    }\\n    else {\\n        return supportedWaapiEasing[easing];\\n    }\\n}\\n\\nconst isDragging = {\\n    x: false,\\n    y: false,\\n};\\nfunction isDragActive() {\\n    return isDragging.x || isDragging.y;\\n}\\n\\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\\n    var _a;\\n    if (elementOrSelector instanceof EventTarget) {\\n        return [elementOrSelector];\\n    }\\n    else if (typeof elementOrSelector === \\\"string\\\") {\\n        let root = document;\\n        if (scope) {\\n            // TODO: Refactor to utils package\\n            // invariant(\\n            //     Boolean(scope.current),\\n            //     \\\"Scope provided, but no element detected.\\\"\\n            // )\\n            root = scope.current;\\n        }\\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\\n        return elements ? Array.from(elements) : [];\\n    }\\n    return Array.from(elementOrSelector);\\n}\\n\\nfunction setupGesture(elementOrSelector, options) {\\n    const elements = resolveElements(elementOrSelector);\\n    const gestureAbortController = new AbortController();\\n    const eventOptions = {\\n        passive: true,\\n        ...options,\\n        signal: gestureAbortController.signal,\\n    };\\n    const cancel = () => gestureAbortController.abort();\\n    return [elements, eventOptions, cancel];\\n}\\n\\nfunction isValidHover(event) {\\n    return !(event.pointerType === \\\"touch\\\" || isDragActive());\\n}\\n/**\\n * Create a hover gesture. hover() is different to .addEventListener(\\\"pointerenter\\\")\\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\\n * with drag gestures, and automatically removes the \\\"pointerennd\\\" event listener when the hover ends.\\n *\\n * @public\\n */\\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\\n    const onPointerEnter = (enterEvent) => {\\n        if (!isValidHover(enterEvent))\\n            return;\\n        const { target } = enterEvent;\\n        const onHoverEnd = onHoverStart(target, enterEvent);\\n        if (typeof onHoverEnd !== \\\"function\\\" || !target)\\n            return;\\n        const onPointerLeave = (leaveEvent) => {\\n            if (!isValidHover(leaveEvent))\\n                return;\\n            onHoverEnd(leaveEvent);\\n            target.removeEventListener(\\\"pointerleave\\\", onPointerLeave);\\n        };\\n        target.addEventListener(\\\"pointerleave\\\", onPointerLeave, eventOptions);\\n    };\\n    elements.forEach((element) => {\\n        element.addEventListener(\\\"pointerenter\\\", onPointerEnter, eventOptions);\\n    });\\n    return cancel;\\n}\\n\\nfunction capturePointer(event, action) {\\n    const actionName = `${action}PointerCapture`;\\n    if (event.target instanceof Element &&\\n        actionName in event.target &&\\n        event.pointerId !== undefined) {\\n        try {\\n            event.target[actionName](event.pointerId);\\n        }\\n        catch (e) { }\\n    }\\n}\\n\\n/**\\n * Recursively traverse up the tree to check whether the provided child node\\n * is the parent or a descendant of it.\\n *\\n * @param parent - Element to find\\n * @param child - Element to test against parent\\n */\\nconst isNodeOrChild = (parent, child) => {\\n    if (!child) {\\n        return false;\\n    }\\n    else if (parent === child) {\\n        return true;\\n    }\\n    else {\\n        return isNodeOrChild(parent, child.parentElement);\\n    }\\n};\\n\\nconst isPrimaryPointer = (event) => {\\n    if (event.pointerType === \\\"mouse\\\") {\\n        return typeof event.button !== \\\"number\\\" || event.button <= 0;\\n    }\\n    else {\\n        /**\\n         * isPrimary is true for all mice buttons, whereas every touch point\\n         * is regarded as its own input. So subsequent concurrent touch points\\n         * will be false.\\n         *\\n         * Specifically match against false here as incomplete versions of\\n         * PointerEvents in very old browser might have it set as undefined.\\n         */\\n        return event.isPrimary !== false;\\n    }\\n};\\n\\nconst focusableElements = new Set([\\n    \\\"BUTTON\\\",\\n    \\\"INPUT\\\",\\n    \\\"SELECT\\\",\\n    \\\"TEXTAREA\\\",\\n    \\\"A\\\",\\n]);\\nfunction isElementKeyboardAccessible(element) {\\n    return (focusableElements.has(element.tagName) ||\\n        element.tabIndex !== -1);\\n}\\n\\nconst isPressing = new WeakSet();\\n\\n/**\\n * Filter out events that are not \\\"Enter\\\" keys.\\n */\\nfunction filterEvents(callback) {\\n    return (event) => {\\n        if (event.key !== \\\"Enter\\\")\\n            return;\\n        callback(event);\\n    };\\n}\\nfunction firePointerEvent(target, type) {\\n    target.dispatchEvent(new PointerEvent(\\\"pointer\\\" + type, { isPrimary: true, bubbles: true }));\\n}\\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\\n    const element = focusEvent.currentTarget;\\n    if (!element)\\n        return;\\n    const handleKeydown = filterEvents(() => {\\n        if (isPressing.has(element))\\n            return;\\n        firePointerEvent(element, \\\"down\\\");\\n        const handleKeyup = filterEvents(() => {\\n            firePointerEvent(element, \\\"up\\\");\\n        });\\n        const handleBlur = () => firePointerEvent(element, \\\"cancel\\\");\\n        element.addEventListener(\\\"keyup\\\", handleKeyup, eventOptions);\\n        element.addEventListener(\\\"blur\\\", handleBlur, eventOptions);\\n    });\\n    element.addEventListener(\\\"keydown\\\", handleKeydown, eventOptions);\\n    /**\\n     * Add an event listener that fires on blur to remove the keydown events.\\n     */\\n    element.addEventListener(\\\"blur\\\", () => element.removeEventListener(\\\"keydown\\\", handleKeydown), eventOptions);\\n};\\n\\n/**\\n * Filter out events that are not primary pointer events, or are triggering\\n * while a Motion gesture is active.\\n */\\nfunction isValidPressEvent(event) {\\n    return isPrimaryPointer(event) && !isDragActive();\\n}\\n/**\\n * Create a press gesture.\\n *\\n * Press is different to `\\\"pointerdown\\\"`, `\\\"pointerup\\\"` in that it\\n * automatically filters out secondary pointer events like right\\n * click and multitouch.\\n *\\n * It also adds accessibility support for keyboards, where\\n * an element with a press gesture will receive focus and\\n *  trigger on Enter `\\\"keydown\\\"` and `\\\"keyup\\\"` events.\\n *\\n * This is different to a browser's `\\\"click\\\"` event, which does\\n * respond to keyboards but only for the `\\\"click\\\"` itself, rather\\n * than the press start and end/cancel. The element also needs\\n * to be focusable for this to work, whereas a press gesture will\\n * make an element focusable by default.\\n *\\n * @public\\n */\\nfunction press(targetOrSelector, onPressStart, options = {}) {\\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\\n    const startPress = (startEvent) => {\\n        const target = startEvent.currentTarget;\\n        if (!target || !isValidPressEvent(startEvent) || isPressing.has(target))\\n            return;\\n        isPressing.add(target);\\n        capturePointer(startEvent, \\\"set\\\");\\n        const onPressEnd = onPressStart(target, startEvent);\\n        const onPointerEnd = (endEvent, success) => {\\n            target.removeEventListener(\\\"pointerup\\\", onPointerUp);\\n            target.removeEventListener(\\\"pointercancel\\\", onPointerCancel);\\n            capturePointer(endEvent, \\\"release\\\");\\n            if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\\n                return;\\n            }\\n            isPressing.delete(target);\\n            if (typeof onPressEnd === \\\"function\\\") {\\n                onPressEnd(endEvent, { success });\\n            }\\n        };\\n        const onPointerUp = (upEvent) => {\\n            const isOutside = !upEvent.isTrusted\\n                ? false\\n                : checkOutside(upEvent, target instanceof Element\\n                    ? target.getBoundingClientRect()\\n                    : {\\n                        left: 0,\\n                        top: 0,\\n                        right: window.innerWidth,\\n                        bottom: window.innerHeight,\\n                    });\\n            if (isOutside) {\\n                onPointerEnd(upEvent, false);\\n            }\\n            else {\\n                onPointerEnd(upEvent, !(target instanceof Element) ||\\n                    isNodeOrChild(target, upEvent.target));\\n            }\\n        };\\n        const onPointerCancel = (cancelEvent) => {\\n            onPointerEnd(cancelEvent, false);\\n        };\\n        target.addEventListener(\\\"pointerup\\\", onPointerUp, eventOptions);\\n        target.addEventListener(\\\"pointercancel\\\", onPointerCancel, eventOptions);\\n        target.addEventListener(\\\"lostpointercapture\\\", onPointerCancel, eventOptions);\\n    };\\n    targets.forEach((target) => {\\n        target = options.useGlobalTarget ? window : target;\\n        let canAddKeyboardAccessibility = false;\\n        if (target instanceof HTMLElement) {\\n            canAddKeyboardAccessibility = true;\\n            if (!isElementKeyboardAccessible(target) &&\\n                target.getAttribute(\\\"tabindex\\\") === null) {\\n                target.tabIndex = 0;\\n            }\\n        }\\n        target.addEventListener(\\\"pointerdown\\\", startPress, eventOptions);\\n        if (canAddKeyboardAccessibility) {\\n            target.addEventListener(\\\"focus\\\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\\n        }\\n    });\\n    return cancelEvents;\\n}\\nfunction checkOutside(event, rect) {\\n    return (event.clientX < rect.left ||\\n        event.clientX > rect.right ||\\n        event.clientY < rect.top ||\\n        event.clientY > rect.bottom);\\n}\\n\\nconst defaultEasing = \\\"easeOut\\\";\\nfunction applyGeneratorOptions(options) {\\n    var _a;\\n    if (isGenerator(options.type)) {\\n        const generatorOptions = createGeneratorEasing(options, 100, options.type);\\n        options.ease = supportsLinearEasing()\\n            ? generatorOptions.ease\\n            : defaultEasing;\\n        options.duration = motionUtils.secondsToMilliseconds(generatorOptions.duration);\\n        options.type = \\\"keyframes\\\";\\n    }\\n    else {\\n        options.duration = motionUtils.secondsToMilliseconds((_a = options.duration) !== null && _a !== void 0 ? _a : 0.3);\\n        options.ease = options.ease || defaultEasing;\\n    }\\n}\\n// TODO: Reuse for NativeAnimation\\nfunction convertMotionOptionsToNative(valueName, keyframes, options) {\\n    var _a;\\n    const nativeKeyframes = {};\\n    const nativeOptions = {\\n        fill: \\\"both\\\",\\n        easing: \\\"linear\\\",\\n        composite: \\\"replace\\\",\\n    };\\n    nativeOptions.delay = motionUtils.secondsToMilliseconds((_a = options.delay) !== null && _a !== void 0 ? _a : 0);\\n    applyGeneratorOptions(options);\\n    nativeOptions.duration = options.duration;\\n    const { ease, times } = options;\\n    if (times)\\n        nativeKeyframes.offset = times;\\n    nativeKeyframes[valueName] = keyframes;\\n    const easing = mapEasingToNativeEasing(ease, options.duration);\\n    /**\\n     * If this is an easing array, apply to keyframes, not animation as a whole\\n     */\\n    if (Array.isArray(easing)) {\\n        nativeKeyframes.easing = easing;\\n    }\\n    else {\\n        nativeOptions.easing = easing;\\n    }\\n    return {\\n        keyframes: nativeKeyframes,\\n        options: nativeOptions,\\n    };\\n}\\n\\nclass PseudoAnimation extends NativeAnimationControls {\\n    constructor(target, pseudoElement, valueName, keyframes, options) {\\n        const animationOptions = convertMotionOptionsToNative(valueName, keyframes, options);\\n        const animation = target.animate(animationOptions.keyframes, {\\n            pseudoElement,\\n            ...animationOptions.options,\\n        });\\n        super(animation);\\n    }\\n}\\n\\nfunction chooseLayerType(valueName) {\\n    if (valueName === \\\"layout\\\")\\n        return \\\"group\\\";\\n    if (valueName === \\\"enter\\\" || valueName === \\\"new\\\")\\n        return \\\"new\\\";\\n    if (valueName === \\\"exit\\\" || valueName === \\\"old\\\")\\n        return \\\"old\\\";\\n    return \\\"group\\\";\\n}\\n\\nlet pendingRules = {};\\nlet style = null;\\nconst css = {\\n    set: (selector, values) => {\\n        pendingRules[selector] = values;\\n    },\\n    commit: () => {\\n        if (!style) {\\n            style = document.createElement(\\\"style\\\");\\n            style.id = \\\"motion-view\\\";\\n        }\\n        let cssText = \\\"\\\";\\n        for (const selector in pendingRules) {\\n            const rule = pendingRules[selector];\\n            cssText += `${selector} {\\\\n`;\\n            for (const [property, value] of Object.entries(rule)) {\\n                cssText += `  ${property}: ${value};\\\\n`;\\n            }\\n            cssText += \\\"}\\\\n\\\";\\n        }\\n        style.textContent = cssText;\\n        document.head.appendChild(style);\\n        pendingRules = {};\\n    },\\n    remove: () => {\\n        if (style && style.parentElement) {\\n            style.parentElement.removeChild(style);\\n        }\\n    },\\n};\\n\\nfunction getLayerName(pseudoElement) {\\n    const match = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\\\\((.*?)\\\\)/);\\n    if (!match)\\n        return null;\\n    return { layer: match[2], type: match[1] };\\n}\\n\\nfunction filterViewAnimations(animation) {\\n    var _a;\\n    const { effect } = animation;\\n    if (!effect)\\n        return false;\\n    return (effect.target === document.documentElement &&\\n        ((_a = effect.pseudoElement) === null || _a === void 0 ? void 0 : _a.startsWith(\\\"::view-transition\\\")));\\n}\\nfunction getViewAnimations() {\\n    return document.getAnimations().filter(filterViewAnimations);\\n}\\n\\nfunction hasTarget(target, targets) {\\n    return targets.has(target) && Object.keys(targets.get(target)).length > 0;\\n}\\n\\nconst definitionNames = [\\\"layout\\\", \\\"enter\\\", \\\"exit\\\", \\\"new\\\", \\\"old\\\"];\\nfunction startViewAnimation(update, defaultOptions, targets) {\\n    if (!document.startViewTransition) {\\n        return new Promise(async (resolve) => {\\n            await update();\\n            resolve(new BaseGroupPlaybackControls([]));\\n        });\\n    }\\n    // TODO: Go over existing targets and ensure they all have ids\\n    /**\\n     * If we don't have any animations defined for the root target,\\n     * remove it from being captured.\\n     */\\n    if (!hasTarget(\\\"root\\\", targets)) {\\n        css.set(\\\":root\\\", {\\n            \\\"view-transition-name\\\": \\\"none\\\",\\n        });\\n    }\\n    /**\\n     * Set the timing curve to linear for all view transition layers.\\n     * This gets baked into the keyframes, which can't be changed\\n     * without breaking the generated animation.\\n     *\\n     * This allows us to set easing via updateTiming - which can be changed.\\n     */\\n    css.set(\\\"::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)\\\", { \\\"animation-timing-function\\\": \\\"linear !important\\\" });\\n    css.commit(); // Write\\n    const transition = document.startViewTransition(async () => {\\n        await update();\\n        // TODO: Go over new targets and ensure they all have ids\\n    });\\n    transition.finished.finally(() => {\\n        css.remove(); // Write\\n    });\\n    return new Promise((resolve) => {\\n        transition.ready.then(() => {\\n            var _a;\\n            const generatedViewAnimations = getViewAnimations();\\n            const animations = [];\\n            /**\\n             * Create animations for our definitions\\n             */\\n            targets.forEach((definition, target) => {\\n                // TODO: If target is not \\\"root\\\", resolve elements\\n                // and iterate over each\\n                for (const key of definitionNames) {\\n                    if (!definition[key])\\n                        continue;\\n                    const { keyframes, options } = definition[key];\\n                    for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\\n                        if (!valueKeyframes)\\n                            continue;\\n                        const valueOptions = {\\n                            ...getValueTransition(defaultOptions, valueName),\\n                            ...getValueTransition(options, valueName),\\n                        };\\n                        const type = chooseLayerType(key);\\n                        /**\\n                         * If this is an opacity animation, and keyframes are not an array,\\n                         * we need to convert them into an array and set an initial value.\\n                         */\\n                        if (valueName === \\\"opacity\\\" &&\\n                            !Array.isArray(valueKeyframes)) {\\n                            const initialValue = type === \\\"new\\\" ? 0 : 1;\\n                            valueKeyframes = [initialValue, valueKeyframes];\\n                        }\\n                        /**\\n                         * Resolve stagger function if provided.\\n                         */\\n                        if (typeof valueOptions.delay === \\\"function\\\") {\\n                            valueOptions.delay = valueOptions.delay(0, 1);\\n                        }\\n                        const animation = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\\n                        animations.push(animation);\\n                    }\\n                }\\n            });\\n            /**\\n             * Handle browser generated animations\\n             */\\n            for (const animation of generatedViewAnimations) {\\n                if (animation.playState === \\\"finished\\\")\\n                    continue;\\n                const { effect } = animation;\\n                if (!effect || !(effect instanceof KeyframeEffect))\\n                    continue;\\n                const { pseudoElement } = effect;\\n                if (!pseudoElement)\\n                    continue;\\n                const name = getLayerName(pseudoElement);\\n                if (!name)\\n                    continue;\\n                const targetDefinition = targets.get(name.layer);\\n                if (!targetDefinition) {\\n                    /**\\n                     * If transition name is group then update the timing of the animation\\n                     * whereas if it's old or new then we could possibly replace it using\\n                     * the above method.\\n                     */\\n                    const transitionName = name.type === \\\"group\\\" ? \\\"layout\\\" : \\\"\\\";\\n                    const animationTransition = {\\n                        ...getValueTransition(defaultOptions, transitionName),\\n                    };\\n                    applyGeneratorOptions(animationTransition);\\n                    const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\\n                    effect.updateTiming({\\n                        delay: motionUtils.secondsToMilliseconds((_a = animationTransition.delay) !== null && _a !== void 0 ? _a : 0),\\n                        duration: animationTransition.duration,\\n                        easing,\\n                    });\\n                    animations.push(new NativeAnimationControls(animation));\\n                }\\n                else if (hasOpacity(targetDefinition, \\\"enter\\\") &&\\n                    hasOpacity(targetDefinition, \\\"exit\\\") &&\\n                    effect\\n                        .getKeyframes()\\n                        .some((keyframe) => keyframe.mixBlendMode)) {\\n                    animations.push(new NativeAnimationControls(animation));\\n                }\\n                else {\\n                    animation.cancel();\\n                }\\n            }\\n            resolve(new BaseGroupPlaybackControls(animations));\\n        });\\n    });\\n}\\nfunction hasOpacity(target, key) {\\n    var _a;\\n    return (_a = target === null || target === void 0 ? void 0 : target[key]) === null || _a === void 0 ? void 0 : _a.keyframes.opacity;\\n}\\n\\n/**\\n * TODO:\\n * - Create view transition on next tick\\n * - Replace animations with Motion animations\\n * - Return GroupAnimation on next tick\\n */\\nclass ViewTransitionBuilder {\\n    constructor(update, options = {}) {\\n        this.currentTarget = \\\"root\\\";\\n        this.targets = new Map();\\n        this.notifyReady = motionUtils.noop;\\n        this.readyPromise = new Promise((resolve) => {\\n            this.notifyReady = resolve;\\n        });\\n        queueMicrotask(() => {\\n            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));\\n        });\\n    }\\n    get(selector) {\\n        this.currentTarget = selector;\\n        return this;\\n    }\\n    layout(keyframes, options) {\\n        this.updateTarget(\\\"layout\\\", keyframes, options);\\n        return this;\\n    }\\n    new(keyframes, options) {\\n        this.updateTarget(\\\"new\\\", keyframes, options);\\n        return this;\\n    }\\n    old(keyframes, options) {\\n        this.updateTarget(\\\"old\\\", keyframes, options);\\n        return this;\\n    }\\n    enter(keyframes, options) {\\n        this.updateTarget(\\\"enter\\\", keyframes, options);\\n        return this;\\n    }\\n    exit(keyframes, options) {\\n        this.updateTarget(\\\"exit\\\", keyframes, options);\\n        return this;\\n    }\\n    crossfade(options) {\\n        this.updateTarget(\\\"enter\\\", { opacity: 1 }, options);\\n        this.updateTarget(\\\"exit\\\", { opacity: 0 }, options);\\n        return this;\\n    }\\n    updateTarget(target, keyframes, options = {}) {\\n        const { currentTarget, targets } = this;\\n        if (!targets.has(currentTarget)) {\\n            targets.set(currentTarget, {});\\n        }\\n        const targetData = targets.get(currentTarget);\\n        targetData[target] = { keyframes, options };\\n    }\\n    then(resolve, reject) {\\n        return this.readyPromise.then(resolve, reject);\\n    }\\n}\\nfunction view(update, defaultOptions = {}) {\\n    return new ViewTransitionBuilder(update, defaultOptions);\\n}\\n\\nfunction setDragLock(axis) {\\n    if (axis === \\\"x\\\" || axis === \\\"y\\\") {\\n        if (isDragging[axis]) {\\n            return null;\\n        }\\n        else {\\n            isDragging[axis] = true;\\n            return () => {\\n                isDragging[axis] = false;\\n            };\\n        }\\n    }\\n    else {\\n        if (isDragging.x || isDragging.y) {\\n            return null;\\n        }\\n        else {\\n            isDragging.x = isDragging.y = true;\\n            return () => {\\n                isDragging.x = isDragging.y = false;\\n            };\\n        }\\n    }\\n}\\n\\nexports.GroupPlaybackControls = GroupPlaybackControls;\\nexports.NativeAnimationControls = NativeAnimationControls;\\nexports.ViewTransitionBuilder = ViewTransitionBuilder;\\nexports.attachTimeline = attachTimeline;\\nexports.calcGeneratorDuration = calcGeneratorDuration;\\nexports.capturePointer = capturePointer;\\nexports.createGeneratorEasing = createGeneratorEasing;\\nexports.cubicBezierAsString = cubicBezierAsString;\\nexports.generateLinearEasing = generateLinearEasing;\\nexports.getValueTransition = getValueTransition;\\nexports.hover = hover;\\nexports.isBezierDefinition = isBezierDefinition;\\nexports.isDragActive = isDragActive;\\nexports.isDragging = isDragging;\\nexports.isGenerator = isGenerator;\\nexports.isNodeOrChild = isNodeOrChild;\\nexports.isPrimaryPointer = isPrimaryPointer;\\nexports.isWaapiSupportedEasing = isWaapiSupportedEasing;\\nexports.mapEasingToNativeEasing = mapEasingToNativeEasing;\\nexports.maxGeneratorDuration = maxGeneratorDuration;\\nexports.press = press;\\nexports.resolveElements = resolveElements;\\nexports.setDragLock = setDragLock;\\nexports.supportedWaapiEasing = supportedWaapiEasing;\\nexports.supportsFlags = supportsFlags;\\nexports.supportsLinearEasing = supportsLinearEasing;\\nexports.supportsScrollTimeline = supportsScrollTimeline;\\nexports.view = view;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getValueTransition\",\"transition\",\"key\",\"undefined\",\"calcGeneratorDuration\",\"generator\",\"duration\",\"state\",\"next\",\"done\",\"maxGeneratorDuration\",\"timeStep\",\"Infinity\",\"createGeneratorEasing\",\"options\",\"scale\",\"createGenerator\",\"keyframes\",\"Math\",\"min\",\"type\",\"ease\",\"progress\",\"value\",\"motionUtils\",\"millisecondsToSeconds\",\"isGenerator\",\"attachTimeline\",\"animation\",\"timeline\",\"onfinish\",\"isWaapiSupportedEasing\",\"easing\",\"supportsLinearEasing\",\"supportedWaapiEasing\",\"isBezierDefinition\",\"Array\",\"isArray\",\"every\",\"mapEasingToNativeEasing\",\"generateLinearEasing\",\"cubicBezierAsString\",\"map\",\"segmentEasing\",\"easeOut\",\"isDragActive\",\"isDragging\",\"x\",\"y\",\"resolveElements\",\"elementOrSelector\",\"scope\",\"selectorCache\",\"_a\",\"EventTarget\",\"root\",\"document\",\"current\",\"elements\",\"querySelectorAll\",\"from\",\"setupGesture\",\"gestureAbortController\",\"AbortController\",\"eventOptions\",\"passive\",\"signal\",\"cancel\",\"abort\",\"capturePointer\",\"event\",\"action\",\"actionName\",\"target\",\"Element\",\"pointerId\",\"e\",\"isElementKeyboardAccessible\",\"element\",\"focusableElements\",\"has\",\"tagName\",\"tabIndex\",\"filterEvents\",\"callback\",\"firePointerEvent\",\"dispatchEvent\",\"PointerEvent\",\"isPrimary\",\"bubbles\",\"applyGeneratorOptions\",\"generatorOptions\",\"defaultEasing\",\"secondsToMilliseconds\",\"getLayerName\",\"pseudoElement\",\"match\",\"layer\",\"filterViewAnimations\",\"effect\",\"documentElement\",\"startsWith\",\"hasTarget\",\"targets\",\"Object\",\"keys\",\"get\",\"length\",\"startViewAnimation\",\"update\",\"defaultOptions\",\"startViewTransition\",\"Promise\",\"resolve\",\"BaseGroupPlaybackControls\",\"css\",\"set\",\"commit\",\"finished\",\"finally\",\"remove\",\"ready\",\"then\",\"generatedViewAnimations\",\"getAnimations\",\"filter\",\"animations\",\"forEach\",\"definition\",\"definitionNames\",\"valueName\",\"valueKeyframes\",\"entries\",\"valueOptions\",\"initialValue\",\"delay\",\"PseudoAnimation\",\"push\",\"playState\",\"KeyframeEffect\",\"name\",\"targetDefinition\",\"hasOpacity\",\"getKeyframes\",\"some\",\"keyframe\",\"mixBlendMode\",\"NativeAnimationControls\",\"animationTransition\",\"transitionName\",\"updateTiming\",\"opacity\",\"defineProperty\",\"supportsScrollTimeline\",\"memo\",\"window\",\"ScrollTimeline\",\"constructor\",\"stop\",\"this.stop\",\"runAll\",\"Boolean\",\"all\",\"getAll\",\"propName\",\"setAll\",\"newValue\",\"i\",\"fallback\",\"subscriptions\",\"time\",\"speed\",\"max\",\"methodName\",\"controls\",\"flatten\",\"play\",\"pause\",\"complete\",\"GroupPlaybackControls\",\"onResolve\",\"onReject\",\"catch\",\"_b\",\"_c\",\"durationInMs\",\"getComputedTiming\",\"Number\",\"currentTime\",\"newTime\",\"playbackRate\",\"newSpeed\",\"startTime\",\"commitStyles\",\"noop\",\"finish\",\"supportsFlags\",\"linearEasing\",\"memoSupports\",\"supportsFlag\",\"memoized\",\"createElement\",\"animate\",\"resolution\",\"points\",\"numPoints\",\"round\",\"substring\",\"a\",\"b\",\"c\",\"d\",\"linear\",\"easeIn\",\"easeInOut\",\"circIn\",\"circOut\",\"backIn\",\"backOut\",\"isNodeOrChild\",\"parent\",\"child\",\"parentElement\",\"isPrimaryPointer\",\"pointerType\",\"button\",\"Set\",\"isPressing\",\"WeakSet\",\"enableKeyboardPress\",\"focusEvent\",\"currentTarget\",\"handleKeydown\",\"handleKeyup\",\"addEventListener\",\"handleBlur\",\"removeEventListener\",\"nativeKeyframes\",\"nativeOptions\",\"fill\",\"composite\",\"times\",\"offset\",\"pendingRules\",\"style\",\"selector\",\"values\",\"id\",\"cssText\",\"rule\",\"property\",\"textContent\",\"head\",\"appendChild\",\"removeChild\",\"ViewTransitionBuilder\",\"Map\",\"notifyReady\",\"readyPromise\",\"queueMicrotask\",\"layout\",\"updateTarget\",\"new\",\"old\",\"enter\",\"exit\",\"crossfade\",\"targetData\",\"reject\",\"hover\",\"onHoverStart\",\"onPointerEnter\",\"enterEvent\",\"onHoverEnd\",\"onPointerLeave\",\"leaveEvent\",\"press\",\"targetOrSelector\",\"onPressStart\",\"cancelEvents\",\"startPress\",\"startEvent\",\"add\",\"onPressEnd\",\"onPointerEnd\",\"endEvent\",\"success\",\"onPointerUp\",\"onPointerCancel\",\"delete\",\"upEvent\",\"isTrusted\",\"clientX\",\"rect\",\"left\",\"right\",\"clientY\",\"top\",\"bottom\",\"isOutside\",\"cancelEvent\",\"useGlobalTarget\",\"canAddKeyboardAccessibility\",\"HTMLElement\",\"getAttribute\",\"setDragLock\",\"axis\",\"view\"]\n}\n"]