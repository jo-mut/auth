shadow$provide.module$node_modules$framer_motion$dist$cjs$index = function(global, require, module, exports) {
  function useUnmountEffect(callback) {
    return React.useEffect(() => () => callback(), []);
  }
  function useIsMounted() {
    const isMounted = React.useRef(!1);
    create.useIsomorphicLayoutEffect(() => {
      isMounted.current = !0;
      return () => {
        isMounted.current = !1;
      };
    }, []);
    return isMounted;
  }
  function useForceUpdate() {
    const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = React.useState(0), forceRender = React.useCallback(() => {
      isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
    }, [forcedRenderCount]);
    return [React.useCallback(() => create.frame.postRender(forceRender), [forceRender]), forcedRenderCount];
  }
  function PopChild({children, isPresent, anchorX}) {
    const id = React.useId(), ref = React.useRef(null), size = React.useRef({width:0, height:0, top:0, left:0, right:0}), {nonce} = React.useContext(create.MotionConfigContext);
    React.useInsertionEffect(() => {
      const {width, height, top, left, right} = size.current;
      if (!isPresent && ref.current && width && height) {
        var x = "left" === anchorX ? `left: ${left}` : `right: ${right}`;
        ref.current.dataset.motionPopId = id;
        var style = document.createElement("style");
        nonce && (style.nonce = nonce);
        document.head.appendChild(style);
        style.sheet && style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
        return () => {
          document.head.removeChild(style);
        };
      }
    }, [isPresent]);
    return jsxRuntime.jsx(PopChildMeasure, {isPresent, childRef:ref, sizeRef:size, children:React__namespace.cloneElement(children, {ref})});
  }
  function newChildrenMap() {
    return new Map();
  }
  function onlyElements(children) {
    const filtered = [];
    React.Children.forEach(children, child => {
      React.isValidElement(child) && filtered.push(child);
    });
    return filtered;
  }
  function nodeGroup() {
    const nodes = new Set(), subscriptions = new WeakMap(), dirtyAll = () => nodes.forEach(notify);
    return {add:node => {
      nodes.add(node);
      subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
    }, remove:node => {
      nodes.delete(node);
      const unsubscribe = subscriptions.get(node);
      unsubscribe && (unsubscribe(), subscriptions.delete(node));
      nodes.forEach(notify);
    }, dirty:dirtyAll};
  }
  function getEasingForSegment(easing, i) {
    return create.isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
  }
  function isDOMKeyframes(keyframes) {
    return "object" === typeof keyframes && !Array.isArray(keyframes);
  }
  function resolveSubjects(subject, keyframes, scope, selectorCache) {
    return "string" === typeof subject && isDOMKeyframes(keyframes) ? motionDom.resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
  }
  function calcNextTime(current, next, prev, labels) {
    var _a;
    return "number" === typeof next ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current + parseFloat(next)) : "\x3c" === next ? prev : null !== (_a = labels.get(next)) && void 0 !== _a ? _a : current;
  }
  function compareByTime(a, b) {
    return a.at === b.at ? null === a.value ? 1 : null === b.value ? -1 : 0 : a.at - b.at;
  }
  function createAnimationsFromSequence(sequence, {defaultTransition = {}, ...sequenceTransition} = {}, scope, generators) {
    const defaultDuration = defaultTransition.duration || 0.3, animationDefinitions = new Map(), sequences = new Map(), elementCache = {}, timeLabels = new Map();
    var prevTime = 0;
    let currentTime = 0, totalDuration = 0;
    for (let i = 0; i < sequence.length; i++) {
      var segment = sequence[i];
      if ("string" === typeof segment) {
        timeLabels.set(segment, currentTime);
        continue;
      } else if (!Array.isArray(segment)) {
        timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
        continue;
      }
      let [subject, keyframes, transition = {}] = segment;
      void 0 !== transition.at && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
      let maxDuration = 0;
      prevTime = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
        valueKeyframes = Array.isArray(valueKeyframes) ? valueKeyframes : [valueKeyframes];
        const {delay = 0, times = create.defaultOffset(valueKeyframes), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition} = valueTransition;
        let {ease = defaultTransition.ease || "easeOut", duration} = valueTransition;
        valueTransition = "function" === typeof delay ? delay(elementIndex, numSubjects) : delay;
        var numKeyframes = valueKeyframes.length;
        elementIndex = motionDom.isGenerator(type) ? type : null === generators || void 0 === generators ? void 0 : generators[type];
        2 >= numKeyframes && elementIndex && (numSubjects = 100, 2 === numKeyframes && valueKeyframes.every(isNumber) && (numSubjects = Math.abs(valueKeyframes[1] - valueKeyframes[0])), numKeyframes = {...remainingTransition}, void 0 !== duration && (numKeyframes.duration = motionUtils.secondsToMilliseconds(duration)), elementIndex = motionDom.createGeneratorEasing(numKeyframes, numSubjects, elementIndex), ease = elementIndex.ease, duration = elementIndex.duration);
        null !== duration && void 0 !== duration ? duration : duration = defaultDuration;
        elementIndex = currentTime + valueTransition;
        1 === times.length && 0 === times[0] && (times[1] = 1);
        numSubjects = times.length - valueKeyframes.length;
        0 < numSubjects && create.fillOffset(times, numSubjects);
        1 === valueKeyframes.length && valueKeyframes.unshift(null);
        if (repeat) {
          motionUtils.invariant(20 > repeat, "Repeat count too high, must be less than 20");
          duration *= repeat + 1;
          numSubjects = [...valueKeyframes];
          numKeyframes = [...times];
          ease = Array.isArray(ease) ? [...ease] : [ease];
          var originalEase = [...ease];
          for (var repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
            valueKeyframes.push(...numSubjects);
            for (let keyframeIndex = 0; keyframeIndex < numSubjects.length; keyframeIndex++) {
              times.push(numKeyframes[keyframeIndex] + (repeatIndex + 1)), ease.push(0 === keyframeIndex ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
            }
          }
          for (numSubjects = 0; numSubjects < times.length; numSubjects++) {
            times[numSubjects] /= repeat + 1;
          }
        }
        numSubjects = elementIndex + duration;
        numKeyframes = ease;
        for (originalEase = 0; originalEase < valueSequence.length; originalEase++) {
          repeatIndex = valueSequence[originalEase], repeatIndex.at > elementIndex && repeatIndex.at < numSubjects && (create.removeItem(valueSequence, repeatIndex), originalEase--);
        }
        for (originalEase = 0; originalEase < valueKeyframes.length; originalEase++) {
          valueSequence.push({value:valueKeyframes[originalEase], at:create.mixNumber(elementIndex, numSubjects, times[originalEase]), easing:getEasingForSegment(numKeyframes, originalEase)});
        }
        maxDuration = Math.max(valueTransition + duration, maxDuration);
        totalDuration = Math.max(numSubjects, totalDuration);
      };
      if (create.isMotionValue(subject)) {
        segment = getSubjectSequence(subject, sequences), prevTime(keyframes, transition, getValueSequence("default", segment));
      } else {
        segment = resolveSubjects(subject, keyframes, scope, elementCache);
        const numSubjects = segment.length;
        for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
          const subjectSequence = getSubjectSequence(segment[subjectIndex], sequences);
          for (const key in keyframes) {
            prevTime(keyframes[key], transition && transition[key] ? {...transition, ...transition[key]} : {...transition}, getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
          }
        }
      }
      prevTime = currentTime;
      currentTime += maxDuration;
    }
    sequences.forEach((valueSequences, element) => {
      for (const key in valueSequences) {
        var valueSequence = valueSequences[key];
        valueSequence.sort(compareByTime);
        const keyframes = [], valueOffset = [], valueEasing = [];
        for (let i = 0; i < valueSequence.length; i++) {
          const {at, value, easing} = valueSequence[i];
          keyframes.push(value);
          valueOffset.push(motionUtils.progress(0, totalDuration, at));
          valueEasing.push(easing || "easeOut");
        }
        0 !== valueOffset[0] && (valueOffset.unshift(0), keyframes.unshift(keyframes[0]), valueEasing.unshift("easeInOut"));
        1 !== valueOffset[valueOffset.length - 1] && (valueOffset.push(1), keyframes.push(null));
        animationDefinitions.has(element) || animationDefinitions.set(element, {keyframes:{}, transition:{}});
        valueSequence = animationDefinitions.get(element);
        valueSequence.keyframes[key] = keyframes;
        valueSequence.transition[key] = {...defaultTransition, duration:totalDuration, ease:valueEasing, times:valueOffset, ...sequenceTransition};
      }
    });
    return animationDefinitions;
  }
  function getSubjectSequence(subject, sequences) {
    !sequences.has(subject) && sequences.set(subject, {});
    return sequences.get(subject);
  }
  function getValueSequence(name, sequences) {
    sequences[name] || (sequences[name] = []);
    return sequences[name];
  }
  function createDOMVisualElement(element) {
    var options = {presenceContext:null, props:{}, visualState:{renderState:{transform:{}, transformOrigin:{}, style:{}, vars:{}, attrs:{}}, latestValues:{}}};
    options = create.isSVGElement(element) ? new create.SVGVisualElement(options) : new create.HTMLVisualElement(options);
    options.mount(element);
    create.visualElementStore.set(element, options);
  }
  function createObjectVisualElement(subject) {
    const node = new ObjectVisualElement({presenceContext:null, props:{}, visualState:{renderState:{output:{}}, latestValues:{}}});
    node.mount(subject);
    create.visualElementStore.set(subject, node);
  }
  function animateSubject(subject, keyframes, options, scope) {
    const animations = [];
    if (create.isMotionValue(subject) || "number" === typeof subject || "string" === typeof subject && !isDOMKeyframes(keyframes)) {
      animations.push(create.animateSingleValue(subject, isDOMKeyframes(keyframes) ? keyframes.default || keyframes : keyframes, options ? options.default || options : options));
    } else {
      subject = resolveSubjects(subject, keyframes, scope);
      scope = subject.length;
      motionUtils.invariant(!!scope, "No valid elements provided.");
      for (let i = 0; i < scope; i++) {
        var thisSubject = subject[i], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
        create.visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
        thisSubject = create.visualElementStore.get(thisSubject);
        createVisualElement = {...options};
        "delay" in createVisualElement && "function" === typeof createVisualElement.delay && (createVisualElement.delay = createVisualElement.delay(i, scope));
        animations.push(...create.animateTarget(thisSubject, {...keyframes, transition:createVisualElement}, {}));
      }
    }
    return animations;
  }
  function animateSequence(sequence, options, scope) {
    const animations = [];
    createAnimationsFromSequence(sequence, options, scope, {spring:create.spring}).forEach(({keyframes, transition}, subject) => {
      animations.push(...animateSubject(subject, keyframes, transition));
    });
    return animations;
  }
  function createScopedAnimate(scope) {
    return function(subjectOrSequence, optionsOrKeyframes, options) {
      subjectOrSequence = Array.isArray(subjectOrSequence) && subjectOrSequence.some(Array.isArray) ? animateSequence(subjectOrSequence, optionsOrKeyframes, scope) : animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
      subjectOrSequence = new motionDom.GroupPlaybackControls(subjectOrSequence);
      scope && scope.animations.push(subjectOrSequence);
      return subjectOrSequence;
    };
  }
  function setCSSVar(element, name, value) {
    element.style.setProperty(name, value);
  }
  function setStyle(element, name, value) {
    element.style[name] = value;
  }
  function hydrateKeyframes(valueName, keyframes, read) {
    for (let i = 0; i < keyframes.length; i++) {
      null === keyframes[i] && (keyframes[i] = 0 === i ? read() : keyframes[i - 1]), "number" === typeof keyframes[i] && create.browserNumberValueTypes[valueName] && (keyframes[i] = create.browserNumberValueTypes[valueName].transform(keyframes[i]));
    }
    !supportsPartialKeyframes() && 2 > keyframes.length && keyframes.unshift(read());
  }
  function getElementAnimationState(element) {
    const animationState = state.get(element) || new Map();
    state.set(element, animationState);
    return state.get(element);
  }
  function observeTimeline(update, timeline) {
    let prevProgress;
    const onFrame = () => {
      var {currentTime} = timeline;
      currentTime = (null === currentTime ? 0 : currentTime.value) / 100;
      prevProgress !== currentTime && update(currentTime);
      prevProgress = currentTime;
    };
    create.frame.update(onFrame, !0);
    return () => create.cancelFrame(onFrame);
  }
  function notifyTarget({target, contentRect, borderBoxSize}) {
    var _a;
    null === (_a = resizeHandlers.get(target)) || void 0 === _a || _a.forEach(handler => {
      handler({target, contentSize:contentRect, get size() {
        if (borderBoxSize) {
          const {inlineSize, blockSize} = borderBoxSize[0];
          var JSCompiler_inline_result = {width:inlineSize, height:blockSize};
        } else {
          JSCompiler_inline_result = target instanceof SVGElement && "getBBox" in target ? target.getBBox() : {width:target.offsetWidth, height:target.offsetHeight};
        }
        return JSCompiler_inline_result;
      }});
    });
  }
  function notifyAll(entries) {
    entries.forEach(notifyTarget);
  }
  function resizeElement(target, handler) {
    observer || "undefined" !== typeof ResizeObserver && (observer = new ResizeObserver(notifyAll));
    const elements = motionDom.resolveElements(target);
    elements.forEach(element => {
      let elementHandlers = resizeHandlers.get(element);
      elementHandlers || (elementHandlers = new Set(), resizeHandlers.set(element, elementHandlers));
      elementHandlers.add(handler);
      null === observer || void 0 === observer || observer.observe(element);
    });
    return () => {
      elements.forEach(element => {
        const elementHandlers = resizeHandlers.get(element);
        null === elementHandlers || void 0 === elementHandlers || elementHandlers.delete(handler);
        (null === elementHandlers || void 0 === elementHandlers ? 0 : elementHandlers.size) || null === observer || void 0 === observer || observer.unobserve(element);
      });
    };
  }
  function createWindowResizeHandler() {
    windowResizeHandler = () => {
      const size = {width:window.innerWidth, height:window.innerHeight}, info = {target:window, size, contentSize:size};
      windowCallbacks.forEach(callback => callback(info));
    };
    window.addEventListener("resize", windowResizeHandler);
  }
  function resizeWindow(callback) {
    windowCallbacks.add(callback);
    windowResizeHandler || createWindowResizeHandler();
    return () => {
      windowCallbacks.delete(callback);
      !windowCallbacks.size && windowResizeHandler && (windowResizeHandler = void 0);
    };
  }
  function resize(a, b) {
    return "function" === typeof a ? resizeWindow(a) : resizeElement(a, b);
  }
  function updateAxisInfo(element, axisName, info, time) {
    const axis = info[axisName], {length, position} = keys[axisName];
    axisName = axis.current;
    info = info.time;
    axis.current = element[`scroll${position}`];
    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];
    axis.offset.length = 0;
    axis.offset[0] = 0;
    axis.offset[1] = axis.scrollLength;
    axis.progress = motionUtils.progress(0, axis.scrollLength, axis.current);
    element = time - info;
    axis.velocity = 50 < element ? 0 : create.velocityPerSecond(axis.current - axisName, element);
  }
  function resolveEdge(edge, length, inset = 0) {
    let delta = 0;
    edge in namedEdges && (edge = namedEdges[edge]);
    if ("string" === typeof edge) {
      const asNumber = parseFloat(edge);
      edge.endsWith("px") ? delta = asNumber : edge.endsWith("%") ? edge = asNumber / 100 : edge.endsWith("vw") ? delta = asNumber / 100 * document.documentElement.clientWidth : edge.endsWith("vh") ? delta = asNumber / 100 * document.documentElement.clientHeight : edge = asNumber;
    }
    "number" === typeof edge && (delta = length * edge);
    return inset + delta;
  }
  function measure(container, target = container, info) {
    info.x.targetOffset = 0;
    info.y.targetOffset = 0;
    if (target !== container) {
      let node = target;
      for (; node && node !== container;) {
        info.x.targetOffset += node.offsetLeft, info.y.targetOffset += node.offsetTop, node = node.offsetParent;
      }
    }
    info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
    info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
    info.x.containerLength = container.clientWidth;
    info.y.containerLength = container.clientHeight;
    container && target && target !== container && create.warnOnce("static" !== getComputedStyle(container).position, "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
  }
  function createOnScrollHandler(element, onScroll, info, options = {}) {
    return {measure:() => measure(element, options.target, info), update:time => {
      updateAxisInfo(element, "x", info, time);
      updateAxisInfo(element, "y", info, time);
      info.time = time;
      if (options.offset || options.target) {
        ({offset:time = ScrollOffset.All} = options);
        const {target = element, axis = "y"} = options, lengthLabel = "y" === axis ? "height" : "width";
        if (target !== element) {
          var JSCompiler_temp = {x:0, y:0};
          for (var current = target; current && current !== element;) {
            if (current instanceof HTMLElement) {
              JSCompiler_temp.x += current.offsetLeft, JSCompiler_temp.y += current.offsetTop, current = current.offsetParent;
            } else if ("svg" === current.tagName) {
              var svgBoundingBox = current.getBoundingClientRect();
              current = current.parentElement;
              var parentBoundingBox = current.getBoundingClientRect();
              JSCompiler_temp.x += svgBoundingBox.left - parentBoundingBox.left;
              JSCompiler_temp.y += svgBoundingBox.top - parentBoundingBox.top;
            } else if (current instanceof SVGGraphicsElement) {
              const {x, y} = current.getBBox();
              JSCompiler_temp.x += x;
              JSCompiler_temp.y += y;
              svgBoundingBox = null;
              for (parentBoundingBox = current.parentNode; !svgBoundingBox;) {
                "svg" === parentBoundingBox.tagName && (svgBoundingBox = parentBoundingBox), parentBoundingBox = current.parentNode;
              }
              current = svgBoundingBox;
            } else {
              break;
            }
          }
        } else {
          JSCompiler_temp = point;
        }
        current = target === element ? {width:element.scrollWidth, height:element.scrollHeight} : "getBBox" in target && "svg" !== target.tagName ? target.getBBox() : {width:target.clientWidth, height:target.clientHeight};
        svgBoundingBox = {width:element.clientWidth, height:element.clientHeight};
        info[axis].offset.length = 0;
        parentBoundingBox = !info[axis].interpolate;
        const numOffsets = time.length;
        for (let i = 0; i < numOffsets; i++) {
          var containerPoint = void 0, targetPoint = void 0;
          targetPoint = time[i];
          containerPoint = svgBoundingBox[lengthLabel];
          var targetLength = current[lengthLabel], targetInset = JSCompiler_temp[axis];
          let offsetDefinition = Array.isArray(targetPoint) ? targetPoint : defaultOffset;
          "number" === typeof targetPoint ? offsetDefinition = [targetPoint, targetPoint] : "string" === typeof targetPoint && (targetPoint = targetPoint.trim(), offsetDefinition = targetPoint.includes(" ") ? targetPoint.split(" ") : [targetPoint, namedEdges[targetPoint] ? targetPoint : "0"]);
          targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
          containerPoint = resolveEdge(offsetDefinition[1], containerPoint);
          containerPoint = targetPoint - containerPoint;
          parentBoundingBox || containerPoint === info[axis].interpolatorOffsets[i] || (parentBoundingBox = !0);
          info[axis].offset[i] = containerPoint;
        }
        parentBoundingBox && (info[axis].interpolate = create.interpolate(info[axis].offset, create.defaultOffset(time), {clamp:!1}), info[axis].interpolatorOffsets = [...info[axis].offset]);
        info[axis].progress = create.clamp(0, 1, info[axis].interpolate(info[axis].current));
      }
    }, notify:() => onScroll(info)};
  }
  function scrollInfo(onScroll, {container = document.documentElement, ...options} = {}) {
    let containerHandlers = onScrollHandlers.get(container);
    containerHandlers || (containerHandlers = new Set(), onScrollHandlers.set(container, containerHandlers));
    const info = {time:0, x:createAxisInfo(), y:createAxisInfo()}, containerHandler = createOnScrollHandler(container, onScroll, info, options);
    containerHandlers.add(containerHandler);
    if (!scrollListeners.has(container)) {
      const measureAll = () => {
        for (const handler of containerHandlers) {
          handler.measure();
        }
      }, updateAll = () => {
        for (const handler of containerHandlers) {
          handler.update(create.frameData.timestamp);
        }
      }, notifyAll = () => {
        for (const handler of containerHandlers) {
          handler.notify();
        }
      };
      onScroll = () => {
        create.frame.read(measureAll, !1, !0);
        create.frame.read(updateAll, !1, !0);
        create.frame.update(notifyAll, !1, !0);
      };
      scrollListeners.set(container, onScroll);
      options = container === document.documentElement ? window : container;
      window.addEventListener("resize", onScroll, {passive:!0});
      container !== document.documentElement && resizeListeners.set(container, resize(container, onScroll));
      options.addEventListener("scroll", onScroll, {passive:!0});
    }
    const listener = scrollListeners.get(container);
    create.frame.read(listener, !1, !0);
    return () => {
      var _a;
      create.cancelFrame(listener);
      var currentHandlers = onScrollHandlers.get(container);
      currentHandlers && (currentHandlers.delete(containerHandler), currentHandlers.size || (currentHandlers = scrollListeners.get(container), scrollListeners.delete(container), currentHandlers && ((container === document.documentElement ? window : container).removeEventListener("scroll", currentHandlers), null === (_a = resizeListeners.get(container)) || void 0 === _a || _a(), window.removeEventListener("resize", currentHandlers))));
    };
  }
  function scrollTimelineFallback({source, container, axis = "y"}) {
    source && (container = source);
    const currentTime = {value:0};
    source = scrollInfo(info => {
      currentTime.value = 100 * info[axis].progress;
    }, {container, axis});
    return {currentTime, cancel:source};
  }
  function getTimeline({source, container = document.documentElement, axis = "y"} = {}) {
    source && (container = source);
    timelineCache.has(container) || timelineCache.set(container, {});
    source = timelineCache.get(container);
    source[axis] || (source[axis] = motionDom.supportsScrollTimeline() ? new ScrollTimeline({source:container, axis}) : scrollTimelineFallback({source:container, axis}));
    return source[axis];
  }
  function scrollFunction(onScroll, options) {
    return 2 === onScroll.length || options && (options.target || options.offset) ? scrollInfo(info => {
      onScroll(info[options.axis].progress, info);
    }, options) : observeTimeline(onScroll, getTimeline(options));
  }
  function scrollAnimation(animation, options) {
    animation.flatten();
    if (options && (options.target || options.offset)) {
      return animation.pause(), scrollInfo(info => {
        animation.time = animation.duration * info[options.axis].progress;
      }, options);
    }
    const timeline = getTimeline(options);
    return animation.attachTimeline ? animation.attachTimeline(timeline, valueAnimation => {
      valueAnimation.pause();
      return observeTimeline(progress => {
        valueAnimation.time = valueAnimation.duration * progress;
      }, timeline);
    }) : motionUtils.noop;
  }
  function scroll(onScroll, {axis = "y", ...options} = {}) {
    axis = {axis, ...options};
    return "function" === typeof onScroll ? scrollFunction(onScroll, axis) : scrollAnimation(onScroll, axis);
  }
  function inView(elementOrSelector, onStart, {root, margin:rootMargin, amount = "some"} = {}) {
    elementOrSelector = motionDom.resolveElements(elementOrSelector);
    const activeIntersections = new WeakMap(), observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        var onEnd = activeIntersections.get(entry.target);
        entry.isIntersecting !== !!onEnd && (entry.isIntersecting ? (onEnd = onStart(entry.target, entry), "function" === typeof onEnd ? activeIntersections.set(entry.target, onEnd) : observer.unobserve(entry.target)) : "function" === typeof onEnd && (onEnd(entry), activeIntersections.delete(entry.target)));
      });
    }, {root, rootMargin, threshold:"number" === typeof amount ? amount : thresholds[amount]});
    elementOrSelector.forEach(element => observer.observe(element));
    return () => observer.disconnect();
  }
  function transform(...args) {
    const useImmediate = !Array.isArray(args[0]), argOffset = useImmediate ? 0 : -1, inputValue = args[0 + argOffset], outputRange = args[2 + argOffset];
    var JSCompiler_temp_const = create, v = outputRange[0];
    args = JSCompiler_temp_const.interpolate.call(JSCompiler_temp_const, args[1 + argOffset], outputRange, {mixer:v && "object" === typeof v && v.mix ? v.mix : void 0, ...args[3 + argOffset]});
    return useImmediate ? args(inputValue) : args;
  }
  function isLazyBundle(features) {
    return "function" === typeof features;
  }
  function createDOMMotionComponentProxy(componentFactory) {
    if ("undefined" === typeof Proxy) {
      return componentFactory;
    }
    const componentCache = new Map();
    return new Proxy((...args) => {
      create.warnOnce(!1, "motion() is deprecated. Use motion.create() instead.");
      return componentFactory(...args);
    }, {get:(_target, key) => {
      if ("create" === key) {
        return componentFactory;
      }
      componentCache.has(key) || componentCache.set(key, componentFactory(key));
      return componentCache.get(key);
    }});
  }
  function checkReorder(order, value, offset, velocity) {
    if (!velocity) {
      return order;
    }
    const index = order.findIndex(item => item.value === value);
    if (-1 === index) {
      return order;
    }
    velocity = 0 < velocity ? 1 : -1;
    var nextItem = order[index + velocity];
    if (!nextItem) {
      return order;
    }
    const item = order[index];
    nextItem = nextItem.layout;
    nextItem = create.mixNumber(nextItem.min, nextItem.max, 0.5);
    return 1 === velocity && item.layout.max + offset > nextItem || -1 === velocity && item.layout.min + offset < nextItem ? create.moveItem(order, index, index + velocity) : order;
  }
  function getValue(item) {
    return item.value;
  }
  function compareMin(a, b) {
    return a.layout.min - b.layout.min;
  }
  function useMotionValue(initial) {
    const value = create.useConstant(() => create.motionValue(initial)), {isStatic} = React.useContext(create.MotionConfigContext);
    if (isStatic) {
      const [, setLatest] = React.useState(initial);
      React.useEffect(() => value.on("change", setLatest), []);
    }
    return value;
  }
  function useCombineMotionValues(values, combineValues) {
    const value = useMotionValue(combineValues()), updateValue = () => value.set(combineValues());
    value.set(combineValues());
    create.useIsomorphicLayoutEffect(() => {
      const scheduleUpdate = () => create.frame.preRender(updateValue, !1, !0), subscriptions = values.map(v => v.on("change", scheduleUpdate));
      return () => {
        subscriptions.forEach(unsubscribe => unsubscribe());
        create.cancelFrame(updateValue);
      };
    });
    return value;
  }
  function useComputed(compute) {
    create.collectMotionValues.current = [];
    compute();
    compute = useCombineMotionValues(create.collectMotionValues.current, compute);
    create.collectMotionValues.current = void 0;
    return compute;
  }
  function useTransform(input, inputRangeOrTransformer, outputRange, options) {
    if ("function" === typeof input) {
      return useComputed(input);
    }
    const transformer = "function" === typeof inputRangeOrTransformer ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
  }
  function useListTransform(values, transformer) {
    const latest = create.useConstant(() => []);
    return useCombineMotionValues(values, () => {
      latest.length = 0;
      const numValues = values.length;
      for (let i = 0; i < numValues; i++) {
        latest[i] = values[i].get();
      }
      return transformer(latest);
    });
  }
  function useDefaultMotionValue(value, defaultValue = 0) {
    return create.isMotionValue(value) ? value : useMotionValue(defaultValue);
  }
  function useMotionValueEvent(value, event, callback) {
    React.useInsertionEffect(() => value.on(event, callback), [value, event, callback]);
  }
  function refWarning(name, ref) {
    motionUtils.warning(!(ref && !ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
  }
  function useScroll({container, target, layoutEffect = !0, ...options} = {}) {
    const values = create.useConstant(createScrollMotionValues);
    (layoutEffect ? create.useIsomorphicLayoutEffect : React.useEffect)(() => {
      refWarning("target", target);
      refWarning("container", container);
      return scroll((_progress, {x, y}) => {
        values.scrollX.set(x.current);
        values.scrollXProgress.set(x.progress);
        values.scrollY.set(y.current);
        values.scrollYProgress.set(y.progress);
      }, {...options, container:(null === container || void 0 === container ? void 0 : container.current) || void 0, target:(null === target || void 0 === target ? void 0 : target.current) || void 0});
    }, [container, target, JSON.stringify(options.offset)]);
    return values;
  }
  function asNumber(v) {
    return "number" === typeof v ? v : parseFloat(v);
  }
  function useAnimationFrame(callback) {
    const initialTimestamp = React.useRef(0), {isStatic} = React.useContext(create.MotionConfigContext);
    React.useEffect(() => {
      if (!isStatic) {
        var provideTimeSinceStart = ({timestamp, delta}) => {
          initialTimestamp.current || (initialTimestamp.current = timestamp);
          callback(timestamp - initialTimestamp.current, delta);
        };
        create.frame.update(provideTimeSinceStart, !0);
        return () => create.cancelFrame(provideTimeSinceStart);
      }
    }, [callback]);
  }
  function useReducedMotion() {
    !create.hasReducedMotionListener.current && create.initPrefersReducedMotion();
    const [shouldReduceMotion] = React.useState(create.prefersReducedMotion.current);
    create.warnOnce(!0 !== shouldReduceMotion, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    return shouldReduceMotion;
  }
  function stopAnimation(visualElement) {
    visualElement.values.forEach(value => value.stop());
  }
  function setVariants(visualElement, variantLabels) {
    [...variantLabels].reverse().forEach(key => {
      (key = visualElement.getVariant(key)) && create.setTarget(visualElement, key);
      visualElement.variantChildren && visualElement.variantChildren.forEach(child => {
        setVariants(child, variantLabels);
      });
    });
  }
  function animationControls() {
    let hasMounted = !1;
    const subscribers = new Set(), controls = {subscribe(visualElement) {
      subscribers.add(visualElement);
      return () => void subscribers.delete(visualElement);
    }, start(definition, transitionOverride) {
      motionUtils.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const animations = [];
      subscribers.forEach(visualElement => {
        animations.push(create.animateVisualElement(visualElement, definition, {transitionOverride}));
      });
      return Promise.all(animations);
    }, set(definition) {
      motionUtils.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach(visualElement => {
        Array.isArray(definition) ? setVariants(visualElement, definition) : "string" === typeof definition ? setVariants(visualElement, [definition]) : create.setTarget(visualElement, definition);
      });
    }, stop() {
      subscribers.forEach(visualElement => {
        stopAnimation(visualElement);
      });
    }, mount() {
      hasMounted = !0;
      return () => {
        hasMounted = !1;
        controls.stop();
      };
    }};
    return controls;
  }
  function useAnimationControls() {
    const controls = create.useConstant(animationControls);
    create.useIsomorphicLayoutEffect(controls.mount, []);
    return controls;
  }
  function isMotionComponent(component) {
    return null !== component && "object" === typeof component && create.motionComponentSymbol in component;
  }
  function startTransition(callback) {
    create.rootProjectionNode.current && (create.rootProjectionNode.current.isUpdating = !1, create.rootProjectionNode.current.blockUpdate(), callback && callback());
  }
  function handoffOptimizedAppearAnimation(elementId, valueName, frame) {
    function cancelAnimation() {
      var _a;
      null === (_a = window.MotionCancelOptimisedAnimation) || void 0 === _a || _a.call(window, elementId, valueName, frame);
    }
    var _a, storeId = appearStoreId(elementId, valueName);
    storeId = appearAnimationStore.get(storeId);
    if (!storeId) {
      return null;
    }
    const {animation, startTime} = storeId;
    animation.onfinish = cancelAnimation;
    return null === startTime || (null === (_a = window.MotionHandoffIsComplete) || void 0 === _a ? 0 : _a.call(window, elementId)) ? (cancelAnimation(), null) : startTime;
  }
  function resumeSuspendedAnimations() {
    suspendedAnimations.forEach(data => {
      data.animation.play();
      data.animation.startTime = data.startTime;
    });
    suspendedAnimations.clear();
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var jsxRuntime = require("module$node_modules$react$jsx_runtime"), React = require("module$node_modules$react$index"), create = require("module$node_modules$framer_motion$dist$cjs$create_CGKJurkh"), motionUtils = require("module$node_modules$motion_utils$dist$cjs$index"), motionDom = require("module$node_modules$motion_dom$dist$cjs$index"), React__namespace = function(e) {
    var n = Object.create(null);
    e && Object.keys(e).forEach(function(k) {
      if ("default" !== k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {enumerable:!0, get:function() {
          return e[k];
        }});
      }
    });
    n.default = e;
    return Object.freeze(n);
  }(React);
  class PopChildMeasure extends React__namespace.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        prevProps = element.offsetParent;
        prevProps = prevProps instanceof HTMLElement ? prevProps.offsetWidth || 0 : 0;
        const size = this.props.sizeRef.current;
        size.height = element.offsetHeight || 0;
        size.width = element.offsetWidth || 0;
        size.top = element.offsetTop;
        size.left = element.offsetLeft;
        size.right = prevProps - size.width - size.left;
      }
      return null;
    }
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  }
  const PresenceChild = ({children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX}) => {
    const presenceChildren = create.useConstant(newChildrenMap), id = React.useId(), memoizedOnExitComplete = React.useCallback(childId => {
      presenceChildren.set(childId, !0);
      for (const isComplete of presenceChildren.values()) {
        if (!isComplete) {
          return;
        }
      }
      onExitComplete && onExitComplete();
    }, [presenceChildren, onExitComplete]);
    presenceAffectsLayout = React.useMemo(() => ({id, initial, isPresent, custom, onExitComplete:memoizedOnExitComplete, register:childId => {
      presenceChildren.set(childId, !1);
      return () => presenceChildren.delete(childId);
    }}), presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);
    React.useMemo(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, !1));
    }, [isPresent]);
    React__namespace.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    "popLayout" === mode && (children = jsxRuntime.jsx(PopChild, {isPresent, anchorX, children}));
    return jsxRuntime.jsx(create.PresenceContext.Provider, {value:presenceAffectsLayout, children});
  }, getChildKey = child => child.key || "", DeprecatedLayoutGroupContext = React.createContext(null), notify = node => !node.isLayoutDirty && node.willUpdate(!1), wrap = (min, max, v) => {
    max -= min;
    return ((v - min) % max + max) % max + min;
  }, isNumber = keyframe => "number" === typeof keyframe;
  class ObjectVisualElement extends create.VisualElement {
    constructor() {
      super(...arguments);
      this.type = "object";
    }
    readValueFromInstance(instance, key) {
      if (key in instance && (instance = instance[key], "string" === typeof instance || "number" === typeof instance)) {
        return instance;
      }
    }
    getBaseTargetFromProps() {
    }
    removeValueFromRenderState(key, renderState) {
      delete renderState.output[key];
    }
    measureInstanceViewportBox() {
      return create.createBox();
    }
    build(renderState, latestValues) {
      Object.assign(renderState.output, latestValues);
    }
    renderInstance(instance, {output}) {
      Object.assign(instance, output);
    }
    sortInstanceNodePosition() {
      return 0;
    }
  }
  const animate = createScopedAnimate(), supportsPartialKeyframes = motionUtils.memo(() => {
    try {
      document.createElement("div").animate({opacity:[1]});
    } catch (e) {
      return !1;
    }
    return !0;
  }), state = new WeakMap();
  class NativeAnimation extends motionDom.NativeAnimationControls {
    constructor(element, valueName, valueKeyframes, options) {
      const isCSSVar = valueName.startsWith("--");
      motionUtils.invariant("string" !== typeof options.type, 'animateMini doesn\'t support "type" as a string. Did you mean to import { spring } from "framer-motion"?');
      var existingAnimation = getElementAnimationState(element).get(valueName);
      existingAnimation && existingAnimation.stop();
      Array.isArray(valueKeyframes) || (valueKeyframes = [valueKeyframes]);
      hydrateKeyframes(valueName, valueKeyframes, () => valueName.startsWith("--") ? element.style.getPropertyValue(valueName) : window.getComputedStyle(element)[valueName]);
      motionDom.isGenerator(options.type) ? (existingAnimation = motionDom.createGeneratorEasing(options, 100, options.type), options.ease = motionDom.supportsLinearEasing() ? existingAnimation.ease : "easeOut", options.duration = motionUtils.secondsToMilliseconds(existingAnimation.duration), options.type = "keyframes") : options.ease = options.ease || "easeOut";
      existingAnimation = () => {
        this.setValue(element, valueName, create.getFinalKeyframe(valueKeyframes, options));
        this.cancel();
        this.resolveFinishedPromise();
      };
      const init = () => {
        this.setValue = isCSSVar ? setCSSVar : setStyle;
        this.options = options;
        this.updateFinishedPromise();
        this.removeAnimation = () => {
          const elementState = state.get(element);
          elementState && elementState.delete(valueName);
        };
      };
      create.supportsWaapi() ? (super(create.startWaapiAnimation(element, valueName, valueKeyframes, options)), init(), !1 === options.autoplay && this.animation.pause(), this.animation.onfinish = existingAnimation, getElementAnimationState(element).set(valueName, this)) : (super(), init(), existingAnimation());
    }
    then(resolve, reject) {
      return this.currentFinishedPromise.then(resolve, reject);
    }
    updateFinishedPromise() {
      this.currentFinishedPromise = new Promise(resolve => {
        this.resolveFinishedPromise = resolve;
      });
    }
    play() {
      "finished" === this.state && this.updateFinishedPromise();
      super.play();
    }
    cancel() {
      this.removeAnimation();
      super.cancel();
    }
  }
  const createScopedWaapiAnimate = scope => function(elementOrSelector, keyframes, options) {
    var JSCompiler_temp_const = motionDom.GroupPlaybackControls;
    elementOrSelector = motionDom.resolveElements(elementOrSelector, scope);
    const numElements = elementOrSelector.length;
    motionUtils.invariant(!!numElements, "No valid element provided.");
    const animations = [];
    for (let i = 0; i < numElements; i++) {
      const element = elementOrSelector[i], elementTransition = {...options};
      "function" === typeof elementTransition.delay && (elementTransition.delay = elementTransition.delay(i, numElements));
      for (const valueName in keyframes) {
        const valueKeyframes = keyframes[valueName], valueOptions = {...motionDom.getValueTransition(elementTransition, valueName)};
        valueOptions.duration = valueOptions.duration ? motionUtils.secondsToMilliseconds(valueOptions.duration) : valueOptions.duration;
        valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay || 0);
        animations.push(new NativeAnimation(element, valueName, valueKeyframes, valueOptions));
      }
    }
    return new JSCompiler_temp_const(animations);
  }, animateMini = createScopedWaapiAnimate(), resizeHandlers = new WeakMap();
  let observer;
  const windowCallbacks = new Set();
  let windowResizeHandler;
  const createAxisInfo = () => ({current:0, offset:[], progress:0, scrollLength:0, targetOffset:0, targetLength:0, containerLength:0, velocity:0}), keys = {x:{length:"Width", position:"Left"}, y:{length:"Height", position:"Top"}}, namedEdges = {start:0, center:0.5, end:1}, defaultOffset = [0, 0], ScrollOffset = {Enter:[[0, 1], [1, 1]], Exit:[[0, 0], [1, 0]], Any:[[1, 0], [0, 1]], All:[[0, 0], [1, 1]]}, point = {x:0, y:0}, scrollListeners = new WeakMap(), resizeListeners = new WeakMap(), onScrollHandlers = 
  new WeakMap(), timelineCache = new Map(), thresholds = {some:0, all:1}, sync = create.frame, cancelSync = create.stepsOrder.reduce((acc, key) => {
    acc[key] = process => create.cancelFrame(process);
    return acc;
  }, {}), LayoutGroup = ({children, id, inherit = !0}) => {
    const layoutGroupContext = React.useContext(create.LayoutGroupContext);
    var deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);
    const [forceRender, key] = useForceUpdate(), context = React.useRef(null);
    deprecatedLayoutGroupContext = layoutGroupContext.id || deprecatedLayoutGroupContext;
    null === context.current && ((!0 === inherit === !0 || "id" === inherit) && deprecatedLayoutGroupContext && (id = id ? deprecatedLayoutGroupContext + "-" + id : deprecatedLayoutGroupContext), context.current = {id, group:!0 === inherit ? layoutGroupContext.group || nodeGroup() : nodeGroup()});
    id = React.useMemo(() => ({...context.current, forceRender}), [key]);
    return jsxRuntime.jsx(create.LayoutGroupContext.Provider, {value:id, children});
  }, ReorderContext = React.createContext(null), motion = createDOMMotionComponentProxy(create.createMotionComponent), ReorderGroup = React.forwardRef(function({children, as = "ul", axis = "y", onReorder, values, ...props}, externalRef) {
    const Component = create.useConstant(() => motion[as]), order = [], isReordering = React.useRef(!1);
    motionUtils.invariant(!!values, "Reorder.Group must be provided a values prop");
    const context = {axis, registerItem:(value, layout) => {
      const idx = order.findIndex(entry => value === entry.value);
      -1 !== idx ? order[idx].layout = layout[axis] : order.push({value, layout:layout[axis]});
      order.sort(compareMin);
    }, updateOrder:(item, offset, velocity) => {
      isReordering.current || (item = checkReorder(order, item, offset, velocity), order !== item && (isReordering.current = !0, onReorder(item.map(getValue).filter(value => -1 !== values.indexOf(value)))));
    }};
    React.useEffect(() => {
      isReordering.current = !1;
    });
    return jsxRuntime.jsx(Component, {...props, ref:externalRef, ignoreStrict:!0, children:jsxRuntime.jsx(ReorderContext.Provider, {value:context, children})});
  }), ReorderItem = React.forwardRef(function({children, style = {}, value, as = "li", onDrag, layout = !0, ...props}, externalRef) {
    const Component = create.useConstant(() => motion[as]), context = React.useContext(ReorderContext), point = {x:useDefaultMotionValue(style.x), y:useDefaultMotionValue(style.y)}, zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
    motionUtils.invariant(!!context, "Reorder.Item must be a child of Reorder.Group");
    const {axis, registerItem, updateOrder} = context;
    return jsxRuntime.jsx(Component, {drag:axis, ...props, dragSnapToOrigin:!0, style:{...style, x:point.x, y:point.y, zIndex}, layout, onDrag:(event, gesturePoint) => {
      const {velocity} = gesturePoint;
      velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
      onDrag && onDrag(event, gesturePoint);
    }, onLayoutMeasure:measured => registerItem(value, measured), ref:externalRef, ignoreStrict:!0, children});
  });
  var namespace = Object.freeze({__proto__:null, Group:ReorderGroup, Item:ReorderItem});
  const createMinimalMotionComponent = create.createMotionComponentFactory(), m = createDOMMotionComponentProxy(createMinimalMotionComponent), domAnimation = {renderer:create.createDomVisualElement, ...create.animations, ...create.gestureAnimations}, domMax = {...domAnimation, ...create.drag, ...create.layout}, domMin = {renderer:create.createDomVisualElement, ...create.animations}, createScrollMotionValues = () => ({scrollX:create.motionValue(0), scrollY:create.motionValue(0), scrollXProgress:create.motionValue(0), 
  scrollYProgress:create.motionValue(0)});
  class WillChangeMotionValue extends create.MotionValue {
    constructor() {
      super(...arguments);
      this.values = [];
    }
    add(name) {
      name = create.transformProps.has(name) ? "transform" : create.acceleratedValues.has(name) ? create.camelToDash(name) : void 0;
      name && (create.addUniqueItem(this.values, name), this.update());
    }
    update() {
      this.set(this.values.length ? this.values.join(", ") : "auto");
    }
  }
  class DragControls {
    constructor() {
      this.componentControls = new Set();
    }
    subscribe(controls) {
      this.componentControls.add(controls);
      return () => this.componentControls.delete(controls);
    }
    start(event, options) {
      this.componentControls.forEach(controls => {
        controls.start(event.nativeEvent || event, options);
      });
    }
  }
  const createDragControls = () => new DragControls(), appearStoreId = (elementId, valueName) => {
    valueName = create.transformProps.has(valueName) ? "transform" : valueName;
    return `${elementId}: ${valueName}`;
  }, appearAnimationStore = new Map(), appearComplete = new Map();
  let startFrameTime, readyAnimation;
  const suspendedAnimations = new Set(), createObject = () => ({});
  class StateVisualElement extends create.VisualElement {
    constructor() {
      super(...arguments);
      this.measureInstanceViewportBox = create.createBox;
    }
    build() {
    }
    resetTransform() {
    }
    restoreTransform() {
    }
    removeValueFromRenderState() {
    }
    renderInstance() {
    }
    scrapeMotionValuesFromProps() {
      return {};
    }
    getBaseTargetFromProps() {
    }
    readValueFromInstance(_state, key, options) {
      return options.initialState[key] || 0;
    }
    sortInstanceNodePosition() {
      return 0;
    }
  }
  const useVisualState = create.makeUseVisualState({scrapeMotionValuesFromProps:createObject, createRenderState:createObject});
  let id = 0;
  const invertScale = scale => 0.001 < scale ? 1 / scale : 100000;
  let hasWarned = !1;
  exports.AcceleratedAnimation = create.AcceleratedAnimation;
  exports.FlatTree = create.FlatTree;
  exports.LayoutGroupContext = create.LayoutGroupContext;
  exports.MotionConfigContext = create.MotionConfigContext;
  exports.MotionContext = create.MotionContext;
  exports.MotionGlobalConfig = create.MotionGlobalConfig;
  exports.MotionValue = create.MotionValue;
  exports.PresenceContext = create.PresenceContext;
  exports.SwitchLayoutGroupContext = create.SwitchLayoutGroupContext;
  exports.VisualElement = create.VisualElement;
  exports.addPointerEvent = create.addPointerEvent;
  exports.addPointerInfo = create.addPointerInfo;
  exports.addScaleCorrector = create.addScaleCorrector;
  exports.animateValue = create.animateValue;
  exports.animateVisualElement = create.animateVisualElement;
  exports.animations = create.animations;
  exports.anticipate = create.anticipate;
  exports.backIn = create.backIn;
  exports.backInOut = create.backInOut;
  exports.backOut = create.backOut;
  exports.buildTransform = create.buildTransform;
  exports.calcLength = create.calcLength;
  exports.cancelFrame = create.cancelFrame;
  exports.circIn = create.circIn;
  exports.circInOut = create.circInOut;
  exports.circOut = create.circOut;
  exports.clamp = create.clamp;
  exports.color = create.color;
  exports.complex = create.complex;
  exports.createBox = create.createBox;
  exports.createRendererMotionComponent = create.createRendererMotionComponent;
  exports.cubicBezier = create.cubicBezier;
  exports.delay = create.delay;
  exports.distance = create.distance;
  exports.distance2D = create.distance2D;
  exports.easeIn = create.easeIn;
  exports.easeInOut = create.easeInOut;
  exports.easeOut = create.easeOut;
  exports.filterProps = create.filterProps;
  exports.findSpring = create.findSpring;
  exports.frame = create.frame;
  exports.frameData = create.frameData;
  exports.frameSteps = create.frameSteps;
  exports.inertia = create.inertia;
  exports.interpolate = create.interpolate;
  exports.isBrowser = create.isBrowser;
  exports.isMotionValue = create.isMotionValue;
  exports.isValidMotionProp = create.isValidMotionProp;
  exports.keyframes = create.keyframes;
  exports.makeUseVisualState = create.makeUseVisualState;
  exports.mirrorEasing = create.mirrorEasing;
  exports.mix = create.mix;
  exports.motionValue = create.motionValue;
  exports.optimizedAppearDataAttribute = create.optimizedAppearDataAttribute;
  exports.pipe = create.pipe;
  exports.px = create.px;
  exports.resolveMotionValue = create.resolveMotionValue;
  exports.reverseEasing = create.reverseEasing;
  exports.spring = create.spring;
  exports.time = create.time;
  exports.useIsPresent = create.useIsPresent;
  exports.useIsomorphicLayoutEffect = create.useIsomorphicLayoutEffect;
  exports.usePresence = create.usePresence;
  exports.visualElementStore = create.visualElementStore;
  Object.defineProperty(exports, "invariant", {enumerable:!0, get:function() {
    return motionUtils.invariant;
  }});
  Object.defineProperty(exports, "noop", {enumerable:!0, get:function() {
    return motionUtils.noop;
  }});
  Object.defineProperty(exports, "progress", {enumerable:!0, get:function() {
    return motionUtils.progress;
  }});
  Object.defineProperty(exports, "hover", {enumerable:!0, get:function() {
    return motionDom.hover;
  }});
  Object.defineProperty(exports, "isDragActive", {enumerable:!0, get:function() {
    return motionDom.isDragActive;
  }});
  Object.defineProperty(exports, "press", {enumerable:!0, get:function() {
    return motionDom.press;
  }});
  exports.AnimatePresence = ({children, custom, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync", propagate = !1, anchorX = "left"}) => {
    const [isParentPresent, safeToRemove] = create.usePresence(propagate), presentChildren = React.useMemo(() => onlyElements(children), [children]), presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey), isInitialRender = React.useRef(!0), pendingPresentChildren = React.useRef(presentChildren), exitComplete = create.useConstant(() => new Map()), [diffedChildren, setDiffedChildren] = React.useState(presentChildren), [renderedChildren, setRenderedChildren] = React.useState(presentChildren);
    create.useIsomorphicLayoutEffect(() => {
      isInitialRender.current = !1;
      pendingPresentChildren.current = presentChildren;
      for (let i = 0; i < renderedChildren.length; i++) {
        const key = renderedChildren[i].key || "";
        presentKeys.includes(key) ? exitComplete.delete(key) : !0 !== exitComplete.get(key) && exitComplete.set(key, !1);
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i = 0; i < renderedChildren.length; i++) {
        const child = renderedChildren[i];
        presentKeys.includes(child.key || "") || (nextChildren.splice(i, 0, child), exitingChildren.push(child));
      }
      "wait" === mode && exitingChildren.length && (nextChildren = exitingChildren);
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    "wait" === mode && 1 < renderedChildren.length && console.warn('You\'re attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.');
    const {forceRender} = React.useContext(create.LayoutGroupContext);
    return jsxRuntime.jsx(jsxRuntime.Fragment, {children:renderedChildren.map(child => {
      const key = child.key || "", isPresent = propagate && !isParentPresent ? !1 : presentChildren === renderedChildren || presentKeys.includes(key), onExit = () => {
        if (exitComplete.has(key)) {
          exitComplete.set(key, !0);
          var isEveryExitComplete = !0;
          exitComplete.forEach(isExitComplete => {
            isExitComplete || (isEveryExitComplete = !1);
          });
          isEveryExitComplete && (null === forceRender || void 0 === forceRender || forceRender(), setRenderedChildren(pendingPresentChildren.current), propagate && (null === safeToRemove || void 0 === safeToRemove || safeToRemove()), onExitComplete && onExitComplete());
        }
      };
      return jsxRuntime.jsx(PresenceChild, {isPresent, initial:!isInitialRender.current || initial ? void 0 : !1, custom, presenceAffectsLayout, mode, onExitComplete:isPresent ? void 0 : onExit, anchorX, children:child}, key);
    })});
  };
  exports.AnimateSharedLayout = ({children}) => {
    React__namespace.useEffect(() => {
      motionUtils.invariant(!1, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
    }, []);
    return jsxRuntime.jsx(LayoutGroup, {id:create.useConstant(() => `asl-${id++}`), children});
  };
  exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;
  exports.DragControls = DragControls;
  exports.LayoutGroup = LayoutGroup;
  exports.LazyMotion = function({children, features, strict = !1}) {
    const [, setIsLoaded] = React.useState(!isLazyBundle(features)), loadedRenderer = React.useRef(void 0);
    if (!isLazyBundle(features)) {
      const {renderer, ...loadedFeatures} = features;
      loadedRenderer.current = renderer;
      create.loadFeatures(loadedFeatures);
    }
    React.useEffect(() => {
      isLazyBundle(features) && features().then(({renderer, ...loadedFeatures}) => {
        create.loadFeatures(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(!0);
      });
    }, []);
    return jsxRuntime.jsx(create.LazyContext.Provider, {value:{renderer:loadedRenderer.current, strict}, children});
  };
  exports.MotionConfig = function({children, isValidProp, ...config}) {
    isValidProp && create.loadExternalIsValidProp(isValidProp);
    config = {...React.useContext(create.MotionConfigContext), ...config};
    config.isStatic = create.useConstant(() => config.isStatic);
    isValidProp = React.useMemo(() => config, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
    return jsxRuntime.jsx(create.MotionConfigContext.Provider, {value:isValidProp, children});
  };
  exports.Reorder = namespace;
  exports.animate = animate;
  exports.animateMini = animateMini;
  exports.animationControls = animationControls;
  exports.cancelSync = cancelSync;
  exports.createScopedAnimate = createScopedAnimate;
  exports.disableInstantTransitions = function() {
    create.instantAnimationState.current = !1;
  };
  exports.domAnimation = domAnimation;
  exports.domMax = domMax;
  exports.domMin = domMin;
  exports.inView = inView;
  exports.isMotionComponent = isMotionComponent;
  exports.m = m;
  exports.motion = motion;
  exports.scroll = scroll;
  exports.scrollInfo = scrollInfo;
  exports.stagger = function(duration = 0.1, {startDelay = 0, from = 0, ease} = {}) {
    return (i, total) => {
      if ("number" === typeof from) {
        var JSCompiler_temp = from;
      } else {
        "first" === from ? JSCompiler_temp = 0 : (JSCompiler_temp = total - 1, JSCompiler_temp = "last" === from ? JSCompiler_temp : JSCompiler_temp / 2);
      }
      i = duration * Math.abs(JSCompiler_temp - i);
      ease && (total *= duration, i = create.easingDefinitionToFunction(ease)(i / total) * total);
      return startDelay + i;
    };
  };
  exports.startOptimizedAppearAnimation = function(element, name, keyframes, options, onReady) {
    if (!window.MotionIsMounted) {
      var id = element.dataset[create.optimizedAppearDataId];
      if (id) {
        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
        var storeId = appearStoreId(id, name);
        readyAnimation || (readyAnimation = create.startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], {duration:10000, ease:"linear"}), appearAnimationStore.set(storeId, {animation:readyAnimation, startTime:null}), window.MotionHandoffAnimation = handoffOptimizedAppearAnimation, window.MotionHasOptimisedAnimation = (elementId, valueName) => {
          if (!elementId) {
            return !1;
          }
          if (!valueName) {
            return appearComplete.has(elementId);
          }
          elementId = appearStoreId(elementId, valueName);
          return !!appearAnimationStore.get(elementId);
        }, window.MotionHandoffMarkAsComplete = elementId => {
          appearComplete.has(elementId) && appearComplete.set(elementId, !0);
        }, window.MotionHandoffIsComplete = elementId => !0 === appearComplete.get(elementId), window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {
          elementId = appearStoreId(elementId, valueName);
          const data = appearAnimationStore.get(elementId);
          data && (frame && void 0 === canResume ? frame.postRender(() => {
            frame.postRender(() => {
              data.animation.cancel();
            });
          }) : data.animation.cancel(), frame && canResume ? (suspendedAnimations.add(data), frame.render(resumeSuspendedAnimations)) : (appearAnimationStore.delete(elementId), appearAnimationStore.size || (window.MotionCancelOptimisedAnimation = void 0)));
        }, window.MotionCheckAppearSync = (visualElement, valueName, value) => {
          var _a, _b;
          const appearId = create.getOptimisedAppearId(visualElement);
          if (appearId) {
            var valueIsOptimised = null === (_a = window.MotionHasOptimisedAnimation) || void 0 === _a ? void 0 : _a.call(window, appearId, valueName), externalAnimationValue = null === (_b = visualElement.props.values) || void 0 === _b ? void 0 : _b[valueName];
            if (valueIsOptimised && externalAnimationValue) {
              var removeSyncCheck = value.on("change", latestValue => {
                var _a;
                externalAnimationValue.get() !== latestValue && (null === (_a = window.MotionCancelOptimisedAnimation) || void 0 === _a || _a.call(window, appearId, valueName), removeSyncCheck());
              });
              return removeSyncCheck;
            }
          }
        });
        var startAnimation = () => {
          readyAnimation.cancel();
          const appearAnimation = create.startWaapiAnimation(element, name, keyframes, options);
          void 0 === startFrameTime && (startFrameTime = performance.now());
          appearAnimation.startTime = startFrameTime;
          appearAnimationStore.set(storeId, {animation:appearAnimation, startTime:startFrameTime});
          onReady && onReady(appearAnimation);
        };
        appearComplete.set(id, !1);
        readyAnimation.ready ? readyAnimation.ready.then(startAnimation).catch(motionUtils.noop) : startAnimation();
      }
    }
  };
  exports.steps = function(numSteps, direction = "end") {
    return progress => {
      progress = "end" === direction ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
      progress *= numSteps;
      return create.clamp(0, 1, ("end" === direction ? Math.floor(progress) : Math.ceil(progress)) / numSteps);
    };
  };
  exports.sync = sync;
  exports.transform = transform;
  exports.unwrapMotionComponent = function(component) {
    if (isMotionComponent(component)) {
      return component[create.motionComponentSymbol];
    }
  };
  exports.useAnimate = function() {
    const scope = create.useConstant(() => ({current:null, animations:[]})), animate = create.useConstant(() => createScopedAnimate(scope));
    useUnmountEffect(() => {
      scope.animations.forEach(animation => animation.stop());
    });
    return [scope, animate];
  };
  exports.useAnimateMini = function() {
    const scope = create.useConstant(() => ({current:null, animations:[]})), animate = create.useConstant(() => createScopedWaapiAnimate(scope));
    useUnmountEffect(() => {
      scope.animations.forEach(animation => animation.stop());
    });
    return [scope, animate];
  };
  exports.useAnimation = useAnimationControls;
  exports.useAnimationControls = useAnimationControls;
  exports.useAnimationFrame = useAnimationFrame;
  exports.useCycle = function(...items) {
    const index = React.useRef(0), [item, setItem] = React.useState(items[index.current]), runCycle = React.useCallback(next => {
      index.current = "number" !== typeof next ? wrap(0, items.length, index.current + 1) : next;
      setItem(items[index.current]);
    }, [items.length, ...items]);
    return [item, runCycle];
  };
  exports.useDeprecatedAnimatedState = function(initialState) {
    const [animationState, setAnimationState] = React.useState(initialState), visualState = useVisualState({}, !1), element = create.useConstant(() => new StateVisualElement({props:{onUpdate:v => {
      setAnimationState({...v});
    }}, visualState, presenceContext:null}, {initialState}));
    React.useLayoutEffect(() => {
      element.mount({});
      return () => element.unmount();
    }, [element]);
    const startAnimation = create.useConstant(() => animationDefinition => create.animateVisualElement(element, animationDefinition));
    return [animationState, startAnimation];
  };
  exports.useDeprecatedInvertedScale = function(scale) {
    let parentScaleX = useMotionValue(1);
    var parentScaleY = useMotionValue(1);
    const {visualElement} = React.useContext(create.MotionContext);
    motionUtils.invariant(!(!scale && !visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
    motionUtils.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
    hasWarned = !0;
    scale ? (parentScaleX = scale.scaleX || parentScaleX, parentScaleY = scale.scaleY || parentScaleY) : visualElement && (parentScaleX = visualElement.getValue("scaleX", 1), parentScaleY = visualElement.getValue("scaleY", 1));
    scale = useTransform(parentScaleX, invertScale);
    parentScaleY = useTransform(parentScaleY, invertScale);
    return {scaleX:scale, scaleY:parentScaleY};
  };
  exports.useDomEvent = function(ref, eventName, handler, options) {
    React.useEffect(() => {
      const element = ref.current;
      if (handler && element) {
        return create.addDomEvent(element, eventName, handler, options);
      }
    }, [ref, eventName, handler, options]);
  };
  exports.useDragControls = function() {
    return create.useConstant(createDragControls);
  };
  exports.useElementScroll = function(ref) {
    create.warnOnce(!1, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
    return useScroll({container:ref});
  };
  exports.useForceUpdate = useForceUpdate;
  exports.useInView = function(ref, {root, margin, amount, once = !1, initial = !1} = {}) {
    const [isInView, setInView] = React.useState(initial);
    React.useEffect(() => {
      if (!(!ref.current || once && isInView)) {
        return inView(ref.current, () => {
          setInView(!0);
          return once ? void 0 : () => setInView(!1);
        }, {root:root && root.current || void 0, margin, amount});
      }
    }, [root, ref, margin, once, amount]);
    return isInView;
  };
  exports.useInstantLayoutTransition = function() {
    return startTransition;
  };
  exports.useInstantTransition = function() {
    const [forceUpdate, forcedRenderCount] = useForceUpdate(), unlockOnFrameRef = React.useRef(-1);
    React.useEffect(() => {
      create.frame.postRender(() => create.frame.postRender(() => {
        forcedRenderCount === unlockOnFrameRef.current && (create.instantAnimationState.current = !1);
      }));
    }, [forcedRenderCount]);
    return callback => {
      startTransition(() => {
        create.instantAnimationState.current = !0;
        forceUpdate();
        callback();
        unlockOnFrameRef.current = forcedRenderCount + 1;
      });
    };
  };
  exports.useMotionTemplate = function(fragments, ...values) {
    const numFragments = fragments.length;
    return useCombineMotionValues(values.filter(create.isMotionValue), function() {
      let output = "";
      for (let i = 0; i < numFragments; i++) {
        output += fragments[i];
        const value = values[i];
        value && (output += create.isMotionValue(value) ? value.get() : value);
      }
      return output;
    });
  };
  exports.useMotionValue = useMotionValue;
  exports.useMotionValueEvent = useMotionValueEvent;
  exports.usePresenceData = function() {
    const context = React.useContext(create.PresenceContext);
    return context ? context.custom : void 0;
  };
  exports.useReducedMotion = useReducedMotion;
  exports.useReducedMotionConfig = function() {
    const reducedMotionPreference = useReducedMotion(), {reducedMotion} = React.useContext(create.MotionConfigContext);
    return "never" === reducedMotion ? !1 : "always" === reducedMotion ? !0 : reducedMotionPreference;
  };
  exports.useResetProjection = function() {
    return React.useCallback(() => {
      const root = create.rootProjectionNode.current;
      root && root.resetTree();
    }, []);
  };
  exports.useScroll = useScroll;
  exports.useSpring = function(source, config = {}) {
    const {isStatic} = React.useContext(create.MotionConfigContext), activeSpringAnimation = React.useRef(null), initialValue = create.useConstant(() => create.isMotionValue(source) ? source.get() : source), unit = create.useConstant(() => "string" === typeof initialValue ? initialValue.replace(/[\d.-]/g, "") : void 0), value = useMotionValue(initialValue), latestValue = React.useRef(initialValue), latestSetter = React.useRef(motionUtils.noop), startAnimation = () => {
      stopAnimation();
      activeSpringAnimation.current = create.animateValue({keyframes:[asNumber(value.get()), asNumber(latestValue.current)], velocity:value.getVelocity(), type:"spring", restDelta:0.001, restSpeed:0.01, ...config, onUpdate:latestSetter.current});
    }, stopAnimation = () => {
      activeSpringAnimation.current && activeSpringAnimation.current.stop();
    };
    React.useInsertionEffect(() => value.attach((v, set) => {
      if (isStatic) {
        return set(v);
      }
      latestValue.current = v;
      latestSetter.current = latest => set(unit ? latest + unit : latest);
      create.frame.postRender(startAnimation);
      return value.get();
    }, stopAnimation), [JSON.stringify(config)]);
    create.useIsomorphicLayoutEffect(() => {
      if (create.isMotionValue(source)) {
        return source.on("change", v => value.set(unit ? v + unit : v));
      }
    }, [value, unit]);
    return value;
  };
  exports.useTime = function() {
    const time = useMotionValue(0);
    useAnimationFrame(t => time.set(t));
    return time;
  };
  exports.useTransform = useTransform;
  exports.useUnmountEffect = useUnmountEffect;
  exports.useVelocity = function(value) {
    const velocity = useMotionValue(value.getVelocity()), updateVelocity = () => {
      const latest = value.getVelocity();
      velocity.set(latest);
      latest && create.frame.update(updateVelocity);
    };
    useMotionValueEvent(value, "change", () => {
      create.frame.update(updateVelocity, !1, !0);
    });
    return velocity;
  };
  exports.useViewportScroll = function() {
    create.warnOnce(!1, "useViewportScroll is deprecated. Convert to useScroll().");
    return useScroll();
  };
  exports.useWillChange = function() {
    return create.useConstant(() => new WillChangeMotionValue("auto"));
  };
  exports.wrap = wrap;
};

//# sourceMappingURL=module$node_modules$framer_motion$dist$cjs$index.js.map
