shadow$provide.module$node_modules$framer_motion$dist$cjs$create_CGKJurkh = function(global, require, module, exports) {
  function isAnimationControls(v) {
    return null !== v && "object" === typeof v && "function" === typeof v.start;
  }
  function getValueState(visualElement) {
    const state = [{}, {}];
    null === visualElement || void 0 === visualElement || visualElement.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if ("function" === typeof definition) {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(void 0 !== custom ? custom : props.custom, current, velocity);
    }
    "string" === typeof definition && (definition = props.variants && props.variants[definition]);
    if ("function" === typeof definition) {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(void 0 !== custom ? custom : props.custom, current, velocity);
    }
    return definition;
  }
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, void 0 !== custom ? custom : props.custom, visualElement);
  }
  function createRenderStep(runNextFrame, stepName) {
    function triggerCallback(callback) {
      toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame());
      numCalls++;
      callback(latestFrameData);
    }
    let thisFrame = new Set(), nextFrame = new Set(), isProcessing = !1, flushNextFrame = !1;
    const toKeepAlive = new WeakSet();
    let latestFrameData = {delta:0.0, timestamp:0.0, isProcessing:!1}, numCalls = 0;
    const step = {schedule:(callback, keepAlive = !1, immediate = !1) => {
      immediate = immediate && isProcessing ? thisFrame : nextFrame;
      keepAlive && toKeepAlive.add(callback);
      immediate.has(callback) || immediate.add(callback);
      return callback;
    }, cancel:callback => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    }, process:frameData => {
      latestFrameData = frameData;
      isProcessing ? flushNextFrame = !0 : (isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], thisFrame.forEach(triggerCallback), stepName && statsBuffer.value && statsBuffer.value.frameloop[stepName].push(numCalls), numCalls = 0, thisFrame.clear(), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData)));
    }};
    return step;
  }
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = !1, useDefaultElapsed = !0;
    const state = {delta:0.0, timestamp:0.0, isProcessing:!1}, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
      return acc;
    }, {}), {read, resolveKeyframes, update, preRender, render, postRender} = steps, processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = !1;
      MotionGlobalConfig.useManualTiming || (state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, 40), 1));
      state.timestamp = timestamp;
      state.isProcessing = !0;
      read.process(state);
      resolveKeyframes.process(state);
      update.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = !1;
      runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
    };
    return {schedule:stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process, keepAlive = !1, immediate = !1) => {
        runNextFrame || (useDefaultElapsed = runNextFrame = !0, state.isProcessing || scheduleNextBatch(processBatch));
        return step.schedule(process, keepAlive, immediate);
      };
      return acc;
    }, {}), cancel:process => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process);
      }
    }, state, steps};
  }
  function clearTime() {
    now = void 0;
  }
  function addUniqueItem(arr, item) {
    -1 === arr.indexOf(item) && arr.push(item);
  }
  function removeItem(arr, item) {
    item = arr.indexOf(item);
    -1 < item && arr.splice(item, 1);
  }
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? 1000 / frameDuration * velocity : 0;
  }
  function warnOnce(condition, message, element) {
    condition || warned.has(message) || (console.warn(message), element && console.warn(element), warned.add(message));
  }
  function motionValue(init, options) {
    return new MotionValue(init, options);
  }
  function setTarget(visualElement, definition) {
    definition = resolveVariant(visualElement, definition);
    let {transitionEnd = {}, transition = {}, ...target} = definition || {};
    target = {...target, ...transitionEnd};
    for (const key in target) {
      definition = target[key];
      const value = Array.isArray(definition) ? definition[definition.length - 1] || 0 : definition;
      definition = visualElement;
      definition.hasValue(key) ? definition.getValue(key).set(value) : definition.addValue(key, motionValue(value));
    }
  }
  function addValueToWillChange(visualElement, key) {
    if ((visualElement = visualElement.getValue("willChange")) && visualElement.getVelocity && visualElement.add) {
      return visualElement.add(key);
    }
  }
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    return mX1 === mY1 && mX2 === mY2 ? motionUtils.noop : t => {
      if (0 !== t && 1 !== t) {
        var lowerBound = 0, upperBound = 1;
        let currentX, currentT, i = 0;
        do {
          currentT = lowerBound + (upperBound - lowerBound) / 2.0, currentX = (((1.0 - 3.0 * mX2 + 3.0 * mX1) * currentT + (3.0 * mX2 - 6.0 * mX1)) * currentT + 3.0 * mX1) * currentT - t, 0.0 < currentX ? upperBound = currentT : lowerBound = currentT;
        } while (0.0000001 < Math.abs(currentX) && 12 > ++i);
        t = currentT;
        t *= ((1.0 - 3.0 * mY2 + 3.0 * mY1) * t + (3.0 * mY2 - 6.0 * mY1)) * t + 3.0 * mY1;
      }
      return t;
    };
  }
  function analyseComplexValue(value) {
    const values = [], indexes = {color:[], number:[], var:[]}, types = [];
    let i = 0;
    value = value.toString().replace(complexRegex, parsedValue => {
      color.test(parsedValue) ? (indexes.color.push(i), types.push("color"), values.push(color.parse(parsedValue))) : parsedValue.startsWith("var(") ? (indexes.var.push(i), types.push("var"), values.push(parsedValue)) : (indexes.number.push(i), types.push("number"), values.push(parseFloat(parsedValue)));
      ++i;
      return "${}";
    }).split("${}");
    return {values, split:value, indexes, types};
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const {split, types} = analyseComplexValue(source), numSections = split.length;
    return v => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        if (output += split[i], void 0 !== v[i]) {
          const type = types[i];
          output = "number" === type ? output + Math.round(100000 * v[i]) / 100000 : "color" === type ? output + color.transform(v[i]) : output + v[i];
        }
      }
      return output;
    };
  }
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if ("drop-shadow" === name) {
      return v;
    }
    const [number] = value.match(floatRegex) || [];
    if (!number) {
      return v;
    }
    v = value.replace(number, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    number !== value && (defaultValue *= 100);
    return name + "(" + defaultValue + v + ")";
  }
  function getAnimatableNone(key, value) {
    key = defaultValueTypes[key];
    key !== filter && (key = complex);
    return key.getAnimatableNone ? key.getAnimatableNone(value) : void 0;
  }
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach(key => {
      const value = visualElement.getValue(key);
      void 0 !== value && (removedTransforms.push([key, value.get()]), value.set(key.startsWith("scale") ? 1 : 0));
    });
    return removedTransforms;
  }
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element)), transformsToRestore = new Map();
      elementsToMeasure.forEach(element => {
        const removedTransforms = removeNonTranslationalTransform(element);
        removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
      });
      resolversToMeasure.forEach(resolver => resolver.measureInitialState());
      elementsToMeasure.forEach(element => {
        element.render();
        const restore = transformsToRestore.get(element);
        restore && restore.forEach(([key, value]) => {
          var _a;
          null === (_a = element.getValue(key)) || void 0 === _a || _a.set(value);
        });
      });
      resolversToMeasure.forEach(resolver => resolver.measureEndState());
      resolversToMeasure.forEach(resolver => {
        void 0 !== resolver.suspendedScrollY && window.scrollTo(0, resolver.suspendedScrollY);
      });
    }
    isScheduled = anyNeedsMeasurement = !1;
    toResolve.forEach(resolver => resolver.complete());
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach(resolver => {
      resolver.readKeyframes();
      resolver.needsMeasurement && (anyNeedsMeasurement = !0);
    });
  }
  function getVariableValue(current, element, depth = 1) {
    motionUtils.invariant(4 >= depth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
    if (current = splitCSSVariableRegex.exec(current)) {
      var [, token1, token2, fallback] = current;
      current = [`--${null !== token1 && void 0 !== token1 ? token1 : token2}`, fallback];
    } else {
      current = [, ];
    }
    const [token, fallback$jscomp$0] = current;
    if (token) {
      return (current = window.getComputedStyle(element).getPropertyValue(token)) ? (element = current.trim(), /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(element) ? parseFloat(element) : element) : isCSSVariableToken(fallback$jscomp$0) ? getVariableValue(fallback$jscomp$0, element, depth + 1) : fallback$jscomp$0;
    }
  }
  function getFinalKeyframe(keyframes, {repeat, repeatType = "loop"}, finalKeyframe) {
    keyframes = keyframes.filter(isNotNull);
    return (repeat = repeat && "loop" !== repeatType && 1 === repeat % 2 ? 0 : keyframes.length - 1) && void 0 !== finalKeyframe ? finalKeyframe : keyframes[repeat];
  }
  function hueToRgb(p, q, t) {
    0 > t && (t += 1);
    1 < t && --t;
    return t < 1 / 6 ? p + 6 * (q - p) * t : .5 > t ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
  }
  function hslaToRgba({hue, saturation, lightness, alpha}) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    if (saturation) {
      const q = 0.5 > lightness ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p = 2 * lightness - q;
      lightness = hueToRgb(p, q, hue + 1 / 3);
      saturation = hueToRgb(p, q, hue);
      hue = hueToRgb(p, q, hue - 1 / 3);
    } else {
      lightness = saturation = hue = lightness;
    }
    return {red:Math.round(255 * lightness), green:Math.round(255 * saturation), blue:Math.round(255 * hue), alpha};
  }
  function mixImmediate(a, b) {
    return p => 0 < p ? b : a;
  }
  function asRGBA(color) {
    const type = getColorType(color);
    motionUtils.warning(!!type, `'${color}' is not an animatable color. Use the equivalent color code instead.`);
    if (!type) {
      return !1;
    }
    color = type.parse(color);
    type === hsla && (color = hslaToRgba(color));
    return color;
  }
  function mixVisibility(origin, target) {
    return invisibleValues.has(origin) ? p => 0 >= p ? origin : target : p => 1 <= p ? target : origin;
  }
  function mixNumber(a, b) {
    return p => a + (b - a) * p;
  }
  function getMixer(a) {
    return "number" === typeof a ? mixNumber : "string" === typeof a ? isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex : Array.isArray(a) ? mixArray : "object" === typeof a ? color.test(a) ? mixColor : mixObject : mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a], numValues = output.length, blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return p => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = {...a, ...b}, blendValue = {};
    for (const key in output) {
      void 0 !== a[key] && void 0 !== b[key] && (blendValue[key] = getMixer(a[key])(a[key], b[key]));
    }
    return v => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function mix(from, to, p) {
    return "number" === typeof from && "number" === typeof to && "number" === typeof p ? from + (to - from) * p : getMixer(from)(from, to);
  }
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - 5, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  }
  function findSpring({duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass}) {
    let envelope;
    motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));
    1 > dampingRatio ? (envelope = undampedFreq => {
      const exponentialDecay = undampedFreq * dampingRatio;
      return 0.001 - (exponentialDecay - velocity) / (undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio)) * Math.exp(-(exponentialDecay * duration));
    }, bounce = undampedFreq => {
      var delta = undampedFreq * dampingRatio * duration;
      const d = delta * velocity + velocity, e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
      delta = Math.exp(-delta);
      const g = Math.pow(undampedFreq, 2) * Math.sqrt(1 - dampingRatio * dampingRatio);
      return (0 < -envelope(undampedFreq) + 0.001 ? -1 : 1) * (d - e) * delta / g;
    }) : (envelope = undampedFreq => -0.001 + Math.exp(-undampedFreq * duration) * ((undampedFreq - velocity) * duration + 1), bounce = undampedFreq => Math.exp(-undampedFreq * duration) * (velocity - undampedFreq) * duration * duration);
    bounce = approximateRoot(envelope, bounce, 5 / duration);
    duration = motionUtils.secondsToMilliseconds(duration);
    if (isNaN(bounce)) {
      return {stiffness:springDefaults.stiffness, damping:springDefaults.damping, duration};
    }
    bounce = Math.pow(bounce, 2) * mass;
    return {stiffness:bounce, damping:2 * dampingRatio * Math.sqrt(mass * bounce), duration};
  }
  function approximateRoot(envelope, derivative, initialGuess) {
    for (let i = 1; 12 > i; i++) {
      initialGuess -= envelope(initialGuess) / derivative(initialGuess);
    }
    return initialGuess;
  }
  function isSpringType(options, keys) {
    return keys.some(key => void 0 !== options[key]);
  }
  function getSpringOptions(options) {
    let springOptions = {velocity:springDefaults.velocity, stiffness:springDefaults.stiffness, damping:springDefaults.damping, mass:springDefaults.mass, isResolvedFromDuration:!1, ...options};
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        var root = 2 * Math.PI / (1.2 * options.visualDuration);
        root *= root;
        options = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(root);
        springOptions = {...springOptions, mass:springDefaults.mass, stiffness:root, damping:options};
      } else {
        options = findSpring(options), springOptions = {...springOptions, ...options, mass:springDefaults.mass, isResolvedFromDuration:!0};
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    optionsOrVisualDuration = "object" !== typeof optionsOrVisualDuration ? {visualDuration:optionsOrVisualDuration, keyframes:[0, 1], bounce} : optionsOrVisualDuration;
    let {restSpeed, restDelta} = optionsOrVisualDuration;
    bounce = optionsOrVisualDuration.keyframes[0];
    const target = optionsOrVisualDuration.keyframes[optionsOrVisualDuration.keyframes.length - 1], state = {done:!1, value:bounce}, {stiffness, damping, mass, duration, velocity, isResolvedFromDuration} = getSpringOptions({...optionsOrVisualDuration, velocity:-motionUtils.millisecondsToSeconds(optionsOrVisualDuration.velocity || 0)}), initialVelocity = velocity || 0.0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - bounce, undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / 
    mass));
    optionsOrVisualDuration = 5 > Math.abs(initialDelta);
    restSpeed || (restSpeed = optionsOrVisualDuration ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = optionsOrVisualDuration ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (1 > dampingRatio) {
      const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
      resolveSpring = t => target - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    } else if (1 === dampingRatio) {
      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = t => {
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return target - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {calculatedDuration:isResolvedFromDuration ? duration || null : null, next:t => {
      const current = resolveSpring(t);
      if (isResolvedFromDuration) {
        state.done = t >= duration;
      } else {
        let currentVelocity = 0.0;
        1 > dampingRatio && (currentVelocity = 0 === t ? motionUtils.secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current));
        t = Math.abs(target - current) <= restDelta;
        state.done = Math.abs(currentVelocity) <= restSpeed && t;
      }
      state.value = state.done ? target : current;
      return state;
    }, toString:() => {
      const calculatedDuration = Math.min(motionDom.calcGeneratorDuration(generator), motionDom.maxGeneratorDuration), easing = motionDom.generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    }};
    return generator;
  }
  function inertia({keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed}) {
    keyframes = keyframes[0];
    const state = {done:!1, value:keyframes};
    let amplitude = power * velocity;
    velocity = keyframes + amplitude;
    const target = void 0 === modifyTarget ? velocity : modifyTarget(velocity);
    target !== velocity && (amplitude = target - keyframes);
    const calcLatest = t => target + -amplitude * Math.exp(-t / timeConstant), applyFriction = t => {
      const latest = target + -amplitude * Math.exp(-t / timeConstant);
      state.done = Math.abs(-amplitude * Math.exp(-t / timeConstant)) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary, spring$1;
    const checkCatchBoundary = t => {
      var v = state.value;
      if (void 0 !== min && v < min || void 0 !== max && v > max) {
        timeReachedBoundary = t;
        v = state.value;
        var JSCompiler_inline_result = state.value;
        JSCompiler_inline_result = void 0 === min ? max : void 0 === max ? min : Math.abs(min - JSCompiler_inline_result) < Math.abs(max - JSCompiler_inline_result) ? min : max;
        spring$1 = spring({keyframes:[v, JSCompiler_inline_result], velocity:calcGeneratorVelocity(calcLatest, t, state.value), damping:bounceDamping, stiffness:bounceStiffness, restDelta, restSpeed});
      }
    };
    checkCatchBoundary(0);
    return {calculatedDuration:null, next:t => {
      let hasUpdatedFrame = !1;
      spring$1 || void 0 !== timeReachedBoundary || (hasUpdatedFrame = !0, applyFriction(t), checkCatchBoundary(t));
      if (void 0 !== timeReachedBoundary && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      }
      !hasUpdatedFrame && applyFriction(t);
      return state;
    }};
  }
  function createMixers(output, ease, customMixer) {
    const mixers = [];
    customMixer = customMixer || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = customMixer(output[i], output[i + 1]);
      ease && (mixer = [Array.isArray(ease) ? ease[i] || motionUtils.noop : ease, mixer].reduce(combineFunctions));
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, {clamp:isClamp = !0, ease, mixer} = {}) {
    const inputLength = input.length;
    motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
    if (1 === inputLength) {
      return () => output[0];
    }
    if (2 === inputLength && output[0] === output[1]) {
      return () => output[1];
    }
    const isZeroDeltaRange = input[0] === input[1];
    input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());
    const mixers = createMixers(output, ease, mixer), numMixers = mixers.length, interpolator = v => {
      if (isZeroDeltaRange && v < input[0]) {
        return output[0];
      }
      let i = 0;
      if (1 < numMixers) {
        for (; i < input.length - 2 && !(v < input[i + 1]); i++) {
        }
      }
      v = motionUtils.progress(input[i], input[i + 1], v);
      return mixers[i](v);
    };
    return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = motionUtils.progress(0, remaining, i);
      offset.push(min + (1 - min) * offsetProgress);
    }
  }
  function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
  }
  function convertOffsetToTimes(offset, duration) {
    return offset.map(o => o * duration);
  }
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({duration = 300, keyframes:keyframeValues, times, ease = "easeInOut"}) {
    ease = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
    const state = {done:!1, value:keyframeValues[0]};
    times = convertOffsetToTimes(times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues), duration);
    const mapTimeToKeyframe = interpolate(times, keyframeValues, {ease:Array.isArray(ease) ? ease : defaultEasing(keyframeValues, ease)});
    return {calculatedDuration:duration, next:t => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }};
  }
  function startWaapiAnimation(element, valueName, keyframes, {delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times} = {}) {
    valueName = {[valueName]:keyframes};
    times && (valueName.offset = times);
    ease = motionDom.mapEasingToNativeEasing(ease, duration);
    Array.isArray(ease) && (valueName.easing = ease);
    return element.animate(valueName, {delay, duration, easing:Array.isArray(ease) ? "linear" : ease, fill:"both", iterations:repeat + 1, direction:"reverse" === repeatType ? "alternate" : "normal"});
  }
  function requiresPregeneratedKeyframes(options) {
    return motionDom.isGenerator(options.type) || "spring" === options.type || !motionDom.isWaapiSupportedEasing(options.ease);
  }
  function pregenerateKeyframes(keyframes, options) {
    options = new MainThreadAnimation({...options, keyframes, repeat:0, delay:0, isGenerator:!0});
    keyframes = {done:!1, value:keyframes[0]};
    const pregeneratedKeyframes = [];
    let t = 0;
    for (; !keyframes.done && 20000 > t;) {
      keyframes = options.sample(t), pregeneratedKeyframes.push(keyframes.value), t += 10;
    }
    return {times:void 0, keyframes:pregeneratedKeyframes, duration:t - 10, ease:"linear"};
  }
  function isTransitionDefined({when, delay:_delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition}) {
    return !!Object.keys(transition).length;
  }
  function shouldBlockAnimation({protectedKeys, needsAnimating}, key) {
    protectedKeys = protectedKeys.hasOwnProperty(key) && !0 !== needsAnimating[key];
    needsAnimating[key] = !1;
    return protectedKeys;
  }
  function animateTarget(visualElement, targetAndTransition, {delay = 0, transitionOverride, type} = {}) {
    var _a;
    let {transition = visualElement.getDefaultTransition(), transitionEnd, ...target} = targetAndTransition;
    transitionOverride && (transition = transitionOverride);
    targetAndTransition = [];
    type = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      transitionOverride = visualElement.getValue(key, null !== (_a = visualElement.latestValues[key]) && void 0 !== _a ? _a : null);
      const valueTarget = target[key];
      if (void 0 === valueTarget || type && shouldBlockAnimation(type, key)) {
        continue;
      }
      const valueTransition = {delay, ...motionDom.getValueTransition(transition || {}, key)};
      let isHandoff = !1;
      if (window.MotionHandoffAnimation) {
        var appearId = getOptimisedAppearId(visualElement);
        appearId && (appearId = window.MotionHandoffAnimation(appearId, key, frame), null !== appearId && (valueTransition.startTime = appearId, isHandoff = !0));
      }
      addValueToWillChange(visualElement, key);
      transitionOverride.start(animateMotionValue(key, transitionOverride, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? {type:!1} : valueTransition, visualElement, isHandoff));
      (transitionOverride = transitionOverride.animation) && targetAndTransition.push(transitionOverride);
    }
    transitionEnd && Promise.all(targetAndTransition).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
    return targetAndTransition;
  }
  function animateVariant(visualElement, variant, options = {}) {
    var _a;
    const resolved = resolveVariant(visualElement, variant, "exit" === options.type ? null === (_a = visualElement.presenceContext) || void 0 === _a ? void 0 : _a.custom : void 0);
    let {transition = visualElement.getDefaultTransition() || {}} = resolved || {};
    options.transitionOverride && (transition = options.transitionOverride);
    _a = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const {delayChildren = 0, staggerChildren, staggerDirection} = transition;
      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve(), {when} = transition;
    if (when) {
      const [first, last] = "beforeChildren" === when ? [_a, getChildAnimations] : [getChildAnimations, _a];
      return first().then(() => last());
    }
    return Promise.all([_a(), getChildAnimations(options.delay)]);
  }
  function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = 1 === staggerDirection ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
      child.notify("AnimationStart", variant);
      animations.push(animateVariant(child, variant, {...options, delay:delayChildren + generateStaggerDuration(i)}).then(() => child.notify("AnimationComplete", variant)));
    });
    return Promise.all(animations);
  }
  function sortByTreeOrder(a, b) {
    return a.sortNodePosition(b);
  }
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    if (Array.isArray(definition)) {
      var animation = definition.map(variant => animateVariant(visualElement, variant, options));
      animation = Promise.all(animation);
    } else {
      "string" === typeof definition ? animation = animateVariant(visualElement, definition, options) : (animation = "function" === typeof definition ? resolveVariant(visualElement, definition, options.custom) : definition, animation = Promise.all(animateTarget(visualElement, animation, options)));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev)) {
      return !1;
    }
    const prevLength = prev.length;
    if (prevLength !== next.length) {
      return !1;
    }
    for (let i = 0; i < prevLength; i++) {
      if (prev[i] !== next[i]) {
        return !1;
      }
    }
    return !0;
  }
  function isVariantLabel(v) {
    return "string" === typeof v || Array.isArray(v);
  }
  function getVariantContext(visualElement) {
    if (visualElement) {
      if (!visualElement.isControllingVariants) {
        var context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
        void 0 !== visualElement.props.initial && (context.initial = visualElement.props.initial);
        return context;
      }
      context = {};
      for (let i = 0; i < numVariantProps; i++) {
        const name = variantProps[i], prop = visualElement.props[name];
        if (isVariantLabel(prop) || !1 === prop) {
          context[name] = prop;
        }
      }
      return context;
    }
  }
  function animateList(visualElement) {
    return animations => Promise.all(animations.map(({animation, options}) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    function animateChanges(changedActiveType) {
      const {props} = visualElement, context = getVariantContext(visualElement.parent) || {}, animations = [], removedKeys = new Set();
      let encounteredKeys = {}, removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i], typeState = state[type];
        var prop = void 0 !== props[type] ? props[type] : context[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
        !1 === activeDelta && (removedVariantIndex = i);
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1);
        typeState.protectedKeys = {...encounteredKeys};
        if (!typeState.isActive && null === activeDelta || !prop && !typeState.prevProp || isAnimationControls(prop) || "boolean" === typeof prop) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
        propIsVariant = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = propIsVariant.reduce(buildResolvedTypeValues(type), {});
        !1 === activeDelta && (resolvedValues = {});
        ({prevResolvedValues:activeDelta = {}} = typeState);
        var allKeys = {...activeDelta, ...resolvedValues};
        const markToAnimate = key => {
          shouldAnimateType = !0;
          removedKeys.has(key) && (handledRemovedValues = !0, removedKeys.delete(key));
          typeState.needsAnimating[key] = !0;
          if (key = visualElement.getValue(key)) {
            key.liveStyle = !1;
          }
        };
        for (const key in allKeys) {
          allKeys = resolvedValues[key];
          const prev = activeDelta[key];
          if (encounteredKeys.hasOwnProperty(key)) {
            continue;
          }
          let valueHasChanged = !1;
          (valueHasChanged = Array.isArray(allKeys) && Array.isArray(prev) ? !shallowCompare(allKeys, prev) : allKeys !== prev) ? void 0 !== allKeys && null !== allKeys ? markToAnimate(key) : removedKeys.add(key) : void 0 !== allKeys && removedKeys.has(key) ? markToAnimate(key) : typeState.protectedKeys[key] = !0;
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        typeState.isActive && (encounteredKeys = {...encounteredKeys, ...resolvedValues});
        isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1);
        prop = !(isInherited && variantDidChange) || handledRemovedValues;
        shouldAnimateType && prop && animations.push(...propIsVariant.map(animation => ({animation, options:{type}})));
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        "boolean" !== typeof props.initial && (changedActiveType = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial)) && changedActiveType.transition && (fallbackAnimation.transition = changedActiveType.transition);
        removedKeys.forEach(key => {
          const fallbackTarget = visualElement.getBaseTarget(key), motionValue = visualElement.getValue(key);
          motionValue && (motionValue.liveStyle = !0);
          fallbackAnimation[key] = null !== fallbackTarget && void 0 !== fallbackTarget ? fallbackTarget : null;
        });
        animations.push({animation:fallbackAnimation});
      }
      changedActiveType = !!animations.length;
      !isInitialRender || !1 !== props.initial && props.initial !== props.animate || visualElement.manuallyAnimateOnMount || (changedActiveType = !1);
      isInitialRender = !1;
      return changedActiveType ? animate(animations) : Promise.resolve();
    }
    let animate = animateList(visualElement), state = createState(), isInitialRender = !0;
    const buildResolvedTypeValues = type => (acc, definition) => {
      var _a;
      if (definition = resolveVariant(visualElement, definition, "exit" === type ? null === (_a = visualElement.presenceContext) || void 0 === _a ? void 0 : _a.custom : void 0)) {
        const {transition, transitionEnd, ...target} = definition;
        acc = {...acc, ...target, ...transitionEnd};
      }
      return acc;
    };
    return {animateChanges, setActive:function(type, isActive) {
      var _a;
      if (state[type].isActive === isActive) {
        return Promise.resolve();
      }
      null === (_a = visualElement.variantChildren) || void 0 === _a || _a.forEach(child => {
        var _a;
        return null === (_a = child.animationState) || void 0 === _a ? void 0 : _a.setActive(type, isActive);
      });
      state[type].isActive = isActive;
      _a = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return _a;
    }, setAnimateFunction:function(makeAnimator) {
      animate = makeAnimator(visualElement);
    }, getState:() => state, reset:() => {
      state = createState();
      isInitialRender = !0;
    }};
  }
  function checkVariantsDidChange(prev, next) {
    return "string" === typeof next ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
  }
  function createTypeState(isActive = !1) {
    return {isActive, protectedKeys:{}, needsAnimating:{}, prevResolvedValues:{}};
  }
  function createState() {
    return {animate:createTypeState(!0), whileInView:createTypeState(), whileHover:createTypeState(), whileTap:createTypeState(), whileDrag:createTypeState(), whileFocus:createTypeState(), exit:createTypeState()};
  }
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if (.9999 <= delta.scale && 1.0001 >= delta.scale || isNaN(delta.scale)) {
      delta.scale = 1.0;
    }
    if (-.01 <= delta.translate && .01 >= delta.translate || isNaN(delta.translate)) {
      delta.translate = 0.0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativePosition(target$jscomp$0, layout$jscomp$0, parent) {
    var target = target$jscomp$0.x, layout = layout$jscomp$0.x;
    target.min = layout.min - parent.x.min;
    target.max = target.min + calcLength(layout);
    target$jscomp$0 = target$jscomp$0.y;
    layout$jscomp$0 = layout$jscomp$0.y;
    target$jscomp$0.min = layout$jscomp$0.min - parent.y.min;
    target$jscomp$0.max = target$jscomp$0.min + calcLength(layout$jscomp$0);
  }
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && "draggable" !== key || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }
  function loadExternalIsValidProp(isValidProp) {
    isValidProp && (shouldForward = key => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key));
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if ("values" !== key || "object" !== typeof props.values) {
        if (shouldForward(key) || !0 === forwardMotionProps && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props.draggable && key.startsWith("onDrag")) {
          filteredProps[key] = props[key];
        }
      }
    }
    return filteredProps;
  }
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return !(!isControllingVariants(props) && !props.variants);
  }
  function useConstant(init) {
    const ref = React.useRef(null);
    null === ref.current && (ref.current = init());
    return ref.current;
  }
  function resolveMotionValue(value) {
    return (value = value && value.getVelocity ? value.get() : value) && "object" === typeof value && value.mix && value.toValue ? value.toValue() : value;
  }
  function makeState({scrapeMotionValuesFromProps, createRenderState, onUpdate}, props, context, presenceContext) {
    const state = {latestValues:makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps), renderState:createRenderState()};
    onUpdate && (state.onMount = instance => onUpdate({props, current:instance, ...state}), state.onUpdate = visualElement => onUpdate(visualElement));
    return state;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    scrapeMotionValues = scrapeMotionValues(props, {});
    for (var key in scrapeMotionValues) {
      values[key] = resolveMotionValue(scrapeMotionValues[key]);
    }
    let {initial, animate} = props;
    key = isControllingVariants(props);
    scrapeMotionValues = isVariantNode(props);
    context && scrapeMotionValues && !key && !1 !== props.inherit && (void 0 === initial && (initial = context.initial), void 0 === animate && (animate = context.animate));
    if ((presenceContext = (context = (context = presenceContext ? !1 === presenceContext.initial : !1) || !1 === initial) ? animate : initial) && "boolean" !== typeof presenceContext && !isAnimationControls(presenceContext)) {
      for (presenceContext = Array.isArray(presenceContext) ? presenceContext : [presenceContext], key = 0; key < presenceContext.length; key++) {
        if (scrapeMotionValues = resolveVariantFromProps(props, presenceContext[key])) {
          const {transitionEnd, transition, ...target} = scrapeMotionValues;
          for (const key in target) {
            scrapeMotionValues = target[key], Array.isArray(scrapeMotionValues) && (scrapeMotionValues = scrapeMotionValues[context ? scrapeMotionValues.length - 1 : 0]), null !== scrapeMotionValues && (values[key] = scrapeMotionValues);
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  function addDomEvent(target, eventName, handler, options = {passive:!0}) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }
  function extractEventInfo(event) {
    return {point:{x:event.pageX, y:event.pageY}};
  }
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }
  function usePresence(subscribe = !0) {
    var context = React.useContext(PresenceContext);
    if (null === context) {
      return [!0, null];
    }
    const {isPresent, onExitComplete, register} = context, id = React.useId();
    React.useEffect(() => {
      if (subscribe) {
        return register(id);
      }
    }, [subscribe]);
    context = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);
    return !isPresent && onExitComplete ? [!1, context] : [!0];
  }
  function animateSingleValue(value, keyframes, options) {
    value = value && value.getVelocity ? value : motionValue(value);
    value.start(animateMotionValue("", value, keyframes, options));
    return value.animation;
  }
  function isSVGElement(element) {
    return element instanceof SVGElement && "svg" !== element.tagName;
  }
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = !0;
    if (isBrowser) {
      if (window.matchMedia) {
        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
        motionMediaQuery.addListener(() => prefersReducedMotion.current = motionMediaQuery.matches);
        prefersReducedMotion.current = motionMediaQuery.matches;
      } else {
        prefersReducedMotion.current = !1;
      }
    }
  }
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "", transformIsDefault = !0;
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      var value = latestValues[key];
      if (void 0 === value) {
        continue;
      }
      let valueIsDefault;
      valueIsDefault = "number" === typeof value ? value === (key.startsWith("scale") ? 1 : 0) : 0 === parseFloat(value);
      if (!valueIsDefault || transformTemplate) {
        value = getValueAsType(value, numberValueTypes[key]), valueIsDefault || (transformIsDefault = !1, transformString += `${translateAlias[key] || key}(${value}) `), transformTemplate && (transform[key] = value);
      }
    }
    transformString = transformString.trim();
    transformTemplate ? transformString = transformTemplate(transform, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none");
    return transformString;
  }
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const {style, vars, transformOrigin} = state;
    let hasTransform = !1, hasTransformOrigin = !1;
    for (const key in latestValues) {
      var value = latestValues[key];
      transformProps.has(key) ? hasTransform = !0 : isCSSVariableName(key) ? vars[key] = value : (value = getValueAsType(value, numberValueTypes[key]), key.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key] = value) : style[key] = value);
    }
    latestValues.transform || (hasTransform || transformTemplate ? style.transform = buildTransform(latestValues, state.transform, transformTemplate) : style.transform && (style.transform = "none"));
    if (hasTransformOrigin) {
      const {originX = "50%", originY = "50%", originZ = 0} = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = !0) {
    attrs.pathLength = 1;
    useDashCase = useDashCase ? dashKeys : camelKeys;
    attrs[useDashCase.offset] = px.transform(-offset);
    length = px.transform(length);
    spacing = px.transform(spacing);
    attrs[useDashCase.array] = `${length} ${spacing}`;
  }
  function buildSVGAttrs(state, {attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, ...latest}, isSVGTag, transformTemplate) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag) {
      state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    } else {
      state.attrs = state.style;
      state.style = {};
      var {attrs, style, dimensions} = state;
      attrs.transform && (dimensions && (style.transform = attrs.transform), delete attrs.transform);
      dimensions && (void 0 !== originX || void 0 !== originY || style.transform) && (state = void 0 !== originY ? originY : 0.5, originX = void 0 !== originX ? originX : 0.5, originX = "string" === typeof originX ? originX : px.transform(dimensions.x + dimensions.width * originX), state = "string" === typeof state ? state : px.transform(dimensions.y + dimensions.height * state), style.transformOrigin = `${originX} ${state}`);
      void 0 !== attrX && (attrs.x = attrX);
      void 0 !== attrY && (attrs.y = attrY);
      void 0 !== attrScale && (attrs.scale = attrScale);
      void 0 !== pathLength && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
    }
  }
  function updateSVGDimensions(instance, renderState) {
    try {
      renderState.dimensions = "function" === typeof instance.getBBox ? instance.getBBox() : instance.getBoundingClientRect();
    } catch (e) {
      renderState.dimensions = {x:0, y:0, width:0, height:0};
    }
  }
  function renderHTML(element, {style, vars}, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    for (const key in vars) {
      element.style.setProperty(key, vars[key]);
    }
  }
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(camelCaseAttributes.has(key) ? key : camelToDash(key), renderState.attrs[key]);
    }
  }
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key], isCSSVariableName(key) && (scaleCorrectors[key].isCSSVariable = !0);
    }
  }
  function isForcedMotionValue(key, {layout, layoutId}) {
    return transformProps.has(key) || key.startsWith("origin") || (layout || void 0 !== layoutId) && (!!scaleCorrectors[key] || "opacity" === key);
  }
  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    var _a;
    const {style} = props, newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || void 0 !== (null === (_a = null === visualElement || void 0 === visualElement ? void 0 : visualElement.getValue(key)) || void 0 === _a ? void 0 : _a.liveStyle)) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    visualElement = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = -1 !== transformPropOrder.indexOf(key) ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        visualElement[targetKey] = props[key];
      }
    }
    return visualElement;
  }
  function convertBoundingBoxToBox({top, left, right, bottom}) {
    return {x:{min:left, max:right}, y:{min:top, max:bottom}};
  }
  function convertBoxToBoundingBox({x, y}) {
    return {top:y.min, right:x.max, bottom:y.max, left:x.min};
  }
  function transformBoxPoints(point, transformPoint) {
    if (!transformPoint) {
      return point;
    }
    const topLeft = transformPoint({x:point.left, y:point.top});
    point = transformPoint({x:point.right, y:point.bottom});
    return {top:topLeft.y, left:topLeft.x, bottom:point.y, right:point.x};
  }
  function hasScale({scale, scaleX, scaleY}) {
    return !(void 0 === scale || 1 === scale) || !(void 0 === scaleX || 1 === scaleX) || !(void 0 === scaleY || 1 === scaleY);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && "0%" !== value;
  }
  function applyPointDelta(point, translate, scale, originPoint, boxScale) {
    void 0 !== boxScale && (point = originPoint + boxScale * (point - originPoint));
    return originPoint + scale * (point - originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
  }
  function applyBoxDelta(box, {x, y}) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
    const treeLength = treePath.length;
    if (treeLength) {
      treeScale.x = treeScale.y = 1;
      for (let i = 0; i < treeLength; i++) {
        var node = treePath[i];
        var delta = node.projectionDelta;
        const {visualElement} = node.options;
        visualElement && visualElement.props.style && "contents" === visualElement.props.style.display || (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(box, {x:-node.scroll.offset.x, y:-node.scroll.offset.y}), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node.latestValues) && transformBox(box, node.latestValues));
      }
      1.0000000000001 > treeScale.x && 0.999999999999 < treeScale.x && (treeScale.x = 1.0);
      1.0000000000001 > treeScale.y && 0.999999999999 < treeScale.y && (treeScale.y = 1.0);
    }
  }
  function translateAxis(axis, distance) {
    axis.min += distance;
    axis.max += distance;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    axisOrigin = mixNumber$1(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, axisOrigin, boxScale);
  }
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }
  function delay(callback, timeout) {
    const start = time.now(), checkElapsed = ({timestamp}) => {
      timestamp -= start;
      timestamp >= timeout && (cancelFrame(checkElapsed), callback(timestamp - timeout));
    };
    frame.read(checkElapsed, !0);
    return () => cancelFrame(checkElapsed);
  }
  function distance2D(a, b) {
    return Math.sqrt(Math.abs(a.x - b.x) ** 2 + Math.abs(a.y - b.y) ** 2);
  }
  function compress(min, max, easing) {
    return p => p < min ? 0 : p > max ? 1 : easing(motionUtils.progress(min, max, p));
  }
  function copyBoxInto(box, originBox) {
    var axis = box.x, originAxis = originBox.x;
    axis.min = originAxis.min;
    axis.max = originAxis.max;
    box = box.y;
    originBox = originBox.y;
    box.min = originBox.min;
    box.max = originBox.max;
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }
  function removePointDelta(point, translate, scale, originPoint, boxScale) {
    point = originPoint + 1 / scale * (point - translate - originPoint);
    void 0 !== boxScale && (point = originPoint + 1 / boxScale * (point - originPoint));
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min);
    "number" === typeof translate && (origin = mixNumber$1(originAxis.min, originAxis.max, origin), axis === originAxis && (origin -= translate), axis.min = removePointDelta(axis.min, translate, scale, origin, boxScale), axis.max = removePointDelta(axis.max, translate, scale, origin, boxScale));
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }
  function isAxisDeltaZero(delta) {
    return 0 === delta.translate && 1 === delta.scale;
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  }
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const {latestValues} = visualElement;
    latestValues[key] && (values[key] = latestValues[key], visualElement.setStaticValue(key, 0), sharedAnimationValues && (sharedAnimationValues[key] = 0));
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = !0;
    if (projectionNode.root !== projectionNode) {
      var {visualElement} = projectionNode.options;
      if (visualElement) {
        visualElement = getOptimisedAppearId(visualElement);
        if (window.MotionHasOptimisedAnimation(visualElement, "transform")) {
          const {layout, layoutId} = projectionNode.options;
          window.MotionCancelOptimisedAnimation(visualElement, "transform", frame, !(layout || layoutId));
        }
        ({parent:projectionNode} = projectionNode);
        projectionNode && !projectionNode.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(projectionNode);
      }
    }
  }
  function createProjectionNode$1({attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform}) {
    return class {
      constructor(latestValues = {}, parent = null === defaultParent || void 0 === defaultParent ? void 0 : defaultParent()) {
        this.id = id++;
        this.animationId = 0;
        this.children = new Set();
        this.options = {};
        this.hasCheckedOptimisedAppear = this.shouldResetTransform = this.needsReset = this.isSVG = this.isUpdating = this.updateBlockedByResize = this.updateManuallyBlocked = this.isTransformDirty = this.isSharedProjectionDirty = this.isProjectionDirty = this.isLayoutDirty = this.isAnimationBlocked = this.isTreeAnimating = !1;
        this.treeScale = {x:1, y:1};
        this.eventHandlers = new Map();
        this.updateScheduled = this.hasTreeAnimated = !1;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = !1;
        this.checkUpdateFailed = () => {
          this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = !1;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
        };
        this.resolvedRelativeTargetAt = 0.0;
        this.hasProjected = !1;
        this.isVisible = !0;
        this.animationProgress = 0;
        this.sharedNodes = new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.depth = (this.parent = parent) ? parent.depth + 1 : 0;
        for (latestValues = 0; latestValues < this.path.length; latestValues++) {
          this.path[latestValues].shouldResetTransform = !0;
        }
        this.root === this && (this.nodes = new FlatTree());
      }
      addEventListener(name, handler) {
        this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager());
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        (name = this.eventHandlers.get(name)) && name.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
        if (!this.instance) {
          this.isSVG = isSVGElement(instance);
          this.instance = instance;
          var {layoutId, layout, visualElement} = this.options;
          visualElement && !visualElement.current && visualElement.mount(instance);
          this.root.nodes.add(this);
          this.parent && this.parent.children.add(this);
          isLayoutDirty && (layout || layoutId) && (this.isLayoutDirty = !0);
          if (attachResizeListener) {
            let cancelDelay;
            const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
            attachResizeListener(instance, () => {
              this.root.updateBlockedByResize = !0;
              cancelDelay && cancelDelay();
              cancelDelay = delay(resizeUnblockUpdate, 250);
              globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
            });
          }
          layoutId && this.root.registerSharedNode(layoutId, this);
          !1 !== this.options.animate && visualElement && (layoutId || layout) && this.addEventListener("didUpdate", ({delta, hasLayoutChanged, hasRelativeLayoutChanged, layout:newLayout}) => {
            if (this.isTreeAnimationBlocked()) {
              this.relativeTarget = this.target = void 0;
            } else {
              var layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, {onLayoutAnimationStart, onLayoutAnimationComplete} = visualElement.getProps(), JSCompiler_temp;
              (JSCompiler_temp = !this.targetLayout) || (JSCompiler_temp = this.targetLayout, JSCompiler_temp = !(axisEqualsRounded(JSCompiler_temp.x, newLayout.x) && axisEqualsRounded(JSCompiler_temp.y, newLayout.y)));
              hasRelativeLayoutChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
              if (this.options.layoutRoot || this.resumeFrom || hasRelativeLayoutChanged || hasLayoutChanged && (JSCompiler_temp || !this.currentAnimation)) {
                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
                this.setAnimationOrigin(delta, hasRelativeLayoutChanged);
                delta = {...motionDom.getValueTransition(layoutTransition, "layout"), onPlay:onLayoutAnimationStart, onComplete:onLayoutAnimationComplete};
                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                  delta.delay = 0, delta.type = !1;
                }
                this.startAnimation(delta);
              } else {
                if (hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete) {
                  this.options.onExitComplete();
                }
              }
              this.targetLayout = newLayout;
            }
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        cancelFrame(this.updateProjection);
      }
      blockUpdate() {
        this.updateManuallyBlocked = !0;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = !1;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
      }
      startUpdate() {
        this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
      }
      getTransformTemplate() {
        const {visualElement} = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = !0) {
        this.root.hasTreeAnimated = !0;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
        } else {
          if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), !this.isLayoutDirty) {
            this.isLayoutDirty = !0;
            for (var i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              node.shouldResetTransform = !0;
              node.updateScroll("snapshot");
              node.options.layoutRoot && node.willUpdate(!1);
            }
            var {layoutId, layout} = this.options;
            if (void 0 !== layoutId || layout) {
              this.prevTransformTemplateValue = (i = this.getTransformTemplate()) ? i(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
            }
          }
        }
      }
      update() {
        this.updateScheduled = !1;
        if (this.isUpdateBlocked()) {
          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        } else {
          this.isUpdating || this.nodes.forEach(clearIsLayoutDirty);
          this.isUpdating = !1;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
          this.clearAllSnapshots();
          var now = time.now();
          frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
          frameData.timestamp = now;
          frameData.isProcessing = !0;
          frameSteps.update.process(frameData);
          frameSteps.preRender.process(frameData);
          frameSteps.render.process(frameData);
          frameData.isProcessing = !1;
        }
      }
      didUpdate() {
        this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
        });
      }
      updateSnapshot() {
        !this.snapshot && this.instance && (!(this.snapshot = this.measure()) || calcLength(this.snapshot.measuredBox.x) || calcLength(this.snapshot.measuredBox.y) || (this.snapshot = void 0));
      }
      updateLayout() {
        if (this.instance && (this.updateScroll(), this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty)) {
          if (this.resumeFrom && !this.resumeFrom.instance) {
            for (var i = 0; i < this.path.length; i++) {
              this.path[i].updateScroll();
            }
          }
          i = this.layout;
          this.layout = this.measure(!1);
          this.layoutCorrected = createBox();
          this.isLayoutDirty = !1;
          this.projectionDelta = void 0;
          this.notifyListeners("measure", this.layout.layoutBox);
          var {visualElement} = this.options;
          visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, i ? i.layoutBox : void 0);
        }
      }
      updateScroll(phase = "measure") {
        var needsMeasurement = !(!this.options.layoutScroll || !this.instance);
        this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1);
        needsMeasurement && (needsMeasurement = checkIsScrollRoot(this.instance), this.scroll = {animationId:this.root.animationId, phase, isRoot:needsMeasurement, offset:measureScroll(this.instance), wasRoot:this.scroll ? this.scroll.isRoot : needsMeasurement});
      }
      resetTransform() {
        if (resetTransform) {
          var isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, JSCompiler_temp;
          if (JSCompiler_temp = this.projectionDelta) {
            JSCompiler_temp = this.projectionDelta, JSCompiler_temp = !(isAxisDeltaZero(JSCompiler_temp.x) && isAxisDeltaZero(JSCompiler_temp.y));
          }
          var transformTemplate = this.getTransformTemplate();
          transformTemplate = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          var transformTemplateHasChanged = transformTemplate !== this.prevTransformTemplateValue;
          isResetRequested && (JSCompiler_temp || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplate), this.shouldResetTransform = !1, this.scheduleRender());
        }
      }
      measure(removeTransform = !0) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        removeTransform && (layoutBox = this.removeTransform(layoutBox));
        removeTransform = layoutBox;
        roundAxis(removeTransform.x);
        roundAxis(removeTransform.y);
        return {animationId:this.root.animationId, measuredBox:pageBox, layoutBox, latestValues:{}, source:this.id};
      }
      measurePageBox() {
        var _a, {visualElement} = this.options;
        if (!visualElement) {
          return createBox();
        }
        visualElement = visualElement.measureViewportBox();
        (null === (_a = this.scroll) || void 0 === _a ? 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot) || ({scroll:_a} = this.root, _a && (translateAxis(visualElement.x, _a.offset.x), translateAxis(visualElement.y, _a.offset.y)));
        return visualElement;
      }
      removeElementScroll(box) {
        var _a;
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (null === (_a = this.scroll) || void 0 === _a ? 0 : _a.wasRoot) {
          return boxWithoutScroll;
        }
        for (_a = 0; _a < this.path.length; _a++) {
          const node = this.path[_a], {scroll, options} = node;
          node !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = !1) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (box = 0; box < this.path.length; box++) {
          const node = this.path[box];
          !transformOnly && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(withTransforms, {x:-node.scroll.offset.x, y:-node.scroll.offset.y});
          hasTransform(node.latestValues) && transformBox(withTransforms, node.latestValues);
        }
        hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues);
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (box = 0; box < this.path.length; box++) {
          const node = this.path[box];
          if (!node.instance) {
            continue;
          }
          if (!hasTransform(node.latestValues)) {
            continue;
          }
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox(), nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues);
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = !0;
      }
      setOptions(options) {
        this.options = {...this.options, ...options, crossfade:void 0 !== options.crossfade ? options.crossfade : !0};
      }
      clearMeasurements() {
        this.target = this.targetDelta = this.prevTransformTemplateValue = this.snapshot = this.layout = this.scroll = void 0;
        this.isLayoutDirty = !1;
      }
      forceRelativeParentToResolveTarget() {
        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
      }
      resolveTargetDelta(forceRecalculation = !1) {
        var _a, lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        lead = !!this.resumingFrom || this !== lead;
        if (forceRecalculation || lead && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (_a = this.parent) || void 0 === _a ? 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize) {
          var {layout, layoutId} = this.options;
          if (this.layout && (layout || layoutId) && (this.resolvedRelativeTargetAt = frameData.timestamp, this.targetDelta || this.relativeTarget || ((forceRecalculation = this.getClosestProjectingParent()) && forceRecalculation.layout && 1 !== this.animationProgress ? (this.relativeParent = forceRecalculation, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, 
          forceRecalculation.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0), this.relativeTarget || this.targetDelta)) {
            this.target || (this.target = createBox(), this.targetWithTransforms = createBox());
            if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
              this.forceRelativeParentToResolveTarget();
              lead = this.target;
              _a = this.relativeTarget;
              forceRecalculation = this.relativeParent.target;
              var target = lead.x, relative = _a.x;
              target.min = forceRecalculation.x.min + relative.min;
              target.max = target.min + calcLength(relative);
              lead = lead.y;
              _a = _a.y;
              lead.min = forceRecalculation.y.min + _a.min;
              lead.max = lead.min + calcLength(_a);
            } else {
              this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox);
            }
            this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, (forceRecalculation = this.getClosestProjectingParent()) && !!forceRecalculation.resumingFrom === !!this.resumingFrom && !forceRecalculation.options.layoutScroll && forceRecalculation.target && 1 !== this.animationProgress ? (this.relativeParent = forceRecalculation, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, 
            this.target, forceRecalculation.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0);
          }
        }
      }
      getClosestProjectingParent() {
        if (this.parent && !hasScale(this.parent.latestValues) && !has2DTranslate(this.parent.latestValues)) {
          return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return !(!(this.relativeTarget || this.targetDelta || this.options.layoutRoot) || !this.layout);
      }
      calcProjection() {
        var _a, lead = this.getLead();
        const isShared = !!this.resumingFrom || this !== lead;
        var canSkip = !0;
        if (this.isProjectionDirty || (null === (_a = this.parent) || void 0 === _a ? 0 : _a.isProjectionDirty)) {
          canSkip = !1;
        }
        isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1);
        this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1);
        if (!canSkip) {
          var {layout, layoutId} = this.options;
          this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
          this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0);
          this.layout && (layout || layoutId) && (copyBoxInto(this.layoutCorrected, this.layout.layoutBox), _a = this.treeScale.x, canSkip = this.treeScale.y, applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), !lead.layout || lead.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox()), {target:lead} = lead, lead ? (this.projectionDelta && this.prevProjectionDelta ? (copyAxisDeltaInto(this.prevProjectionDelta.x, 
          this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), calcBoxDelta(this.projectionDelta, this.layoutCorrected, lead, this.latestValues), this.treeScale.x === _a && this.treeScale.y === canSkip && axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) && axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", 
          lead))) : this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()));
        }
      }
      hide() {
        this.isVisible = !1;
      }
      show() {
        this.isVisible = !0;
      }
      scheduleRender(notifyAll = !0) {
        var _a;
        null === (_a = this.options.visualElement) || void 0 === _a || _a.scheduleRender();
        notifyAll && (notifyAll = this.getStack()) && notifyAll.scheduleRender();
        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = {x:createAxisDelta(), y:createAxisDelta()};
        this.projectionDelta = {x:createAxisDelta(), y:createAxisDelta()};
        this.projectionDeltaWithTransform = {x:createAxisDelta(), y:createAxisDelta()};
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
        const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = {...this.latestValues}, targetDelta = {x:createAxisDelta(), y:createAxisDelta()};
        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0);
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox(), isSharedLayoutAnimation = (snapshot ? snapshot.source : void 0) !== (this.layout ? this.layout.source : void 0);
        hasOnlyRelativeTargetChanged = this.getStack();
        const isOnlyMember = !hasOnlyRelativeTargetChanged || 1 >= hasOnlyRelativeTargetChanged.members.length, shouldCrossfadeOpacity = !(!isSharedLayoutAnimation || isOnlyMember || !0 !== this.options.crossfade || this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = latest => {
          latest /= 1000;
          mixAxisDelta(targetDelta.x, delta.x, latest);
          mixAxisDelta(targetDelta.y, delta.y, latest);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            var output = this.relativeTarget, from = this.relativeTargetOrigin, output$jscomp$0 = output.x, from$jscomp$0 = from.x, to = relativeLayout.x;
            output$jscomp$0.min = mixNumber$1(from$jscomp$0.min, to.min, latest);
            output$jscomp$0.max = mixNumber$1(from$jscomp$0.max, to.max, latest);
            output = output.y;
            from = from.y;
            output$jscomp$0 = relativeLayout.y;
            output.min = mixNumber$1(from.min, output$jscomp$0.min, latest);
            output.max = mixNumber$1(from.max, output$jscomp$0.max, latest);
            if (from = prevRelativeTarget) {
              from = this.relativeTarget, output = prevRelativeTarget, from = axisEquals(from.x, output.x) && axisEquals(from.y, output.y);
            }
            from && (this.isProjectionDirty = !1);
            prevRelativeTarget || (prevRelativeTarget = createBox());
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            from = this.latestValues;
            shouldCrossfadeOpacity ? (mixedValues.opacity = mixNumber$1(0, void 0 !== from.opacity ? from.opacity : 1, easeCrossfadeIn(latest)), mixedValues.opacityExit = mixNumber$1(void 0 !== snapshotLatestValues.opacity ? snapshotLatestValues.opacity : 1, 0, easeCrossfadeOut(latest))) : isOnlyMember && (mixedValues.opacity = mixNumber$1(void 0 !== snapshotLatestValues.opacity ? snapshotLatestValues.opacity : 1, void 0 !== from.opacity ? from.opacity : 1, latest));
            for (output = 0; output < numBorders; output++) {
              if (output$jscomp$0 = `border${borders[output]}Radius`, from$jscomp$0 = void 0 !== snapshotLatestValues[output$jscomp$0] ? snapshotLatestValues[output$jscomp$0] : snapshotLatestValues.borderRadius, to = void 0 !== from[output$jscomp$0] ? from[output$jscomp$0] : from.borderRadius, void 0 !== from$jscomp$0 || void 0 !== to) {
                if (from$jscomp$0 || (from$jscomp$0 = 0), to || (to = 0), 0 === from$jscomp$0 || 0 === to || ("number" === typeof from$jscomp$0 || px.test(from$jscomp$0)) === ("number" === typeof to || px.test(to))) {
                  if (mixedValues[output$jscomp$0] = Math.max(mixNumber$1(asNumber(from$jscomp$0), asNumber(to), latest), 0), percent.test(to) || percent.test(from$jscomp$0)) {
                    mixedValues[output$jscomp$0] += "%";
                  }
                } else {
                  mixedValues[output$jscomp$0] = to;
                }
              }
            }
            if (snapshotLatestValues.rotate || from.rotate) {
              mixedValues.rotate = mixNumber$1(snapshotLatestValues.rotate || 0, from.rotate || 0, latest);
            }
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = latest;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation && this.currentAnimation.stop();
        this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop();
        this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0);
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = !0;
          this.currentAnimation = animateSingleValue(0, 1000, {...options, onUpdate:latest => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          }, onStop:() => {
          }, onComplete:() => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }});
          this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation);
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1000), this.currentAnimation.stop());
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let {targetWithTransforms, target, layout, latestValues} = lead;
        if (targetWithTransforms && target && layout) {
          if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
            target = this.target || createBox();
            var xLength = calcLength(this.layout.layoutBox.x);
            target.x.min = lead.target.x.min;
            target.x.max = target.x.min + xLength;
            xLength = calcLength(this.layout.layoutBox.y);
            target.y.min = lead.target.y.min;
            target.y.max = target.y.min + xLength;
          }
          copyBoxInto(targetWithTransforms, target);
          transformBox(targetWithTransforms, latestValues);
          calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
        }
      }
      registerSharedNode(layoutId, node) {
        this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack());
        this.sharedNodes.get(layoutId).add(node);
        layoutId = node.options.initialPromotionConfig;
        node.promote({transition:layoutId ? layoutId.transition : void 0, preserveFollowOpacity:layoutId && layoutId.shouldPreserveFollowOpacity ? layoutId.shouldPreserveFollowOpacity(node) : void 0});
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : !0;
      }
      getLead() {
        var _a;
        const {layoutId} = this.options;
        return layoutId ? (null === (_a = this.getStack()) || void 0 === _a ? void 0 : _a.lead) || this : this;
      }
      getPrevLead() {
        var _a;
        const {layoutId} = this.options;
        return layoutId ? null === (_a = this.getStack()) || void 0 === _a ? void 0 : _a.prevLead : void 0;
      }
      getStack() {
        const {layoutId} = this.options;
        if (layoutId) {
          return this.root.sharedNodes.get(layoutId);
        }
      }
      promote({needsReset, transition, preserveFollowOpacity} = {}) {
        const stack = this.getStack();
        stack && stack.promote(this, preserveFollowOpacity);
        needsReset && (this.projectionDelta = void 0, this.needsReset = !0);
        transition && this.setOptions({transition});
      }
      relegate() {
        const stack = this.getStack();
        return stack ? stack.relegate(this) : !1;
      }
      resetSkewAndRotation() {
        const {visualElement} = this.options;
        if (visualElement) {
          var hasDistortingTransform = !1, {latestValues} = visualElement;
          if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
            hasDistortingTransform = !0;
          }
          if (hasDistortingTransform) {
            hasDistortingTransform = {};
            latestValues.z && resetDistortingTransform("z", visualElement, hasDistortingTransform, this.animationValues);
            for (latestValues = 0; latestValues < transformAxes.length; latestValues++) {
              resetDistortingTransform(`rotate${transformAxes[latestValues]}`, visualElement, hasDistortingTransform, this.animationValues), resetDistortingTransform(`skew${transformAxes[latestValues]}`, visualElement, hasDistortingTransform, this.animationValues);
            }
            visualElement.render();
            for (const key in hasDistortingTransform) {
              visualElement.setStaticValue(key, hasDistortingTransform[key]), this.animationValues && (this.animationValues[key] = hasDistortingTransform[key]);
            }
            visualElement.scheduleRender();
          }
        }
      }
      getProjectionStyles(styleProp) {
        var _a, _b;
        if (this.instance && !this.isSVG) {
          if (!this.isVisible) {
            return hiddenVisibility;
          }
          var styles = {visibility:""}, transformTemplate = this.getTransformTemplate();
          if (this.needsReset) {
            return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
          }
          var lead = this.getLead();
          if (!this.projectionDelta || !this.layout || !lead.target) {
            return styles = {}, this.options.layoutId && (styles.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, styles.pointerEvents = resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (styles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), styles;
          }
          var valuesToRender = lead.animationValues || lead.latestValues;
          this.applyTransformsToTarget();
          var delta = this.projectionDeltaWithTransform, treeScale = this.treeScale, transform = "", xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = (null === valuesToRender || void 0 === valuesToRender ? void 0 : valuesToRender.z) || 0;
          if (xTranslate || yTranslate || zTranslate) {
            transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
          }
          if (1 !== treeScale.x || 1 !== treeScale.y) {
            transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
          }
          if (valuesToRender) {
            const {transformPerspective, rotate, rotateX, rotateY, skewX, skewY} = valuesToRender;
            transformPerspective && (transform = `perspective(${transformPerspective}px) ${transform}`);
            rotate && (transform += `rotate(${rotate}deg) `);
            rotateX && (transform += `rotateX(${rotateX}deg) `);
            rotateY && (transform += `rotateY(${rotateY}deg) `);
            skewX && (transform += `skewX(${skewX}deg) `);
            skewY && (transform += `skewY(${skewY}deg) `);
          }
          xTranslate = delta.x.scale * treeScale.x;
          delta = delta.y.scale * treeScale.y;
          if (1 !== xTranslate || 1 !== delta) {
            transform += `scale(${xTranslate}, ${delta})`;
          }
          styles.transform = transform || "none";
          transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
          var {x, y} = this.projectionDelta;
          styles.transformOrigin = `${100 * x.origin}% ${100 * y.origin}% 0`;
          styles.opacity = lead.animationValues ? lead === this ? null !== (_b = null !== (_a = valuesToRender.opacity) && void 0 !== _a ? _a : this.latestValues.opacity) && void 0 !== _b ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : lead === this ? void 0 !== valuesToRender.opacity ? valuesToRender.opacity : "" : void 0 !== valuesToRender.opacityExit ? valuesToRender.opacityExit : 0;
          for (const key in scaleCorrectors) {
            if (void 0 === valuesToRender[key]) {
              continue;
            }
            const {correct, applyTo, isCSSVariable} = scaleCorrectors[key];
            transformTemplate = "none" === styles.transform ? valuesToRender[key] : correct(valuesToRender[key], lead);
            if (applyTo) {
              for (_a = applyTo.length, _b = 0; _b < _a; _b++) {
                styles[applyTo[_b]] = transformTemplate;
              }
            } else {
              isCSSVariable ? this.options.visualElement.renderState.vars[key] = transformTemplate : styles[key] = transformTemplate;
            }
          }
          this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(null === styleProp || void 0 === styleProp ? void 0 : styleProp.pointerEvents) || "" : "none");
          return styles;
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      resetTree() {
        this.root.nodes.forEach(node => {
          var _a;
          return null === (_a = node.currentAnimation) || void 0 === _a ? void 0 : _a.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    var _a;
    const snapshot = (null === (_a = node.resumeFrom) || void 0 === _a ? void 0 : _a.snapshot) || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const {layoutBox:layout, measuredBox:measuredLayout} = node.layout;
      ({animationType:_a} = node.options);
      const isShared = snapshot.source !== node.layout.source;
      "size" === _a ? eachAxis(axis => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      }) : shouldAnimatePositionOnly(_a, snapshot.layoutBox, layout) && eachAxis(axis => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        node.relativeTarget && !node.currentAnimation && (node.isProjectionDirty = !0, node.relativeTarget[axis].max = node.relativeTarget[axis].min + length);
      });
      _a = {x:createAxisDelta(), y:createAxisDelta()};
      calcBoxDelta(_a, layout, snapshot.layoutBox);
      const visualDelta = {x:createAxisDelta(), y:createAxisDelta()};
      isShared ? calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
      const hasLayoutChanged = !(isAxisDeltaZero(_a.x) && isAxisDeltaZero(_a.y));
      let hasRelativeLayoutChanged = !1;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const {snapshot:parentSnapshot, layout:parentLayout} = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
            axisEqualsRounded(relativeSnapshot.x, relativeLayout.x) && axisEqualsRounded(relativeSnapshot.y, relativeLayout.y) || (hasRelativeLayoutChanged = !0);
            relativeParent.options.layoutRoot && (node.relativeTarget = relativeLayout, node.relativeTargetOrigin = relativeSnapshot, node.relativeParent = relativeParent);
          }
        }
      }
      node.notifyListeners("didUpdate", {layout, snapshot, delta:visualDelta, layoutDelta:_a, hasLayoutChanged, hasRelativeLayoutChanged});
    } else {
      node.isLead() && ({onExitComplete:_a} = node.options, _a && _a());
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    node.parent && (node.isProjecting() || (node.isProjectionDirty = node.parent.isProjectionDirty), node.isSharedProjectionDirty || (node.isSharedProjectionDirty = !!(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty)), node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty));
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = !1;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = !1;
  }
  function resetTransformStyle(node) {
    const {visualElement} = node.options;
    visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure");
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = !0;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber$1(delta.translate, 0, p);
    output.scale = mixNumber$1(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && void 0 !== node.animationValues.opacityExit;
  }
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout) {
    var JSCompiler_temp;
    if (!(JSCompiler_temp = "position" === animationType)) {
      if (animationType = "preserve-aspect" === animationType) {
        snapshot = aspectRatio(snapshot), layout = aspectRatio(layout), animationType = !(.2 >= Math.abs(snapshot - layout));
      }
      JSCompiler_temp = animationType;
    }
    return JSCompiler_temp;
  }
  function checkNodeWasScrollRoot(node) {
    var _a;
    return node !== node.root && (null === (_a = node.scroll) || void 0 === _a ? void 0 : _a.wasRoot);
  }
  function pixelsToPercent(pixels, axis) {
    return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
  }
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {...featureDefinitions[key], ...features[key]};
    }
  }
  function isRefObject(ref) {
    return ref && "object" === typeof ref && Object.prototype.hasOwnProperty.call(ref, "current");
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? {point:transformPagePoint(info.point)} : info;
  }
  function subtractPoint(a, b) {
    return {x:a.x - b.x, y:a.y - b.y};
  }
  function getPanInfo({point}, history) {
    return {point, delta:subtractPoint(point, history[history.length - 1]), offset:subtractPoint(point, history[0]), velocity:getVelocity(history, 0.1)};
  }
  function getVelocity(history, timeDelta) {
    if (2 > history.length) {
      return {x:0, y:0};
    }
    let i = history.length - 1;
    var timestampedPoint = null;
    const lastPoint = history[history.length - 1];
    for (; 0 <= i;) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > motionUtils.secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return {x:0, y:0};
    }
    history = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (0 === history) {
      return {x:0, y:0};
    }
    timestampedPoint = {x:(lastPoint.x - timestampedPoint.x) / history, y:(lastPoint.y - timestampedPoint.y) / history};
    Infinity === timestampedPoint.x && (timestampedPoint.x = 0);
    Infinity === timestampedPoint.y && (timestampedPoint.y = 0);
    return timestampedPoint;
  }
  function applyConstraints(point, {min, max}, elastic) {
    void 0 !== min && point < min ? point = elastic ? min + (point - min) * elastic.min : Math.max(point, min) : void 0 !== max && point > max && (point = elastic ? max + (point - max) * elastic.max : Math.min(point, max));
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {min:void 0 !== min ? axis.min + min : void 0, max:void 0 !== max ? axis.max + max - (axis.max - axis.min) : void 0};
  }
  function calcRelativeConstraints(layoutBox, {top, left, bottom, right}) {
    return {x:calcRelativeAxisConstraints(layoutBox.x, left, right), y:calcRelativeAxisConstraints(layoutBox.y, top, bottom)};
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min, max = constraintsAxis.max - layoutAxis.max;
    constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min, max] = [max, min]);
    return {min, max};
  }
  function resolveDragElastic(dragElastic = 0.35) {
    !1 === dragElastic ? dragElastic = 0 : !0 === dragElastic && (dragElastic = 0.35);
    var JSCompiler_inline_result = dragElastic;
    JSCompiler_inline_result = {min:resolvePointElastic(JSCompiler_inline_result, "left"), max:resolvePointElastic(JSCompiler_inline_result, "right")};
    dragElastic = {min:resolvePointElastic(dragElastic, "top"), max:resolvePointElastic(dragElastic, "bottom")};
    return {x:JSCompiler_inline_result, y:dragElastic};
  }
  function resolvePointElastic(dragElastic, label) {
    return "number" === typeof dragElastic ? dragElastic : dragElastic[label] || 0;
  }
  function shouldDrag(direction, drag, currentDirection) {
    return (!0 === drag || drag === direction) && (null === currentDirection || currentDirection === direction);
  }
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    Math.abs(offset.y) > lockThreshold ? direction = "y" : Math.abs(offset.x) > lockThreshold && (direction = "x");
    return direction;
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence(), layoutGroup = React.useContext(LayoutGroupContext);
    return jsxRuntime.jsx(MeasureLayoutWithContext, {...props, layoutGroup, switchLayoutGroup:React.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove});
  }
  function handleHoverEvent(node, event, lifecycle) {
    const {props} = node;
    node.animationState && props.whileHover && node.animationState.setActive("whileHover", "Start" === lifecycle);
    const callback = props["onHover" + lifecycle];
    callback && frame.postRender(() => callback(event, extractEventInfo(event)));
  }
  function handlePressEvent(node, event, lifecycle) {
    const {props} = node;
    if (!(node.current instanceof HTMLButtonElement && node.current.disabled)) {
      node.animationState && props.whileTap && node.animationState.setActive("whileTap", "Start" === lifecycle);
      var callback = props["onTap" + ("End" === lifecycle ? "" : lifecycle)];
      callback && frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  function initIntersectionObserver({root, ...options}) {
    var lookupRoot = root || document;
    observers.has(lookupRoot) || observers.set(lookupRoot, {});
    lookupRoot = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    lookupRoot[key] || (lookupRoot[key] = new IntersectionObserver(fireAllObserverCallbacks, {root, ...options}));
    return lookupRoot[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }
  function hasViewportOptionChanged({viewport = {}}, {viewport:prevViewport = {}} = {}) {
    return name => viewport[name] !== prevViewport[name];
  }
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const {initial, animate} = props;
      return {initial:!1 === initial || isVariantLabel(initial) ? initial : void 0, animate:isVariantLabel(animate) ? animate : void 0};
    }
    return !1 !== props.inherit ? context : {};
  }
  function useCreateMotionContext(props) {
    const {initial, animate} = getCurrentTreeVariants(props, React.useContext(MotionContext));
    return React.useMemo(() => ({initial, animate}), [Array.isArray(initial) ? initial.join(" ") : initial, Array.isArray(animate) ? animate.join(" ") : animate]);
  }
  function useMotionRef(visualState, visualElement, externalRef) {
    return React.useCallback(instance => {
      instance && visualState.onMount && visualState.onMount(instance);
      visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount());
      externalRef && ("function" === typeof externalRef ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    }, [visualElement]);
  }
  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    var _a, _b;
    const {visualElement:parent} = React.useContext(MotionContext), lazyContext = React.useContext(LazyContext), presenceContext = React.useContext(PresenceContext), reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion, visualElementRef = React.useRef(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component, {visualState, parent, props, presenceContext, blockInitialAnimation:presenceContext ? !1 === presenceContext.initial : !1, reducedMotionConfig}));
    const visualElement = visualElementRef.current;
    Component = React.useContext(SwitchLayoutGroupContext);
    !visualElement || visualElement.projection || !ProjectionNodeConstructor || "html" !== visualElement.type && "svg" !== visualElement.type || createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, Component);
    const isMounted = React.useRef(!1);
    React.useInsertionEffect(() => {
      visualElement && isMounted.current && visualElement.update(props, presenceContext);
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = React.useRef(!!optimisedAppearId && !(null === (_a = window.MotionHandoffIsComplete) || void 0 === _a ? 0 : _a.call(window, optimisedAppearId)) && (null === (_b = window.MotionHasOptimisedAnimation) || void 0 === _b ? void 0 : _b.call(window, optimisedAppearId)));
    useIsomorphicLayoutEffect(() => {
      visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), microtask.render(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
    });
    React.useEffect(() => {
      visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
        var _a;
        null === (_a = window.MotionHandoffMarkAsComplete) || void 0 === _a || _a.call(window, optimisedAppearId);
      }), wantsHandoff.current = !1));
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const {layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot} = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({layoutId, layout, alwaysMeasureLayout:!!drag || dragConstraints && isRefObject(dragConstraints), visualElement, animationType:"string" === typeof layout ? layout : "both", initialPromotionConfig, layoutScroll, layoutRoot});
  }
  function getClosestProjectingNode(visualElement) {
    if (visualElement) {
      return !1 !== visualElement.options.allowProjection ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
    }
  }
  function createRendererMotionComponent({preloadedFeatures, createVisualElement, useRender, useVisualState, Component}) {
    function MotionComponent(props, externalRef) {
      const configAndProps = {...React.useContext(MotionConfigContext), ...props, layoutId:useLayoutId(props)}, {isStatic} = configAndProps, context = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        var MeasureLayout = React.useContext(LazyContext).strict;
        preloadedFeatures && MeasureLayout && (configAndProps.ignoreStrict ? motionUtils.warning(!1, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.") : motionUtils.invariant(!1, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead."));
        {
          const {drag, layout} = featureDefinitions;
          drag || layout ? (MeasureLayout = {...drag, ...layout}, MeasureLayout = {MeasureLayout:(null === drag || void 0 === drag ? 0 : drag.isEnabled(configAndProps)) || (null === layout || void 0 === layout ? 0 : layout.isEnabled(configAndProps)) ? MeasureLayout.MeasureLayout : void 0, ProjectionNode:MeasureLayout.ProjectionNode}) : MeasureLayout = {};
        }
        const layoutProjection = MeasureLayout;
        MeasureLayout = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return jsxRuntime.jsxs(MotionContext.Provider, {value:context, children:[MeasureLayout && context.visualElement ? jsxRuntime.jsx(MeasureLayout, {visualElement:context.visualElement, ...configAndProps}) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)]});
    }
    var _a, _b;
    preloadedFeatures && loadFeatures(preloadedFeatures);
    MotionComponent.displayName = `motion.${"string" === typeof Component ? Component : `create(${null !== (_b = null !== (_a = Component.displayName) && void 0 !== _a ? _a : Component.name) && void 0 !== _b ? _b : ""})`}`;
    _a = React.forwardRef(MotionComponent);
    _a[motionComponentSymbol] = Component;
    return _a;
  }
  function useLayoutId({layoutId}) {
    const layoutGroupId = React.useContext(LayoutGroupContext).id;
    return layoutGroupId && void 0 !== layoutId ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      isMotionValue(source[key]) || isForcedMotionValue(key, props) || (target[key] = source[key]);
    }
  }
  function useInitialMotionValues({transformTemplate}, visualState) {
    return React.useMemo(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {}, style = {};
    copyRawValuesOnly(style, props.style || {}, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    props.drag && !1 !== props.dragListener && (htmlProps.draggable = !1, style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none", style.touchAction = !0 === props.drag ? "none" : `pan-${"x" === props.drag ? "y" : "x"}`);
    void 0 === props.tabIndex && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0);
    htmlProps.style = style;
    return htmlProps;
  }
  function isSVGComponent(Component) {
    return "string" === typeof Component && !Component.includes("-") && (-1 < lowercaseSVGElements.indexOf(Component) || /[A-Z]/u.test(Component)) ? !0 : !1;
  }
  function useSVGProps(props, visualState, _isStatic, Component) {
    _isStatic = React.useMemo(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
      return {...state.attrs, style:{...state.style}};
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      _isStatic.style = {...rawStyles, ..._isStatic.style};
    }
    return _isStatic;
  }
  function createUseRender(forwardMotionProps = !1) {
    return (Component, props, ref, {latestValues}, isStatic) => {
      latestValues = (isSVGComponent(Component) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component);
      isStatic = filterProps(props, "string" === typeof Component, forwardMotionProps);
      ref = Component !== React.Fragment ? {...isStatic, ...latestValues, ref} : {};
      const {children} = props;
      props = React.useMemo(() => children && children.getVelocity ? children.get() : children, [children]);
      return React.createElement(Component, {...ref, children:props});
    };
  }
  function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
    return function(Component, {forwardMotionProps} = {forwardMotionProps:!1}) {
      Component = {...(isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig), preloadedFeatures, useRender:createUseRender(forwardMotionProps), createVisualElement, Component};
      return createRendererMotionComponent(Component);
    };
  }
  var motionDom = require("module$node_modules$motion_dom$dist$cjs$index"), motionUtils = require("module$node_modules$motion_utils$dist$cjs$index"), jsxRuntime = require("module$node_modules$react$jsx_runtime"), React = require("module$node_modules$react$index");
  const LayoutGroupContext = React.createContext({}), MotionGlobalConfig = {skipAnimations:!1, useManualTiming:!1}, stepsOrder = "read resolveKeyframes update preRender render postRender".split(" "), statsBuffer = {value:null, addProjectionMetrics:null}, {schedule:frame, cancel:cancelFrame, state:frameData, steps:frameSteps} = createRenderBatcher("undefined" !== typeof requestAnimationFrame ? requestAnimationFrame : motionUtils.noop, !0), transformPropOrder = "transformPerspective x y z translateX translateY translateZ scale scaleX scaleY rotate rotateX rotateY rotateZ skew skewX skewY".split(" "), 
  transformProps = new Set(transformPropOrder), positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", ...transformPropOrder]);
  let now;
  const time = {now:() => {
    void 0 === now && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    return now;
  }, set:newTime => {
    now = newTime;
    queueMicrotask(clearTime);
  }};
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (numSubscriptions) {
        if (1 === numSubscriptions) {
          this.subscriptions[0](a, b, c);
        } else {
          for (let i = 0; i < numSubscriptions; i++) {
            const handler = this.subscriptions[i];
            handler && handler(a, b, c);
          }
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const warned = new Set(), collectMotionValues = {current:void 0};
  class MotionValue {
    constructor(init, options = {}) {
      this.version = "12.4.7";
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v, render = !0) => {
        const currentTime = time.now();
        this.updatedAt !== currentTime && this.setPrevFrameValue();
        this.prev = this.current;
        this.setCurrent(v);
        this.current !== this.prev && this.events.change && this.events.change.notify(this.current);
        render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
      };
      this.hasAnimated = !1;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      null === this.canTrackVelocity && void 0 !== current && (this.canTrackVelocity = !isNaN(parseFloat(this.current)));
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    onChange(subscription) {
      warnOnce(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).');
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
      const unsubscribe = this.events[eventName].add(callback);
      return "change" === eventName ? () => {
        unsubscribe();
        frame.read(() => {
          this.events.change.getSize() || this.stop();
        });
      } : unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    set(v, render = !0) {
      render && this.passiveEffect ? this.passiveEffect(v, this.updateAndNotify) : this.updateAndNotify(v, render);
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    jump(v, endAnimation = !0) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      this.stopPassiveEffect && this.stopPassiveEffect();
    }
    get() {
      collectMotionValues.current && collectMotionValues.current.push(this);
      return this.current;
    }
    getPrevious() {
      return this.prev;
    }
    getVelocity() {
      var currentTime = time.now();
      if (!this.canTrackVelocity || void 0 === this.prevFrameValue || 30 < currentTime - this.updatedAt) {
        return 0;
      }
      currentTime = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), currentTime);
    }
    start(startAnimation) {
      this.stop();
      return (new Promise(resolve => {
        this.hasAnimated = !0;
        this.animation = startAnimation(resolve);
        this.events.animationStart && this.events.animationStart.notify();
      })).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify();
        this.clearAnimation();
      });
    }
    stop() {
      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify());
      this.clearAnimation();
    }
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    destroy() {
      this.clearListeners();
      this.stop();
      this.stopPassiveEffect && this.stopPassiveEffect();
    }
  }
  const isMotionValue = value => !(!value || !value.getVelocity), camelToDash = str => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataAttribute = "data-" + camelToDash("framerAppearId"), instantAnimationState = {current:!1}, mirrorEasing = easing => p => 0.5 >= p ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2, reverseEasing = easing => p => 1 - easing(1 - p), backOut = cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), 
  anticipate = p => 1 > (p *= 2) ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))), circIn = p => 1 - Math.sin(Math.acos(p)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), clamp = (min, max, v) => v > max ? max : v < min ? min : v, number = {test:v => "number" === typeof v, parse:parseFloat, transform:v => v}, alpha = {...number, transform:v => 1 < v ? 1 : 0 > v ? 0 : v}, scale = {...number, default:1}, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, 
  isColorString = (type, testProp) => v => !!("string" === typeof v && singleColorRegex.test(v) && v.startsWith(type) || testProp && null != v && Object.prototype.hasOwnProperty.call(v, testProp)), splitColor = (aName, bName, cName) => v => {
    if ("string" !== typeof v) {
      return v;
    }
    const [a, b, c, alpha] = v.match(floatRegex);
    return {[aName]:parseFloat(a), [bName]:parseFloat(b), [cName]:parseFloat(c), alpha:void 0 !== alpha ? parseFloat(alpha) : 1};
  }, rgbUnit = {...number, transform:v => Math.round(255 < v ? 255 : 0 > v ? 0 : v)}, rgba = {test:isColorString("rgb", "red"), parse:splitColor("red", "green", "blue"), transform:({red, green, blue, alpha:alpha$1 = 1}) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + Math.round(100000 * alpha.transform(alpha$1)) / 100000 + ")"}, hex = {test:isColorString("#"), parse:function(v) {
    let r, g, b;
    5 < v.length ? (r = v.substring(1, 3), g = v.substring(3, 5), b = v.substring(5, 7), v = v.substring(7, 9)) : (r = v.substring(1, 2), g = v.substring(2, 3), b = v.substring(3, 4), v = v.substring(4, 5), r += r, g += g, b += b, v += v);
    return {red:parseInt(r, 16), green:parseInt(g, 16), blue:parseInt(b, 16), alpha:v ? parseInt(v, 16) / 255 : 1};
  }, transform:rgba.transform}, createUnitType = unit => ({test:v => "string" === typeof v && v.endsWith(unit) && 1 === v.split(" ").length, parse:parseFloat, transform:v => `${v}${unit}`}), degrees = createUnitType("deg"), percent = createUnitType("%"), px = createUnitType("px"), vh = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = {...percent, parse:v => percent.parse(v) / 100, transform:v => percent.transform(100 * v)}, hsla = {test:isColorString("hsl", "hue"), parse:splitColor("hue", 
  "saturation", "lightness"), transform:({hue, saturation, lightness, alpha:alpha$1 = 1}) => "hsla(" + Math.round(hue) + ", " + percent.transform(Math.round(100000 * saturation) / 100000) + ", " + percent.transform(Math.round(100000 * lightness) / 100000) + ", " + Math.round(100000 * alpha.transform(alpha$1)) / 100000 + ")"}, color = {test:v => rgba.test(v) || hex.test(v) || hsla.test(v), parse:v => rgba.test(v) ? rgba.parse(v) : hsla.test(v) ? hsla.parse(v) : hex.parse(v), transform:v => "string" === 
  typeof v ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v)}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu, convertNumbersToZero = v => "number" === typeof v ? 
  0 : v, complex = {test:function(v) {
    var _a, _b;
    return isNaN(v) && "string" === typeof v && 0 < ((null === (_a = v.match(floatRegex)) || void 0 === _a ? void 0 : _a.length) || 0) + ((null === (_b = v.match(colorRegex)) || void 0 === _b ? void 0 : _b.length) || 0);
  }, parse:parseComplexValue, createTransformer, getAnimatableNone:function(v) {
    const parsed = parseComplexValue(v);
    return createTransformer(v)(parsed.map(convertNumbersToZero));
  }}, maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]), functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {...complex, getAnimatableNone:v => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }}, browserNumberValueTypes = {borderWidth:px, borderTopWidth:px, borderRightWidth:px, borderBottomWidth:px, borderLeftWidth:px, borderRadius:px, radius:px, borderTopLeftRadius:px, borderTopRightRadius:px, borderBottomRightRadius:px, borderBottomLeftRadius:px, width:px, maxWidth:px, height:px, maxHeight:px, top:px, right:px, bottom:px, left:px, padding:px, paddingTop:px, paddingRight:px, paddingBottom:px, paddingLeft:px, margin:px, marginTop:px, marginRight:px, marginBottom:px, marginLeft:px, backgroundPositionX:px, 
  backgroundPositionY:px}, int = {...number, transform:Math.round}, numberValueTypes = {...browserNumberValueTypes, rotate:degrees, rotateX:degrees, rotateY:degrees, rotateZ:degrees, scale, scaleX:scale, scaleY:scale, scaleZ:scale, skew:degrees, skewX:degrees, skewY:degrees, distance:px, translateX:px, translateY:px, translateZ:px, x:px, y:px, z:px, perspective:px, transformPerspective:px, opacity:alpha, originX:progressPercentage, originY:progressPercentage, originZ:px, zIndex:int, size:px, fillOpacity:alpha, 
  strokeOpacity:alpha, numOctaves:int}, defaultValueTypes = {...numberValueTypes, color, backgroundColor:color, outlineColor:color, fill:color, stroke:color, borderColor:color, borderTopColor:color, borderRightColor:color, borderBottomColor:color, borderLeftColor:color, filter, WebkitFilter:filter}, invalidTemplates = new Set(["auto", "none", "0"]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, {transform}) => "none" !== transform && transform ? (_bbox = transform.match(/^matrix3d\((.+)\)$/u)) ? 
  parseFloat(_bbox[1].split(", ")[pos3]) : (transform = transform.match(/^matrix\((.+)\)$/u)) ? parseFloat(transform[1].split(", ")[pos2]) : 0 : 0, transformKeys = new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key)), positionalValues = {width:({x}, {paddingLeft = "0", paddingRight = "0"}) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight), height:({y}, {paddingTop = "0", paddingBottom = "0"}) => y.max - y.min - parseFloat(paddingTop) - 
  parseFloat(paddingBottom), top:(_bbox, {top}) => parseFloat(top), left:(_bbox, {left}) => parseFloat(left), bottom:({y}, {top}) => parseFloat(top) + (y.max - y.min), right:({x}, {left}) => parseFloat(left) + (x.max - x.min), x:getTranslateFromMatrix(4, 13), y:getTranslateFromMatrix(5, 14)};
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  const toResolve = new Set();
  let isScheduled = !1, anyNeedsMeasurement = !1;
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = !1) {
      this.isScheduled = this.needsMeasurement = this.isAsync = this.isComplete = !1;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.isScheduled = !0;
      this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
    }
    readKeyframes() {
      const {unresolvedKeyframes, name, element, motionValue} = this;
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (null === unresolvedKeyframes[i]) {
          if (0 === i) {
            const currentValue = null === motionValue || void 0 === motionValue ? void 0 : motionValue.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
            if (void 0 !== currentValue) {
              unresolvedKeyframes[0] = currentValue;
            } else if (element && name) {
              const valueAsRead = element.readValue(name, finalKeyframe);
              void 0 !== valueAsRead && null !== valueAsRead && (unresolvedKeyframes[0] = valueAsRead);
            }
            void 0 === unresolvedKeyframes[0] && (unresolvedKeyframes[0] = finalKeyframe);
            motionValue && void 0 === currentValue && motionValue.set(unresolvedKeyframes[0]);
          } else {
            unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
          }
        }
      }
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete() {
      this.isComplete = !0;
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
      toResolve.delete(this);
    }
    cancel() {
      this.isComplete || (this.isScheduled = !1, toResolve.delete(this));
    }
    resume() {
      this.isComplete || this.scheduleResolve();
    }
  }
  const checkStringStartsWith = token => key => "string" === typeof key && key.startsWith(token), isCSSVariableName = checkStringStartsWith("--"), startsAsVariableToken = checkStringStartsWith("var(--"), isCSSVariableToken = value => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u, 
  testValueType = v => type => type.test(v), dimensionValueTypes = [number, px, percent, degrees, vw, vh, {test:v => "auto" === v, parse:v => v}];
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue, element, !0);
    }
    readKeyframes() {
      const {unresolvedKeyframes, element, name} = this;
      if (element && element.current) {
        super.readKeyframes();
        for (var i = 0; i < unresolvedKeyframes.length; i++) {
          var keyframe = unresolvedKeyframes[i];
          if ("string" === typeof keyframe && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
            const resolved = getVariableValue(keyframe, element.current);
            void 0 !== resolved && (unresolvedKeyframes[i] = resolved);
            i === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
          }
        }
        this.resolveNoneKeyframes();
        if (positionalKeys.has(name) && 2 === unresolvedKeyframes.length) {
          var [origin, target] = unresolvedKeyframes;
          i = dimensionValueTypes.find(testValueType(origin));
          keyframe = dimensionValueTypes.find(testValueType(target));
          if (i !== keyframe) {
            if (i !== number && i !== px || keyframe !== number && keyframe !== px) {
              this.needsMeasurement = !0;
            } else {
              for (i = 0; i < unresolvedKeyframes.length; i++) {
                keyframe = unresolvedKeyframes[i], "string" === typeof keyframe && (unresolvedKeyframes[i] = parseFloat(keyframe));
              }
            }
          }
        }
      }
    }
    resolveNoneKeyframes() {
      const {unresolvedKeyframes, name} = this, noneKeyframeIndexes = [];
      for (var i = 0; i < unresolvedKeyframes.length; i++) {
        var JSCompiler_inline_result = unresolvedKeyframes[i];
        JSCompiler_inline_result = "number" === typeof JSCompiler_inline_result ? 0 === JSCompiler_inline_result : null !== JSCompiler_inline_result ? "none" === JSCompiler_inline_result || "0" === JSCompiler_inline_result || /^0[^.\s]+$/u.test(JSCompiler_inline_result) : !0;
        JSCompiler_inline_result && noneKeyframeIndexes.push(i);
      }
      if (noneKeyframeIndexes.length) {
        i = 0;
        for (JSCompiler_inline_result = void 0; i < unresolvedKeyframes.length && !JSCompiler_inline_result;) {
          const keyframe = unresolvedKeyframes[i];
          "string" === typeof keyframe && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (JSCompiler_inline_result = unresolvedKeyframes[i]);
          i++;
        }
        if (JSCompiler_inline_result && name) {
          for (const noneIndex of noneKeyframeIndexes) {
            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, JSCompiler_inline_result);
          }
        }
      }
    }
    measureInitialState() {
      const {element, unresolvedKeyframes, name} = this;
      if (element && element.current) {
        "height" === name && (this.suspendedScrollY = window.pageYOffset);
        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        unresolvedKeyframes[0] = this.measuredOrigin;
        var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        void 0 !== measureKeyframe && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
      }
    }
    measureEndState() {
      var _a;
      const {element, name, unresolvedKeyframes} = this;
      if (element && element.current) {
        var value = element.getValue(name);
        value && value.jump(this.measuredOrigin, !1);
        value = unresolvedKeyframes.length - 1;
        var finalKeyframe = unresolvedKeyframes[value];
        unresolvedKeyframes[value] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        null !== finalKeyframe && void 0 === this.finalKeyframe && (this.finalKeyframe = finalKeyframe);
        (null === (_a = this.removedTransforms) || void 0 === _a ? 0 : _a.length) && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
        this.resolveNoneKeyframes();
      }
    }
  }
  const isAnimatable = (value, name) => "zIndex" === name ? !1 : "number" === typeof value || Array.isArray(value) || "string" === typeof value && (complex.test(value) || "0" === value) && !value.startsWith("url(") ? !0 : !1, isNotNull = value => null !== value;
  class BaseAnimation {
    constructor({autoplay = !0, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options}) {
      this.hasAttemptedResolve = this.isStopped = !1;
      this.createdAt = time.now();
      this.options = {autoplay, delay, type, repeat, repeatDelay, repeatType, ...options};
      this.updateFinishedPromise();
    }
    calcStartTime() {
      return this.resolvedAt ? 40 < this.resolvedAt - this.createdAt ? this.resolvedAt : this.createdAt : this.createdAt;
    }
    get resolved() {
      this._resolved || this.hasAttemptedResolve || (readAllKeyframes(), measureAllKeyframes());
      return this._resolved;
    }
    onKeyframesResolved(keyframes, finalKeyframe) {
      this.resolvedAt = time.now();
      this.hasAttemptedResolve = !0;
      const {name, type, velocity, delay, onComplete, onUpdate, isGenerator} = this.options;
      var JSCompiler_temp;
      if (JSCompiler_temp = !isGenerator) {
        {
          const originKeyframe = keyframes[0];
          if (null === originKeyframe) {
            JSCompiler_temp = !1;
          } else {
            if ("display" === name || "visibility" === name) {
              JSCompiler_temp = !0;
            } else {
              JSCompiler_temp = keyframes[keyframes.length - 1];
              var isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(JSCompiler_temp, name);
              motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${JSCompiler_temp}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${JSCompiler_temp} via the \`style\` property.`);
              if (isOriginAnimatable && isTargetAnimatable) {
                b: {
                  if (JSCompiler_temp = keyframes[0], 1 === keyframes.length) {
                    JSCompiler_temp = !0;
                  } else {
                    for (isOriginAnimatable = 0; isOriginAnimatable < keyframes.length; isOriginAnimatable++) {
                      if (keyframes[isOriginAnimatable] !== JSCompiler_temp) {
                        JSCompiler_temp = !0;
                        break b;
                      }
                    }
                    JSCompiler_temp = void 0;
                  }
                }
                JSCompiler_temp = JSCompiler_temp || ("spring" === type || motionDom.isGenerator(type)) && velocity;
              } else {
                JSCompiler_temp = !1;
              }
            }
          }
        }
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp) {
        if (instantAnimationState.current || !delay) {
          onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));
          onComplete && onComplete();
          this.resolveFinishedPromise();
          return;
        }
        this.options.duration = 0;
      }
      JSCompiler_temp = this.initPlayback(keyframes, finalKeyframe);
      !1 !== JSCompiler_temp && (this._resolved = {keyframes, finalKeyframe, ...JSCompiler_temp}, this.onPostResolved());
    }
    onPostResolved() {
    }
    then(resolve, reject) {
      return this.currentFinishedPromise.then(resolve, reject);
    }
    flatten() {
      this.options.type = "keyframes";
      this.options.ease = "linear";
    }
    updateFinishedPromise() {
      this.currentFinishedPromise = new Promise(resolve => {
        this.resolveFinishedPromise = resolve;
      });
    }
  }
  const mixNumber$1 = (from, to, progress) => from + (to - from) * progress, mixLinearColor = (from, to, v) => {
    from *= from;
    to = v * (to * to - from) + from;
    return 0 > to ? 0 : Math.sqrt(to);
  }, colorTypes = [hex, rgba, hsla], getColorType = v => colorTypes.find(type => type.test(v)), mixColor = (from, to) => {
    const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = {...fromRGBA};
    return v => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  }, combineFunctions = (a, b) => v => b(a(v)), invisibleValues = new Set(["none", "hidden"]), mixComplex = (origin, target) => {
    const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
    if (originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      origin = mixArray;
      var _a;
      target = [];
      const pointers = {color:0, var:0, number:0};
      for (let i = 0; i < targetStats.values.length; i++) {
        const type = targetStats.types[i], originValue = null !== (_a = originStats.values[originStats.indexes[type][pointers[type]]]) && void 0 !== _a ? _a : 0;
        target[i] = originValue;
        pointers[type]++;
      }
      return [origin(target, targetStats.values), template].reduce(combineFunctions);
    }
    motionUtils.warning(!0, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin, target);
  }, springDefaults = {stiffness:100, damping:10, mass:1.0, velocity:0.0, duration:800, bounce:0.3, visualDuration:0.3, restSpeed:{granular:0.01, default:2}, restDelta:{granular:0.005, default:0.5}, minDuration:0.01, maxDuration:10.0, minDamping:0.05, maxDamping:1}, durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"], easeIn = cubicBezier(0.42, 0, 1, 1), easeOut = cubicBezier(0, 0, 0.58, 1), easeInOut = cubicBezier(0.42, 0, 0.58, 1), isEasingArray = ease => Array.isArray(ease) && 
  "number" !== typeof ease[0], easingLookup = {linear:motionUtils.noop, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate}, easingDefinitionToFunction = definition => {
    if (motionDom.isBezierDefinition(definition)) {
      motionUtils.invariant(4 === definition.length, "Cubic bezier arrays must contain four numerical values.");
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    }
    return "string" === typeof definition ? (motionUtils.invariant(void 0 !== easingLookup[definition], `Invalid easing type '${definition}'`), easingLookup[definition]) : definition;
  }, frameloopDriver = update => {
    const passTimestamp = ({timestamp}) => update(timestamp);
    return {start:() => frame.update(passTimestamp, !0), stop:() => cancelFrame(passTimestamp), now:() => frameData.isProcessing ? frameData.timestamp : time.now()};
  }, generators = {decay:inertia, inertia, tween:keyframes, keyframes, spring}, percentToProgress = percent => percent / 100;
  class MainThreadAnimation extends BaseAnimation {
    constructor(options) {
      super(options);
      this.cancelTime = this.holdTime = null;
      this.currentTime = 0;
      this.playbackSpeed = 1;
      this.pendingPlayState = "running";
      this.startTime = null;
      this.state = "idle";
      this.stop = () => {
        this.resolver.cancel();
        this.isStopped = !0;
        if ("idle" !== this.state) {
          this.teardown();
          var {onStop} = this.options;
          onStop && onStop();
        }
      };
      const {name, motionValue, element, keyframes} = this.options;
      this.resolver = new ((null === element || void 0 === element ? void 0 : element.KeyframeResolver) || KeyframeResolver)(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);
      this.resolver.scheduleResolve();
    }
    flatten() {
      super.flatten();
      this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
    initPlayback(keyframes$1) {
      const {type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0} = this.options;
      var generatorFactory = motionDom.isGenerator(type) ? type : generators[type] || keyframes;
      let mapPercentToKeyframes, mirroredGenerator;
      generatorFactory !== keyframes && motionUtils.invariant(2 >= keyframes$1.length, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
      generatorFactory !== keyframes && "number" !== typeof keyframes$1[0] && (mapPercentToKeyframes = [percentToProgress, mix(keyframes$1[0], keyframes$1[1])].reduce(combineFunctions), keyframes$1 = [0, 100]);
      const generator = generatorFactory({...this.options, keyframes:keyframes$1});
      "mirror" === repeatType && (mirroredGenerator = generatorFactory({...this.options, keyframes:[...keyframes$1].reverse(), velocity:-velocity}));
      null === generator.calculatedDuration && (generator.calculatedDuration = motionDom.calcGeneratorDuration(generator));
      ({calculatedDuration:keyframes$1} = generator);
      generatorFactory = keyframes$1 + repeatDelay;
      return {generator, mirroredGenerator, mapPercentToKeyframes, calculatedDuration:keyframes$1, resolvedDuration:generatorFactory, totalDuration:generatorFactory * (repeat + 1) - repeatDelay};
    }
    onPostResolved() {
      const {autoplay = !0} = this.options;
      this.play();
      "paused" !== this.pendingPlayState && autoplay ? this.state = this.pendingPlayState : this.pause();
    }
    tick(timestamp, sample = !1) {
      var {resolved} = this;
      if (!resolved) {
        return {keyframes:timestamp} = this.options, {done:!0, value:timestamp[timestamp.length - 1]};
      }
      const {finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration} = resolved;
      if (null === this.startTime) {
        return generator.next(0);
      }
      const {delay, repeat, repeatType, repeatDelay, onUpdate} = this.options;
      0 < this.speed ? this.startTime = Math.min(this.startTime, timestamp) : 0 > this.speed && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime));
      this.currentTime = sample ? timestamp : null !== this.holdTime ? this.holdTime : Math.round(timestamp - this.startTime) * this.speed;
      sample = this.currentTime - delay * (0 <= this.speed ? 1 : -1);
      timestamp = 0 <= this.speed ? 0 > sample : sample > totalDuration;
      this.currentTime = Math.max(sample, 0);
      "finished" === this.state && null === this.holdTime && (this.currentTime = totalDuration);
      resolved = this.currentTime;
      sample = generator;
      if (repeat) {
        resolved = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(resolved), iterationProgress = resolved % 1.0;
        !iterationProgress && 1 <= resolved && (iterationProgress = 1);
        1 === iterationProgress && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        currentIteration % 2 && ("reverse" === repeatType ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : "mirror" === repeatType && (sample = mirroredGenerator));
        resolved = (1 < iterationProgress ? 1 : 0 > iterationProgress ? 0 : iterationProgress) * resolvedDuration;
      }
      sample = timestamp ? {done:!1, value:keyframes[0]} : sample.next(resolved);
      mapPercentToKeyframes && (sample.value = mapPercentToKeyframes(sample.value));
      ({done:resolved} = sample);
      timestamp || null === calculatedDuration || (resolved = 0 <= this.speed ? this.currentTime >= totalDuration : 0 >= this.currentTime);
      (timestamp = null === this.holdTime && ("finished" === this.state || "running" === this.state && resolved)) && void 0 !== finalKeyframe && (sample.value = getFinalKeyframe(keyframes, this.options, finalKeyframe));
      onUpdate && onUpdate(sample.value);
      timestamp && this.finish();
      return sample;
    }
    get duration() {
      const {resolved} = this;
      return resolved ? motionUtils.millisecondsToSeconds(resolved.calculatedDuration) : 0;
    }
    get time() {
      return motionUtils.millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      this.currentTime = newTime = motionUtils.secondsToMilliseconds(newTime);
      null !== this.holdTime || 0 === this.speed ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.speed);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      hasChanged && (this.time = motionUtils.millisecondsToSeconds(this.currentTime));
    }
    play() {
      this.resolver.isScheduled || this.resolver.resume();
      if (!this._resolved) {
        this.pendingPlayState = "running";
      } else {
        if (!this.isStopped) {
          var {driver = frameloopDriver, onPlay, startTime} = this.options;
          this.driver || (this.driver = driver(timestamp => this.tick(timestamp)));
          onPlay && onPlay();
          var now = this.driver.now();
          null !== this.holdTime ? this.startTime = now - this.holdTime : this.startTime ? "finished" === this.state && (this.startTime = now) : this.startTime = null !== startTime && void 0 !== startTime ? startTime : this.calcStartTime();
          "finished" === this.state && this.updateFinishedPromise();
          this.cancelTime = this.startTime;
          this.holdTime = null;
          this.state = "running";
          this.driver.start();
        }
      }
    }
    pause() {
      var _a;
      this._resolved ? (this.state = "paused", this.holdTime = null !== (_a = this.currentTime) && void 0 !== _a ? _a : 0) : this.pendingPlayState = "paused";
    }
    complete() {
      "running" !== this.state && this.play();
      this.pendingPlayState = this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.teardown();
      this.state = "finished";
      const {onComplete} = this.options;
      onComplete && onComplete();
    }
    cancel() {
      null !== this.cancelTime && this.tick(this.cancelTime);
      this.teardown();
      this.updateFinishedPromise();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.resolveFinishedPromise();
      this.updateFinishedPromise();
      this.startTime = this.cancelTime = null;
      this.resolver.cancel();
    }
    stopDriver() {
      this.driver && (this.driver.stop(), this.driver = void 0);
    }
    sample(time) {
      this.startTime = 0;
      return this.tick(time, !0);
    }
  }
  const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"]), supportsWaapi = motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), unsupportedEasingFunctions = {anticipate, backInOut, circInOut};
  class AcceleratedAnimation extends BaseAnimation {
    constructor(options) {
      super(options);
      const {name, motionValue, element, keyframes} = this.options;
      this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);
      this.resolver.scheduleResolve();
    }
    initPlayback(keyframes, finalKeyframe) {
      let {duration = 300, times, ease, type, motionValue, name, startTime} = this.options;
      if (!motionValue.owner || !motionValue.owner.current) {
        return !1;
      }
      "string" === typeof ease && motionDom.supportsLinearEasing() && ease in unsupportedEasingFunctions && (ease = unsupportedEasingFunctions[ease]);
      if (requiresPregeneratedKeyframes(this.options)) {
        const {onComplete, onUpdate, motionValue, element, ...options} = this.options;
        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);
        keyframes = pregeneratedAnimation.keyframes;
        1 === keyframes.length && (keyframes[1] = keyframes[0]);
        duration = pregeneratedAnimation.duration;
        times = pregeneratedAnimation.times;
        ease = pregeneratedAnimation.ease;
        type = "keyframes";
      }
      pregeneratedAnimation = startWaapiAnimation(motionValue.owner.current, name, keyframes, {...this.options, duration, times, ease});
      pregeneratedAnimation.startTime = null !== startTime && void 0 !== startTime ? startTime : this.calcStartTime();
      this.pendingTimeline ? (motionDom.attachTimeline(pregeneratedAnimation, this.pendingTimeline), this.pendingTimeline = void 0) : pregeneratedAnimation.onfinish = () => {
        const {onComplete} = this.options;
        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
      return {animation:pregeneratedAnimation, duration, times, type, ease, keyframes};
    }
    get duration() {
      var {resolved} = this;
      if (!resolved) {
        return 0;
      }
      ({duration:resolved} = resolved);
      return motionUtils.millisecondsToSeconds(resolved);
    }
    get time() {
      var {resolved} = this;
      if (!resolved) {
        return 0;
      }
      ({animation:resolved} = resolved);
      return motionUtils.millisecondsToSeconds(resolved.currentTime || 0);
    }
    set time(newTime) {
      var {resolved} = this;
      resolved && ({animation:resolved} = resolved, resolved.currentTime = motionUtils.secondsToMilliseconds(newTime));
    }
    get speed() {
      var {resolved} = this;
      if (!resolved) {
        return 1;
      }
      ({animation:resolved} = resolved);
      return resolved.playbackRate;
    }
    set speed(newSpeed) {
      var {resolved} = this;
      resolved && ({animation:resolved} = resolved, resolved.playbackRate = newSpeed);
    }
    get state() {
      var {resolved} = this;
      if (!resolved) {
        return "idle";
      }
      ({animation:resolved} = resolved);
      return resolved.playState;
    }
    get startTime() {
      var {resolved} = this;
      if (!resolved) {
        return null;
      }
      ({animation:resolved} = resolved);
      return resolved.startTime;
    }
    attachTimeline(timeline) {
      if (this._resolved) {
        var {resolved} = this;
        if (!resolved) {
          return motionUtils.noop;
        }
        ({animation:resolved} = resolved);
        motionDom.attachTimeline(resolved, timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return motionUtils.noop;
    }
    play() {
      if (!this.isStopped) {
        var {resolved} = this;
        resolved && ({animation:resolved} = resolved, "finished" === resolved.playState && this.updateFinishedPromise(), resolved.play());
      }
    }
    pause() {
      var {resolved} = this;
      resolved && ({animation:resolved} = resolved, resolved.pause());
    }
    stop() {
      this.resolver.cancel();
      this.isStopped = !0;
      if ("idle" !== this.state) {
        this.resolveFinishedPromise();
        this.updateFinishedPromise();
        var {resolved} = this;
        if (resolved) {
          var {animation, keyframes, duration, type, ease, times} = resolved;
          if ("idle" !== animation.playState && "finished" !== animation.playState) {
            if (this.time) {
              const {motionValue, onUpdate, onComplete, element, ...options} = this.options;
              resolved = new MainThreadAnimation({...options, keyframes, duration, type, ease, times, isGenerator:!0});
              const sampleTime = motionUtils.secondsToMilliseconds(this.time);
              motionValue.setWithVelocity(resolved.sample(sampleTime - 10).value, resolved.sample(sampleTime).value, 10);
            }
            ({onStop:resolved} = this.options);
            resolved && resolved();
            this.cancel();
          }
        }
      }
    }
    complete() {
      const {resolved} = this;
      resolved && resolved.animation.finish();
    }
    cancel() {
      const {resolved} = this;
      resolved && resolved.animation.cancel();
    }
    static supports(options) {
      const {motionValue, name, repeatDelay, repeatType, damping, type} = options;
      if (!(motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement)) {
        return !1;
      }
      const {onUpdate, transformTemplate} = motionValue.owner.getProps();
      return supportsWaapi() && name && acceleratedValues.has(name) && !onUpdate && !transformTemplate && !repeatDelay && "mirror" !== repeatType && 0 !== damping && "inertia" !== type;
    }
  }
  const underDampedSpring = {type:"spring", stiffness:500, damping:25, restSpeed:10}, keyframesTransition = {type:"keyframes", duration:0.8}, ease = {type:"keyframes", ease:[0.25, 0.1, 0.35, 1], duration:0.3}, getDefaultTransition = (valueKey, {keyframes}) => 2 < keyframes.length ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? {type:"spring", stiffness:550, damping:0 === keyframes[1] ? 2 * Math.sqrt(550) : 30, restSpeed:10} : underDampedSpring : ease, animateMotionValue = 
  (name, value, target, transition = {}, element, isHandoff) => onComplete => {
    const valueTransition = motionDom.getValueTransition(transition, name) || {};
    var delay = valueTransition.delay || transition.delay || 0;
    let {elapsed = 0} = transition;
    elapsed -= motionUtils.secondsToMilliseconds(delay);
    let options = {keyframes:Array.isArray(target) ? target : [null, target], ease:"easeOut", velocity:value.getVelocity(), ...valueTransition, delay:-elapsed, onUpdate:v => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    }, onComplete:() => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    }, name, motionValue:value, element:isHandoff ? void 0 : element};
    isTransitionDefined(valueTransition) || (options = {...options, ...getDefaultTransition(name, options)});
    options.duration && (options.duration = motionUtils.secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay));
    void 0 !== options.from && (options.keyframes[0] = options.from);
    delay = !1;
    if (!1 === options.type || 0 === options.duration && !options.repeatDelay) {
      options.duration = 0, 0 === options.delay && (delay = !0);
    }
    if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
      delay = !0, options.duration = 0, options.delay = 0;
    }
    if (delay && !isHandoff && void 0 !== value.get()) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (void 0 !== finalKeyframe) {
        return frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        }), new motionDom.GroupPlaybackControls([]);
      }
    }
    return !isHandoff && AcceleratedAnimation.supports(options) ? new AcceleratedAnimation(options) : new MainThreadAnimation(options);
  }, variantPriorityOrder = "animate whileInView whileFocus whileHover whileTap whileDrag exit".split(" "), variantProps = ["initial", ...variantPriorityOrder], numVariantProps = variantProps.length, reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
  class Feature {
    constructor(node) {
      this.isMounted = !1;
      this.node = node;
    }
    update() {
    }
  }
  class AnimationFeature extends Feature {
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const {animate} = this.node.getProps();
      isAnimationControls(animate) && (this.unmountControls = animate.subscribe(this.node));
    }
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const {animate} = this.node.getProps(), {animate:prevAnimate} = this.node.prevProps || {};
      animate !== prevAnimate && this.updateAnimationControlsSubscription();
    }
    unmount() {
      var _a;
      this.node.animationState.reset();
      null === (_a = this.unmountControls) || void 0 === _a || _a.call(this);
    }
  }
  let id$1 = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id$1++;
    }
    update() {
      if (this.node.presenceContext) {
        var {isPresent, onExitComplete} = this.node.presenceContext, {isPresent:prevIsPresent} = this.node.prevPresenceContext || {};
        this.node.animationState && isPresent !== prevIsPresent && (prevIsPresent = this.node.animationState.setActive("exit", !isPresent), onExitComplete && !isPresent && prevIsPresent.then(() => {
          onExitComplete(this.id);
        }));
      }
    }
    mount() {
      const {register, onExitComplete} = this.node.presenceContext || {};
      onExitComplete && onExitComplete(this.id);
      register && (this.unmount = register(this.id));
    }
    unmount() {
    }
  }
  const animations = {animation:{Feature:AnimationFeature}, exit:{Feature:ExitAnimationFeature}}, MotionContext = React.createContext({}), createAxisDelta = () => ({translate:0, scale:1, origin:0, originPoint:0}), createBox = () => ({x:{min:0, max:0}, y:{min:0, max:0}}), validMotionProps = new Set("animate exit variants initial style values variants transition transformTemplate custom inherit onBeforeLayoutMeasure onAnimationStart onAnimationComplete onUpdate onDragStart onDrag onDragEnd onMeasureDragConstraints onDirectionLock onDragTransitionEnd _dragX _dragY onHoverStart onHoverEnd onViewportEnter onViewportLeave globalTapTarget ignoreStrict viewport".split(" "));
  let shouldForward = key => !isValidMotionProp(key);
  try {
    loadExternalIsValidProp(require("module$node_modules$$emotion$is_prop_valid$dist$emotion_is_prop_valid_cjs").default);
  } catch (_a) {
  }
  const PresenceContext = React.createContext(null), makeUseVisualState = config => (props, isStatic) => {
    const context = React.useContext(MotionContext), presenceContext = React.useContext(PresenceContext), make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  }, addPointerInfo = handler => event => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event)), isBrowser = "undefined" !== typeof window, useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect, MotionConfigContext = React.createContext({transformPagePoint:p => p, isStatic:!1, reducedMotion:"never"}), visualElementStore = new WeakMap(), featureProps = {animation:"animate variants whileHover whileTap exit whileInView whileFocus whileDrag".split(" "), 
  exit:["exit"], drag:["drag", "dragControls"], focus:["whileFocus"], hover:["whileHover", "onHoverStart", "onHoverEnd"], tap:["whileTap", "onTap", "onTapStart", "onTapCancel"], pan:["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView:["whileInView", "onViewportEnter", "onViewportLeave"], layout:["layout", "layoutId"]}, featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {isEnabled:props => featureProps[key].some(name => !!props[name])};
  }
  const prefersReducedMotion = {current:null}, hasReducedMotionListener = {current:!1}, valueTypes = [...dimensionValueTypes, color, complex], propEventHandlers = "AnimationStart AnimationComplete Update BeforeLayoutMeasure LayoutMeasure LayoutAnimationStart LayoutAnimationComplete".split(" ");
  class VisualElement {
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState}, options = {}) {
      this.current = null;
      this.children = new Set();
      this.isControllingVariants = this.isVariantNode = !1;
      this.shouldReduceMotion = null;
      this.values = new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
      };
      this.renderScheduledAt = 0.0;
      this.scheduleRender = () => {
        const now = time.now();
        this.renderScheduledAt < now && (this.renderScheduledAt = now, frame.render(this.render, !1, !0));
      };
      const {latestValues, renderState, onUpdate} = visualState;
      this.onUpdate = onUpdate;
      this.latestValues = latestValues;
      this.baseTarget = {...latestValues};
      this.initialValues = props.initial ? {...latestValues} : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = !!blockInitialAnimation;
      this.isControllingVariants = isControllingVariants(props);
      if (this.isVariantNode = isVariantNode(props)) {
        this.variantChildren = new Set();
      }
      this.manuallyAnimateOnMount = !(!parent || !parent.current);
      const {willChange, ...initialMotionValues} = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        parent = initialMotionValues[key], void 0 !== latestValues[key] && parent && parent.getVelocity && parent.set(latestValues[key], !1);
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      this.projection && !this.projection.instance && this.projection.mount(instance);
      this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this));
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      hasReducedMotionListener.current || initPrefersReducedMotion();
      this.shouldReduceMotion = "never" === this.reducedMotionConfig ? !1 : "always" === this.reducedMotionConfig ? !0 : prefersReducedMotion.current;
      warnOnce(!0 !== this.shouldReduceMotion, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
      this.parent && this.parent.children.add(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach(remove => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent && this.parent.children.delete(this);
      for (var key$jscomp$0 in this.events) {
        this.events[key$jscomp$0].clear();
      }
      for (const key in this.features) {
        if (key$jscomp$0 = this.features[key]) {
          key$jscomp$0.unmount(), key$jscomp$0.isMounted = !1;
        }
      }
      this.current = null;
    }
    bindToMotionValue(key, value) {
      this.valueSubscriptions.has(key) && this.valueSubscriptions.get(key)();
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", latestValue => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
      }), removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
      let removeSyncCheck;
      window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key, value));
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        removeOnRenderRequest();
        removeSyncCheck && removeSyncCheck();
        value.owner && value.stop();
      });
    }
    sortNodePosition(other) {
      return this.current && this.sortInstanceNodePosition && this.type === other.type ? this.sortInstanceNodePosition(this.current, other.current) : 0;
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        var featureDefinition = featureDefinitions[key];
        if (!featureDefinition) {
          continue;
        }
        const {isEnabled, Feature:FeatureConstructor} = featureDefinition;
        !this.features[key] && FeatureConstructor && isEnabled(this.props) && (this.features[key] = new FeatureConstructor(this));
        this.features[key] && (featureDefinition = this.features[key], featureDefinition.isMounted ? featureDefinition.update() : (featureDefinition.mount(), featureDefinition.isMounted = !0));
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    update(props, presenceContext) {
      (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender();
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (presenceContext = 0; presenceContext < propEventHandlers.length; presenceContext++) {
        var key$jscomp$0 = propEventHandlers[presenceContext];
        this.propEventSubscriptions[key$jscomp$0] && (this.propEventSubscriptions[key$jscomp$0](), delete this.propEventSubscriptions[key$jscomp$0]);
        var listener = props["on" + key$jscomp$0];
        listener && (this.propEventSubscriptions[key$jscomp$0] = this.on(key$jscomp$0, listener));
      }
      props = this.scrapeMotionValuesFromProps(props, this.prevProps, this);
      presenceContext = this.prevMotionValues;
      for (const key in props) {
        key$jscomp$0 = props[key], listener = presenceContext[key], key$jscomp$0 && key$jscomp$0.getVelocity ? (this.addValue(key, key$jscomp$0), warnOnce("12.4.7" === key$jscomp$0.version, `Attempting to mix Motion versions ${key$jscomp$0.version} with 12.4.7 may not work as expected.`)) : listener && listener.getVelocity ? this.addValue(key, motionValue(key$jscomp$0, {owner:this})) : listener !== key$jscomp$0 && (this.hasValue(key) ? (listener = this.getValue(key), !0 === listener.liveStyle ? listener.jump(key$jscomp$0) : 
        listener.hasAnimated || listener.set(key$jscomp$0)) : (listener = this.getStaticValue(key), this.addValue(key, motionValue(void 0 !== listener ? listener : key$jscomp$0, {owner:this}))));
      }
      for (const key in presenceContext) {
        void 0 === props[key] && this.removeValue(key);
      }
      this.prevMotionValues = props;
      this.handleChildMotionValue && this.handleChildMotionValue();
      this.onUpdate && this.onUpdate(this);
    }
    getProps() {
      return this.props;
    }
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
      }
    }
    addValue(key, value) {
      const existingValue = this.values.get(key);
      value !== existingValue && (existingValue && this.removeValue(key), this.bindToMotionValue(key, value), this.values.set(key, value), this.latestValues[key] = value.get());
    }
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key));
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      void 0 === value && void 0 !== defaultValue && (value = motionValue(null === defaultValue ? void 0 : defaultValue, {owner:this}), this.addValue(key, value));
      return value;
    }
    readValue(key, target) {
      var _a;
      let value = void 0 === this.latestValues[key] && this.current ? null !== (_a = this.getBaseTargetFromProps(this.props, key)) && void 0 !== _a ? _a : this.readValueFromInstance(this.current, key, this.options) : this.latestValues[key];
      void 0 !== value && null !== value && ("string" === typeof value && (/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(value) || /^0[^.\s]+$/u.test(value)) ? value = parseFloat(value) : !valueTypes.find(testValueType(value)) && complex.test(target) && (value = getAnimatableNone(key, target)), this.setBaseTarget(key, value && value.getVelocity ? value.get() : value));
      return value && value.getVelocity ? value.get() : value;
    }
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    getBaseTarget(key) {
      var _a;
      const {initial} = this.props;
      let valueFromInitial;
      if ("string" === typeof initial || "object" === typeof initial) {
        const variant = resolveVariantFromProps(this.props, initial, null === (_a = this.presenceContext) || void 0 === _a ? void 0 : _a.custom);
        variant && (valueFromInitial = variant[key]);
      }
      if (initial && void 0 !== valueFromInitial) {
        return valueFromInitial;
      }
      _a = this.getBaseTargetFromProps(this.props, key);
      return void 0 === _a || _a && _a.getVelocity ? void 0 !== this.initialValues[key] && void 0 === valueFromInitial ? void 0 : this.baseTarget[key] : _a;
    }
    on(eventName, callback) {
      this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      this.events[eventName] && this.events[eventName].notify(...args);
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, {vars, style}) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      this.childSubscription && (this.childSubscription(), delete this.childSubscription);
      const {children} = this.props;
      children && children.getVelocity && (this.childSubscription = children.on("change", latest => {
        this.current && (this.current.textContent = `${latest}`);
      }));
    }
  }
  const getValueAsType = (value, type) => type && "number" === typeof value ? type.transform(value) : value, translateAlias = {x:"translateX", y:"translateY", z:"translateZ", transformPerspective:"perspective"}, numTransforms = transformPropOrder.length, dashKeys = {offset:"stroke-dashoffset", array:"stroke-dasharray"}, camelKeys = {offset:"strokeDashoffset", array:"strokeDasharray"}, camelCaseAttributes = new Set("baseFrequency diffuseConstant kernelMatrix kernelUnitLength keySplines keyTimes limitingConeAngle markerHeight markerWidth numOctaves targetX targetY surfaceScale specularConstant specularExponent stdDeviation tableValues viewBox gradientTransform pathLength startOffset textLength lengthAdjust".split(" ")), 
  isSVGTag = tag => "string" === typeof tag && "svg" === tag.toLowerCase(), scaleCorrectors = {};
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = !1;
      this.measureInstanceViewportBox = createBox;
      this.updateDimensions = () => {
        this.current && !this.renderState.dimensions && updateSVGDimensions(this.current, this.renderState);
      };
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return (instance = defaultValueTypes[key]) ? instance.default || 0 : 0;
      }
      key = camelCaseAttributes.has(key) ? key : camelToDash(key);
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    onBindTransform() {
      this.current && !this.renderState.dimensions && frame.postRender(this.updateDimensions);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return (key = defaultValueTypes[key]) ? key.default || 0 : 0;
      }
      instance = window.getComputedStyle(instance);
      key = (isCSSVariableName(key) ? instance.getPropertyValue(key) : instance[key]) || 0;
      return "string" === typeof key ? key.trim() : key;
    }
    measureInstanceViewportBox(instance, {transformPagePoint}) {
      return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPagePoint));
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
  }
  const {schedule:microtask} = createRenderBatcher(queueMicrotask, !1), compareByDepth = (a, b) => a.depth - b.depth;
  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = !1;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = !0;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = !0;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = !1;
      this.children.forEach(callback);
    }
  }
  const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = value => "string" === typeof value ? parseFloat(value) : value, easeCrossfadeIn = compress(0, 0.5, circOut), easeCrossfadeOut = compress(0.5, 0.95, motionUtils.noop), xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      node === this.prevLead && (this.prevLead = void 0);
      node === this.lead && (node = this.members[this.members.length - 1]) && this.promote(node);
    }
    relegate(node) {
      var indexOfNode = this.members.findIndex(member => node === member);
      if (0 === indexOfNode) {
        return !1;
      }
      let prevLead;
      for (; 0 <= indexOfNode; indexOfNode--) {
        const member = this.members[indexOfNode];
        if (!1 !== member.isPresent) {
          prevLead = member;
          break;
        }
      }
      return prevLead ? (this.promote(prevLead), !0) : !1;
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      node !== prevLead && (this.prevLead = prevLead, this.lead = node, node.show(), prevLead && (prevLead.instance && prevLead.scheduleRender(), node.scheduleRender(), node.resumeFrom = prevLead, preserveFollowOpacity && (node.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node.snapshot = prevLead.snapshot, node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node.root && node.root.isUpdating && (node.isLayoutDirty = !0), {crossfade:node} = node.options, !1 === 
      node && prevLead.hide()));
    }
    exitAnimationComplete() {
      this.members.forEach(node => {
        const {options, resumingFrom} = node;
        options.onExitComplete && options.onExitComplete();
        resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      });
    }
    scheduleRender() {
      this.members.forEach(node => {
        node.instance && node.scheduleRender(!1);
      });
    }
    removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }
  }
  const globalProjectionState = {hasAnimatedSinceResize:!0, hasEverUpdated:!1}, transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = {visibility:"hidden"};
  let id = 0;
  const defaultLayoutTransition = {duration:0.45, ease:[0.4, 0, 0.1, 1]}, userAgentContains = string => "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : motionUtils.noop, DocumentProjectionNode = createProjectionNode$1({attachResizeListener:(ref, notify) => addDomEvent(ref, "resize", notify), measureScroll:() => ({x:document.documentElement.scrollLeft || 
  document.body.scrollLeft, y:document.documentElement.scrollTop || document.body.scrollTop}), checkIsScrollRoot:() => !0}), rootProjectionNode = {current:void 0}, HTMLProjectionNode = createProjectionNode$1({measureScroll:instance => ({x:instance.scrollLeft, y:instance.scrollTop}), defaultParent:() => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({layoutScroll:!0});
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  }, resetTransform:(instance, value) => {
    instance.style.transform = void 0 !== value ? value : "none";
  }, checkIsScrollRoot:instance => "fixed" === window.getComputedStyle(instance).position}), correctBorderRadius = {correct:(latest, node) => {
    if (!node.target) {
      return latest;
    }
    if ("string" === typeof latest) {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    latest = pixelsToPercent(latest, node.target.y);
    return `${x}% ${latest}%`;
  }}, LazyContext = React.createContext({strict:!1});
  class PanSession {
    constructor(event, handlers, {transformPagePoint, dragSnapToOrigin = !1} = {}) {
      this.lastMoveEventInfo = this.lastMoveEvent = this.startEvent = null;
      this.handlers = {};
      this.updatePoint = () => {
        if (this.lastMoveEvent && this.lastMoveEventInfo) {
          var info = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = null !== this.startEvent, isDistancePastThreshold = 3 <= distance2D(info.offset, {x:0, y:0});
          if (isPanStarted || isDistancePastThreshold) {
            ({point:isDistancePastThreshold} = info);
            var {timestamp} = frameData;
            this.history.push({...isDistancePastThreshold, timestamp});
            var {onStart, onMove} = this.handlers;
            isPanStarted || (onStart && onStart(this.lastMoveEvent, info), this.startEvent = this.lastMoveEvent);
            onMove && onMove(this.lastMoveEvent, info);
          }
        }
      };
      this.handlePointerMove = (event, info) => {
        if (event.target instanceof Element && event.target.hasPointerCapture && void 0 !== event.pointerId) {
          try {
            if (!event.target.hasPointerCapture(event.pointerId)) {
              return;
            }
          } catch (e) {
          }
        }
        this.lastMoveEvent = event;
        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
        frame.update(this.updatePoint, !0);
      };
      this.handlePointerUp = (event, info) => {
        motionDom.capturePointer(event, "release");
        this.end();
        const {onEnd, onSessionEnd, resumeAnimation} = this.handlers;
        this.dragSnapToOrigin && resumeAnimation && resumeAnimation();
        this.lastMoveEvent && this.lastMoveEventInfo && (info = getPanInfo("pointercancel" === event.type || "lostpointercapture" === event.type ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history), this.startEvent && onEnd && onEnd(event, info), onSessionEnd && onSessionEnd(event, info));
      };
      if (motionDom.isPrimaryPointer(event)) {
        this.dragSnapToOrigin = dragSnapToOrigin;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        transformPagePoint = extractEventInfo(event);
        transformPagePoint = transformPoint(transformPagePoint, this.transformPagePoint);
        ({point:dragSnapToOrigin} = transformPagePoint);
        var {timestamp} = frameData;
        this.history = [{...dragSnapToOrigin, timestamp}];
        ({onSessionStart:handlers} = handlers);
        handlers && handlers(event, getPanInfo(transformPagePoint, this.history));
        motionDom.capturePointer(event, "set");
        this.removeListeners = [addPointerEvent(event.currentTarget, "pointermove", this.handlePointerMove), addPointerEvent(event.currentTarget, "pointerup", this.handlePointerUp), addPointerEvent(event.currentTarget, "pointercancel", this.handlePointerUp), addPointerEvent(event.currentTarget, "lostpointercapture", this.handlePointerUp)].reduce(combineFunctions);
      }
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  }
  const elementDragControls = new WeakMap();
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = !1;
      this.currentDirection = null;
      this.originPoint = {x:0, y:0};
      this.hasMutatedConstraints = this.constraints = !1;
      this.elastic = createBox();
      this.visualElement = visualElement;
    }
    start(originEvent, {snapToCursor = !1} = {}) {
      var {presenceContext} = this.visualElement;
      presenceContext && !1 === presenceContext.isPresent || ({dragSnapToOrigin:presenceContext} = this.getProps(), this.panSession = new PanSession(originEvent, {onSessionStart:event => {
        const {dragSnapToOrigin} = this.getProps();
        dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
        snapToCursor && this.snapToCursor(extractEventInfo(event).point);
      }, onStart:(event, info) => {
        const {drag, dragPropagation, onDragStart} = this.getProps();
        if (drag && !dragPropagation && (this.openDragLock && this.openDragLock(), this.openDragLock = motionDom.setDragLock(drag), !this.openDragLock)) {
          return;
        }
        this.isDragging = !0;
        this.currentDirection = null;
        this.resolveConstraints();
        this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0);
        eachAxis(axis => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            var {projection} = this.visualElement;
            projection && projection.layout && (projection = projection.layout.layoutBox[axis]) && (current = calcLength(projection) * (parseFloat(current) / 100));
          }
          this.originPoint[axis] = current;
        });
        onDragStart && frame.postRender(() => onDragStart(event, info));
        addValueToWillChange(this.visualElement, "transform");
        const {animationState} = this.visualElement;
        animationState && animationState.setActive("whileDrag", !0);
      }, onMove:(event, info) => {
        const {dragPropagation, dragDirectionLock, onDirectionLock, onDrag} = this.getProps();
        if (dragPropagation || this.openDragLock) {
          var {offset} = info;
          dragDirectionLock && null === this.currentDirection ? (this.currentDirection = getCurrentDirection(offset), null !== this.currentDirection && onDirectionLock && onDirectionLock(this.currentDirection)) : (this.updateAxis("x", info.point, offset), this.updateAxis("y", info.point, offset), this.visualElement.render(), onDrag && onDrag(event, info));
        }
      }, onSessionEnd:(event, info) => this.stop(event, info), resumeAnimation:() => eachAxis(axis => {
        var _a;
        return "paused" === this.getAnimationState(axis) && (null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.play());
      })}, {transformPagePoint:this.visualElement.getTransformPagePoint(), dragSnapToOrigin:presenceContext}));
    }
    stop(event, info) {
      var isDragging = this.isDragging;
      this.cancel();
      if (isDragging) {
        ({velocity:isDragging} = info);
        this.startAnimation(isDragging);
        var {onDragEnd} = this.getProps();
        onDragEnd && frame.postRender(() => onDragEnd(event, info));
      }
    }
    cancel() {
      this.isDragging = !1;
      const {projection, animationState} = this.visualElement;
      projection && (projection.isAnimationBlocked = !1);
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const {dragPropagation} = this.getProps();
      !dragPropagation && this.openDragLock && (this.openDragLock(), this.openDragLock = null);
      animationState && animationState.setActive("whileDrag", !1);
    }
    updateAxis(axis, _point, offset) {
      ({drag:_point} = this.getProps());
      offset && shouldDrag(axis, _point, this.currentDirection) && (_point = this.getAxisMotionValue(axis), offset = this.originPoint[axis] + offset[axis], this.constraints && this.constraints[axis] && (offset = applyConstraints(offset, this.constraints[axis], this.elastic[axis])), _point.set(offset));
    }
    resolveConstraints() {
      var _a;
      const {dragConstraints, dragElastic} = this.getProps(), layout$jscomp$0 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (_a = this.visualElement.projection) || void 0 === _a ? void 0 : _a.layout;
      _a = this.constraints;
      dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = dragConstraints && layout$jscomp$0 ? calcRelativeConstraints(layout$jscomp$0.layoutBox, dragConstraints) : !1;
      this.elastic = resolveDragElastic(dragElastic);
      _a !== this.constraints && layout$jscomp$0 && this.constraints && !this.hasMutatedConstraints && eachAxis(axis => {
        if (!1 !== this.constraints && this.getAxisMotionValue(axis)) {
          var JSCompiler_temp_const = this.constraints, layout = layout$jscomp$0.layoutBox[axis], constraints = this.constraints[axis];
          const relativeConstraints = {};
          void 0 !== constraints.min && (relativeConstraints.min = constraints.min - layout.min);
          void 0 !== constraints.max && (relativeConstraints.max = constraints.max - layout.min);
          JSCompiler_temp_const[axis] = relativeConstraints;
        }
      });
    }
    resolveRefConstraints() {
      const {dragConstraints:constraints, onMeasureDragConstraints} = this.getProps();
      if (!constraints || !isRefObject(constraints)) {
        return !1;
      }
      var constraintsElement = constraints.current;
      motionUtils.invariant(null !== constraintsElement, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      var {projection} = this.visualElement;
      if (!projection || !projection.layout) {
        return !1;
      }
      var rootProjectionNode = projection.root, transformPagePoint = this.visualElement.getTransformPagePoint();
      constraintsElement = convertBoundingBoxToBox(transformBoxPoints(constraintsElement.getBoundingClientRect(), transformPagePoint));
      ({scroll:rootProjectionNode} = rootProjectionNode);
      rootProjectionNode && (translateAxis(constraintsElement.x, rootProjectionNode.offset.x), translateAxis(constraintsElement.y, rootProjectionNode.offset.y));
      projection = projection.layout.layoutBox;
      projection = {x:calcViewportAxisConstraints(projection.x, constraintsElement.x), y:calcViewportAxisConstraints(projection.y, constraintsElement.y)};
      onMeasureDragConstraints && (rootProjectionNode = onMeasureDragConstraints(convertBoxToBoundingBox(projection)), this.hasMutatedConstraints = !!rootProjectionNode, rootProjectionNode && (projection = convertBoundingBoxToBox(rootProjectionNode)));
      return projection;
    }
    startAnimation(velocity) {
      const {drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd} = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis(axis => {
        if (shouldDrag(axis, drag, this.currentDirection)) {
          var transition = constraints && constraints[axis] || {};
          dragSnapToOrigin && (transition = {min:0, max:0});
          return this.startAxisValueAnimation(axis, {type:"inertia", velocity:dragMomentum ? velocity[axis] : 0, bounceStiffness:dragElastic ? 200 : 1000000, bounceDamping:dragElastic ? 40 : 10000000, timeConstant:750, restDelta:1, restSpeed:10, ...dragTransition, ...transition});
        }
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
    }
    stopAnimation() {
      eachAxis(axis => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis(axis => {
        var _a;
        return null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.pause();
      });
    }
    getAnimationState(axis) {
      var _a;
      return null === (_a = this.getAxisMotionValue(axis).animation) || void 0 === _a ? void 0 : _a.state;
    }
    getAxisMotionValue(axis) {
      var dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      return (dragKey = props[dragKey]) ? dragKey : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis(axis => {
        var {drag} = this.getProps();
        if (shouldDrag(axis, drag, this.currentDirection)) {
          ({projection:drag} = this.visualElement);
          var axisValue = this.getAxisMotionValue(axis);
          if (drag && drag.layout) {
            const {min, max} = drag.layout.layoutBox[axis];
            axisValue.set(point[axis] - (min + 0.5 * (max - min)));
          }
        }
      });
    }
    scalePositionWithinConstraints() {
      if (this.visualElement.current) {
        var {drag, dragConstraints} = this.getProps(), {projection} = this.visualElement;
        if (isRefObject(dragConstraints) && projection && this.constraints) {
          this.stopAnimation();
          var boxProgress = {x:0, y:0};
          eachAxis(axis => {
            var axisValue = this.getAxisMotionValue(axis);
            if (axisValue && !1 !== this.constraints) {
              axisValue = axisValue.get();
              axisValue = {min:axisValue, max:axisValue};
              var target = this.constraints[axis];
              let origin = 0.5;
              const sourceLength = calcLength(axisValue), targetLength = calcLength(target);
              targetLength > sourceLength ? origin = motionUtils.progress(target.min, target.max - sourceLength, axisValue.min) : sourceLength > targetLength && (origin = motionUtils.progress(axisValue.min, axisValue.max - targetLength, target.min));
              boxProgress[axis] = 1 < origin ? 1 : 0 > origin ? 0 : origin;
            }
          });
          var {transformTemplate} = this.visualElement.getProps();
          this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
          this.resolveConstraints();
          eachAxis(axis => {
            if (shouldDrag(axis, drag, null)) {
              var axisValue = this.getAxisMotionValue(axis), {min, max} = this.constraints[axis];
              axisValue.set(min + (max - min) * boxProgress[axis]);
            }
          });
        }
      }
    }
    addListeners() {
      if (this.visualElement.current) {
        elementDragControls.set(this.visualElement, this);
        var stopPointerListener = addPointerEvent(this.visualElement.current, "pointerdown", event => {
          const {drag, dragListener = !0} = this.getProps();
          drag && dragListener && this.start(event);
        }), measureDragConstraints = () => {
          const {dragConstraints} = this.getProps();
          isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
        }, {projection} = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout());
        frame.read(measureDragConstraints);
        var stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({delta, hasLayoutChanged}) => {
          this.isDragging && hasLayoutChanged && (eachAxis(axis => {
            const motionValue = this.getAxisMotionValue(axis);
            motionValue && (this.originPoint[axis] += delta[axis].translate, motionValue.set(motionValue.get() + delta[axis].translate));
          }), this.visualElement.render());
        });
        return () => {
          stopResizeListener();
          stopPointerListener();
          stopMeasureLayoutListener();
          stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
      }
    }
    getProps() {
      const props = this.visualElement.getProps(), {drag = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = 0.35, dragMomentum = !0} = props;
      return {...props, drag, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum};
    }
  }
  class DragGesture extends Feature {
    constructor(node) {
      super(node);
      this.removeListeners = this.removeGroupControls = motionUtils.noop;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const {dragControls} = this.node.getProps();
      dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls));
      this.removeListeners = this.controls.addListeners() || motionUtils.noop;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  }
  const asyncHandler = handler => (event, info) => {
    handler && frame.postRender(() => handler(event, info));
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = motionUtils.noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {transformPagePoint:this.node.getTransformPagePoint()});
    }
    createPanHandlers() {
      const {onPanSessionStart, onPanStart, onPan, onPanEnd} = this.node.getProps();
      return {onSessionStart:asyncHandler(onPanSessionStart), onStart:asyncHandler(onPanStart), onMove:onPan, onEnd:(event, info) => {
        delete this.session;
        onPanEnd && frame.postRender(() => onPanEnd(event, info));
      }};
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", event => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  }
  const SwitchLayoutGroupContext = React.createContext({});
  class MeasureLayoutWithContext extends React.Component {
    componentDidMount() {
      const {visualElement, layoutGroup, switchLayoutGroup, layoutId} = this.props, {projection} = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      }), projection.setOptions({...projection.options, onExitComplete:() => this.safeToRemove()}));
      globalProjectionState.hasEverUpdated = !0;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const {layoutDependency, visualElement, drag, isPresent} = this.props, projection = visualElement.projection;
      if (!projection) {
        return null;
      }
      projection.isPresent = isPresent;
      drag || prevProps.layoutDependency !== layoutDependency || void 0 === layoutDependency ? projection.willUpdate() : this.safeToRemove();
      prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
        const stack = projection.getStack();
        stack && stack.members.length || this.safeToRemove();
      }));
      return null;
    }
    componentDidUpdate() {
      const {projection} = this.props.visualElement;
      projection && (projection.root.didUpdate(), microtask.postRender(() => {
        !projection.currentAnimation && projection.isLead() && this.safeToRemove();
      }));
    }
    componentWillUnmount() {
      const {visualElement, layoutGroup, switchLayoutGroup:promoteContext} = this.props, {projection} = visualElement;
      projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
    }
    safeToRemove() {
      const {safeToRemove} = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  const defaultScaleCorrectors = {borderRadius:{...correctBorderRadius, applyTo:["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]}, borderTopLeftRadius:correctBorderRadius, borderTopRightRadius:correctBorderRadius, borderBottomLeftRadius:correctBorderRadius, borderBottomRightRadius:correctBorderRadius, boxShadow:{correct:(latest, {treeScale, projectionDelta}) => {
    const shadow = complex.parse(latest);
    if (5 < shadow.length) {
      return latest;
    }
    latest = complex.createTransformer(latest);
    const offset = "number" !== typeof shadow[0] ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x;
    treeScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= treeScale;
    treeScale = xScale + 0.5 * (treeScale - xScale);
    "number" === typeof shadow[2 + offset] && (shadow[2 + offset] /= treeScale);
    "number" === typeof shadow[3 + offset] && (shadow[3 + offset] /= treeScale);
    return latest(shadow);
  }}}, drag = {pan:{Feature:PanGesture}, drag:{Feature:DragGesture, ProjectionNode:HTMLProjectionNode, MeasureLayout}};
  class HoverGesture extends Feature {
    mount() {
      const {current} = this.node;
      current && (this.unmount = motionDom.hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return endEvent => handleHoverEvent(this.node, endEvent, "End");
      }));
    }
    unmount() {
    }
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = !1;
    }
    onFocus() {
      let isFocusVisible = !1;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = !0;
      }
      isFocusVisible && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
    }
    onBlur() {
      this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
    }
    mount() {
      this.unmount = [addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur())].reduce(combineFunctions);
    }
    unmount() {
    }
  }
  class PressGesture extends Feature {
    mount() {
      const {current} = this.node;
      current && (this.unmount = motionDom.press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, {success}) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, {useGlobalTarget:this.node.props.globalTapTarget}));
    }
    unmount() {
    }
  }
  const observerCallbacks = new WeakMap(), observers = new WeakMap(), fireObserverCallback = entry => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  }, fireAllObserverCallbacks = entries => {
    entries.forEach(fireObserverCallback);
  }, thresholdNames = {some:0, all:1};
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.isInView = this.hasEnteredView = !1;
    }
    startObserver() {
      this.unmount();
      const {viewport = {}} = this.node.getProps(), {root, margin:rootMargin, amount = "some", once} = viewport;
      return observeIntersection(this.node.current, {root:root ? root.current : void 0, rootMargin, threshold:"number" === typeof amount ? amount : thresholdNames[amount]}, entry => {
        var {isIntersecting} = entry;
        if (this.isInView !== isIntersecting && (this.isInView = isIntersecting, !once || isIntersecting || !this.hasEnteredView)) {
          isIntersecting && (this.hasEnteredView = !0);
          this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
          var {onViewportEnter, onViewportLeave} = this.node.getProps();
          (isIntersecting = isIntersecting ? onViewportEnter : onViewportLeave) && isIntersecting(entry);
        }
      });
    }
    mount() {
      this.startObserver();
    }
    update() {
      if ("undefined" !== typeof IntersectionObserver) {
        var {props, prevProps} = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
      }
    }
    unmount() {
    }
  }
  const gestureAnimations = {inView:{Feature:InViewFeature}, tap:{Feature:PressGesture}, focus:{Feature:FocusGesture}, hover:{Feature:HoverGesture}}, layout = {layout:{ProjectionNode:HTMLProjectionNode, MeasureLayout}}, motionComponentSymbol = Symbol.for("motionComponentSymbol"), createHtmlRenderState = () => ({style:{}, transform:{}, transformOrigin:{}, vars:{}}), lowercaseSVGElements = "animate circle defs desc ellipse g image line filter marker mask metadata path pattern polygon polyline rect stop switch symbol svg text tspan use view".split(" "), 
  createSvgRenderState = () => ({...createHtmlRenderState(), attrs:{}}), htmlMotionConfig = {useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1, createRenderState:createHtmlRenderState})}, layoutProps = "x y width height cx cy r".split(" "), svgMotionConfig = {useVisualState:makeUseVisualState({scrapeMotionValuesFromProps, createRenderState:createSvgRenderState, onUpdate:({props, prevProps, current, renderState, latestValues}) => {
    if (current) {
      var hasTransform = !!props.drag;
      if (!hasTransform) {
        for (var key$jscomp$0 in latestValues) {
          if (transformProps.has(key$jscomp$0)) {
            hasTransform = !0;
            break;
          }
        }
      }
      if (hasTransform) {
        hasTransform = !prevProps;
        if (prevProps) {
          for (key$jscomp$0 = 0; key$jscomp$0 < layoutProps.length; key$jscomp$0++) {
            const key = layoutProps[key$jscomp$0];
            props[key] !== prevProps[key] && (hasTransform = !0);
          }
        }
        hasTransform && frame.read(() => {
          updateSVGDimensions(current, renderState);
          frame.render(() => {
            buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);
            renderSVG(current, renderState);
          });
        });
      }
    }
  }})}, createDomVisualElement = (Component, options) => isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {allowProjection:Component !== React.Fragment}), createMotionComponent = createMotionComponentFactory({...animations, ...gestureAnimations, ...drag, ...layout}, createDomVisualElement);
  exports.AcceleratedAnimation = AcceleratedAnimation;
  exports.FlatTree = FlatTree;
  exports.HTMLVisualElement = HTMLVisualElement;
  exports.LayoutGroupContext = LayoutGroupContext;
  exports.LazyContext = LazyContext;
  exports.MotionConfigContext = MotionConfigContext;
  exports.MotionContext = MotionContext;
  exports.MotionGlobalConfig = MotionGlobalConfig;
  exports.MotionValue = MotionValue;
  exports.PresenceContext = PresenceContext;
  exports.SVGVisualElement = SVGVisualElement;
  exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;
  exports.VisualElement = VisualElement;
  exports.acceleratedValues = acceleratedValues;
  exports.addDomEvent = addDomEvent;
  exports.addPointerEvent = addPointerEvent;
  exports.addPointerInfo = addPointerInfo;
  exports.addScaleCorrector = addScaleCorrector;
  exports.addUniqueItem = addUniqueItem;
  exports.animateSingleValue = animateSingleValue;
  exports.animateTarget = animateTarget;
  exports.animateValue = function(options) {
    return new MainThreadAnimation(options);
  };
  exports.animateVisualElement = animateVisualElement;
  exports.animations = animations;
  exports.anticipate = anticipate;
  exports.backIn = backIn;
  exports.backInOut = backInOut;
  exports.backOut = backOut;
  exports.browserNumberValueTypes = browserNumberValueTypes;
  exports.buildTransform = buildTransform;
  exports.calcLength = calcLength;
  exports.camelToDash = camelToDash;
  exports.cancelFrame = cancelFrame;
  exports.circIn = circIn;
  exports.circInOut = circInOut;
  exports.circOut = circOut;
  exports.clamp = clamp;
  exports.collectMotionValues = collectMotionValues;
  exports.color = color;
  exports.complex = complex;
  exports.createBox = createBox;
  exports.createDomVisualElement = createDomVisualElement;
  exports.createMotionComponent = createMotionComponent;
  exports.createMotionComponentFactory = createMotionComponentFactory;
  exports.createRendererMotionComponent = createRendererMotionComponent;
  exports.cubicBezier = cubicBezier;
  exports.defaultOffset = defaultOffset;
  exports.delay = delay;
  exports.distance = (a, b) => Math.abs(a - b);
  exports.distance2D = distance2D;
  exports.drag = drag;
  exports.easeIn = easeIn;
  exports.easeInOut = easeInOut;
  exports.easeOut = easeOut;
  exports.easingDefinitionToFunction = easingDefinitionToFunction;
  exports.fillOffset = fillOffset;
  exports.filterProps = filterProps;
  exports.findSpring = findSpring;
  exports.frame = frame;
  exports.frameData = frameData;
  exports.frameSteps = frameSteps;
  exports.gestureAnimations = gestureAnimations;
  exports.getFinalKeyframe = getFinalKeyframe;
  exports.getOptimisedAppearId = getOptimisedAppearId;
  exports.hasReducedMotionListener = hasReducedMotionListener;
  exports.inertia = inertia;
  exports.initPrefersReducedMotion = initPrefersReducedMotion;
  exports.instantAnimationState = instantAnimationState;
  exports.interpolate = interpolate;
  exports.isBrowser = isBrowser;
  exports.isEasingArray = isEasingArray;
  exports.isMotionValue = isMotionValue;
  exports.isSVGElement = isSVGElement;
  exports.isValidMotionProp = isValidMotionProp;
  exports.keyframes = keyframes;
  exports.layout = layout;
  exports.loadExternalIsValidProp = loadExternalIsValidProp;
  exports.loadFeatures = loadFeatures;
  exports.makeUseVisualState = makeUseVisualState;
  exports.mirrorEasing = mirrorEasing;
  exports.mix = mix;
  exports.mixNumber = mixNumber$1;
  exports.motionComponentSymbol = motionComponentSymbol;
  exports.motionValue = motionValue;
  exports.moveItem = function([...arr], fromIndex, toIndex) {
    const startIndex = 0 > fromIndex ? arr.length + fromIndex : fromIndex;
    0 <= startIndex && startIndex < arr.length && (toIndex = 0 > toIndex ? arr.length + toIndex : toIndex, [fromIndex] = arr.splice(fromIndex, 1), arr.splice(toIndex, 0, fromIndex));
    return arr;
  };
  exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;
  exports.optimizedAppearDataId = "framerAppearId";
  exports.pipe = (...transformers) => transformers.reduce(combineFunctions);
  exports.prefersReducedMotion = prefersReducedMotion;
  exports.px = px;
  exports.removeItem = removeItem;
  exports.resolveMotionValue = resolveMotionValue;
  exports.reverseEasing = reverseEasing;
  exports.rootProjectionNode = rootProjectionNode;
  exports.setTarget = setTarget;
  exports.spring = spring;
  exports.startWaapiAnimation = startWaapiAnimation;
  exports.stepsOrder = stepsOrder;
  exports.supportsWaapi = supportsWaapi;
  exports.time = time;
  exports.transformProps = transformProps;
  exports.useConstant = useConstant;
  exports.useIsPresent = function() {
    var context = React.useContext(PresenceContext);
    return null === context ? !0 : context.isPresent;
  };
  exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
  exports.usePresence = usePresence;
  exports.velocityPerSecond = velocityPerSecond;
  exports.visualElementStore = visualElementStore;
  exports.warnOnce = warnOnce;
};

//# sourceMappingURL=module$node_modules$framer_motion$dist$cjs$create_CGKJurkh.js.map
