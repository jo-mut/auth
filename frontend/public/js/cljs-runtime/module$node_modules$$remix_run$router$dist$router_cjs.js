shadow$provide.module$node_modules$$remix_run$router$dist$router_cjs = function(global, require, module, exports) {
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i], key;
        for (key in source) {
          Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function invariant(value, message) {
    if (!1 === value || null === value || "undefined" === typeof value) {
      throw Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      "undefined" !== typeof console && console.warn(message);
      try {
        throw Error(message);
      } catch (e) {
      }
    }
  }
  function createLocation(current, to, state, key) {
    void 0 === state && (state = null);
    return _extends({pathname:"string" === typeof current ? current : current.pathname, search:"", hash:""}, "string" === typeof to ? parsePath(to) : to, {state, key:to && to.key || key || Math.random().toString(36).substr(2, 8)});
  }
  function createPath(_ref) {
    let {pathname = "/", search = "", hash = ""} = _ref;
    search && "?" !== search && (pathname += "?" === search.charAt(0) ? search : "?" + search);
    hash && "#" !== hash && (pathname += "#" === hash.charAt(0) ? hash : "#" + hash);
    return pathname;
  }
  function parsePath(path) {
    let parsedPath = {};
    if (path) {
      var hashIndex = path.indexOf("#");
      0 <= hashIndex && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
      hashIndex = path.indexOf("?");
      0 <= hashIndex && (parsedPath.search = path.substr(hashIndex), path = path.substr(0, hashIndex));
      path && (parsedPath.pathname = path);
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
    function getIndex() {
      return (globalHistory.state || {idx:null}).idx;
    }
    function handlePop() {
      action = Action.Pop;
      let nextIndex = getIndex(), delta = null == nextIndex ? null : nextIndex - index;
      index = nextIndex;
      listener && listener({action, location:history.location, delta});
    }
    function createURL(to) {
      let base = "null" !== window.location.origin ? window.location.origin : window.location.href;
      to = "string" === typeof to ? to : createPath(to);
      to = to.replace(/ $/, "%20");
      invariant(base, "No window.location.(origin|href) available to create URL for href: " + to);
      return new URL(to, base);
    }
    void 0 === options && (options = {});
    let {window = document.defaultView, v5Compat = !1} = options, globalHistory = window.history, action = Action.Pop, listener = null, index = getIndex();
    null == index && (index = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {idx:index}), ""));
    let history = {get action() {
      return action;
    }, get location() {
      return getLocation(window, globalHistory);
    }, listen(fn) {
      if (listener) {
        throw Error("A history only accepts one active listener");
      }
      window.addEventListener("popstate", handlePop);
      listener = fn;
      return () => {
        window.removeEventListener("popstate", handlePop);
        listener = null;
      };
    }, createHref(to) {
      return createHref(window, to);
    }, createURL, encodeLocation(to) {
      to = createURL(to);
      return {pathname:to.pathname, search:to.search, hash:to.hash};
    }, push:function(to, state) {
      action = Action.Push;
      state = createLocation(history.location, to, state);
      validateLocation && validateLocation(state, to);
      index = getIndex() + 1;
      to = {usr:state.state, key:state.key, idx:index};
      state = history.createHref(state);
      try {
        globalHistory.pushState(to, "", state);
      } catch (error) {
        if (error instanceof DOMException && "DataCloneError" === error.name) {
          throw error;
        }
        window.location.assign(state);
      }
      v5Compat && listener && listener({action, location:history.location, delta:1});
    }, replace:function(to, state) {
      action = Action.Replace;
      state = createLocation(history.location, to, state);
      validateLocation && validateLocation(state, to);
      index = getIndex();
      to = {usr:state.state, key:state.key, idx:index};
      state = history.createHref(state);
      globalHistory.replaceState(to, "", state);
      v5Compat && listener && listener({action, location:history.location, delta:0});
    }, go(n) {
      return globalHistory.go(n);
    }};
    return history;
  }
  function convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {
    void 0 === parentPath && (parentPath = []);
    void 0 === manifest && (manifest = {});
    return routes.map((route, index) => {
      let treePath = [...parentPath, String(index)];
      index = "string" === typeof route.id ? route.id : treePath.join("-");
      invariant(!0 !== route.index || !route.children, "Cannot specify children on an index route");
      invariant(!manifest[index], 'Found a route id collision on id "' + index + "\".  Route id's must be globally unique within Data Router usages");
      if (!0 === route.index) {
        return route = _extends({}, route, mapRouteProperties(route), {id:index}), manifest[index] = route;
      }
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {id:index, children:void 0});
      manifest[index] = pathOrLayoutRoute;
      route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest));
      return pathOrLayoutRoute;
    });
  }
  function matchRoutes(routes, locationArg, basename) {
    void 0 === basename && (basename = "/");
    return matchRoutesImpl(routes, locationArg, basename, !1);
  }
  function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
    locationArg = "string" === typeof locationArg ? parsePath(locationArg) : locationArg;
    basename = stripBasename(locationArg.pathname || "/", basename);
    if (null == basename) {
      return null;
    }
    routes = flattenRoutes(routes);
    rankRouteBranches(routes);
    var matches = null;
    for (locationArg = 0; null == matches && locationArg < routes.length; ++locationArg) {
      matches = decodePath(basename);
      a: {
        var branch = routes[locationArg], allowPartial$jscomp$0 = allowPartial;
        void 0 === allowPartial$jscomp$0 && (allowPartial$jscomp$0 = !1);
        ({routesMeta:branch} = branch);
        let matchedParams = {}, matchedPathname = "/", matches$jscomp$0 = [];
        for (let i = 0; i < branch.length; ++i) {
          let meta = branch[i], end = i === branch.length - 1, remainingPathname = "/" === matchedPathname ? matches : matches.slice(matchedPathname.length) || "/", match = matchPath({path:meta.relativePath, caseSensitive:meta.caseSensitive, end}, remainingPathname), route = meta.route;
          !match && end && allowPartial$jscomp$0 && !branch[branch.length - 1].route.index && (match = matchPath({path:meta.relativePath, caseSensitive:meta.caseSensitive, end:!1}, remainingPathname));
          if (!match) {
            matches = null;
            break a;
          }
          Object.assign(matchedParams, match.params);
          matches$jscomp$0.push({params:matchedParams, pathname:joinPaths([matchedPathname, match.pathname]), pathnameBase:normalizePathname(joinPaths([matchedPathname, match.pathnameBase])), route});
          "/" !== match.pathnameBase && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
        }
        matches = matches$jscomp$0;
      }
    }
    return matches;
  }
  function convertRouteMatchToUiMatch(match, loaderData) {
    let {route, pathname, params} = match;
    return {id:route.id, pathname, params, data:loaderData[route.id], handle:route.handle};
  }
  function flattenRoutes(routes, branches, parentsMeta, parentPath) {
    void 0 === branches && (branches = []);
    void 0 === parentsMeta && (parentsMeta = []);
    void 0 === parentPath && (parentPath = "");
    let flattenRoute = (route, index, relativePath) => {
      relativePath = {relativePath:void 0 === relativePath ? route.path || "" : relativePath, caseSensitive:!0 === route.caseSensitive, childrenIndex:index, route};
      relativePath.relativePath.startsWith("/") && (invariant(relativePath.relativePath.startsWith(parentPath), 'Absolute route path "' + relativePath.relativePath + '" nested under path "' + (parentPath + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.')), relativePath.relativePath = relativePath.relativePath.slice(parentPath.length));
      index = joinPaths([parentPath, relativePath.relativePath]);
      relativePath = parentsMeta.concat(relativePath);
      route.children && 0 < route.children.length && (invariant(!0 !== route.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + (index + '".')), flattenRoutes(route.children, branches, relativePath, index));
      (null != route.path || route.index) && branches.push({path:index, score:computeScore(index, route.index), routesMeta:relativePath});
    };
    routes.forEach((route, index) => {
      var _route$path;
      if ("" !== route.path && null != (_route$path = route.path) && _route$path.includes("?")) {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index, exploded);
        }
      } else {
        flattenRoute(route, index);
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path) {
    var segments = path.split("/");
    if (0 === segments.length) {
      return [];
    }
    let [first, ...rest] = segments;
    segments = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (0 === rest.length) {
      return segments ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/")), result = [];
    result.push(...restExploded.map(subpath => "" === subpath ? required : [required, subpath].join("/")));
    segments && result.push(...restExploded);
    return result.map(exploded => path.startsWith("/") && "" === exploded ? "/" : exploded);
  }
  function rankRouteBranches(branches) {
    branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
  }
  function computeScore(path, index) {
    path = path.split("/");
    let initialScore = path.length;
    path.some(isSplat) && (initialScore += -2);
    index && (initialScore += 2);
    return path.filter(s => "*" !== s).reduce((score, segment) => score + (paramRe.test(segment) ? 3 : "" === segment ? 1 : 10), initialScore);
  }
  function compareIndexes(a, b) {
    return a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]) ? a[a.length - 1] - b[b.length - 1] : 0;
  }
  function matchPath(pattern, pathname) {
    "string" === typeof pattern && (pattern = {path:pattern, caseSensitive:!1, end:!0});
    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
    pathname = pathname.match(matcher);
    if (!pathname) {
      return null;
    }
    let matchedPathname = pathname[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = pathname.slice(1);
    return {params:compiledParams.reduce((memo, _ref, index) => {
      let {paramName, isOptional} = _ref;
      "*" === paramName && (pathnameBase = matchedPathname.slice(0, matchedPathname.length - (captureGroups[index] || "").length).replace(/(.)\/+$/, "$1"));
      _ref = captureGroups[index];
      memo[paramName] = isOptional && !_ref ? void 0 : (_ref || "").replace(/%2F/g, "/");
      return memo;
    }, {}), pathname:matchedPathname, pathnameBase, pattern};
  }
  function compilePath(path, caseSensitive, end) {
    void 0 === caseSensitive && (caseSensitive = !1);
    void 0 === end && (end = !0);
    warning("*" === path || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were "' + (path.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "') + (path.replace(/\*$/, "/*") + '".'));
    let params = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$\x26").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
      params.push({paramName, isOptional:null != isOptional});
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    });
    path.endsWith("*") ? (params.push({paramName:"*"}), regexpSource += "*" === path || "/*" === path ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end ? regexpSource += "\\/*$" : "" !== path && "/" !== path && (regexpSource += "(?:(?\x3d\\/|$))");
    return [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), params];
  }
  function decodePath(value) {
    try {
      return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
    } catch (error) {
      return warning(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + (error + ").")), value;
    }
  }
  function stripBasename(pathname, basename) {
    if ("/" === basename) {
      return pathname;
    }
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    basename = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(basename);
    return nextChar && "/" !== nextChar ? null : pathname.slice(basename) || "/";
  }
  function resolvePath(to, fromPathname) {
    void 0 === fromPathname && (fromPathname = "/");
    let {pathname:toPathname, search = "", hash = ""} = "string" === typeof to ? parsePath(to) : to;
    to = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    fromPathname = search && "?" !== search ? search.startsWith("?") ? search : "?" + search : "";
    var JSCompiler_inline_result = hash && "#" !== hash ? hash.startsWith("#") ? hash : "#" + hash : "";
    return {pathname:to, search:fromPathname, hash:JSCompiler_inline_result};
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    relativePath.split("/").forEach(segment => {
      ".." === segment ? 1 < segments.length && segments.pop() : "." !== segment && segments.push(segment);
    });
    return 1 < segments.length ? segments.join("/") : "/";
  }
  function getInvalidPathError(char, field, dest, path) {
    return "Cannot include a '" + char + "' character in a manually specified `to." + (field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the `to.") + (dest + '` field. Alternatively you may provide the full path as a string in \x3cLink to\x3d"..."\x3e and the router will parse it for you.');
  }
  function getPathContributingMatches(matches) {
    return matches.filter((match, index) => 0 === index || match.route.path && 0 < match.route.path.length);
  }
  function getResolveToMatches(matches, v7_relativeSplatPath) {
    let pathMatches = getPathContributingMatches(matches);
    return v7_relativeSplatPath ? pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase) : pathMatches.map(match => match.pathnameBase);
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
    void 0 === isPathRelative && (isPathRelative = !1);
    if ("string" === typeof toArg) {
      var to = parsePath(toArg);
    } else {
      to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
    }
    let toPathname = (toArg = "" === toArg || "" === to.pathname) ? "/" : to.pathname;
    if (null == toPathname) {
      routePathnames = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        for (isPathRelative = toPathname.split("/"); ".." === isPathRelative[0];) {
          isPathRelative.shift(), --routePathnameIndex;
        }
        to.pathname = isPathRelative.join("/");
      }
      routePathnames = 0 <= routePathnameIndex ? routePathnames[routePathnameIndex] : "/";
    }
    to = resolvePath(to, routePathnames);
    routePathnames = toPathname && "/" !== toPathname && toPathname.endsWith("/");
    locationPathname = (toArg || "." === toPathname) && locationPathname.endsWith("/");
    to.pathname.endsWith("/") || !routePathnames && !locationPathname || (to.pathname += "/");
    return to;
  }
  function isRouteErrorResponse(error) {
    return null != error && "number" === typeof error.status && "string" === typeof error.statusText && "boolean" === typeof error.internal && "data" in error;
  }
  function throwStaticHandlerAbortedError(request, isRouteRequest, future) {
    if (future.v7_throwAbortReason && void 0 !== request.signal.reason) {
      throw request.signal.reason;
    }
    throw Error((isRouteRequest ? "queryRoute" : "query") + "() call aborted: " + request.method + " " + request.url);
  }
  function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
    let contextualMatches;
    if (fromRouteId) {
      contextualMatches = [];
      for (let match of matches) {
        if (contextualMatches.push(match), match.route.id === fromRouteId) {
          var activeRouteMatch = match;
          break;
        }
      }
    } else {
      contextualMatches = matches, activeRouteMatch = matches[matches.length - 1];
    }
    matches = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, "path" === relative);
    null == to && (matches.search = location.search, matches.hash = location.hash);
    if ((null == to || "" === to || "." === to) && activeRouteMatch) {
      if (location = hasNakedIndexQuery(matches.search), activeRouteMatch.route.index && !location) {
        matches.search = matches.search ? matches.search.replace(/^\?/, "?index\x26") : "?index";
      } else if (!activeRouteMatch.route.index && location) {
        let params = new URLSearchParams(matches.search);
        activeRouteMatch = params.getAll("index");
        params.delete("index");
        activeRouteMatch.filter(v => v).forEach(v => params.append("index", v));
        activeRouteMatch = params.toString();
        matches.search = activeRouteMatch ? "?" + activeRouteMatch : "";
      }
    }
    prependBasename && "/" !== basename && (matches.pathname = "/" === matches.pathname ? basename : joinPaths([basename, matches.pathname]));
    return createPath(matches);
  }
  function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
    if (!opts || null == opts || !("formData" in opts && null != opts.formData || "body" in opts && void 0 !== opts.body)) {
      return {path};
    }
    if (opts.formMethod && !validRequestMethods.has(opts.formMethod.toLowerCase())) {
      return {path, error:getInternalRouterError(405, {method:opts.formMethod})};
    }
    var getInvalidBodyError = () => ({path, error:getInternalRouterError(400, {type:"invalid-body"})}), rawFormMethod = opts.formMethod || "get";
    normalizeFormMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
    rawFormMethod = stripHashFromPath(path);
    if (void 0 !== opts.body) {
      if ("text/plain" === opts.formEncType) {
        if (!isMutationMethod(normalizeFormMethod)) {
          return getInvalidBodyError();
        }
        isFetcher = "string" === typeof opts.body ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name, value] = _ref3;
          return "" + acc + name + "\x3d" + value + "\n";
        }, "") : String(opts.body);
        return {path, submission:{formMethod:normalizeFormMethod, formAction:rawFormMethod, formEncType:opts.formEncType, formData:void 0, json:void 0, text:isFetcher}};
      }
      if ("application/json" === opts.formEncType) {
        if (!isMutationMethod(normalizeFormMethod)) {
          return getInvalidBodyError();
        }
        try {
          let json = "string" === typeof opts.body ? JSON.parse(opts.body) : opts.body;
          return {path, submission:{formMethod:normalizeFormMethod, formAction:rawFormMethod, formEncType:opts.formEncType, formData:void 0, json, text:void 0}};
        } catch (e) {
          return getInvalidBodyError();
        }
      }
    }
    invariant("function" === typeof FormData, "FormData is not available in this environment");
    let searchParams, formData;
    if (opts.formData) {
      searchParams = convertFormDataToSearchParams(opts.formData), formData = opts.formData;
    } else if (opts.body instanceof FormData) {
      searchParams = convertFormDataToSearchParams(opts.body), formData = opts.body;
    } else if (opts.body instanceof URLSearchParams) {
      searchParams = opts.body, formData = convertSearchParamsToFormData(searchParams);
    } else if (null == opts.body) {
      searchParams = new URLSearchParams(), formData = new FormData();
    } else {
      try {
        searchParams = new URLSearchParams(opts.body), formData = convertSearchParamsToFormData(searchParams);
      } catch (e) {
        return getInvalidBodyError();
      }
    }
    opts = {formMethod:normalizeFormMethod, formAction:rawFormMethod, formEncType:opts && opts.formEncType || "application/x-www-form-urlencoded", formData, json:void 0, text:void 0};
    if (isMutationMethod(opts.formMethod)) {
      return {path, submission:opts};
    }
    getInvalidBodyError = parsePath(path);
    isFetcher && getInvalidBodyError.search && hasNakedIndexQuery(getInvalidBodyError.search) && searchParams.append("index", "");
    getInvalidBodyError.search = "?" + searchParams;
    return {path:createPath(getInvalidBodyError), submission:opts};
  }
  function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {
    void 0 === includeBoundary && (includeBoundary = !1);
    let index = matches.findIndex(m => m.route.id === boundaryId);
    return 0 <= index ? matches.slice(0, includeBoundary ? index + 1 : index) : matches;
  }
  function getMatchesToLoad(history, state, matches, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location);
    history = matches;
    initialHydration && state.errors ? history = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], !0) : pendingActionResult && isErrorResult(pendingActionResult[1]) && (history = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]));
    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0, shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && 400 <= actionStatus;
    skipActionErrorRevalidation = history.filter((match, index) => {
      let {route} = match;
      if (route.lazy) {
        return !0;
      }
      if (null == route.loader) {
        return !1;
      }
      if (initialHydration) {
        return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
      }
      if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
        return !0;
      }
      index = state.matches[index];
      return shouldRevalidateLoader(match, _extends({currentUrl, currentParams:index.params, nextUrl, nextParams:match.params}, submission, {actionResult, actionStatus, defaultShouldRevalidate:shouldSkipRevalidation ? !1 : isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || currentUrl.search !== nextUrl.search || isNewRouteInstance(index, match)}));
    });
    let revalidatingFetchers = [];
    fetchLoadMatches.forEach((f, key) => {
      if (!initialHydration && matches.some(m => m.route.id === f.routeId) && !deletedFetchers.has(key)) {
        var fetcherMatches = matchRoutes(routesToUse, f.path, basename);
        if (fetcherMatches) {
          var fetcher = state.fetchers.get(key), fetcherMatch = getTargetMatch(fetcherMatches, f.path), shouldRevalidate = !1;
          fetchRedirectIds.has(key) ? shouldRevalidate = !1 : cancelledFetcherLoads.has(key) ? (cancelledFetcherLoads.delete(key), shouldRevalidate = !0) : shouldRevalidate = fetcher && "idle" !== fetcher.state && void 0 === fetcher.data ? isRevalidationRequired : shouldRevalidateLoader(fetcherMatch, _extends({currentUrl, currentParams:state.matches[state.matches.length - 1].params, nextUrl, nextParams:matches[matches.length - 1].params}, submission, {actionResult, actionStatus, defaultShouldRevalidate:shouldSkipRevalidation ? 
          !1 : isRevalidationRequired}));
          shouldRevalidate && revalidatingFetchers.push({key, routeId:f.routeId, path:f.path, matches:fetcherMatches, match:fetcherMatch, controller:new AbortController()});
        } else {
          revalidatingFetchers.push({key, routeId:f.routeId, path:f.path, matches:null, match:null, controller:null});
        }
      }
    });
    return [skipActionErrorRevalidation, revalidatingFetchers];
  }
  function shouldLoadRouteOnHydration(route, loaderData, errors) {
    if (route.lazy) {
      return !0;
    }
    if (!route.loader) {
      return !1;
    }
    loaderData = null != loaderData && void 0 !== loaderData[route.id];
    errors = null != errors && void 0 !== errors[route.id];
    return !loaderData && errors ? !1 : "function" === typeof route.loader && !0 === route.loader.hydrate ? !0 : !loaderData && !errors;
  }
  function isNewLoader(currentLoaderData, currentMatch, match) {
    currentLoaderData = void 0 === currentLoaderData[match.route.id];
    return !currentMatch || match.route.id !== currentMatch.route.id || currentLoaderData;
  }
  function isNewRouteInstance(currentMatch, match) {
    let currentPath = currentMatch.route.path;
    return currentMatch.pathname !== match.pathname || null != currentPath && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"];
  }
  function shouldRevalidateLoader(loaderMatch, arg) {
    return loaderMatch.route.shouldRevalidate && (loaderMatch = loaderMatch.route.shouldRevalidate(arg), "boolean" === typeof loaderMatch) ? loaderMatch : arg.defaultShouldRevalidate;
  }
  function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties) {
    var _childrenToPatch;
    let childrenToPatch;
    routeId ? (routesToUse = manifest[routeId], invariant(routesToUse, "No route found to patch children into: routeId \x3d " + routeId), routesToUse.children || (routesToUse.children = []), childrenToPatch = routesToUse.children) : childrenToPatch = routesToUse;
    children = children.filter(newRoute => !childrenToPatch.some(existingRoute => isSameRoute(newRoute, existingRoute)));
    routeId = convertRoutesToDataRoutes(children, mapRouteProperties, [routeId || "_", "patch", String((null == (_childrenToPatch = childrenToPatch) ? void 0 : _childrenToPatch.length) || "0")], manifest);
    childrenToPatch.push(...routeId);
  }
  function isSameRoute(newRoute, existingRoute) {
    return "id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id ? !0 : newRoute.index !== existingRoute.index || newRoute.path !== existingRoute.path || newRoute.caseSensitive !== existingRoute.caseSensitive ? !1 : newRoute.children && 0 !== newRoute.children.length || existingRoute.children && 0 !== existingRoute.children.length ? newRoute.children.every((aChild, i) => {
      var _existingRoute$childr;
      return null == (_existingRoute$childr = existingRoute.children) ? void 0 : _existingRoute$childr.some(bChild => isSameRoute(aChild, bChild));
    }) : !0;
  }
  async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
    if (route.lazy) {
      var lazyRoute = await route.lazy();
      if (route.lazy) {
        route = manifest[route.id];
        invariant(route, "No route found in manifest");
        manifest = {};
        for (let lazyRouteProperty in lazyRoute) {
          let isPropertyStaticallyDefined = void 0 !== route[lazyRouteProperty] && "hasErrorBoundary" !== lazyRouteProperty;
          warning(!isPropertyStaticallyDefined, 'Route "' + route.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. The lazy route property "' + (lazyRouteProperty + '" will be ignored.'));
          isPropertyStaticallyDefined || immutableRouteKeys.has(lazyRouteProperty) || (manifest[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
        }
        Object.assign(route, manifest);
        Object.assign(route, _extends({}, mapRouteProperties(route), {lazy:void 0}));
      }
    }
  }
  async function defaultDataStrategy(_ref4) {
    ({matches:_ref4} = _ref4);
    let matchesToLoad = _ref4.filter(m => m.shouldLoad);
    return (await Promise.all(matchesToLoad.map(m => m.resolve()))).reduce((acc, result, i) => Object.assign(acc, {[matchesToLoad[i].route.id]:result}), {});
  }
  async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties, requestContext) {
    let loadRouteDefinitionsPromises = matches.map(m => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties, manifest) : void 0);
    state = matches.map((match, i) => {
      let loadRoutePromise = loadRouteDefinitionsPromises[i], shouldLoad = matchesToLoad.some(m => m.route.id === match.route.id);
      return _extends({}, match, {shouldLoad, resolve:async handlerOverride => {
        handlerOverride && "GET" === request.method && (match.route.lazy || match.route.loader) && (shouldLoad = !0);
        return shouldLoad ? callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({type:ResultType.data, result:void 0});
      }});
    });
    dataStrategyImpl = await dataStrategyImpl({matches:state, request, params:matches[0].params, fetcherKey, context:requestContext});
    try {
      await Promise.all(loadRouteDefinitionsPromises);
    } catch (e) {
    }
    return dataStrategyImpl;
  }
  async function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {
    let result, onReject, runHandler = handler => {
      let reject, abortPromise = new Promise((_, r) => reject = r);
      onReject = () => reject();
      request.signal.addEventListener("abort", onReject);
      let actualHandler = ctx => "function" !== typeof handler ? Promise.reject(Error('You cannot call the handler for a route which defines a boolean "' + (type + '" [routeId: ' + match.route.id + "]"))) : handler({request, params:match.params, context:staticContext}, ...(void 0 !== ctx ? [ctx] : [])), handlerPromise = (async() => {
        try {
          return {type:"data", result:await (handlerOverride ? handlerOverride(ctx => actualHandler(ctx)) : actualHandler())};
        } catch (e) {
          return {type:"error", result:e};
        }
      })();
      return Promise.race([handlerPromise, abortPromise]);
    };
    try {
      let handler = match.route[type];
      if (loadRoutePromise) {
        if (handler) {
          let handlerError, [value] = await Promise.all([runHandler(handler).catch(e => {
            handlerError = e;
          }), loadRoutePromise]);
          if (void 0 !== handlerError) {
            throw handlerError;
          }
          result = value;
        } else {
          if (await loadRoutePromise, handler = match.route[type]) {
            result = await runHandler(handler);
          } else {
            if ("action" === type) {
              let url = new URL(request.url);
              throw getInternalRouterError(405, {method:request.method, pathname:url.pathname + url.search, routeId:match.route.id});
            }
            return {type:ResultType.data, result:void 0};
          }
        }
      } else if (handler) {
        result = await runHandler(handler);
      } else {
        let url = new URL(request.url);
        throw getInternalRouterError(404, {pathname:url.pathname + url.search});
      }
      invariant(void 0 !== result.result, "You defined " + ("action" === type ? "an action" : "a loader") + ' for route "' + (match.route.id + "\" but didn't return anything from your `" + type + "` function. Please return a value or `null`."));
    } catch (e) {
      return {type:ResultType.error, result:e};
    } finally {
      onReject && request.signal.removeEventListener("abort", onReject);
    }
    return result;
  }
  async function convertDataStrategyResultToDataResult(dataStrategyResult) {
    let {result, type} = dataStrategyResult;
    if (isResponse(result)) {
      let data;
      try {
        let contentType = result.headers.get("Content-Type");
        data = contentType && /\bapplication\/json\b/.test(contentType) ? null == result.body ? null : await result.json() : await result.text();
      } catch (e) {
        return {type:ResultType.error, error:e};
      }
      return type === ResultType.error ? {type:ResultType.error, error:new ErrorResponseImpl(result.status, result.statusText, data), statusCode:result.status, headers:result.headers} : {type:ResultType.data, data, statusCode:result.status, headers:result.headers};
    }
    if (type === ResultType.error) {
      if (isDataWithResponseInit(result)) {
        var _result$init3, _result$init4;
        if (result.data instanceof Error) {
          var _result$init, _result$init2;
          return {type:ResultType.error, error:result.data, statusCode:null == (_result$init = result.init) ? void 0 : _result$init.status, headers:null != (_result$init2 = result.init) && _result$init2.headers ? new Headers(result.init.headers) : void 0};
        }
        return {type:ResultType.error, error:new ErrorResponseImpl((null == (_result$init3 = result.init) ? void 0 : _result$init3.status) || 500, void 0, result.data), statusCode:isRouteErrorResponse(result) ? result.status : void 0, headers:null != (_result$init4 = result.init) && _result$init4.headers ? new Headers(result.init.headers) : void 0};
      }
      return {type:ResultType.error, error:result, statusCode:isRouteErrorResponse(result) ? result.status : void 0};
    }
    if (isDeferredData(result)) {
      var _result$init5, _result$init6;
      return {type:ResultType.deferred, deferredData:result, statusCode:null == (_result$init5 = result.init) ? void 0 : _result$init5.status, headers:(null == (_result$init6 = result.init) ? void 0 : _result$init6.headers) && new Headers(result.init.headers)};
    }
    if (isDataWithResponseInit(result)) {
      var _result$init7, _result$init8;
      return {type:ResultType.data, data:result.data, statusCode:null == (_result$init7 = result.init) ? void 0 : _result$init7.status, headers:null != (_result$init8 = result.init) && _result$init8.headers ? new Headers(result.init.headers) : void 0};
    }
    return {type:ResultType.data, data:result};
  }
  function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
    let location = response.headers.get("Location");
    invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
    ABSOLUTE_URL_REGEX.test(location) || (matches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1), location = normalizeTo(new URL(request.url), matches, basename, !0, location, v7_relativeSplatPath), response.headers.set("Location", location));
    return response;
  }
  function normalizeRedirectLocation(location, currentUrl, basename) {
    if (ABSOLUTE_URL_REGEX.test(location)) {
      let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
      basename = null != stripBasename(url.pathname, basename);
      if (url.origin === currentUrl.origin && basename) {
        return url.pathname + url.search + url.hash;
      }
    }
    return location;
  }
  function createClientSideRequest(history, location, signal, submission) {
    history = history.createURL(stripHashFromPath(location)).toString();
    signal = {signal};
    if (submission && isMutationMethod(submission.formMethod)) {
      let {formMethod, formEncType} = submission;
      signal.method = formMethod.toUpperCase();
      "application/json" === formEncType ? (signal.headers = new Headers({"Content-Type":formEncType}), signal.body = JSON.stringify(submission.json)) : signal.body = "text/plain" === formEncType ? submission.text : "application/x-www-form-urlencoded" === formEncType && submission.formData ? convertFormDataToSearchParams(submission.formData) : submission.formData;
    }
    return new Request(history, signal);
  }
  function convertFormDataToSearchParams(formData) {
    let searchParams = new URLSearchParams();
    for (let [key, value] of formData.entries()) {
      searchParams.append(key, "string" === typeof value ? value : value.name);
    }
    return searchParams;
  }
  function convertSearchParamsToFormData(searchParams) {
    let formData = new FormData();
    for (let [key, value] of searchParams.entries()) {
      formData.append(key, value);
    }
    return formData;
  }
  function processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
    let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {}, pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
    matches.forEach(match => {
      if (match.route.id in results) {
        match = match.route.id;
        var result = results[match];
        invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
        if (isErrorResult(result)) {
          let error = result.error;
          void 0 !== pendingError && (error = pendingError, pendingError = void 0);
          errors = errors || {};
          if (skipLoaderErrorBubbling) {
            errors[match] = error;
          } else {
            let boundaryMatch = findNearestBoundary(matches, match);
            null == errors[boundaryMatch.route.id] && (errors[boundaryMatch.route.id] = error);
          }
          loaderData[match] = void 0;
          foundError || (foundError = !0, statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500);
        } else {
          isDeferredResult(result) ? (activeDeferreds.set(match, result.deferredData), loaderData[match] = result.deferredData.data, null == result.statusCode || 200 === result.statusCode || foundError || (statusCode = result.statusCode)) : (loaderData[match] = result.data, result.statusCode && 200 !== result.statusCode && !foundError && (statusCode = result.statusCode));
        }
        result.headers && (loaderHeaders[match] = result.headers);
      }
    });
    void 0 !== pendingError && pendingActionResult && (errors = {[pendingActionResult[0]]:pendingError}, loaderData[pendingActionResult[0]] = void 0);
    return {loaderData, errors, statusCode:statusCode || 200, loaderHeaders};
  }
  function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
    let {loaderData, errors} = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, !1);
    revalidatingFetchers.forEach(rf => {
      let {key, match, controller} = rf;
      rf = fetcherResults[key];
      invariant(rf, "Did not find corresponding fetcher result");
      if (!controller || !controller.signal.aborted) {
        if (isErrorResult(rf)) {
          let boundaryMatch = findNearestBoundary(state.matches, null == match ? void 0 : match.route.id);
          errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {[boundaryMatch.route.id]:rf.error}));
          state.fetchers.delete(key);
        } else {
          isRedirectResult(rf) ? invariant(!1, "Unhandled fetcher revalidation redirect") : isDeferredResult(rf) ? invariant(!1, "Unhandled fetcher deferred data") : (rf = getDoneFetcher(rf.data), state.fetchers.set(key, rf));
        }
      }
    });
    return {loaderData, errors};
  }
  function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
    let mergedLoaderData = _extends({}, newLoaderData);
    for (let match of matches) {
      if (matches = match.route.id, newLoaderData.hasOwnProperty(matches) ? void 0 !== newLoaderData[matches] && (mergedLoaderData[matches] = newLoaderData[matches]) : void 0 !== loaderData[matches] && match.route.loader && (mergedLoaderData[matches] = loaderData[matches]), errors && errors.hasOwnProperty(matches)) {
        break;
      }
    }
    return mergedLoaderData;
  }
  function getActionDataForCommit(pendingActionResult) {
    return pendingActionResult ? isErrorResult(pendingActionResult[1]) ? {actionData:{}} : {actionData:{[pendingActionResult[0]]:pendingActionResult[1].data}} : {};
  }
  function findNearestBoundary(matches, routeId) {
    return (routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches]).reverse().find(m => !0 === m.route.hasErrorBoundary) || matches[0];
  }
  function getShortCircuitMatches(routes) {
    routes = 1 === routes.length ? routes[0] : routes.find(r => r.index || !r.path || "/" === r.path) || {id:"__shim-error-route__"};
    return {matches:[{params:{}, pathname:"", pathnameBase:"", route:routes}], route:routes};
  }
  function getInternalRouterError(status, _temp5) {
    let {pathname, routeId, method, type} = void 0 === _temp5 ? {} : _temp5;
    _temp5 = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";
    400 === status ? (_temp5 = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but did not provide a `loader` for route "' + (routeId + '", so there is no way to handle the request.') : "defer-action" === type ? errorMessage = "defer() is not supported in actions" : "invalid-body" === type && (errorMessage = "Unable to encode submission body")) : 403 === status ? (_temp5 = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + 
    pathname + '"') : 404 === status ? (_temp5 = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : 405 === status && (_temp5 = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but did not provide an `action` for route "' + (routeId + '", so there is no way to handle the request.') : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"'));
    return new ErrorResponseImpl(status || 500, _temp5, Error(errorMessage), !0);
  }
  function findRedirect(results) {
    results = Object.entries(results);
    for (let i = results.length - 1; 0 <= i; i--) {
      let [key, result] = results[i];
      if (isRedirectResult(result)) {
        return {key, result};
      }
    }
  }
  function stripHashFromPath(path) {
    path = "string" === typeof path ? parsePath(path) : path;
    return createPath(_extends({}, path, {hash:""}));
  }
  function isRedirectDataStrategyResultResult(result) {
    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
  }
  function isDeferredResult(result) {
    return result.type === ResultType.deferred;
  }
  function isErrorResult(result) {
    return result.type === ResultType.error;
  }
  function isRedirectResult(result) {
    return (result && result.type) === ResultType.redirect;
  }
  function isDataWithResponseInit(value) {
    return "object" === typeof value && null != value && "type" in value && "data" in value && "init" in value && "DataWithResponseInit" === value.type;
  }
  function isDeferredData(value) {
    return value && "object" === typeof value && "object" === typeof value.data && "function" === typeof value.subscribe && "function" === typeof value.cancel && "function" === typeof value.resolveData;
  }
  function isResponse(value) {
    return null != value && "number" === typeof value.status && "string" === typeof value.statusText && "object" === typeof value.headers && "undefined" !== typeof value.body;
  }
  function isMutationMethod(method) {
    return validMutationMethods.has(method.toLowerCase());
  }
  async function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {
    let entries = Object.entries(results);
    for (let index = 0; index < entries.length; index++) {
      let [routeId, result] = entries[index], match = matches.find(m => (null == m ? void 0 : m.route.id) === routeId);
      if (match) {
        var currentMatch = currentMatches.find(m => m.route.id === match.route.id);
        currentMatch = null != currentMatch && !isNewRouteInstance(currentMatch, match) && void 0 !== (currentLoaderData && currentLoaderData[match.route.id]);
        isDeferredResult(result) && currentMatch && await resolveDeferredData(result, signal, !1).then(result => {
          result && (results[routeId] = result);
        });
      }
    }
  }
  async function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {
    for (let index = 0; index < revalidatingFetchers.length; index++) {
      let {key, routeId, controller} = revalidatingFetchers[index], result = results[key];
      matches.find(m => (null == m ? void 0 : m.route.id) === routeId) && isDeferredResult(result) && (invariant(controller, "Expected an AbortController for revalidating fetcher deferred result"), await resolveDeferredData(result, controller.signal, !0).then(result => {
        result && (results[key] = result);
      }));
    }
  }
  async function resolveDeferredData(result, signal, unwrap) {
    void 0 === unwrap && (unwrap = !1);
    if (!await result.deferredData.resolveData(signal)) {
      if (unwrap) {
        try {
          return {type:ResultType.data, data:result.deferredData.unwrappedData};
        } catch (e) {
          return {type:ResultType.error, error:e};
        }
      }
      return {type:ResultType.data, data:result.deferredData.data};
    }
  }
  function hasNakedIndexQuery(search) {
    return (new URLSearchParams(search)).getAll("index").some(v => "" === v);
  }
  function getTargetMatch(matches, location) {
    location = "string" === typeof location ? parsePath(location).search : location.search;
    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(location || "")) {
      return matches[matches.length - 1];
    }
    matches = getPathContributingMatches(matches);
    return matches[matches.length - 1];
  }
  function getSubmissionFromNavigation(navigation) {
    let {formMethod, formAction, formEncType, text, formData, json} = navigation;
    if (formMethod && formAction && formEncType) {
      if (null != text) {
        return {formMethod, formAction, formEncType, formData:void 0, json:void 0, text};
      }
      if (null != formData) {
        return {formMethod, formAction, formEncType, formData, json:void 0, text:void 0};
      }
      if (void 0 !== json) {
        return {formMethod, formAction, formEncType, formData:void 0, json, text:void 0};
      }
    }
  }
  function getLoadingNavigation(location, submission) {
    return submission ? {state:"loading", location, formMethod:submission.formMethod, formAction:submission.formAction, formEncType:submission.formEncType, formData:submission.formData, json:submission.json, text:submission.text} : {state:"loading", location, formMethod:void 0, formAction:void 0, formEncType:void 0, formData:void 0, json:void 0, text:void 0};
  }
  function getLoadingFetcher(submission, data) {
    return submission ? {state:"loading", formMethod:submission.formMethod, formAction:submission.formAction, formEncType:submission.formEncType, formData:submission.formData, json:submission.json, text:submission.text, data} : {state:"loading", formMethod:void 0, formAction:void 0, formEncType:void 0, formData:void 0, json:void 0, text:void 0, data};
  }
  function getDoneFetcher(data) {
    return {state:"idle", formMethod:void 0, formAction:void 0, formEncType:void 0, formData:void 0, json:void 0, text:void 0, data};
  }
  function restoreAppliedTransitions(_window, transitions) {
    try {
      let sessionPositions = _window.sessionStorage.getItem("remix-router-transitions");
      if (sessionPositions) {
        let json = JSON.parse(sessionPositions);
        for (let [k, v] of Object.entries(json || {})) {
          v && Array.isArray(v) && transitions.set(k, new Set(v || []));
        }
      }
    } catch (e) {
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  let Action = function(Action) {
    Action.Pop = "POP";
    Action.Push = "PUSH";
    Action.Replace = "REPLACE";
    return Action;
  }({}), ResultType = function(ResultType) {
    ResultType.data = "data";
    ResultType.deferred = "deferred";
    ResultType.redirect = "redirect";
    ResultType.error = "error";
    return ResultType;
  }({});
  const immutableRouteKeys = new Set("lazy caseSensitive path id index children".split(" ")), paramRe = /^:[\w-]+$/, isSplat = s => "*" === s, joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  class DataWithResponseInit {
    constructor(data, init) {
      this.type = "DataWithResponseInit";
      this.data = data;
      this.init = init || null;
    }
  }
  class AbortedDeferredError extends Error {
  }
  class DeferredData {
    constructor(data, responseInit) {
      this.pendingKeysSet = new Set();
      this.subscribers = new Set();
      this.deferredKeys = [];
      invariant(data && "object" === typeof data && !Array.isArray(data), "defer() only accepts plain objects");
      let reject;
      this.abortPromise = new Promise((_, r) => reject = r);
      this.controller = new AbortController();
      let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
      this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
      this.controller.signal.addEventListener("abort", onAbort);
      this.data = Object.entries(data).reduce((acc, _ref2) => {
        let [key, value] = _ref2;
        return Object.assign(acc, {[key]:this.trackPromise(key, value)});
      }, {});
      this.done && this.unlistenAbortSignal();
      this.init = responseInit;
    }
    trackPromise(key, value) {
      if (!(value instanceof Promise)) {
        return value;
      }
      this.deferredKeys.push(key);
      this.pendingKeysSet.add(key);
      let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, void 0, data), error => this.onSettle(promise, key, error));
      promise.catch(() => {
      });
      Object.defineProperty(promise, "_tracked", {get:() => !0});
      return promise;
    }
    onSettle(promise, key, error, data) {
      if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
        return this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {get:() => error}), Promise.reject(error);
      }
      this.pendingKeysSet.delete(key);
      this.done && this.unlistenAbortSignal();
      if (void 0 === error && void 0 === data) {
        let undefinedError = Error('Deferred data for key "' + key + '" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
        Object.defineProperty(promise, "_error", {get:() => undefinedError});
        this.emit(!1, key);
        return Promise.reject(undefinedError);
      }
      if (void 0 === data) {
        return Object.defineProperty(promise, "_error", {get:() => error}), this.emit(!1, key), Promise.reject(error);
      }
      Object.defineProperty(promise, "_data", {get:() => data});
      this.emit(!1, key);
      return data;
    }
    emit(aborted, settledKey) {
      this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
    }
    subscribe(fn) {
      this.subscribers.add(fn);
      return () => this.subscribers.delete(fn);
    }
    cancel() {
      this.controller.abort();
      this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
      this.emit(!0);
    }
    async resolveData(signal) {
      let aborted = !1;
      if (!this.done) {
        let onAbort = () => this.cancel();
        signal.addEventListener("abort", onAbort);
        aborted = await new Promise(resolve => {
          this.subscribe(aborted => {
            signal.removeEventListener("abort", onAbort);
            (aborted || this.done) && resolve(aborted);
          });
        });
      }
      return aborted;
    }
    get done() {
      return 0 === this.pendingKeysSet.size;
    }
    get unwrappedData() {
      invariant(null !== this.data && this.done, "Can only unwrap data on initialized and settled deferreds");
      return Object.entries(this.data).reduce((acc, _ref3) => {
        let [key, value] = _ref3;
        _ref3 = Object;
        var JSCompiler_temp_const = _ref3.assign;
        if (value instanceof Promise && !0 === value._tracked) {
          if (value._error) {
            throw value._error;
          }
          var JSCompiler_inline_result = value._data;
        } else {
          JSCompiler_inline_result = value;
        }
        return JSCompiler_temp_const.call(_ref3, acc, {[key]:JSCompiler_inline_result});
      }, {});
    }
    get pendingKeys() {
      return Array.from(this.pendingKeysSet);
    }
  }
  const redirect = function(url, init) {
    void 0 === init && (init = 302);
    "number" === typeof init ? init = {status:init} : "undefined" === typeof init.status && (init.status = 302);
    let headers = new Headers(init.headers);
    headers.set("Location", url);
    return new Response(null, _extends({}, init, {headers}));
  };
  class ErrorResponseImpl {
    constructor(status, statusText, data, internal) {
      void 0 === internal && (internal = !1);
      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;
      data instanceof Error ? (this.data = data.toString(), this.error = data) : this.data = data;
    }
  }
  const validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = new Set([307, 308]), IDLE_NAVIGATION = {state:"idle", location:void 0, formMethod:void 0, formAction:void 0, formEncType:void 0, formData:void 0, json:void 0, text:void 0}, 
  IDLE_FETCHER = {state:"idle", data:void 0, formMethod:void 0, formAction:void 0, formEncType:void 0, formData:void 0, json:void 0, text:void 0}, IDLE_BLOCKER = {state:"unblocked", proceed:void 0, reset:void 0, location:void 0}, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, defaultMapRouteProperties = route => ({hasErrorBoundary:!!route.hasErrorBoundary}), UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
  exports.AbortedDeferredError = AbortedDeferredError;
  exports.Action = Action;
  exports.IDLE_BLOCKER = IDLE_BLOCKER;
  exports.IDLE_FETCHER = IDLE_FETCHER;
  exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
  exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
  exports.UNSAFE_DeferredData = DeferredData;
  exports.UNSAFE_ErrorResponseImpl = ErrorResponseImpl;
  exports.UNSAFE_convertRouteMatchToUiMatch = convertRouteMatchToUiMatch;
  exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
  exports.UNSAFE_decodePath = decodePath;
  exports.UNSAFE_getResolveToMatches = getResolveToMatches;
  exports.UNSAFE_invariant = invariant;
  exports.UNSAFE_warning = warning;
  exports.createBrowserHistory = function(options) {
    void 0 === options && (options = {});
    return getUrlBasedHistory(function(window, globalHistory) {
      let {pathname, search, hash} = window.location;
      return createLocation("", {pathname, search, hash}, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
    }, function(window, to) {
      return "string" === typeof to ? to : createPath(to);
    }, null, options);
  };
  exports.createHashHistory = function(options) {
    void 0 === options && (options = {});
    return getUrlBasedHistory(function(window, globalHistory) {
      let {pathname = "/", search = "", hash = ""} = parsePath(window.location.hash.substr(1));
      pathname.startsWith("/") || pathname.startsWith(".") || (pathname = "/" + pathname);
      return createLocation("", {pathname, search, hash}, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
    }, function(window, to) {
      var base = window.document.querySelector("base");
      let href = "";
      base && base.getAttribute("href") && (window = window.location.href, base = window.indexOf("#"), href = -1 === base ? window : window.slice(0, base));
      return href + "#" + ("string" === typeof to ? to : createPath(to));
    }, function(location, to) {
      warning("/" === location.pathname.charAt(0), "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
    }, options);
  };
  exports.createMemoryHistory = function(options) {
    function createMemoryLocation(to, state, key) {
      void 0 === state && (state = null);
      state = createLocation(entries ? entries[index].pathname : "/", to, state, key);
      warning("/" === state.pathname.charAt(0), "relative pathnames are not supported in memory history: " + JSON.stringify(to));
      return state;
    }
    function createHref(to) {
      return "string" === typeof to ? to : createPath(to);
    }
    void 0 === options && (options = {});
    let {initialEntries = ["/"], initialIndex, v5Compat = !1} = options, entries;
    entries = initialEntries.map((entry, index) => createMemoryLocation(entry, "string" === typeof entry ? null : entry.state, 0 === index ? "default" : void 0));
    let index = Math.min(Math.max(null == initialIndex ? entries.length - 1 : initialIndex, 0), entries.length - 1), action = Action.Pop, listener = null;
    return {get index() {
      return index;
    }, get action() {
      return action;
    }, get location() {
      return entries[index];
    }, createHref, createURL(to) {
      return new URL(createHref(to), "http://localhost");
    }, encodeLocation(to) {
      to = "string" === typeof to ? parsePath(to) : to;
      return {pathname:to.pathname || "", search:to.search || "", hash:to.hash || ""};
    }, push(to, state) {
      action = Action.Push;
      to = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, to);
      v5Compat && listener && listener({action, location:to, delta:1});
    }, replace(to, state) {
      action = Action.Replace;
      to = createMemoryLocation(to, state);
      entries[index] = to;
      v5Compat && listener && listener({action, location:to, delta:0});
    }, go(delta) {
      action = Action.Pop;
      let nextIndex = Math.min(Math.max(index + delta, 0), entries.length - 1), nextLocation = entries[nextIndex];
      index = nextIndex;
      listener && listener({action, location:nextLocation, delta});
    }, listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }};
  };
  exports.createPath = createPath;
  exports.createRouter = function(init) {
    function updateState(newState, opts) {
      void 0 === opts && (opts = {});
      state = _extends({}, state, newState);
      let completedFetchers = [], deletedFetchersKeys = [];
      future.v7_fetcherPersist && state.fetchers.forEach((fetcher, key) => {
        "idle" === fetcher.state && (deletedFetchers.has(key) ? deletedFetchersKeys.push(key) : completedFetchers.push(key));
      });
      deletedFetchers.forEach(key => {
        state.fetchers.has(key) || fetchControllers.has(key) || deletedFetchersKeys.push(key);
      });
      [...subscribers].forEach(subscriber => subscriber(state, {deletedFetchers:deletedFetchersKeys, viewTransitionOpts:opts.viewTransitionOpts, flushSync:!0 === opts.flushSync}));
      future.v7_fetcherPersist ? (completedFetchers.forEach(key => state.fetchers.delete(key)), deletedFetchersKeys.forEach(key => deleteFetcher(key))) : deletedFetchersKeys.forEach(key => deletedFetchers.delete(key));
    }
    function completeNavigation(location, newState, _temp) {
      var _location$state, _location$state2;
      ({flushSync:_temp} = void 0 === _temp ? {} : _temp);
      var isActionReload = null != state.actionData && null != state.navigation.formMethod && isMutationMethod(state.navigation.formMethod) && "loading" === state.navigation.state && !0 !== (null == (_location$state = location.state) ? void 0 : _location$state._isRedirect);
      _location$state = newState.actionData ? 0 < Object.keys(newState.actionData).length ? newState.actionData : null : isActionReload ? state.actionData : null;
      isActionReload = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
      let blockers = state.blockers;
      0 < blockers.size && (blockers = new Map(blockers), blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER)));
      let preventScrollReset = !0 === pendingPreventScrollReset || null != state.navigation.formMethod && isMutationMethod(state.navigation.formMethod) && !0 !== (null == (_location$state2 = location.state) ? void 0 : _location$state2._isRedirect);
      inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0);
      isUninterruptedRevalidation || pendingAction !== Action.Pop && (pendingAction === Action.Push ? init.history.push(location, location.state) : pendingAction === Action.Replace && init.history.replace(location, location.state));
      var viewTransitionOpts;
      pendingAction === Action.Pop ? (_location$state2 = appliedViewTransitions.get(state.location.pathname)) && _location$state2.has(location.pathname) ? viewTransitionOpts = {currentLocation:state.location, nextLocation:location} : appliedViewTransitions.has(location.pathname) && (viewTransitionOpts = {currentLocation:location, nextLocation:state.location}) : pendingViewTransitionEnabled && ((viewTransitionOpts = appliedViewTransitions.get(state.location.pathname)) ? viewTransitionOpts.add(location.pathname) : 
      (viewTransitionOpts = new Set([location.pathname]), appliedViewTransitions.set(state.location.pathname, viewTransitionOpts)), viewTransitionOpts = {currentLocation:state.location, nextLocation:location});
      updateState(_extends({}, newState, {actionData:_location$state, loaderData:isActionReload, historyAction:pendingAction, location, initialized:!0, navigation:IDLE_NAVIGATION, revalidation:"idle", restoreScrollPosition:getSavedScrollPosition(location, newState.matches || state.matches), preventScrollReset, blockers}), {viewTransitionOpts, flushSync:!0 === _temp});
      pendingAction = Action.Pop;
      isRevalidationRequired = isUninterruptedRevalidation = pendingViewTransitionEnabled = pendingPreventScrollReset = !1;
      cancelledDeferredRoutes = [];
    }
    async function navigate(to, opts) {
      if ("number" === typeof to) {
        init.history.go(to);
      } else {
        var normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, null == opts ? void 0 : opts.fromRouteId, null == opts ? void 0 : opts.relative), {path, submission, error} = normalizeNavigateOptions(future.v7_normalizeFormMethod, !1, normalizedPath, opts);
        normalizedPath = state.location;
        var nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
        var userReplace = opts && null != opts.replace ? opts.replace : void 0, historyAction = Action.Push;
        !0 === userReplace ? historyAction = Action.Replace : !1 !== userReplace && null != submission && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = Action.Replace);
        userReplace = opts && "preventScrollReset" in opts ? !0 === opts.preventScrollReset : void 0;
        var flushSync = !0 === (opts && opts.flushSync), blockerKey = shouldBlockNavigation({currentLocation:normalizedPath, nextLocation, historyAction});
        if (blockerKey) {
          updateBlocker(blockerKey, {state:"blocked", location:nextLocation, proceed() {
            updateBlocker(blockerKey, {state:"proceeding", proceed:void 0, reset:void 0, location:nextLocation});
            navigate(to, opts);
          }, reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({blockers});
          }});
        } else {
          return await startNavigation(historyAction, nextLocation, {submission, pendingError:error, preventScrollReset:userReplace, replace:opts && opts.replace, enableViewTransition:opts && opts.viewTransition, flushSync});
        }
      }
    }
    async function startNavigation(historyAction, location, opts) {
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = !0 === (opts && opts.startUninterruptedRevalidation);
      savedScrollPositions && getScrollPosition && (historyAction = getScrollKey(state.location, state.matches), savedScrollPositions[historyAction] = getScrollPosition());
      pendingPreventScrollReset = !0 === (opts && opts.preventScrollReset);
      pendingViewTransitionEnabled = !0 === (opts && opts.enableViewTransition);
      var routesToUse = inFlightDataRoutes || dataRoutes;
      let loadingNavigation = opts && opts.overrideNavigation;
      historyAction = null != opts && opts.initialHydration && state.matches && 0 < state.matches.length && !initialMatchesIsFOW ? state.matches : matchRoutes(routesToUse, location, basename);
      let flushSync = !0 === (opts && opts.flushSync);
      var JSCompiler_temp;
      (JSCompiler_temp = !historyAction || !state.initialized || isRevalidationRequired) || (JSCompiler_temp = state.location, JSCompiler_temp = !(JSCompiler_temp.pathname !== location.pathname || JSCompiler_temp.search !== location.search ? 0 : "" === JSCompiler_temp.hash ? "" !== location.hash : JSCompiler_temp.hash === location.hash || "" !== location.hash));
      if (JSCompiler_temp || opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
        if (routesToUse = checkFogOfWar(historyAction, routesToUse, location.pathname), routesToUse.active && routesToUse.matches && (historyAction = routesToUse.matches), historyAction) {
          pendingNavigationController = new AbortController();
          JSCompiler_temp = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
          if (opts && opts.pendingError) {
            var pendingActionResult = [findNearestBoundary(historyAction).route.id, {type:ResultType.error, error:opts.pendingError}];
          } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
            pendingActionResult = await handleAction(JSCompiler_temp, location, opts.submission, historyAction, routesToUse.active, {replace:opts.replace, flushSync});
            if (pendingActionResult.shortCircuited) {
              return;
            }
            if (pendingActionResult.pendingActionResult) {
              let [routeId, result] = pendingActionResult.pendingActionResult;
              if (isErrorResult(result) && isRouteErrorResponse(result.error) && 404 === result.error.status) {
                pendingNavigationController = null;
                completeNavigation(location, {matches:pendingActionResult.matches, loaderData:{}, errors:{[routeId]:result.error}});
                return;
              }
            }
            historyAction = pendingActionResult.matches || historyAction;
            pendingActionResult = pendingActionResult.pendingActionResult;
            loadingNavigation = getLoadingNavigation(location, opts.submission);
            flushSync = !1;
            routesToUse.active = !1;
            JSCompiler_temp = createClientSideRequest(init.history, JSCompiler_temp.url, JSCompiler_temp.signal);
          }
          var {shortCircuited, matches:updatedMatches, loaderData, errors} = await handleLoaders(JSCompiler_temp, location, historyAction, routesToUse.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && !0 === opts.initialHydration, flushSync, pendingActionResult);
          shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({matches:updatedMatches || historyAction}, getActionDataForCommit(pendingActionResult), {loaderData, errors})));
        } else {
          let {error, notFoundMatches, route} = handleNavigational404(location.pathname);
          completeNavigation(location, {matches:notFoundMatches, loaderData:{}, errors:{[route.id]:error}}, {flushSync});
        }
      } else {
        completeNavigation(location, {matches:historyAction}, {flushSync});
      }
    }
    async function handleAction(request, location, submission, matches, isFogOfWar, opts) {
      void 0 === opts && (opts = {});
      interruptActiveLoads();
      updateState({navigation:{state:"submitting", location, formMethod:submission.formMethod, formAction:submission.formAction, formEncType:submission.formEncType, formData:submission.formData, json:submission.json, text:submission.text}}, {flushSync:!0 === opts.flushSync});
      if (isFogOfWar) {
        matches = await discoverRoutes(matches, location.pathname, request.signal);
        if ("aborted" === matches.type) {
          return {shortCircuited:!0};
        }
        if ("error" === matches.type) {
          return request = findNearestBoundary(matches.partialMatches).route.id, {matches:matches.partialMatches, pendingActionResult:[request, {type:ResultType.error, error:matches.error}]};
        }
        if (matches.matches) {
          matches = matches.matches;
        } else {
          let {notFoundMatches, error, route} = handleNavigational404(location.pathname);
          return {matches:notFoundMatches, pendingActionResult:[route.id, {type:ResultType.error, error}]};
        }
      }
      isFogOfWar = getTargetMatch(matches, location);
      if (isFogOfWar.route.action || isFogOfWar.route.lazy) {
        if (location = (await callDataStrategy("action", state, request, [isFogOfWar], matches, null))[isFogOfWar.route.id], request.signal.aborted) {
          return {shortCircuited:!0};
        }
      } else {
        location = {type:ResultType.error, error:getInternalRouterError(405, {method:request.method, pathname:location.pathname, routeId:isFogOfWar.route.id})};
      }
      if (isRedirectResult(location)) {
        return opts = opts && null != opts.replace ? opts.replace : normalizeRedirectLocation(location.response.headers.get("Location"), new URL(request.url), basename) === state.location.pathname + state.location.search, await startRedirectNavigation(request, location, !0, {submission, replace:opts}), {shortCircuited:!0};
      }
      if (isDeferredResult(location)) {
        throw getInternalRouterError(400, {type:"defer-action"});
      }
      return isErrorResult(location) ? (request = findNearestBoundary(matches, isFogOfWar.route.id), !0 !== (opts && opts.replace) && (pendingAction = Action.Push), {matches, pendingActionResult:[request.route.id, location]}) : {matches, pendingActionResult:[isFogOfWar.route.id, location]};
    }
    async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {
      overrideNavigation = overrideNavigation || getLoadingNavigation(location, submission);
      submission = submission || fetcherSubmission || getSubmissionFromNavigation(overrideNavigation);
      fetcherSubmission = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
      if (isFogOfWar) {
        if (fetcherSubmission) {
          var actionData = getUpdatedActionData(pendingActionResult);
          updateState(_extends({navigation:overrideNavigation}, void 0 !== actionData ? {actionData} : {}), {flushSync});
        }
        actionData = await discoverRoutes(matches, location.pathname, request.signal);
        if ("aborted" === actionData.type) {
          return {shortCircuited:!0};
        }
        if ("error" === actionData.type) {
          return pendingActionResult = findNearestBoundary(actionData.partialMatches).route.id, {matches:actionData.partialMatches, loaderData:{}, errors:{[pendingActionResult]:actionData.error}};
        }
        if (actionData.matches) {
          matches = actionData.matches;
        } else {
          let {error, notFoundMatches, route} = handleNavigational404(location.pathname);
          return {matches:notFoundMatches, loaderData:{}, errors:{[route.id]:error}};
        }
      }
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, location, future.v7_partialHydration && !0 === initialHydration, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, inFlightDataRoutes || dataRoutes, basename, pendingActionResult);
      cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));
      pendingNavigationLoadId = ++incrementingLoadId;
      if (0 === matchesToLoad.length && 0 === revalidatingFetchers.length) {
        return request = markFetchRedirectsDone(), completeNavigation(location, _extends({matches, loaderData:{}, errors:pendingActionResult && isErrorResult(pendingActionResult[1]) ? {[pendingActionResult[0]]:pendingActionResult[1].error} : null}, getActionDataForCommit(pendingActionResult), request ? {fetchers:new Map(state.fetchers)} : {}), {flushSync}), {shortCircuited:!0};
      }
      fetcherSubmission && (location = {}, isFogOfWar || (location.navigation = overrideNavigation, isFogOfWar = getUpdatedActionData(pendingActionResult), void 0 !== isFogOfWar && (location.actionData = isFogOfWar)), 0 < revalidatingFetchers.length && (location.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers)), updateState(location, {flushSync}));
      revalidatingFetchers.forEach(rf => {
        abortFetcher(rf.key);
        rf.controller && fetchControllers.set(rf.key, rf.controller);
      });
      flushSync = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
      pendingNavigationController && pendingNavigationController.signal.addEventListener("abort", flushSync);
      let {loaderResults, fetcherResults} = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);
      if (request.signal.aborted) {
        return {shortCircuited:!0};
      }
      pendingNavigationController && pendingNavigationController.signal.removeEventListener("abort", flushSync);
      revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));
      if (flushSync = findRedirect(loaderResults)) {
        return await startRedirectNavigation(request, flushSync.result, !0, {replace}), {shortCircuited:!0};
      }
      if (flushSync = findRedirect(fetcherResults)) {
        return fetchRedirectIds.add(flushSync.key), await startRedirectNavigation(request, flushSync.result, !0, {replace}), {shortCircuited:!0};
      }
      let {loaderData, errors} = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
      activeDeferreds.forEach((deferredData, routeId) => {
        deferredData.subscribe(aborted => {
          (aborted || deferredData.done) && activeDeferreds.delete(routeId);
        });
      });
      future.v7_partialHydration && initialHydration && state.errors && (errors = _extends({}, state.errors, errors));
      pendingActionResult = markFetchRedirectsDone();
      request = abortStaleFetchLoads(pendingNavigationLoadId);
      return _extends({matches, loaderData, errors}, pendingActionResult || request || 0 < revalidatingFetchers.length ? {fetchers:new Map(state.fetchers)} : {});
    }
    function getUpdatedActionData(pendingActionResult) {
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        return {[pendingActionResult[0]]:pendingActionResult[1].data};
      }
      if (state.actionData) {
        return 0 === Object.keys(state.actionData).length ? null : state.actionData;
      }
    }
    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
      revalidatingFetchers.forEach(rf => {
        var fetcher = state.fetchers.get(rf.key);
        fetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
        state.fetchers.set(rf.key, fetcher);
      });
      return new Map(state.fetchers);
    }
    async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
      function detectAndHandle405Error(m) {
        return m.route.action || m.route.lazy ? !1 : (m = getInternalRouterError(405, {method:submission.formMethod, pathname:path, routeId}), setFetcherError(key, routeId, m, {flushSync}), !0);
      }
      interruptActiveLoads();
      fetchLoadMatches.delete(key);
      if (isFogOfWar || !detectAndHandle405Error(match)) {
        var existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, {state:"submitting", formMethod:submission.formMethod, formAction:submission.formAction, formEncType:submission.formEncType, formData:submission.formData, json:submission.json, text:submission.text, data:existingFetcher ? existingFetcher.data : void 0}, {flushSync});
        existingFetcher = new AbortController();
        var fetchRequest = createClientSideRequest(init.history, path, existingFetcher.signal, submission);
        if (isFogOfWar) {
          match = await discoverRoutes(requestMatches, (new URL(fetchRequest.url)).pathname, fetchRequest.signal, key);
          if ("aborted" === match.type) {
            return;
          }
          if ("error" === match.type) {
            setFetcherError(key, routeId, match.error, {flushSync});
            return;
          }
          if (match.matches) {
            if (requestMatches = match.matches, match = getTargetMatch(requestMatches, path), detectAndHandle405Error(match)) {
              return;
            }
          } else {
            setFetcherError(key, routeId, getInternalRouterError(404, {pathname:path}), {flushSync});
            return;
          }
        }
        fetchControllers.set(key, existingFetcher);
        isFogOfWar = incrementingLoadId;
        requestMatches = (await callDataStrategy("action", state, fetchRequest, [match], requestMatches, key))[match.route.id];
        if (fetchRequest.signal.aborted) {
          fetchControllers.get(key) === existingFetcher && fetchControllers.delete(key);
        } else {
          if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
            if (isRedirectResult(requestMatches) || isErrorResult(requestMatches)) {
              updateFetcherState(key, getDoneFetcher(void 0));
              return;
            }
          } else {
            if (isRedirectResult(requestMatches)) {
              fetchControllers.delete(key);
              if (pendingNavigationLoadId > isFogOfWar) {
                updateFetcherState(key, getDoneFetcher(void 0));
                return;
              }
              fetchRedirectIds.add(key);
              updateFetcherState(key, getLoadingFetcher(submission));
              return startRedirectNavigation(fetchRequest, requestMatches, !1, {fetcherSubmission:submission, preventScrollReset});
            }
            if (isErrorResult(requestMatches)) {
              setFetcherError(key, routeId, requestMatches.error);
              return;
            }
          }
          if (isDeferredResult(requestMatches)) {
            throw getInternalRouterError(400, {type:"defer-action"});
          }
          var nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init.history, nextLocation, existingFetcher.signal), routesToUse = inFlightDataRoutes || dataRoutes;
          fetchRequest = "idle" !== state.navigation.state ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
          invariant(fetchRequest, "Didn't find any matches after fetcher action");
          isFogOfWar = ++incrementingLoadId;
          fetchReloadIds.set(key, isFogOfWar);
          var loadFetcher = getLoadingFetcher(submission, requestMatches.data);
          state.fetchers.set(key, loadFetcher);
          var [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, fetchRequest, submission, nextLocation, !1, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, requestMatches]);
          revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
            let staleKey = rf.key;
            var existingFetcher = state.fetchers.get(staleKey);
            existingFetcher = getLoadingFetcher(void 0, existingFetcher ? existingFetcher.data : void 0);
            state.fetchers.set(staleKey, existingFetcher);
            abortFetcher(staleKey);
            rf.controller && fetchControllers.set(staleKey, rf.controller);
          });
          updateState({fetchers:new Map(state.fetchers)});
          match = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
          existingFetcher.signal.addEventListener("abort", match);
          var {loaderResults, fetcherResults} = await callLoadersAndMaybeResolveData(state, fetchRequest, matchesToLoad, revalidatingFetchers, revalidationRequest);
          if (!existingFetcher.signal.aborted) {
            existingFetcher.signal.removeEventListener("abort", match);
            fetchReloadIds.delete(key);
            fetchControllers.delete(key);
            revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
            if (existingFetcher = findRedirect(loaderResults)) {
              return startRedirectNavigation(revalidationRequest, existingFetcher.result, !1, {preventScrollReset});
            }
            if (existingFetcher = findRedirect(fetcherResults)) {
              return fetchRedirectIds.add(existingFetcher.key), startRedirectNavigation(revalidationRequest, existingFetcher.result, !1, {preventScrollReset});
            }
            var {loaderData, errors} = processLoaderData(state, fetchRequest, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
            state.fetchers.has(key) && (preventScrollReset = getDoneFetcher(requestMatches.data), state.fetchers.set(key, preventScrollReset));
            abortStaleFetchLoads(isFogOfWar);
            "loading" === state.navigation.state && isFogOfWar > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {matches:fetchRequest, loaderData, errors, fetchers:new Map(state.fetchers)})) : (updateState({errors, loaderData:mergeLoaderData(state.loaderData, loaderData, fetchRequest, errors), fetchers:new Map(state.fetchers)}), isRevalidationRequired = 
            !1);
          }
        }
      }
    }
    async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
      var existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {flushSync});
      submission = new AbortController();
      existingFetcher = createClientSideRequest(init.history, path, submission.signal);
      if (isFogOfWar) {
        match = await discoverRoutes(matches, (new URL(existingFetcher.url)).pathname, existingFetcher.signal, key);
        if ("aborted" === match.type) {
          return;
        }
        if ("error" === match.type) {
          setFetcherError(key, routeId, match.error, {flushSync});
          return;
        }
        if (match.matches) {
          matches = match.matches, match = getTargetMatch(matches, path);
        } else {
          setFetcherError(key, routeId, getInternalRouterError(404, {pathname:path}), {flushSync});
          return;
        }
      }
      fetchControllers.set(key, submission);
      path = incrementingLoadId;
      match = (await callDataStrategy("loader", state, existingFetcher, [match], matches, key))[match.route.id];
      isDeferredResult(match) && (match = await resolveDeferredData(match, existingFetcher.signal, !0) || match);
      fetchControllers.get(key) === submission && fetchControllers.delete(key);
      existingFetcher.signal.aborted || (deletedFetchers.has(key) ? updateFetcherState(key, getDoneFetcher(void 0)) : isRedirectResult(match) ? pendingNavigationLoadId > path ? updateFetcherState(key, getDoneFetcher(void 0)) : (fetchRedirectIds.add(key), await startRedirectNavigation(existingFetcher, match, !1, {preventScrollReset})) : isErrorResult(match) ? setFetcherError(key, routeId, match.error) : (invariant(!isDeferredResult(match), "Unhandled fetcher deferred data"), updateFetcherState(key, 
      getDoneFetcher(match.data))));
    }
    async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {
      let {submission, fetcherSubmission, preventScrollReset, replace} = void 0 === _temp2 ? {} : _temp2;
      redirect.response.headers.has("X-Remix-Revalidate") && (isRevalidationRequired = !0);
      _temp2 = redirect.response.headers.get("Location");
      invariant(_temp2, "Expected a Location header on the redirect Response");
      _temp2 = normalizeRedirectLocation(_temp2, new URL(request.url), basename);
      request = createLocation(state.location, _temp2, {_isRedirect:!0});
      if (isBrowser) {
        var isDocumentReload = !1;
        redirect.response.headers.has("X-Remix-Reload-Document") ? isDocumentReload = !0 : ABSOLUTE_URL_REGEX.test(_temp2) && (isDocumentReload = init.history.createURL(_temp2), isDocumentReload = isDocumentReload.origin !== routerWindow.location.origin || null == stripBasename(isDocumentReload.pathname, basename));
        if (isDocumentReload) {
          replace ? routerWindow.location.replace(_temp2) : routerWindow.location.assign(_temp2);
          return;
        }
      }
      pendingNavigationController = null;
      isDocumentReload = !0 === replace || redirect.response.headers.has("X-Remix-Replace") ? Action.Replace : Action.Push;
      let {formMethod, formAction, formEncType} = state.navigation;
      !submission && !fetcherSubmission && formMethod && formAction && formEncType && (submission = getSubmissionFromNavigation(state.navigation));
      let activeSubmission = submission || fetcherSubmission;
      redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod) ? await startNavigation(isDocumentReload, request, {submission:_extends({}, activeSubmission, {formAction:_temp2}), preventScrollReset:preventScrollReset || pendingPreventScrollReset, enableViewTransition:isNavigation ? pendingViewTransitionEnabled : void 0}) : (redirect = getLoadingNavigation(request, submission), await startNavigation(isDocumentReload, request, 
      {overrideNavigation:redirect, fetcherSubmission, preventScrollReset:preventScrollReset || pendingPreventScrollReset, enableViewTransition:isNavigation ? pendingViewTransitionEnabled : void 0}));
    }
    async function callDataStrategy(type, state, request, matchesToLoad, matches, fetcherKey) {
      let results, dataResults = {};
      try {
        results = await callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties);
      } catch (e) {
        return matchesToLoad.forEach(m => {
          dataResults[m.route.id] = {type:ResultType.error, error:e};
        }), dataResults;
      }
      for (let [routeId, result] of Object.entries(results)) {
        isRedirectDataStrategyResultResult(result) ? dataResults[routeId] = {type:ResultType.redirect, response:normalizeRelativeRoutingRedirectResponse(result.result, request, routeId, matches, basename, future.v7_relativeSplatPath)} : dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
      }
      return dataResults;
    }
    async function callLoadersAndMaybeResolveData(state, matches, matchesToLoad, fetchersToLoad, request) {
      let currentMatches = state.matches;
      var loaderResultsPromise = callDataStrategy("loader", state, request, matchesToLoad, matches, null);
      matchesToLoad = Promise.all(fetchersToLoad.map(async f => {
        if (f.matches && f.match && f.controller) {
          let result = (await callDataStrategy("loader", state, createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, f.key))[f.match.route.id];
          return {[f.key]:result};
        }
        return Promise.resolve({[f.key]:{type:ResultType.error, error:getInternalRouterError(404, {pathname:f.path})}});
      }));
      loaderResultsPromise = await loaderResultsPromise;
      matchesToLoad = (await matchesToLoad).reduce((acc, r) => Object.assign(acc, r), {});
      await Promise.all([resolveNavigationDeferredResults(matches, loaderResultsPromise, request.signal, currentMatches, state.loaderData), resolveFetcherDeferredResults(matches, matchesToLoad, fetchersToLoad)]);
      return {loaderResults:loaderResultsPromise, fetcherResults:matchesToLoad};
    }
    function interruptActiveLoads() {
      isRevalidationRequired = !0;
      cancelledDeferredRoutes.push(...cancelActiveDeferreds());
      fetchLoadMatches.forEach((_, key) => {
        fetchControllers.has(key) && cancelledFetcherLoads.add(key);
        abortFetcher(key);
      });
    }
    function updateFetcherState(key, fetcher, opts) {
      void 0 === opts && (opts = {});
      state.fetchers.set(key, fetcher);
      updateState({fetchers:new Map(state.fetchers)}, {flushSync:!0 === (opts && opts.flushSync)});
    }
    function setFetcherError(key, routeId, error, opts) {
      void 0 === opts && (opts = {});
      routeId = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState({errors:{[routeId.route.id]:error}, fetchers:new Map(state.fetchers)}, {flushSync:!0 === (opts && opts.flushSync)});
    }
    function getFetcher(key) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      deletedFetchers.has(key) && deletedFetchers.delete(key);
      return state.fetchers.get(key) || IDLE_FETCHER;
    }
    function deleteFetcher(key) {
      let fetcher = state.fetchers.get(key);
      !fetchControllers.has(key) || fetcher && "loading" === fetcher.state && fetchReloadIds.has(key) || abortFetcher(key);
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      future.v7_fetcherPersist && deletedFetchers.delete(key);
      cancelledFetcherLoads.delete(key);
      state.fetchers.delete(key);
    }
    function abortFetcher(key) {
      let controller = fetchControllers.get(key);
      controller && (controller.abort(), fetchControllers.delete(key));
    }
    function markFetchersDone(keys) {
      for (let key of keys) {
        keys = getFetcher(key), keys = getDoneFetcher(keys.data), state.fetchers.set(key, keys);
      }
    }
    function markFetchRedirectsDone() {
      let doneKeys = [], updatedFetchers = !1;
      for (let key of fetchRedirectIds) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        "loading" === fetcher.state && (fetchRedirectIds.delete(key), doneKeys.push(key), updatedFetchers = !0);
      }
      markFetchersDone(doneKeys);
      return updatedFetchers;
    }
    function abortStaleFetchLoads(landedId) {
      let yeetedKeys = [];
      for (let [key, id] of fetchReloadIds) {
        if (id < landedId) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key);
          "loading" === fetcher.state && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
        }
      }
      markFetchersDone(yeetedKeys);
      return 0 < yeetedKeys.length;
    }
    function deleteBlocker(key) {
      state.blockers.delete(key);
      blockerFunctions.delete(key);
    }
    function updateBlocker(key, newBlocker) {
      var blocker = state.blockers.get(key) || IDLE_BLOCKER;
      invariant("unblocked" === blocker.state && "blocked" === newBlocker.state || "blocked" === blocker.state && "blocked" === newBlocker.state || "blocked" === blocker.state && "proceeding" === newBlocker.state || "blocked" === blocker.state && "unblocked" === newBlocker.state || "proceeding" === blocker.state && "unblocked" === newBlocker.state, "Invalid blocker state transition: " + blocker.state + " -\x3e " + newBlocker.state);
      blocker = new Map(state.blockers);
      blocker.set(key, newBlocker);
      updateState({blockers:blocker});
    }
    function shouldBlockNavigation(_ref2) {
      let {currentLocation, nextLocation, historyAction} = _ref2;
      if (0 !== blockerFunctions.size) {
        1 < blockerFunctions.size && warning(!1, "A router only supports one blocker at a time");
        _ref2 = Array.from(blockerFunctions.entries());
        var [blockerKey, blockerFunction] = _ref2[_ref2.length - 1];
        _ref2 = state.blockers.get(blockerKey);
        if ((!_ref2 || "proceeding" !== _ref2.state) && blockerFunction({currentLocation, nextLocation, historyAction})) {
          return blockerKey;
        }
      }
    }
    function handleNavigational404(pathname) {
      pathname = getInternalRouterError(404, {pathname});
      let {matches, route} = getShortCircuitMatches(inFlightDataRoutes || dataRoutes);
      cancelActiveDeferreds();
      return {notFoundMatches:matches, route, error:pathname};
    }
    function cancelActiveDeferreds(predicate) {
      let cancelledRouteIds = [];
      activeDeferreds.forEach((dfd, routeId) => {
        if (!predicate || predicate(routeId)) {
          dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId);
        }
      });
      return cancelledRouteIds;
    }
    function getScrollKey(location, matches) {
      return getScrollRestorationKey ? getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData))) || location.key : location.key;
    }
    function getSavedScrollPosition(location, matches) {
      return savedScrollPositions && (location = getScrollKey(location, matches), location = savedScrollPositions[location], "number" === typeof location) ? location : null;
    }
    function checkFogOfWar(matches, routesToUse, pathname) {
      if (patchRoutesOnNavigationImpl) {
        if (!matches) {
          return {active:!0, matches:matchRoutesImpl(routesToUse, pathname, basename, !0) || []};
        }
        if (0 < Object.keys(matches[0].params).length) {
          return {active:!0, matches:matchRoutesImpl(routesToUse, pathname, basename, !0)};
        }
      }
      return {active:!1, matches:null};
    }
    async function discoverRoutes(matches, pathname, signal, fetcherKey) {
      if (!patchRoutesOnNavigationImpl) {
        return {type:"success", matches};
      }
      for (;;) {
        var isNonHMR = null == inFlightDataRoutes;
        let routesToUse = inFlightDataRoutes || dataRoutes, localManifest = manifest;
        try {
          await patchRoutesOnNavigationImpl({signal, path:pathname, matches, fetcherKey, patch:(routeId, children) => {
            signal.aborted || patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties);
          }});
        } catch (e) {
          return {type:"error", error:e, partialMatches:matches};
        } finally {
          isNonHMR && !signal.aborted && (dataRoutes = [...dataRoutes]);
        }
        if (signal.aborted) {
          return {type:"aborted"};
        }
        if (isNonHMR = matchRoutes(routesToUse, pathname, basename)) {
          return {type:"success", matches:isNonHMR};
        }
        let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, !0);
        if (!newPartialMatches || matches.length === newPartialMatches.length && matches.every((m, i) => m.route.id === newPartialMatches[i].route.id)) {
          return {type:"success", matches:null};
        }
        matches = newPartialMatches;
      }
    }
    const routerWindow = init.window ? init.window : "undefined" !== typeof window ? window : void 0, isBrowser = "undefined" !== typeof routerWindow && "undefined" !== typeof routerWindow.document && "undefined" !== typeof routerWindow.document.createElement, isServer = !isBrowser;
    invariant(0 < init.routes.length, "You must provide a non-empty routes array to createRouter");
    let mapRouteProperties;
    if (init.mapRouteProperties) {
      mapRouteProperties = init.mapRouteProperties;
    } else if (init.detectErrorBoundary) {
      let detectErrorBoundary = init.detectErrorBoundary;
      mapRouteProperties = route => ({hasErrorBoundary:detectErrorBoundary(route)});
    } else {
      mapRouteProperties = defaultMapRouteProperties;
    }
    let manifest = {}, dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, void 0, manifest), inFlightDataRoutes, basename = init.basename || "/", dataStrategyImpl = init.dataStrategy || defaultDataStrategy, patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation, future = _extends({v7_fetcherPersist:!1, v7_normalizeFormMethod:!1, v7_partialHydration:!1, v7_prependBasename:!1, v7_relativeSplatPath:!1, v7_skipActionErrorRevalidation:!1}, init.future), unlistenHistory = null, 
    subscribers = new Set(), savedScrollPositions = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = null != init.hydrationData, initialMatches = matchRoutes(dataRoutes, init.history.location, basename), initialMatchesIsFOW = !1;
    var initialErrors = null;
    if (null == initialMatches && !patchRoutesOnNavigationImpl) {
      initialErrors = getInternalRouterError(404, {pathname:init.history.location.pathname});
      let {matches, route} = getShortCircuitMatches(dataRoutes);
      initialMatches = matches;
      initialErrors = {[route.id]:initialErrors};
    }
    initialMatches && !init.hydrationData && checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname).active && (initialMatches = null);
    if (initialMatches) {
      if (initialMatches.some(m => m.route.lazy)) {
        var initialized = !1;
      } else if (initialMatches.some(m => m.route.loader)) {
        if (future.v7_partialHydration) {
          let loaderData = init.hydrationData ? init.hydrationData.loaderData : null, errors = init.hydrationData ? init.hydrationData.errors : null;
          errors ? (initialized = initialMatches.findIndex(m => void 0 !== errors[m.route.id]), initialized = initialMatches.slice(0, initialized + 1).every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors))) : initialized = initialMatches.every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
        } else {
          initialized = null != init.hydrationData;
        }
      } else {
        initialized = !0;
      }
    } else {
      if (initialized = !1, initialMatches = [], future.v7_partialHydration) {
        let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);
        fogOfWar.active && fogOfWar.matches && (initialMatchesIsFOW = !0, initialMatches = fogOfWar.matches);
      }
    }
    let router, state = {historyAction:init.history.action, location:init.history.location, matches:initialMatches, initialized, navigation:IDLE_NAVIGATION, restoreScrollPosition:null != init.hydrationData ? !1 : null, preventScrollReset:!1, revalidation:"idle", loaderData:init.hydrationData && init.hydrationData.loaderData || {}, actionData:init.hydrationData && init.hydrationData.actionData || null, errors:init.hydrationData && init.hydrationData.errors || initialErrors, fetchers:new Map(), blockers:new Map()}, 
    pendingAction = Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, pendingViewTransitionEnabled = !1, appliedViewTransitions = new Map(), removePageHideEventListener = null, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = new Set(), fetchControllers = new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = new Map(), fetchRedirectIds = new Set(), fetchLoadMatches = new Map(), activeFetchers = 
    new Map(), deletedFetchers = new Set(), activeDeferreds = new Map(), blockerFunctions = new Map(), unblockBlockerHistoryUpdate = void 0;
    return router = {get basename() {
      return basename;
    }, get future() {
      return future;
    }, get state() {
      return state;
    }, get routes() {
      return dataRoutes;
    }, get window() {
      return routerWindow;
    }, initialize:function() {
      unlistenHistory = init.history.listen(_ref => {
        let {action:historyAction, location, delta} = _ref;
        if (unblockBlockerHistoryUpdate) {
          unblockBlockerHistoryUpdate(), unblockBlockerHistoryUpdate = void 0;
        } else {
          warning(0 === blockerFunctions.size || null != delta, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          var blockerKey = shouldBlockNavigation({currentLocation:state.location, nextLocation:location, historyAction});
          if (blockerKey && null != delta) {
            let nextHistoryUpdatePromise = new Promise(resolve => {
              unblockBlockerHistoryUpdate = resolve;
            });
            init.history.go(-1 * delta);
            updateBlocker(blockerKey, {state:"blocked", location, proceed() {
              updateBlocker(blockerKey, {state:"proceeding", proceed:void 0, reset:void 0, location});
              nextHistoryUpdatePromise.then(() => init.history.go(delta));
            }, reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({blockers});
            }});
          } else {
            return startNavigation(historyAction, location);
          }
        }
      });
      if (isBrowser) {
        restoreAppliedTransitions(routerWindow, appliedViewTransitions);
        let _saveAppliedTransitions = () => {
          var _window = routerWindow, transitions = appliedViewTransitions;
          if (0 < transitions.size) {
            let json = {};
            for (let [k, v] of transitions) {
              json[k] = [...v];
            }
            try {
              _window.sessionStorage.setItem("remix-router-transitions", JSON.stringify(json));
            } catch (error) {
              warning(!1, "Failed to save applied view transitions in sessionStorage (" + error + ").");
            }
          }
        };
        routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
        removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
      }
      state.initialized || startNavigation(Action.Pop, state.location, {initialHydration:!0});
      return router;
    }, subscribe:function(fn) {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }, enableScrollRestoration:function(positions, getPosition, getKey) {
      savedScrollPositions = positions;
      getScrollPosition = getPosition;
      getScrollRestorationKey = getKey || null;
      initialScrollRestored || state.navigation !== IDLE_NAVIGATION || (initialScrollRestored = !0, positions = getSavedScrollPosition(state.location, state.matches), null != positions && updateState({restoreScrollPosition:positions}));
      return () => {
        getScrollRestorationKey = getScrollPosition = savedScrollPositions = null;
      };
    }, navigate, fetch:function(key, routeId, href, opts) {
      if (isServer) {
        throw Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
      }
      abortFetcher(key);
      let flushSync = !0 === (opts && opts.flushSync);
      var routesToUse = inFlightDataRoutes || dataRoutes, normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, null == opts ? void 0 : opts.relative);
      href = matchRoutes(routesToUse, normalizedPath, basename);
      routesToUse = checkFogOfWar(href, routesToUse, normalizedPath);
      routesToUse.active && routesToUse.matches && (href = routesToUse.matches);
      if (href) {
        var {path, submission, error} = normalizeNavigateOptions(future.v7_normalizeFormMethod, !0, normalizedPath, opts);
        error ? setFetcherError(key, routeId, error, {flushSync}) : (normalizedPath = getTargetMatch(href, path), opts = !0 === (opts && opts.preventScrollReset), submission && isMutationMethod(submission.formMethod) ? handleFetcherAction(key, routeId, path, normalizedPath, href, routesToUse.active, flushSync, opts, submission) : (fetchLoadMatches.set(key, {routeId, path}), handleFetcherLoader(key, routeId, path, normalizedPath, href, routesToUse.active, flushSync, opts, submission)));
      } else {
        setFetcherError(key, routeId, getInternalRouterError(404, {pathname:normalizedPath}), {flushSync});
      }
    }, revalidate:function() {
      interruptActiveLoads();
      updateState({revalidation:"loading"});
      "submitting" !== state.navigation.state && ("idle" === state.navigation.state ? startNavigation(state.historyAction, state.location, {startUninterruptedRevalidation:!0}) : startNavigation(pendingAction || state.historyAction, state.navigation.location, {overrideNavigation:state.navigation, enableViewTransition:!0 === pendingViewTransitionEnabled}));
    }, createHref:to => init.history.createHref(to), encodeLocation:to => init.history.encodeLocation(to), getFetcher, deleteFetcher:function(key) {
      let count = (activeFetchers.get(key) || 0) - 1;
      0 >= count ? (activeFetchers.delete(key), deletedFetchers.add(key), future.v7_fetcherPersist || deleteFetcher(key)) : activeFetchers.set(key, count);
      updateState({fetchers:new Map(state.fetchers)});
    }, dispose:function() {
      unlistenHistory && unlistenHistory();
      removePageHideEventListener && removePageHideEventListener();
      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_, key) => deleteFetcher(key));
      state.blockers.forEach((_, key) => deleteBlocker(key));
    }, getBlocker:function(key, fn) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      blockerFunctions.get(key) !== fn && blockerFunctions.set(key, fn);
      return blocker;
    }, deleteBlocker, patchRoutes:function(routeId, children) {
      let isNonHMR = null == inFlightDataRoutes;
      patchRoutesImpl(routeId, children, inFlightDataRoutes || dataRoutes, manifest, mapRouteProperties);
      isNonHMR && (dataRoutes = [...dataRoutes], updateState({}));
    }, _internalFetchControllers:fetchControllers, _internalActiveDeferreds:activeDeferreds, _internalSetRoutes:function(newRoutes) {
      manifest = {};
      inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, void 0, manifest);
    }};
  };
  exports.createStaticHandler = function(routes, opts) {
    async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {
      invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
      try {
        if (isMutationMethod(request.method.toLowerCase())) {
          return await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, null != routeMatch);
        }
        let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch);
        return isResponse(result) ? result : _extends({}, result, {actionData:null, actionHeaders:{}});
      } catch (e) {
        if (null != e && "object" === typeof e && "type" in e && "result" in e && (e.type === ResultType.data || e.type === ResultType.error) && isResponse(e.result)) {
          if (e.type === ResultType.error) {
            throw e.result;
          }
          return e.result;
        }
        location = e;
        isResponse(location) ? (request = location.status, location = location.headers.get("Location"), request = 300 <= request && 399 >= request && null != location) : request = !1;
        if (request) {
          return e;
        }
        throw e;
      }
    }
    async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
      if (actionMatch.route.action || actionMatch.route.lazy) {
        var result = (await callDataStrategy("action", request, [actionMatch], matches, isRouteRequest, requestContext, dataStrategy))[actionMatch.route.id];
        request.signal.aborted && throwStaticHandlerAbortedError(request, isRouteRequest, future);
      } else {
        result = getInternalRouterError(405, {method:request.method, pathname:(new URL(request.url)).pathname, routeId:actionMatch.route.id});
        if (isRouteRequest) {
          throw result;
        }
        result = {type:ResultType.error, error:result};
      }
      if (isRedirectResult(result)) {
        throw new Response(null, {status:result.response.status, headers:{Location:result.response.headers.get("Location")}});
      }
      if (isDeferredResult(result)) {
        result = getInternalRouterError(400, {type:"defer-action"});
        if (isRouteRequest) {
          throw result;
        }
        result = {type:ResultType.error, error:result};
      }
      if (isRouteRequest) {
        if (isErrorResult(result)) {
          throw result.error;
        }
        return {matches:[actionMatch], loaderData:{}, actionData:{[actionMatch.route.id]:result.data}, errors:null, statusCode:200, loaderHeaders:{}, actionHeaders:{}, activeDeferreds:null};
      }
      request = new Request(request.url, {headers:request.headers, redirect:request.redirect, signal:request.signal});
      if (isErrorResult(result)) {
        return isRouteRequest = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id), matches = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, [isRouteRequest.route.id, result]), _extends({}, matches, {statusCode:isRouteErrorResponse(result.error) ? result.error.status : null != result.statusCode ? result.statusCode : 500, actionData:null, actionHeaders:_extends({}, result.headers ? {[actionMatch.route.id]:result.headers} : 
        {})});
      }
      matches = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null);
      return _extends({}, matches, {actionData:{[actionMatch.route.id]:result.data}}, result.statusCode ? {statusCode:result.statusCode} : {}, {actionHeaders:result.headers ? {[actionMatch.route.id]:result.headers} : {}});
    }
    async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
      let isRouteRequest = null != routeMatch;
      if (!(!isRouteRequest || null != routeMatch && routeMatch.route.loader || null != routeMatch && routeMatch.route.lazy)) {
        throw getInternalRouterError(400, {method:request.method, pathname:(new URL(request.url)).pathname, routeId:null == routeMatch ? void 0 : routeMatch.route.id});
      }
      routeMatch = (routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches).filter(m => m.route.loader || m.route.lazy);
      if (0 === routeMatch.length) {
        return {matches, loaderData:matches.reduce((acc, m) => Object.assign(acc, {[m.route.id]:null}), {}), errors:pendingActionResult && isErrorResult(pendingActionResult[1]) ? {[pendingActionResult[0]]:pendingActionResult[1].error} : null, statusCode:200, loaderHeaders:{}, activeDeferreds:null};
      }
      requestContext = await callDataStrategy("loader", request, routeMatch, matches, isRouteRequest, requestContext, dataStrategy);
      request.signal.aborted && throwStaticHandlerAbortedError(request, isRouteRequest, future);
      request = new Map();
      let context = processRouteLoaderData(matches, requestContext, pendingActionResult, request, skipLoaderErrorBubbling), executedLoaders = new Set(routeMatch.map(match => match.route.id));
      matches.forEach(match => {
        executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
      });
      return _extends({}, context, {matches, activeDeferreds:0 < request.size ? Object.fromEntries(request.entries()) : null});
    }
    async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {
      let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, type, null, request, matchesToLoad, matches, null, manifest, mapRouteProperties, requestContext), dataResults = {};
      await Promise.all(matches.map(async match => {
        if (match.route.id in results) {
          var result = results[match.route.id];
          if (isRedirectDataStrategyResultResult(result)) {
            throw normalizeRelativeRoutingRedirectResponse(result.result, request, match.route.id, matches, basename, future.v7_relativeSplatPath);
          }
          if (isResponse(result.result) && isRouteRequest) {
            throw result;
          }
          dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
        }
      }));
      return dataResults;
    }
    invariant(0 < routes.length, "You must provide a non-empty routes array to createStaticHandler");
    let manifest = {}, basename = (opts ? opts.basename : null) || "/", mapRouteProperties;
    if (null != opts && opts.mapRouteProperties) {
      mapRouteProperties = opts.mapRouteProperties;
    } else if (null != opts && opts.detectErrorBoundary) {
      let detectErrorBoundary = opts.detectErrorBoundary;
      mapRouteProperties = route => ({hasErrorBoundary:detectErrorBoundary(route)});
    } else {
      mapRouteProperties = defaultMapRouteProperties;
    }
    let future = _extends({v7_relativeSplatPath:!1, v7_throwAbortReason:!1}, opts ? opts.future : null), dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);
    return {dataRoutes, query:async function(request, _temp3) {
      let {requestContext, skipLoaderErrorBubbling, dataStrategy} = void 0 === _temp3 ? {} : _temp3;
      _temp3 = new URL(request.url);
      let method = request.method;
      _temp3 = createLocation("", createPath(_temp3), null, "default");
      let matches = matchRoutes(dataRoutes, _temp3, basename);
      if (!validRequestMethods.has(method.toLowerCase()) && "HEAD" !== method) {
        request = getInternalRouterError(405, {method});
        let {matches:methodNotAllowedMatches, route} = getShortCircuitMatches(dataRoutes);
        return {basename, location:_temp3, matches:methodNotAllowedMatches, loaderData:{}, actionData:null, errors:{[route.id]:request}, statusCode:request.status, loaderHeaders:{}, actionHeaders:{}, activeDeferreds:null};
      }
      if (!matches) {
        request = getInternalRouterError(404, {pathname:_temp3.pathname});
        let {matches:notFoundMatches, route} = getShortCircuitMatches(dataRoutes);
        return {basename, location:_temp3, matches:notFoundMatches, loaderData:{}, actionData:null, errors:{[route.id]:request}, statusCode:request.status, loaderHeaders:{}, actionHeaders:{}, activeDeferreds:null};
      }
      request = await queryImpl(request, _temp3, matches, requestContext, dataStrategy || null, !0 === skipLoaderErrorBubbling, null);
      return isResponse(request) ? request : _extends({location:_temp3, basename}, request);
    }, queryRoute:async function(request, _temp4) {
      let {routeId, requestContext, dataStrategy} = void 0 === _temp4 ? {} : _temp4;
      var url = new URL(request.url);
      _temp4 = request.method;
      url = createLocation("", createPath(url), null, "default");
      let matches = matchRoutes(dataRoutes, url, basename);
      if (!validRequestMethods.has(_temp4.toLowerCase()) && "HEAD" !== _temp4 && "OPTIONS" !== _temp4) {
        throw getInternalRouterError(405, {method:_temp4});
      }
      if (!matches) {
        throw getInternalRouterError(404, {pathname:url.pathname});
      }
      _temp4 = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, url);
      if (routeId && !_temp4) {
        throw getInternalRouterError(403, {pathname:url.pathname, routeId});
      }
      if (!_temp4) {
        throw getInternalRouterError(404, {pathname:url.pathname});
      }
      request = await queryImpl(request, url, matches, requestContext, dataStrategy || null, !1, _temp4);
      if (isResponse(request)) {
        return request;
      }
      url = request.errors ? Object.values(request.errors)[0] : void 0;
      if (void 0 !== url) {
        throw url;
      }
      if (request.actionData) {
        return Object.values(request.actionData)[0];
      }
      if (request.loaderData) {
        var _result$activeDeferre;
        url = Object.values(request.loaderData)[0];
        null != (_result$activeDeferre = request.activeDeferreds) && _result$activeDeferre[_temp4.route.id] && (url[UNSAFE_DEFERRED_SYMBOL] = request.activeDeferreds[_temp4.route.id]);
        return url;
      }
    }};
  };
  exports.data = function(data, init) {
    return new DataWithResponseInit(data, "number" === typeof init ? {status:init} : init);
  };
  exports.defer = function(data, init) {
    void 0 === init && (init = {});
    return new DeferredData(data, "number" === typeof init ? {status:init} : init);
  };
  exports.generatePath = function(originalPath, params) {
    void 0 === params && (params = {});
    var path = originalPath;
    path.endsWith("*") && "*" !== path && !path.endsWith("/*") && (warning(!1, 'Route path "' + path + '" will be treated as if it were "' + (path.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "') + (path.replace(/\*$/, "/*") + '".')), path = path.replace(/\*$/, "/*"));
    originalPath = path.startsWith("/") ? "/" : "";
    const stringify = p => null == p ? "" : "string" === typeof p ? p : String(p);
    path = path.split(/\/+/).map((segment, index, array) => {
      if (index === array.length - 1 && "*" === segment) {
        return stringify(params["*"]);
      }
      if (index = segment.match(/^:([\w-]+)(\??)$/)) {
        const [, key, optional] = index;
        segment = params[key];
        invariant("?" === optional || null != segment, 'Missing ":' + key + '" param');
        return stringify(segment);
      }
      return segment.replace(/\?$/g, "");
    }).filter(segment => !!segment);
    return originalPath + path.join("/");
  };
  exports.getStaticContextFromError = function(routes, context, error) {
    return _extends({}, context, {statusCode:isRouteErrorResponse(error) ? error.status : 500, errors:{[context._deepestRenderedBoundaryId || routes[0].id]:error}});
  };
  exports.getToPathname = function(to) {
    return "" === to || "" === to.pathname ? "/" : "string" === typeof to ? parsePath(to).pathname : to.pathname;
  };
  exports.isDataWithResponseInit = isDataWithResponseInit;
  exports.isDeferredData = isDeferredData;
  exports.isRouteErrorResponse = isRouteErrorResponse;
  exports.joinPaths = joinPaths;
  exports.json = function(data, init) {
    void 0 === init && (init = {});
    init = "number" === typeof init ? {status:init} : init;
    let headers = new Headers(init.headers);
    headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset\x3dutf-8");
    return new Response(JSON.stringify(data), _extends({}, init, {headers}));
  };
  exports.matchPath = matchPath;
  exports.matchRoutes = matchRoutes;
  exports.normalizePathname = normalizePathname;
  exports.parsePath = parsePath;
  exports.redirect = redirect;
  exports.redirectDocument = (url, init) => {
    url = redirect(url, init);
    url.headers.set("X-Remix-Reload-Document", "true");
    return url;
  };
  exports.replace = (url, init) => {
    url = redirect(url, init);
    url.headers.set("X-Remix-Replace", "true");
    return url;
  };
  exports.resolvePath = resolvePath;
  exports.resolveTo = resolveTo;
  exports.stripBasename = stripBasename;
};

//# sourceMappingURL=module$node_modules$$remix_run$router$dist$router_cjs.js.map
