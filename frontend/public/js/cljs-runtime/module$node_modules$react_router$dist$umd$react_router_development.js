shadow$provide.module$node_modules$react_router$dist$umd$react_router_development = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? factory(exports, require("module$node_modules$react$index"), require("module$node_modules$$remix_run$router$dist$router_cjs")) : "function" === typeof define && define.amd ? define(["exports", "react", "@remix-run/router"], factory) : (global = "undefined" !== typeof globalThis ? globalThis : global || self, factory(global.ReactRouter = {}, global.React, global.RemixRouter));
  })(this, function(exports, React, router) {
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i], key;
          for (key in source) {
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function useInRouterContext() {
      return null != React__namespace.useContext(LocationContext);
    }
    function useLocation() {
      useInRouterContext() || router.UNSAFE_invariant(!1, "useLocation() may be used only in the context of a \x3cRouter\x3e component.");
      return React__namespace.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect(cb) {
      React__namespace.useContext(NavigationContext).static || React__namespace.useLayoutEffect(cb);
    }
    function useNavigate() {
      let {isDataRoute} = React__namespace.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      useInRouterContext() || router.UNSAFE_invariant(!1, "useNavigate() may be used only in the context of a \x3cRouter\x3e component.");
      let dataRouterContext = React__namespace.useContext(DataRouterContext), {basename, future, navigator} = React__namespace.useContext(NavigationContext), {matches} = React__namespace.useContext(RouteContext), {pathname:locationPathname} = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath)), activeRef = React__namespace.useRef(!1);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = !0;
      });
      return React__namespace.useCallback(function(to, options) {
        void 0 === options && (options = {});
        router.UNSAFE_warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.");
        activeRef.current && ("number" === typeof to ? navigator.go(to) : (to = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, "path" === options.relative), null == dataRouterContext && "/" !== basename && (to.pathname = "/" === to.pathname ? basename : router.joinPaths([basename, to.pathname])), (options.replace ? navigator.replace : navigator.push)(to, options.state, options)));
      }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
    }
    function useOutlet(context) {
      let outlet = React__namespace.useContext(RouteContext).outlet;
      return outlet ? React__namespace.createElement(OutletContext.Provider, {value:context}, outlet) : outlet;
    }
    function useResolvedPath(to, _temp2) {
      let {relative} = void 0 === _temp2 ? {} : _temp2;
      ({future:_temp2} = React__namespace.useContext(NavigationContext));
      let {matches} = React__namespace.useContext(RouteContext), {pathname:locationPathname} = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, _temp2.v7_relativeSplatPath));
      return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, "path" === relative), [to, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      useInRouterContext() || router.UNSAFE_invariant(!1, "useRoutes() may be used only in the context of a \x3cRouter\x3e component.");
      let {navigator, static:isStatic} = React__namespace.useContext(NavigationContext), {matches:parentMatches} = React__namespace.useContext(RouteContext);
      var routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      var parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      var parentPath = (routeMatch = routeMatch && routeMatch.route) && routeMatch.path || "";
      warningOnce(parentPathname, !routeMatch || parentPath.endsWith("*"), 'You rendered descendant \x3cRoutes\x3e (or called `useRoutes()`) at "' + (parentPathname + '" (under \x3cRoute path\x3d"' + parentPath + '"\x3e) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent \x3cRoute path\x3d"') + (parentPath + '"\x3e to \x3cRoute path\x3d"') + (("/" === parentPath ? 
      "*" : parentPath + "/*") + '"\x3e.'));
      parentPathname = useLocation();
      var location;
      locationArg ? (parentPathname = "string" === typeof locationArg ? router.parsePath(locationArg) : locationArg, "/" === parentPathnameBase || (null == (location = parentPathname.pathname) ? 0 : location.startsWith(parentPathnameBase)) || router.UNSAFE_invariant(!1, 'When overriding the location using `\x3cRoutes location\x3e` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "' + 
      (parentPathnameBase + '" but pathname "') + (parentPathname.pathname + '" was given in the `location` prop.')), location = parentPathname) : location = parentPathname;
      parentPath = parentPathname = location.pathname || "/";
      "/" !== parentPathnameBase && (parentPath = parentPathnameBase.replace(/^\//, "").split("/"), parentPath = "/" + parentPathname.replace(/^\//, "").split("/").slice(parentPath.length).join("/"));
      routes = !isStatic && dataRouterState && dataRouterState.matches && 0 < dataRouterState.matches.length ? dataRouterState.matches : router.matchRoutes(routes, {pathname:parentPath});
      router.UNSAFE_warning(routeMatch || null != routes, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ');
      router.UNSAFE_warning(null == routes || void 0 !== routes[routes.length - 1].route.element || void 0 !== routes[routes.length - 1].route.Component || void 0 !== routes[routes.length - 1].route.lazy, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an \x3cOutlet /\x3e with a null value by default resulting in an "empty" page.');
      dataRouterState = _renderMatches(routes && routes.map(match => Object.assign({}, match, {params:Object.assign({}, parentParams, match.params), pathname:router.joinPaths([parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]), pathnameBase:"/" === match.pathnameBase ? parentPathnameBase : router.joinPaths([parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])})), 
      parentMatches, dataRouterState, future);
      return locationArg && dataRouterState ? React__namespace.createElement(LocationContext.Provider, {value:{location:_extends({pathname:"/", search:"", hash:"", state:null, key:"default"}, location), navigationType:router.Action.Pop}}, dataRouterState) : dataRouterState;
    }
    function RenderedRoute(_ref) {
      let {routeContext, match, children} = _ref;
      (_ref = React__namespace.useContext(DataRouterContext)) && _ref.static && _ref.staticContext && (match.route.errorElement || match.route.ErrorBoundary) && (_ref.staticContext._deepestRenderedBoundaryId = match.route.id);
      return React__namespace.createElement(RouteContext.Provider, {value:routeContext}, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState, future) {
      var _dataRouterState;
      void 0 === parentMatches && (parentMatches = []);
      void 0 === dataRouterState && (dataRouterState = null);
      void 0 === future && (future = null);
      if (null == matches) {
        var _future;
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if (null != (_future = future) && _future.v7_partialHydration && 0 === parentMatches.length && !dataRouterState.initialized && 0 < dataRouterState.matches.length) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches, errors = null == (_dataRouterState = dataRouterState) ? void 0 : _dataRouterState.errors;
      null != errors && (matches = renderedMatches.findIndex(m => m.route.id && void 0 !== (null == errors ? void 0 : errors[m.route.id])), 0 <= matches || router.UNSAFE_invariant(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, matches + 1)));
      let renderFallback = !1, fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (future = 0; future < renderedMatches.length; future++) {
          matches = renderedMatches[future];
          if (matches.route.HydrateFallback || matches.route.hydrateFallbackElement) {
            fallbackIndex = future;
          }
          if (matches.route.id) {
            let {loaderData, errors} = dataRouterState;
            _dataRouterState = matches.route.loader && void 0 === loaderData[matches.route.id] && (!errors || void 0 === errors[matches.route.id]);
            if (matches.route.lazy || _dataRouterState) {
              renderFallback = !0;
              renderedMatches = 0 <= fallbackIndex ? renderedMatches.slice(0, fallbackIndex + 1) : [renderedMatches[0]];
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match, index) => {
        let error, shouldRenderHydrateFallback = !1, errorElement = null, hydrateFallbackElement = null;
        dataRouterState && (error = errors && match.route.id ? errors[match.route.id] : void 0, errorElement = match.route.errorElement || defaultErrorElement, renderFallback && (0 > fallbackIndex && 0 === index ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), shouldRenderHydrateFallback = !0, hydrateFallbackElement = null) : fallbackIndex === index && (shouldRenderHydrateFallback = !0, hydrateFallbackElement = match.route.hydrateFallbackElement || 
        null)));
        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1)), getChildren = () => {
          let children;
          children = error ? errorElement : shouldRenderHydrateFallback ? hydrateFallbackElement : match.route.Component ? React__namespace.createElement(match.route.Component, null) : match.route.element ? match.route.element : outlet;
          return React__namespace.createElement(RenderedRoute, {match, routeContext:{outlet, matches, isDataRoute:null != dataRouterState}, children});
        };
        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || 0 === index) ? React__namespace.createElement(RenderErrorBoundary, {location:dataRouterState.location, revalidation:dataRouterState.revalidation, component:errorElement, error, children:getChildren(), routeContext:{outlet:null, matches, isDataRoute:!0}}) : getChildren();
      }, null);
    }
    function getDataRouterConsoleError(hookName) {
      return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
    }
    function useDataRouterContext(hookName) {
      let ctx = React__namespace.useContext(DataRouterContext);
      ctx || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = React__namespace.useContext(DataRouterStateContext);
      state || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));
      return state;
    }
    function useCurrentRouteId(hookName) {
      var route = React__namespace.useContext(RouteContext);
      route || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName));
      route = route.matches[route.matches.length - 1];
      route.route.id || router.UNSAFE_invariant(!1, hookName + ' can only be used on routes that contain a unique "id"');
      return route.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = React__namespace.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook.UseRouteError), routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
      return void 0 !== error ? error : null == (_state$errors = state.errors) ? void 0 : _state$errors[routeId];
    }
    function useAsyncValue() {
      let value = React__namespace.useContext(AwaitContext);
      return null == value ? void 0 : value._data;
    }
    function useNavigateStable() {
      let {router:router$1} = useDataRouterContext(DataRouterHook.UseNavigateStable), id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable), activeRef = React__namespace.useRef(!1);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = !0;
      });
      return React__namespace.useCallback(function(to, options) {
        void 0 === options && (options = {});
        router.UNSAFE_warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.");
        activeRef.current && ("number" === typeof to ? router$1.navigate(to) : router$1.navigate(to, _extends({fromRouteId:id}, options)));
      }, [router$1, id]);
    }
    function warningOnce(key, cond, message) {
      cond || alreadyWarned$1[key] || (alreadyWarned$1[key] = !0, router.UNSAFE_warning(!1, message));
    }
    function logV6DeprecationWarnings(renderFuture, routerFuture) {
      void 0 === (null == renderFuture ? void 0 : renderFuture.v7_startTransition) && logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
      void 0 !== (null == renderFuture ? void 0 : renderFuture.v7_relativeSplatPath) || routerFuture && routerFuture.v7_relativeSplatPath || logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
      routerFuture && (void 0 === routerFuture.v7_fetcherPersist && logDeprecation("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist"), void 0 === routerFuture.v7_normalizeFormMethod && logDeprecation("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod"), void 0 === routerFuture.v7_partialHydration && 
      logDeprecation("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration"), void 0 === routerFuture.v7_skipActionErrorRevalidation && logDeprecation("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation"));
    }
    function DataRoutes(_ref2) {
      let {routes, future, state} = _ref2;
      return useRoutesImpl(routes, void 0, state, future);
    }
    function Route(_props) {
      router.UNSAFE_invariant(!1, "A \x3cRoute\x3e is only ever to be used as the child of \x3cRoutes\x3e element, never rendered directly. Please wrap your \x3cRoute\x3e in a \x3cRoutes\x3e.");
    }
    function Router(_ref5) {
      let {basename:basenameProp = "/", children = null, location:locationProp, navigationType = router.Action.Pop, navigator, static:staticProp = !1, future} = _ref5;
      useInRouterContext() && router.UNSAFE_invariant(!1, "You cannot render a \x3cRouter\x3e inside another \x3cRouter\x3e. You should never have more than one in your app.");
      let basename = basenameProp.replace(/^\/*/, "/");
      _ref5 = React__namespace.useMemo(() => ({basename, navigator, static:staticProp, future:_extends({v7_relativeSplatPath:!1}, future)}), [basename, future, navigator, staticProp]);
      "string" === typeof locationProp && (locationProp = router.parsePath(locationProp));
      let {pathname = "/", search = "", hash = "", state = null, key = "default"} = locationProp, locationContext = React__namespace.useMemo(() => {
        let trailingPathname = router.stripBasename(pathname, basename);
        return null == trailingPathname ? null : {location:{pathname:trailingPathname, search, hash, state, key}, navigationType};
      }, [basename, pathname, search, hash, state, key, navigationType]);
      router.UNSAFE_warning(null != locationContext, '\x3cRouter basename\x3d"' + basename + '"\x3e is not able to match the URL ' + ('"' + pathname + search + hash + "\" because it does not start with the basename, so the \x3cRouter\x3e won't render anything."));
      return null == locationContext ? null : React__namespace.createElement(NavigationContext.Provider, {value:_ref5}, React__namespace.createElement(LocationContext.Provider, {children, value:locationContext}));
    }
    function ResolveAwait(_ref8) {
      ({children:_ref8} = _ref8);
      let data = useAsyncValue();
      _ref8 = "function" === typeof _ref8 ? _ref8(data) : _ref8;
      return React__namespace.createElement(React__namespace.Fragment, null, _ref8);
    }
    function createRoutesFromChildren(children, parentPath) {
      void 0 === parentPath && (parentPath = []);
      let routes = [];
      React__namespace.Children.forEach(children, (element, index) => {
        if (React__namespace.isValidElement(element)) {
          if (index = [...parentPath, index], element.type === React__namespace.Fragment) {
            routes.push.apply(routes, createRoutesFromChildren(element.props.children, index));
          } else {
            element.type !== Route && router.UNSAFE_invariant(!1, "[" + ("string" === typeof element.type ? element.type : element.type.name) + "] is not a \x3cRoute\x3e component. All component children of \x3cRoutes\x3e must be a \x3cRoute\x3e or \x3cReact.Fragment\x3e");
            element.props.index && element.props.children && router.UNSAFE_invariant(!1, "An index route cannot have child routes.");
            var route = {id:element.props.id || index.join("-"), caseSensitive:element.props.caseSensitive, element:element.props.element, Component:element.props.Component, index:element.props.index, path:element.props.path, loader:element.props.loader, action:element.props.action, errorElement:element.props.errorElement, ErrorBoundary:element.props.ErrorBoundary, hasErrorBoundary:null != element.props.ErrorBoundary || null != element.props.errorElement, shouldRevalidate:element.props.shouldRevalidate, 
            handle:element.props.handle, lazy:element.props.lazy};
            element.props.children && (route.children = createRoutesFromChildren(element.props.children, index));
            routes.push(route);
          }
        }
      });
      return routes;
    }
    function mapRouteProperties(route) {
      let updates = {hasErrorBoundary:null != route.ErrorBoundary || null != route.errorElement};
      route.Component && (route.element && router.UNSAFE_warning(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(updates, {element:React__namespace.createElement(route.Component), Component:void 0}));
      route.HydrateFallback && (route.hydrateFallbackElement && router.UNSAFE_warning(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(updates, {hydrateFallbackElement:React__namespace.createElement(route.HydrateFallback), HydrateFallback:void 0}));
      route.ErrorBoundary && (route.errorElement && router.UNSAFE_warning(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(updates, {errorElement:React__namespace.createElement(route.ErrorBoundary), ErrorBoundary:void 0}));
      return updates;
    }
    var React__namespace = function(e) {
      if (e && e.__esModule) {
        return e;
      }
      var n = Object.create(null);
      e && Object.keys(e).forEach(function(k) {
        if ("default" !== k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {enumerable:!0, get:function() {
            return e[k];
          }});
        }
      });
      n["default"] = e;
      return Object.freeze(n);
    }(React);
    const DataRouterContext = React__namespace.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    const DataRouterStateContext = React__namespace.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    const AwaitContext = React__namespace.createContext(null);
    AwaitContext.displayName = "Await";
    const NavigationContext = React__namespace.createContext(null);
    NavigationContext.displayName = "Navigation";
    const LocationContext = React__namespace.createContext(null);
    LocationContext.displayName = "Location";
    const RouteContext = React__namespace.createContext({outlet:null, matches:[], isDataRoute:!1});
    RouteContext.displayName = "Route";
    const RouteErrorContext = React__namespace.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    const OutletContext = React__namespace.createContext(null), defaultErrorElement = React__namespace.createElement(function() {
      var error = useRouteError();
      let message = router.isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error), stack = error instanceof Error ? error.stack : null, preStyles = {padding:"0.5rem", backgroundColor:"rgba(200,200,200, 0.5)"}, codeStyles = {padding:"2px 4px", backgroundColor:"rgba(200,200,200, 0.5)"};
      console.error("Error handled by React Router default ErrorBoundary:", error);
      error = React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement("p", null, "\ud83d\udcbf Hey developer \ud83d\udc4b"), React__namespace.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React__namespace.createElement("code", {style:codeStyles}, "ErrorBoundary"), " or", " ", React__namespace.createElement("code", {style:codeStyles}, "errorElement"), " prop on your route."));
      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement("h2", null, "Unexpected Application Error!"), React__namespace.createElement("h3", {style:{fontStyle:"italic"}}, message), stack ? React__namespace.createElement("pre", {style:preStyles}, stack) : null, error);
    }, null);
    class RenderErrorBoundary extends React__namespace.Component {
      constructor(props) {
        super(props);
        this.state = {location:props.location, revalidation:props.revalidation, error:props.error};
      }
      static getDerivedStateFromError(error) {
        return {error};
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location || "idle" !== state.revalidation && "idle" === props.revalidation ? {error:props.error, location:props.location, revalidation:props.revalidation} : {error:void 0 !== props.error ? props.error : state.error, location:state.location, revalidation:props.revalidation || state.revalidation};
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return void 0 !== this.state.error ? React__namespace.createElement(RouteContext.Provider, {value:this.props.routeContext}, React__namespace.createElement(RouteErrorContext.Provider, {value:this.state.error, children:this.props.component})) : this.props.children;
      }
    }
    var DataRouterHook = function(DataRouterHook) {
      DataRouterHook.UseBlocker = "useBlocker";
      DataRouterHook.UseRevalidator = "useRevalidator";
      DataRouterHook.UseNavigateStable = "useNavigate";
      return DataRouterHook;
    }(DataRouterHook || {}), DataRouterStateHook = function(DataRouterStateHook) {
      DataRouterStateHook.UseBlocker = "useBlocker";
      DataRouterStateHook.UseLoaderData = "useLoaderData";
      DataRouterStateHook.UseActionData = "useActionData";
      DataRouterStateHook.UseRouteError = "useRouteError";
      DataRouterStateHook.UseNavigation = "useNavigation";
      DataRouterStateHook.UseRouteLoaderData = "useRouteLoaderData";
      DataRouterStateHook.UseMatches = "useMatches";
      DataRouterStateHook.UseRevalidator = "useRevalidator";
      DataRouterStateHook.UseNavigateStable = "useNavigate";
      DataRouterStateHook.UseRouteId = "useRouteId";
      return DataRouterStateHook;
    }(DataRouterStateHook || {});
    let blockerId = 0;
    const alreadyWarned$1 = {}, alreadyWarned = {}, logDeprecation = (flag, msg, link) => {
      flag = "⚠️ React Router Future Flag Warning: " + msg + ". You can use the `" + (flag + "` future flag to opt-in early. For more information, see ") + (link + ".");
      alreadyWarned[flag] || (alreadyWarned[flag] = !0, console.warn(flag));
    }, startTransitionImpl = React__namespace.startTransition;
    var AwaitRenderStatus = function(AwaitRenderStatus) {
      AwaitRenderStatus[AwaitRenderStatus.pending = 0] = "pending";
      AwaitRenderStatus[AwaitRenderStatus.success = 1] = "success";
      AwaitRenderStatus[AwaitRenderStatus.error = 2] = "error";
      return AwaitRenderStatus;
    }(AwaitRenderStatus || {});
    const neverSettledPromise = new Promise(() => {
    });
    class AwaitErrorBoundary extends React__namespace.Component {
      constructor(props) {
        super(props);
        this.state = {error:null};
      }
      static getDerivedStateFromError(error) {
        return {error};
      }
      componentDidCatch(error, errorInfo) {
        console.error("\x3cAwait\x3e caught the following error during render", error, errorInfo);
      }
      render() {
        let {children, errorElement, resolve} = this.props, promise = null, status = AwaitRenderStatus.pending;
        if (resolve instanceof Promise) {
          if (this.state.error) {
            status = AwaitRenderStatus.error;
            let renderError = this.state.error;
            promise = Promise.reject().catch(() => {
            });
            Object.defineProperty(promise, "_tracked", {get:() => !0});
            Object.defineProperty(promise, "_error", {get:() => renderError});
          } else {
            resolve._tracked ? (promise = resolve, status = "_error" in promise ? AwaitRenderStatus.error : "_data" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (status = AwaitRenderStatus.pending, Object.defineProperty(resolve, "_tracked", {get:() => !0}), promise = resolve.then(data => Object.defineProperty(resolve, "_data", {get:() => data}), error => Object.defineProperty(resolve, "_error", {get:() => error})));
          }
        } else {
          status = AwaitRenderStatus.success, promise = Promise.resolve(), Object.defineProperty(promise, "_tracked", {get:() => !0}), Object.defineProperty(promise, "_data", {get:() => resolve});
        }
        if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {
          throw neverSettledPromise;
        }
        if (status === AwaitRenderStatus.error && !errorElement) {
          throw promise._error;
        }
        if (status === AwaitRenderStatus.error) {
          return React__namespace.createElement(AwaitContext.Provider, {value:promise, children:errorElement});
        }
        if (status === AwaitRenderStatus.success) {
          return React__namespace.createElement(AwaitContext.Provider, {value:promise, children});
        }
        throw promise;
      }
    }
    Object.defineProperty(exports, "AbortedDeferredError", {enumerable:!0, get:function() {
      return router.AbortedDeferredError;
    }});
    Object.defineProperty(exports, "NavigationType", {enumerable:!0, get:function() {
      return router.Action;
    }});
    Object.defineProperty(exports, "createPath", {enumerable:!0, get:function() {
      return router.createPath;
    }});
    Object.defineProperty(exports, "defer", {enumerable:!0, get:function() {
      return router.defer;
    }});
    Object.defineProperty(exports, "generatePath", {enumerable:!0, get:function() {
      return router.generatePath;
    }});
    Object.defineProperty(exports, "isRouteErrorResponse", {enumerable:!0, get:function() {
      return router.isRouteErrorResponse;
    }});
    Object.defineProperty(exports, "json", {enumerable:!0, get:function() {
      return router.json;
    }});
    Object.defineProperty(exports, "matchPath", {enumerable:!0, get:function() {
      return router.matchPath;
    }});
    Object.defineProperty(exports, "matchRoutes", {enumerable:!0, get:function() {
      return router.matchRoutes;
    }});
    Object.defineProperty(exports, "parsePath", {enumerable:!0, get:function() {
      return router.parsePath;
    }});
    Object.defineProperty(exports, "redirect", {enumerable:!0, get:function() {
      return router.redirect;
    }});
    Object.defineProperty(exports, "redirectDocument", {enumerable:!0, get:function() {
      return router.redirectDocument;
    }});
    Object.defineProperty(exports, "replace", {enumerable:!0, get:function() {
      return router.replace;
    }});
    Object.defineProperty(exports, "resolvePath", {enumerable:!0, get:function() {
      return router.resolvePath;
    }});
    exports.Await = function(_ref7) {
      let {children, errorElement, resolve} = _ref7;
      return React__namespace.createElement(AwaitErrorBoundary, {resolve, errorElement}, React__namespace.createElement(ResolveAwait, null, children));
    };
    exports.MemoryRouter = function(_ref3) {
      let {basename, children, initialEntries, initialIndex, future} = _ref3;
      _ref3 = React__namespace.useRef();
      null == _ref3.current && (_ref3.current = router.createMemoryHistory({initialEntries, initialIndex, v5Compat:!0}));
      let history = _ref3.current, [state, setStateImpl] = React__namespace.useState({action:history.action, location:history.location}), {v7_startTransition} = future || {}, setState = React__namespace.useCallback(newState => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
      React__namespace.useEffect(() => logV6DeprecationWarnings(future), [future]);
      return React__namespace.createElement(Router, {basename, children, location:state.location, navigationType:state.action, navigator:history, future});
    };
    exports.Navigate = function(_ref4) {
      let {to, replace, state, relative} = _ref4;
      useInRouterContext() || router.UNSAFE_invariant(!1, "\x3cNavigate\x3e may be used only in the context of a \x3cRouter\x3e component.");
      let {future, static:isStatic} = React__namespace.useContext(NavigationContext);
      router.UNSAFE_warning(!isStatic, "\x3cNavigate\x3e must not be used on the initial render in a \x3cStaticRouter\x3e. This is a no-op, but you should modify your code so the \x3cNavigate\x3e is only ever rendered in response to some user interaction or state change.");
      ({matches:_ref4} = React__namespace.useContext(RouteContext));
      let {pathname:locationPathname} = useLocation(), navigate = useNavigate();
      _ref4 = router.resolveTo(to, router.UNSAFE_getResolveToMatches(_ref4, future.v7_relativeSplatPath), locationPathname, "path" === relative);
      let jsonPath = JSON.stringify(_ref4);
      React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {replace, state, relative}), [navigate, jsonPath, relative, replace, state]);
      return null;
    };
    exports.Outlet = function(props) {
      return useOutlet(props.context);
    };
    exports.Route = Route;
    exports.Router = Router;
    exports.RouterProvider = function(_ref) {
      let {fallbackElement, router:router$1, future} = _ref, [state, setStateImpl] = React__namespace.useState(router$1.state), {v7_startTransition} = future || {}, setState = React__namespace.useCallback(newState => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);
      React__namespace.useEffect(() => {
        router.UNSAFE_warning(null == fallbackElement || !router$1.future.v7_partialHydration, "`\x3cRouterProvider fallbackElement\x3e` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
      }, []);
      let navigator = React__namespace.useMemo(() => ({createHref:router$1.createHref, encodeLocation:router$1.encodeLocation, go:n => router$1.navigate(n), push:(to, state, opts) => router$1.navigate(to, {state, preventScrollReset:null == opts ? void 0 : opts.preventScrollReset}), replace:(to, state, opts) => router$1.navigate(to, {replace:!0, state, preventScrollReset:null == opts ? void 0 : opts.preventScrollReset})}), [router$1]), basename = router$1.basename || "/";
      _ref = React__namespace.useMemo(() => ({router:router$1, navigator, static:!1, basename}), [router$1, navigator, basename]);
      React__namespace.useEffect(() => logV6DeprecationWarnings(future, router$1.future), [router$1, future]);
      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(DataRouterContext.Provider, {value:_ref}, React__namespace.createElement(DataRouterStateContext.Provider, {value:state}, React__namespace.createElement(Router, {basename, location:state.location, navigationType:state.historyAction, navigator, future:{v7_relativeSplatPath:router$1.future.v7_relativeSplatPath}}, state.initialized || router$1.future.v7_partialHydration ? React__namespace.createElement(DataRoutes, 
      {routes:router$1.routes, future:router$1.future, state}) : fallbackElement))), null);
    };
    exports.Routes = function(_ref6) {
      let {children, location} = _ref6;
      return useRoutes(createRoutesFromChildren(children), location);
    };
    exports.UNSAFE_DataRouterContext = DataRouterContext;
    exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;
    exports.UNSAFE_LocationContext = LocationContext;
    exports.UNSAFE_NavigationContext = NavigationContext;
    exports.UNSAFE_RouteContext = RouteContext;
    exports.UNSAFE_logV6DeprecationWarnings = logV6DeprecationWarnings;
    exports.UNSAFE_mapRouteProperties = mapRouteProperties;
    exports.UNSAFE_useRouteId = function() {
      return useCurrentRouteId(DataRouterStateHook.UseRouteId);
    };
    exports.UNSAFE_useRoutesImpl = useRoutesImpl;
    exports.createMemoryRouter = function(routes, opts) {
      return router.createRouter({basename:null == opts ? void 0 : opts.basename, future:_extends({}, null == opts ? void 0 : opts.future, {v7_prependBasename:!0}), history:router.createMemoryHistory({initialEntries:null == opts ? void 0 : opts.initialEntries, initialIndex:null == opts ? void 0 : opts.initialIndex}), hydrationData:null == opts ? void 0 : opts.hydrationData, routes, mapRouteProperties, dataStrategy:null == opts ? void 0 : opts.dataStrategy, patchRoutesOnNavigation:null == opts ? void 0 : 
      opts.patchRoutesOnNavigation}).initialize();
    };
    exports.createRoutesFromChildren = createRoutesFromChildren;
    exports.createRoutesFromElements = createRoutesFromChildren;
    exports.renderMatches = function(matches) {
      return _renderMatches(matches);
    };
    exports.useActionData = function() {
      let state = useDataRouterState(DataRouterStateHook.UseActionData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
      return state.actionData ? state.actionData[routeId] : void 0;
    };
    exports.useAsyncError = function() {
      let value = React__namespace.useContext(AwaitContext);
      return null == value ? void 0 : value._error;
    };
    exports.useAsyncValue = useAsyncValue;
    exports.useBlocker = function(shouldBlock) {
      let {router:router$1, basename} = useDataRouterContext(DataRouterHook.UseBlocker), state = useDataRouterState(DataRouterStateHook.UseBlocker), [blockerKey, setBlockerKey] = React__namespace.useState(""), blockerFunction = React__namespace.useCallback(arg => {
        if ("function" !== typeof shouldBlock) {
          return !!shouldBlock;
        }
        if ("/" === basename) {
          return shouldBlock(arg);
        }
        let {currentLocation, nextLocation, historyAction} = arg;
        return shouldBlock({currentLocation:_extends({}, currentLocation, {pathname:router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname}), nextLocation:_extends({}, nextLocation, {pathname:router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname}), historyAction});
      }, [basename, shouldBlock]);
      React__namespace.useEffect(() => {
        let key = String(++blockerId);
        setBlockerKey(key);
        return () => router$1.deleteBlocker(key);
      }, [router$1]);
      React__namespace.useEffect(() => {
        "" !== blockerKey && router$1.getBlocker(blockerKey, blockerFunction);
      }, [router$1, blockerKey, blockerFunction]);
      return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;
    };
    exports.useHref = function(to, _temp) {
      ({relative:_temp} = void 0 === _temp ? {} : _temp);
      useInRouterContext() || router.UNSAFE_invariant(!1, "useHref() may be used only in the context of a \x3cRouter\x3e component.");
      let {basename, navigator} = React__namespace.useContext(NavigationContext), {hash, pathname, search} = useResolvedPath(to, {relative:_temp});
      to = pathname;
      "/" !== basename && (to = "/" === pathname ? basename : router.joinPaths([basename, pathname]));
      return navigator.createHref({pathname:to, search, hash});
    };
    exports.useInRouterContext = useInRouterContext;
    exports.useLoaderData = function() {
      let state = useDataRouterState(DataRouterStateHook.UseLoaderData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
      if (state.errors && null != state.errors[routeId]) {
        console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
      } else {
        return state.loaderData[routeId];
      }
    };
    exports.useLocation = useLocation;
    exports.useMatch = function(pattern) {
      useInRouterContext() || router.UNSAFE_invariant(!1, "useMatch() may be used only in the context of a \x3cRouter\x3e component.");
      let {pathname} = useLocation();
      return React__namespace.useMemo(() => router.matchPath(pattern, router.UNSAFE_decodePath(pathname)), [pathname, pattern]);
    };
    exports.useMatches = function() {
      let {matches, loaderData} = useDataRouterState(DataRouterStateHook.UseMatches);
      return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
    };
    exports.useNavigate = useNavigate;
    exports.useNavigation = function() {
      return useDataRouterState(DataRouterStateHook.UseNavigation).navigation;
    };
    exports.useNavigationType = function() {
      return React__namespace.useContext(LocationContext).navigationType;
    };
    exports.useOutlet = useOutlet;
    exports.useOutletContext = function() {
      return React__namespace.useContext(OutletContext);
    };
    exports.useParams = function() {
      var {matches} = React__namespace.useContext(RouteContext);
      return (matches = matches[matches.length - 1]) ? matches.params : {};
    };
    exports.useResolvedPath = useResolvedPath;
    exports.useRevalidator = function() {
      let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator), state = useDataRouterState(DataRouterStateHook.UseRevalidator);
      return React__namespace.useMemo(() => ({revalidate:dataRouterContext.router.revalidate, state:state.revalidation}), [dataRouterContext.router.revalidate, state.revalidation]);
    };
    exports.useRouteError = useRouteError;
    exports.useRouteLoaderData = function(routeId) {
      return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId];
    };
    exports.useRoutes = useRoutes;
    Object.defineProperty(exports, "__esModule", {value:!0});
  });
};

//# sourceMappingURL=module$node_modules$react_router$dist$umd$react_router_development.js.map
