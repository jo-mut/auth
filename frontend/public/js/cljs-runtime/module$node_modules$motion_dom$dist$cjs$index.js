shadow$provide.module$node_modules$motion_dom$dist$cjs$index = function(global, require, module, exports) {
  function getValueTransition(transition, key) {
    return transition ? transition[key] || transition["default"] || transition : void 0;
  }
  function calcGeneratorDuration(generator) {
    let duration = 0, state = generator.next(duration);
    for (; !state.done && 20000 > duration;) {
      duration += 50, state = generator.next(duration);
    }
    return 20000 <= duration ? Infinity : duration;
  }
  function createGeneratorEasing(options, scale = 100, createGenerator) {
    const generator = createGenerator({...options, keyframes:[0, scale]}), duration = Math.min(calcGeneratorDuration(generator), 20000);
    return {type:"keyframes", ease:progress => generator.next(duration * progress).value / scale, duration:motionUtils.millisecondsToSeconds(duration)};
  }
  function isGenerator(type) {
    return "function" === typeof type;
  }
  function attachTimeline(animation, timeline) {
    animation.timeline = timeline;
    animation.onfinish = null;
  }
  function isWaapiSupportedEasing(easing) {
    return !!("function" === typeof easing && supportsLinearEasing() || !easing || "string" === typeof easing && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
  }
  function mapEasingToNativeEasing(easing, duration) {
    if (easing) {
      return "function" === typeof easing && supportsLinearEasing() ? generateLinearEasing(easing, duration) : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(segmentEasing => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
    }
  }
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function resolveElements(elementOrSelector, scope, selectorCache) {
    var _a;
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    }
    if ("string" === typeof elementOrSelector) {
      let root = document;
      scope && (root = scope.current);
      return (scope = null !== (_a = null === selectorCache || void 0 === selectorCache ? void 0 : selectorCache[elementOrSelector]) && void 0 !== _a ? _a : root.querySelectorAll(elementOrSelector)) ? Array.from(scope) : [];
    }
    return Array.from(elementOrSelector);
  }
  function setupGesture(elementOrSelector, options) {
    elementOrSelector = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    return [elementOrSelector, {passive:!0, ...options, signal:gestureAbortController.signal}, () => gestureAbortController.abort()];
  }
  function capturePointer(event, action) {
    action = `${action}PointerCapture`;
    if (event.target instanceof Element && action in event.target && void 0 !== event.pointerId) {
      try {
        event.target[action](event.pointerId);
      } catch (e) {
      }
    }
  }
  function isElementKeyboardAccessible(element) {
    return focusableElements.has(element.tagName) || -1 !== element.tabIndex;
  }
  function filterEvents(callback) {
    return event => {
      "Enter" === event.key && callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, {isPrimary:!0, bubbles:!0}));
  }
  function applyGeneratorOptions(options) {
    if (isGenerator(options.type)) {
      var _a = createGeneratorEasing(options, 100, options.type);
      options.ease = supportsLinearEasing() ? _a.ease : "easeOut";
      options.duration = motionUtils.secondsToMilliseconds(_a.duration);
      options.type = "keyframes";
    } else {
      options.duration = motionUtils.secondsToMilliseconds(null !== (_a = options.duration) && void 0 !== _a ? _a : 0.3), options.ease = options.ease || "easeOut";
    }
  }
  function getLayerName(pseudoElement) {
    return (pseudoElement = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\((.*?)\)/)) ? {layer:pseudoElement[2], type:pseudoElement[1]} : null;
  }
  function filterViewAnimations(animation) {
    var _a;
    ({effect:animation} = animation);
    return animation ? animation.target === document.documentElement && (null === (_a = animation.pseudoElement) || void 0 === _a ? void 0 : _a.startsWith("::view-transition")) : !1;
  }
  function hasTarget(target, targets) {
    return targets.has(target) && 0 < Object.keys(targets.get(target)).length;
  }
  function startViewAnimation(update, defaultOptions, targets) {
    if (!document.startViewTransition) {
      return new Promise(async resolve => {
        await update();
        resolve(new BaseGroupPlaybackControls([]));
      });
    }
    hasTarget("root", targets) || css.set(":root", {"view-transition-name":"none"});
    css.set("::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)", {"animation-timing-function":"linear !important"});
    css.commit();
    const transition = document.startViewTransition(async() => {
      await update();
    });
    transition.finished.finally(() => {
      css.remove();
    });
    return new Promise(resolve => {
      transition.ready.then(() => {
        var _a, generatedViewAnimations = document.getAnimations().filter(filterViewAnimations);
        const animations = [];
        targets.forEach((definition, target) => {
          for (const key of definitionNames) {
            if (!definition[key]) {
              continue;
            }
            const {keyframes, options} = definition[key];
            for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {
              if (!valueKeyframes) {
                continue;
              }
              var valueOptions = {...getValueTransition(defaultOptions, valueName), ...getValueTransition(options, valueName)};
              const type = "layout" === key ? "group" : "enter" === key || "new" === key ? "new" : "exit" === key || "old" === key ? "old" : "group";
              "opacity" !== valueName || Array.isArray(valueKeyframes) || (valueKeyframes = ["new" === type ? 0 : 1, valueKeyframes]);
              "function" === typeof valueOptions.delay && (valueOptions.delay = valueOptions.delay(0, 1));
              valueOptions = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);
              animations.push(valueOptions);
            }
          }
        });
        for (const animation of generatedViewAnimations) {
          if ("finished" !== animation.playState && ({effect:generatedViewAnimations} = animation, generatedViewAnimations && generatedViewAnimations instanceof KeyframeEffect)) {
            var {pseudoElement} = generatedViewAnimations;
            if (pseudoElement && (pseudoElement = getLayerName(pseudoElement))) {
              var targetDefinition = targets.get(pseudoElement.layer);
              targetDefinition ? hasOpacity(targetDefinition, "enter") && hasOpacity(targetDefinition, "exit") && generatedViewAnimations.getKeyframes().some(keyframe => keyframe.mixBlendMode) ? animations.push(new NativeAnimationControls(animation)) : animation.cancel() : (pseudoElement = {...getValueTransition(defaultOptions, "group" === pseudoElement.type ? "layout" : "")}, applyGeneratorOptions(pseudoElement), targetDefinition = mapEasingToNativeEasing(pseudoElement.ease, pseudoElement.duration), 
              generatedViewAnimations.updateTiming({delay:motionUtils.secondsToMilliseconds(null !== (_a = pseudoElement.delay) && void 0 !== _a ? _a : 0), duration:pseudoElement.duration, easing:targetDefinition}), animations.push(new NativeAnimationControls(animation)));
            }
          }
        }
        resolve(new BaseGroupPlaybackControls(animations));
      });
    });
  }
  function hasOpacity(target, key) {
    var _a;
    return null === (_a = null === target || void 0 === target ? void 0 : target[key]) || void 0 === _a ? void 0 : _a.keyframes.opacity;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var motionUtils = require("module$node_modules$motion_utils$dist$cjs$index");
  const supportsScrollTimeline = motionUtils.memo(() => void 0 !== window.ScrollTimeline);
  class BaseGroupPlaybackControls {
    constructor(animations) {
      this.stop = () => this.runAll("stop");
      this.animations = animations.filter(Boolean);
    }
    get finished() {
      return Promise.all(this.animations.map(animation => "finished" in animation ? animation.finished : animation));
    }
    getAll(propName) {
      return this.animations[0][propName];
    }
    setAll(propName, newValue) {
      for (let i = 0; i < this.animations.length; i++) {
        this.animations[i][propName] = newValue;
      }
    }
    attachTimeline(timeline, fallback) {
      const subscriptions = this.animations.map(animation => {
        if (supportsScrollTimeline() && animation.attachTimeline) {
          return animation.attachTimeline(timeline);
        }
        if ("function" === typeof fallback) {
          return fallback(animation);
        }
      });
      return () => {
        subscriptions.forEach((cancel, i) => {
          cancel && cancel();
          this.animations[i].stop();
        });
      };
    }
    get time() {
      return this.getAll("time");
    }
    set time(time) {
      this.setAll("time", time);
    }
    get speed() {
      return this.getAll("speed");
    }
    set speed(speed) {
      this.setAll("speed", speed);
    }
    get startTime() {
      return this.getAll("startTime");
    }
    get duration() {
      let max = 0;
      for (let i = 0; i < this.animations.length; i++) {
        max = Math.max(max, this.animations[i].duration);
      }
      return max;
    }
    runAll(methodName) {
      this.animations.forEach(controls => controls[methodName]());
    }
    flatten() {
      this.runAll("flatten");
    }
    play() {
      this.runAll("play");
    }
    pause() {
      this.runAll("pause");
    }
    cancel() {
      this.runAll("cancel");
    }
    complete() {
      this.runAll("complete");
    }
  }
  class GroupPlaybackControls extends BaseGroupPlaybackControls {
    then(onResolve, onReject) {
      return Promise.all(this.animations).then(onResolve).catch(onReject);
    }
  }
  class NativeAnimationControls {
    constructor(animation) {
      this.animation = animation;
    }
    get duration() {
      var _a, _b, _c;
      const durationInMs = (null === (_b = null === (_a = this.animation) || void 0 === _a ? void 0 : _a.effect) || void 0 === _b ? void 0 : _b.getComputedTiming().duration) || (null === (_c = this.options) || void 0 === _c ? void 0 : _c.duration) || 300;
      return motionUtils.millisecondsToSeconds(Number(durationInMs));
    }
    get time() {
      var _a;
      return this.animation ? motionUtils.millisecondsToSeconds((null === (_a = this.animation) || void 0 === _a ? void 0 : _a.currentTime) || 0) : 0;
    }
    set time(newTime) {
      this.animation && (this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime));
    }
    get speed() {
      return this.animation ? this.animation.playbackRate : 1;
    }
    set speed(newSpeed) {
      this.animation && (this.animation.playbackRate = newSpeed);
    }
    get state() {
      return this.animation ? this.animation.playState : "finished";
    }
    get startTime() {
      return this.animation ? this.animation.startTime : null;
    }
    get finished() {
      return this.animation ? this.animation.finished : Promise.resolve();
    }
    play() {
      this.animation && this.animation.play();
    }
    pause() {
      this.animation && this.animation.pause();
    }
    stop() {
      this.animation && "idle" !== this.state && "finished" !== this.state && (this.animation.commitStyles && this.animation.commitStyles(), this.cancel());
    }
    flatten() {
      var _a;
      this.animation && (null === (_a = this.animation.effect) || void 0 === _a || _a.updateTiming({easing:"linear"}));
    }
    attachTimeline(timeline) {
      this.animation && attachTimeline(this.animation, timeline);
      return motionUtils.noop;
    }
    complete() {
      this.animation && this.animation.finish();
    }
    cancel() {
      try {
        this.animation && this.animation.cancel();
      } catch (e) {
      }
    }
  }
  const isBezierDefinition = easing => Array.isArray(easing) && "number" === typeof easing[0], supportsFlags = {linearEasing:void 0}, supportsLinearEasing = function(callback, supportsFlag) {
    const memoized = motionUtils.memo(callback);
    return () => {
      var _a;
      return null !== (_a = supportsFlags[supportsFlag]) && void 0 !== _a ? _a : memoized();
    };
  }(() => {
    try {
      document.createElement("div").animate({opacity:0}, {easing:"linear(0, 1)"});
    } catch (e) {
      return !1;
    }
    return !0;
  }, "linearEasing"), generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    duration = Math.max(Math.round(duration / resolution), 2);
    for (resolution = 0; resolution < duration; resolution++) {
      points += easing(motionUtils.progress(0, duration - 1, resolution)) + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  }, cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`, supportedWaapiEasing = {linear:"linear", ease:"ease", easeIn:"ease-in", easeOut:"ease-out", easeInOut:"ease-in-out", circIn:cubicBezierAsString([0, 0.65, 0.55, 1]), circOut:cubicBezierAsString([0.55, 0, 1, 0.45]), backIn:cubicBezierAsString([0.31, 0.01, 0.66, -0.59]), backOut:cubicBezierAsString([0.33, 1.53, 0.69, 0.99])}, isDragging = {x:!1, y:!1}, isNodeOrChild = (parent, child) => child ? parent === child ? !0 : 
  isNodeOrChild(parent, child.parentElement) : !1, isPrimaryPointer = event => "mouse" === event.pointerType ? "number" !== typeof event.button || 0 >= event.button : !1 !== event.isPrimary, focusableElements = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]), isPressing = new WeakSet(), enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (element) {
      var handleKeydown = filterEvents(() => {
        if (!isPressing.has(element)) {
          firePointerEvent(element, "down");
          var handleKeyup = filterEvents(() => {
            firePointerEvent(element, "up");
          });
          element.addEventListener("keyup", handleKeyup, eventOptions);
          element.addEventListener("blur", () => firePointerEvent(element, "cancel"), eventOptions);
        }
      });
      element.addEventListener("keydown", handleKeydown, eventOptions);
      element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
    }
  };
  class PseudoAnimation extends NativeAnimationControls {
    constructor(target, pseudoElement, valueName, keyframes, options) {
      var _a;
      const nativeKeyframes = {}, nativeOptions = {fill:"both", easing:"linear", composite:"replace"};
      nativeOptions.delay = motionUtils.secondsToMilliseconds(null !== (_a = options.delay) && void 0 !== _a ? _a : 0);
      applyGeneratorOptions(options);
      nativeOptions.duration = options.duration;
      const {ease, times} = options;
      times && (nativeKeyframes.offset = times);
      nativeKeyframes[valueName] = keyframes;
      valueName = mapEasingToNativeEasing(ease, options.duration);
      Array.isArray(valueName) ? nativeKeyframes.easing = valueName : nativeOptions.easing = valueName;
      super(target.animate(nativeKeyframes, {pseudoElement, ...nativeOptions}));
    }
  }
  let pendingRules = {}, style = null;
  const css = {set:(selector, values) => {
    pendingRules[selector] = values;
  }, commit:() => {
    style || (style = document.createElement("style"), style.id = "motion-view");
    let cssText = "";
    for (const selector in pendingRules) {
      const rule = pendingRules[selector];
      cssText += `${selector} {\n`;
      for (const [property, value] of Object.entries(rule)) {
        cssText += `  ${property}: ${value};\n`;
      }
      cssText += "}\n";
    }
    style.textContent = cssText;
    document.head.appendChild(style);
    pendingRules = {};
  }, remove:() => {
    style && style.parentElement && style.parentElement.removeChild(style);
  }}, definitionNames = ["layout", "enter", "exit", "new", "old"];
  class ViewTransitionBuilder {
    constructor(update, options = {}) {
      this.currentTarget = "root";
      this.targets = new Map();
      this.notifyReady = motionUtils.noop;
      this.readyPromise = new Promise(resolve => {
        this.notifyReady = resolve;
      });
      queueMicrotask(() => {
        startViewAnimation(update, options, this.targets).then(animation => this.notifyReady(animation));
      });
    }
    get(selector) {
      this.currentTarget = selector;
      return this;
    }
    layout(keyframes, options) {
      this.updateTarget("layout", keyframes, options);
      return this;
    }
    new(keyframes, options) {
      this.updateTarget("new", keyframes, options);
      return this;
    }
    old(keyframes, options) {
      this.updateTarget("old", keyframes, options);
      return this;
    }
    enter(keyframes, options) {
      this.updateTarget("enter", keyframes, options);
      return this;
    }
    exit(keyframes, options) {
      this.updateTarget("exit", keyframes, options);
      return this;
    }
    crossfade(options) {
      this.updateTarget("enter", {opacity:1}, options);
      this.updateTarget("exit", {opacity:0}, options);
      return this;
    }
    updateTarget(target, keyframes, options = {}) {
      const {currentTarget, targets} = this;
      targets.has(currentTarget) || targets.set(currentTarget, {});
      targets.get(currentTarget)[target] = {keyframes, options};
    }
    then(resolve, reject) {
      return this.readyPromise.then(resolve, reject);
    }
  }
  exports.GroupPlaybackControls = GroupPlaybackControls;
  exports.NativeAnimationControls = NativeAnimationControls;
  exports.ViewTransitionBuilder = ViewTransitionBuilder;
  exports.attachTimeline = attachTimeline;
  exports.calcGeneratorDuration = calcGeneratorDuration;
  exports.capturePointer = capturePointer;
  exports.createGeneratorEasing = createGeneratorEasing;
  exports.cubicBezierAsString = cubicBezierAsString;
  exports.generateLinearEasing = generateLinearEasing;
  exports.getValueTransition = getValueTransition;
  exports.hover = function(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options), onPointerEnter = enterEvent => {
      if ("touch" !== enterEvent.pointerType && !isDragActive()) {
        var {target} = enterEvent, onHoverEnd = onHoverStart(target, enterEvent);
        if ("function" === typeof onHoverEnd && target) {
          var onPointerLeave = leaveEvent => {
            "touch" === leaveEvent.pointerType || isDragActive() || (onHoverEnd(leaveEvent), target.removeEventListener("pointerleave", onPointerLeave));
          };
          target.addEventListener("pointerleave", onPointerLeave, eventOptions);
        }
      }
    };
    elements.forEach(element => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  };
  exports.isBezierDefinition = isBezierDefinition;
  exports.isDragActive = isDragActive;
  exports.isDragging = isDragging;
  exports.isGenerator = isGenerator;
  exports.isNodeOrChild = isNodeOrChild;
  exports.isPrimaryPointer = isPrimaryPointer;
  exports.isWaapiSupportedEasing = isWaapiSupportedEasing;
  exports.mapEasingToNativeEasing = mapEasingToNativeEasing;
  exports.maxGeneratorDuration = 20000;
  exports.press = function(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options), startPress = startEvent => {
      const target = startEvent.currentTarget;
      if (target && isPrimaryPointer(startEvent) && !isDragActive() && !isPressing.has(target)) {
        isPressing.add(target);
        capturePointer(startEvent, "set");
        var onPressEnd = onPressStart(target, startEvent), onPointerEnd = (endEvent, success) => {
          target.removeEventListener("pointerup", onPointerUp);
          target.removeEventListener("pointercancel", onPointerCancel);
          capturePointer(endEvent, "release");
          isPrimaryPointer(endEvent) && !isDragActive() && isPressing.has(target) && (isPressing.delete(target), "function" === typeof onPressEnd && onPressEnd(endEvent, {success}));
        }, onPointerUp = upEvent => {
          if (upEvent.isTrusted) {
            var JSCompiler_temp = target instanceof Element ? target.getBoundingClientRect() : {left:0, top:0, right:window.innerWidth, bottom:window.innerHeight};
            JSCompiler_temp = upEvent.clientX < JSCompiler_temp.left || upEvent.clientX > JSCompiler_temp.right || upEvent.clientY < JSCompiler_temp.top || upEvent.clientY > JSCompiler_temp.bottom;
          } else {
            JSCompiler_temp = !1;
          }
          JSCompiler_temp ? onPointerEnd(upEvent, !1) : onPointerEnd(upEvent, !(target instanceof Element) || isNodeOrChild(target, upEvent.target));
        }, onPointerCancel = cancelEvent => {
          onPointerEnd(cancelEvent, !1);
        };
        target.addEventListener("pointerup", onPointerUp, eventOptions);
        target.addEventListener("pointercancel", onPointerCancel, eventOptions);
        target.addEventListener("lostpointercapture", onPointerCancel, eventOptions);
      }
    };
    targets.forEach(target => {
      target = options.useGlobalTarget ? window : target;
      let canAddKeyboardAccessibility = !1;
      target instanceof HTMLElement && (canAddKeyboardAccessibility = !0, isElementKeyboardAccessible(target) || null !== target.getAttribute("tabindex") || (target.tabIndex = 0));
      target.addEventListener("pointerdown", startPress, eventOptions);
      canAddKeyboardAccessibility && target.addEventListener("focus", event => enableKeyboardPress(event, eventOptions), eventOptions);
    });
    return cancelEvents;
  };
  exports.resolveElements = resolveElements;
  exports.setDragLock = function(axis) {
    if ("x" === axis || "y" === axis) {
      if (isDragging[axis]) {
        return null;
      }
      isDragging[axis] = !0;
      return () => {
        isDragging[axis] = !1;
      };
    }
    if (isDragging.x || isDragging.y) {
      return null;
    }
    isDragging.x = isDragging.y = !0;
    return () => {
      isDragging.x = isDragging.y = !1;
    };
  };
  exports.supportedWaapiEasing = supportedWaapiEasing;
  exports.supportsFlags = supportsFlags;
  exports.supportsLinearEasing = supportsLinearEasing;
  exports.supportsScrollTimeline = supportsScrollTimeline;
  exports.view = function(update, defaultOptions = {}) {
    return new ViewTransitionBuilder(update, defaultOptions);
  };
};

//# sourceMappingURL=module$node_modules$motion_dom$dist$cjs$index.js.map
