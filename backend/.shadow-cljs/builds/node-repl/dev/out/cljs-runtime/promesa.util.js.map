{"version":3,"sources":["promesa/util.cljc"],"mappings":";AAuEA,iCAAA,jCAAMA,0EACHC,MAAMC;AADT,AAEE,IAAMC,WAAQ,6CAAA,7CAACC,+EACK,AAACC,4CAAI,WAAKC;AAAL,AAAa,OAAkBA;IACpC,AAA4BL;AAFhD,AAGE,OAACM,0BAAUJ,SAAQD;;AAEvB,2BAAA,3BAAMM,8DACHC;AADH,AAEE,GAAI,AAACC,uBAAOD;AACV,OAACE,gBAAMF;;AACPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qGAaYK;;IAAAA;;;;uGACEA;;IAAAA;;;;;;;;;;;;;;;;;;;;;;;;AAZlB,qBAAA,rBAAMF;AAAN,AASK,YAAAC,iCAAA","names":["promesa.util/has-method?","klass","name","methods","cljs.core.into","cljs.core.map","method","cljs.core/contains?","promesa.util/maybe-deref","o","cljs.core/delay?","cljs.core/deref","promesa.util/mutex","promesa.util/t_promesa$util12195","_"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns ^:no-doc promesa.util\n  (:require [promesa.protocols :as pt])\n  #?(:clj\n     (:import\n      java.lang.reflect.Method\n      java.time.Duration\n      java.util.concurrent.CompletionException\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.CountDownLatch\n      java.util.concurrent.locks.ReentrantLock\n      ;; java.util.function.BiConsumer\n      ;; java.util.function.BiFunction\n      ;; java.util.function.Consumer\n      ;; java.util.function.Function\n      ;; java.util.function.Supplier\n      )))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n#?(:clj\n   (extend-protocol clojure.core/Inst\n     Duration\n     (inst-ms* [v] (.toMillis ^Duration v))))\n\n#?(:clj\n   (deftype Supplier [f]\n     java.util.function.Supplier\n     (get [_] (f))))\n\n#?(:clj\n   (deftype Function [f]\n     java.util.function.Function\n     (apply [_ v]\n       (f v))))\n\n#?(:clj\n   (def f-identity (->Function identity)))\n\n#?(:clj\n   (defn unwrap-completion-stage\n     {:no-doc true}\n     [it]\n     (.thenCompose ^CompletionStage it\n                   ^java.util.function.Function f-identity)))\n\n#?(:clj\n   (defn unwrap-completion-exception\n     {:no-doc true}\n     [cause]\n     (if (instance? CompletionException cause)\n       (.getCause ^CompletionException cause)\n       cause)))\n\n#?(:clj\n   (deftype Function2 [f]\n     java.util.function.BiFunction\n     (apply [_ r e]\n       (f r (unwrap-completion-exception e)))))\n\n#?(:clj\n   (deftype Consumer2 [f]\n     java.util.function.BiConsumer\n     (accept [_ r e]\n       (f r (unwrap-completion-exception e)))))\n\n(defn has-method?\n  [klass name]\n  (let [methods (into #{}\n                      (map (fn [method] (.getName ^Method method)))\n                      (.getDeclaredMethods ^Class klass))]\n    (contains? methods name)))\n\n(defn maybe-deref\n  [o]\n  (if (delay? o)\n    (deref o)\n    o))\n\n(defn mutex\n  []\n  #?(:clj\n     (let [m (ReentrantLock.)]\n       (reify\n         pt/ILock\n         (-lock! [_] (.lock m))\n         (-unlock! [_] (.unlock m))))\n     :cljs\n     (reify\n       pt/ILock\n       (-lock! [_])\n       (-unlock! [_]))))\n\n#?(:clj\n(defn count-down-latch\n  [n]\n  (let [cdown (CountDownLatch. (int n))]\n    (reify\n      pt/IAwaitable\n      (-await! [_] (pt/-await! cdown))\n      (-await! [_ d] (pt/-await! cdown d))\n\n      clojure.lang.IFn\n      (invoke [_]\n        (.countDown ^CountDownLatch cdown))\n      (invoke [_ _]\n        (.countDown ^CountDownLatch cdown))\n      (invoke [_ _ _]\n        (.countDown ^CountDownLatch cdown))))))\n\n#?(:clj\n(defn wait-all!\n  [promises]\n  (let [total (count promises)]\n    (when (pos? total)\n      (let [cdown-fn (count-down-latch total)]\n        (doseq [p promises]\n          (pt/-finally p cdown-fn))\n        (pt/-await! cdown-fn))))))\n"],"x_google_ignoreList":[0]}