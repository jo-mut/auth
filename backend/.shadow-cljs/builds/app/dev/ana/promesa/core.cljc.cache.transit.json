["^ ","~:output",["^ ","~:js","goog.provide('promesa.core');\n/**\n * Return a resolved promise with provided value.\n */\npromesa.core.resolved = (function promesa$core$resolved(v){\nreturn promesa.impl.resolved(v);\n});\n/**\n * Return a rejected promise with provided reason.\n */\npromesa.core.rejected = (function promesa$core$rejected(v){\nreturn promesa.impl.rejected(v);\n});\n/**\n * Creates an empty promise instance.\n */\npromesa.core.deferred = (function promesa$core$deferred(){\nreturn promesa.impl.deferred();\n});\n/**\n * The coerce based promise constructor. Creates an appropriate promise\n *   instance depending on the provided value.\n * \n *   If an executor is provided, it will be used to resolve this\n *   promise.\n */\npromesa.core.promise = (function promesa$core$promise(var_args){\nvar G__12264 = arguments.length;\nswitch (G__12264) {\ncase 1:\nreturn promesa.core.promise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.promise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.promise.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn promesa.protocols._promise(v);\n}));\n\n(promesa.core.promise.cljs$core$IFn$_invoke$arity$2 = (function (v,executor){\nreturn promesa.protocols._map(promesa.protocols._promise(v),cljs.core.identity,executor);\n}));\n\n(promesa.core.promise.cljs$lang$maxFixedArity = 2);\n\n/**\n * A convenience alias for `promise` coercion function that only accepts\n *   a single argument.\n */\npromesa.core.wrap = (function promesa$core$wrap(v){\nreturn promesa.protocols._promise(v);\n});\n/**\n * Create a promise instance from a factory function. If an executor is\n *   provided, the factory will be executed in the provided executor.\n * \n *   A factory function looks like `(fn [resolve reject] (resolve 1))`.\n */\npromesa.core.create = (function promesa$core$create(var_args){\nvar G__12270 = arguments.length;\nswitch (G__12270) {\ncase 1:\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.create.cljs$core$IFn$_invoke$arity$1 = (function (f){\nvar d = promesa.impl.deferred();\ntry{var G__12272_12377 = (function (p1__12265_SHARP_){\nreturn promesa.protocols._resolve_BANG_(d,p1__12265_SHARP_);\n});\nvar G__12273_12378 = (function (p1__12266_SHARP_){\nreturn promesa.protocols._reject_BANG_(d,p1__12266_SHARP_);\n});\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__12272_12377,G__12273_12378) : f.call(null, G__12272_12377,G__12273_12378));\n}catch (e12271){var e_12379 = e12271;\npromesa.protocols._reject_BANG_(d,e_12379);\n}\nreturn d;\n}));\n\n(promesa.core.create.cljs$core$IFn$_invoke$arity$2 = (function (f,executor){\nvar d = promesa.impl.deferred();\npromesa.exec.run_BANG_.cljs$core$IFn$_invoke$arity$2(executor,(function (){\ntry{var G__12275 = (function (p1__12267_SHARP_){\nreturn promesa.protocols._resolve_BANG_(d,p1__12267_SHARP_);\n});\nvar G__12276 = (function (p1__12268_SHARP_){\nreturn promesa.protocols._reject_BANG_(d,p1__12268_SHARP_);\n});\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__12275,G__12276) : f.call(null, G__12275,G__12276));\n}catch (e12274){var e = e12274;\nreturn promesa.protocols._reject_BANG_(d,e);\n}}));\n\nreturn d;\n}));\n\n(promesa.core.create.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return true if `v` is a promise instance.\n */\npromesa.core.promise_QMARK_ = (function promesa$core$promise_QMARK_(v){\nif((!((v == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === v.promesa$protocols$IPromise$)))){\nreturn true;\n} else {\nif((!v.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(promesa.protocols.IPromise,v);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(promesa.protocols.IPromise,v);\n}\n});\n/**\n * Return true if `v` is a promise instance (alias to `promise?`).\n */\npromesa.core.deferred_QMARK_ = (function promesa$core$deferred_QMARK_(v){\nreturn (v instanceof promesa.impl._STAR_default_promise_STAR_);\n});\n/**\n * Returns true if `v` is a promise like object.\n */\npromesa.core.thenable_QMARK_ = (function promesa$core$thenable_QMARK_(v){\nreturn ((cljs.core.object_QMARK_(v)) && (cljs.core.fn_QMARK_((v[\"then\"]))));\n});\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   successfully resolved. Returns a promise that will be resolved with\n *   the return value of calling `f` with value as single argument; `f`\n *   can return a plain value or promise instance, an automatic\n *   unwrapping will be performed.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n */\npromesa.core.then = (function promesa$core$then(var_args){\nvar G__12279 = arguments.length;\nswitch (G__12279) {\ncase 2:\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.then.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),cljs.core.comp.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise,f));\n}));\n\n(promesa.core.then.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),cljs.core.comp.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise,f),executor);\n}));\n\n(promesa.core.then.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   successfully resolved. Returns a promise that will be resolved with\n *   the return value of calling `f` with value as single argument; `f`\n *   should return a plain value, no automatic unwrapping will be\n *   performed.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n */\npromesa.core.then_SINGLEQUOTE_ = (function promesa$core$then_SINGLEQUOTE_(var_args){\nvar G__12281 = arguments.length;\nswitch (G__12281) {\ncase 2:\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.then_SINGLEQUOTE_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed with when the promise `p` is\n *   successfully resolved. Returns a promise that will mirror the\n *   promise instance returned by calling `f` with the value as single\n *   argument; `f` **must** return a promise instance.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n */\npromesa.core.bind = (function promesa$core$bind(var_args){\nvar G__12283 = arguments.length;\nswitch (G__12283) {\ncase 2:\nreturn promesa.core.bind.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.bind.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.bind.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.bind.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.bind.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   successfully resolved. Returns a promise that will be resolved with\n *   the return value of calling `f` with value as single argument.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   This function is intended to be used with `->>`.\n */\npromesa.core.map = (function promesa$core$map(var_args){\nvar G__12285 = arguments.length;\nswitch (G__12285) {\ncase 2:\nreturn promesa.core.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.map.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.map.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.map.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.map.cljs$lang$maxFixedArity = 3);\n\n/**\n * A convenience alias for `map`.\n */\npromesa.core.fmap = (function promesa$core$fmap(var_args){\nvar G__12287 = arguments.length;\nswitch (G__12287) {\ncase 2:\nreturn promesa.core.fmap.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.fmap.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.fmap.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.fmap.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.fmap.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   successfully resolved. Returns a promise that will mirror the\n *   promise instance returned by calling `f` with the value as single\n *   argument; `f` **must** return a promise instance.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   This funciton is intended to be used with `->>`.\n */\npromesa.core.mapcat = (function promesa$core$mapcat(var_args){\nvar G__12289 = arguments.length;\nswitch (G__12289) {\ncase 2:\nreturn promesa.core.mapcat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.mapcat.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.mapcat.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.mapcat.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.mapcat.cljs$lang$maxFixedArity = 3);\n\n/**\n * A convenience alias for `mapcat`.\n */\npromesa.core.mcat = (function promesa$core$mcat(var_args){\nvar G__12291 = arguments.length;\nswitch (G__12291) {\ncase 2:\nreturn promesa.core.mcat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.mcat.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.mcat.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.mcat.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.mcat.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chain variable number of functions to be executed serially using\n *   `then`.\n */\npromesa.core.chain = (function promesa$core$chain(var_args){\nvar G__12296 = arguments.length;\nswitch (G__12296) {\ncase 2:\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__5751__auto__ = [];\nvar len__5726__auto___12388 = arguments.length;\nvar i__5727__auto___12389 = (0);\nwhile(true){\nif((i__5727__auto___12389 < len__5726__auto___12388)){\nargs_arr__5751__auto__.push((arguments[i__5727__auto___12389]));\n\nvar G__12390 = (i__5727__auto___12389 + (1));\ni__5727__auto___12389 = G__12390;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5752__auto__ = ((((2) < args_arr__5751__auto__.length))?(new cljs.core.IndexedSeq(args_arr__5751__auto__.slice((2)),(0),null)):null);\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5752__auto__);\n\n}\n});\n\n(promesa.core.chain.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic = (function (p,f,fs){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(promesa.core.then,p,cljs.core.cons(f,fs));\n}));\n\n/** @this {Function} */\n(promesa.core.chain.cljs$lang$applyTo = (function (seq12293){\nvar G__12294 = cljs.core.first(seq12293);\nvar seq12293__$1 = cljs.core.next(seq12293);\nvar G__12295 = cljs.core.first(seq12293__$1);\nvar seq12293__$2 = cljs.core.next(seq12293__$1);\nvar self__5711__auto__ = this;\nreturn self__5711__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12294,G__12295,seq12293__$2);\n}));\n\n(promesa.core.chain.cljs$lang$maxFixedArity = (2));\n\n/**\n * Chain variable number of functions to be executed serially using\n *   `map`.\n */\npromesa.core.chain_SINGLEQUOTE_ = (function promesa$core$chain_SINGLEQUOTE_(var_args){\nvar G__12303 = arguments.length;\nswitch (G__12303) {\ncase 2:\nreturn promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__5751__auto__ = [];\nvar len__5726__auto___12392 = arguments.length;\nvar i__5727__auto___12393 = (0);\nwhile(true){\nif((i__5727__auto___12393 < len__5726__auto___12392)){\nargs_arr__5751__auto__.push((arguments[i__5727__auto___12393]));\n\nvar G__12394 = (i__5727__auto___12393 + (1));\ni__5727__auto___12393 = G__12394;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5752__auto__ = ((((2) < args_arr__5751__auto__.length))?(new cljs.core.IndexedSeq(args_arr__5751__auto__.slice((2)),(0),null)):null);\nreturn promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5752__auto__);\n\n}\n});\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic = (function (p,f,fs){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__12298_SHARP_,p2__12297_SHARP_){\nreturn promesa.core.map.cljs$core$IFn$_invoke$arity$2(p2__12297_SHARP_,p1__12298_SHARP_);\n}),promesa.protocols._promise(p),cljs.core.cons(f,fs));\n}));\n\n/** @this {Function} */\n(promesa.core.chain_SINGLEQUOTE_.cljs$lang$applyTo = (function (seq12300){\nvar G__12301 = cljs.core.first(seq12300);\nvar seq12300__$1 = cljs.core.next(seq12300);\nvar G__12302 = cljs.core.first(seq12300__$1);\nvar seq12300__$2 = cljs.core.next(seq12300__$1);\nvar self__5711__auto__ = this;\nreturn self__5711__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12301,G__12302,seq12300__$2);\n}));\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$lang$maxFixedArity = (2));\n\n/**\n * Chains a function `f` to be executed when the promise `p` is completed\n *   (resolved or rejected) and returns a promise completed (resolving or\n *   rejecting) with the return value of calling `f` with both: value and\n *   the exception; `f` can return a new plain value or promise instance,\n *   and automatic unwrapping will be performed.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   For performance sensitive code, look at `hmap` and `hcat`.\n */\npromesa.core.handle = (function promesa$core$handle(var_args){\nvar G__12305 = arguments.length;\nswitch (G__12305) {\ncase 2:\nreturn promesa.core.handle.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.handle.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.handle.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.handle.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.handle.cljs$lang$maxFixedArity = 3);\n\n/**\n * Like `handle` but ignores the return value. Returns a promise that\n *   will mirror the original one.\n */\npromesa.core.finally$ = (function promesa$core$finally(var_args){\nvar G__12307 = arguments.length;\nswitch (G__12307) {\ncase 2:\nreturn promesa.core.finally$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.finally$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.finally$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.finally$.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.finally$.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is completed\n *   (resolved or rejected) and returns a promise completed (resolving or\n *   rejecting) with the return value of calling `f` with both: value and\n *   the exception.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   Intended to be used with `->>`.\n */\npromesa.core.hmap = (function promesa$core$hmap(var_args){\nvar G__12309 = arguments.length;\nswitch (G__12309) {\ncase 2:\nreturn promesa.core.hmap.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.hmap.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.hmap.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.hmap.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.hmap.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is completed\n *   (resolved or rejected) and returns a promise that will mirror the\n *   promise instance returned by calling `f` with both: value and the\n *   exception.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   Intended to be used with `->>`.\n */\npromesa.core.hcat = (function promesa$core$hcat(var_args){\nvar G__12311 = arguments.length;\nswitch (G__12311) {\ncase 2:\nreturn promesa.core.hcat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.hcat.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.hcat.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.hcat.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.hcat.cljs$lang$maxFixedArity = 3);\n\n/**\n * Inverted arguments version of `finally`; intended to be used with\n *   `->>`.\n */\npromesa.core.fnly = (function promesa$core$fnly(var_args){\nvar G__12313 = arguments.length;\nswitch (G__12313) {\ncase 2:\nreturn promesa.core.fnly.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.fnly.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.fnly.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.fnly.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.fnly.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   rejected. Returns a promise that will be resolved with the return\n *   value of calling `f` with exception as single argument; `f` can\n *   return a plain value or promise instance, an automatic unwrapping\n *   will be performed.\n * \n *   The computation will be executed in the completion thread, look at\n *   `merr` if you want the ability to schedule the computation to other\n *   thread.\n */\npromesa.core.catch$ = (function promesa$core$catch(var_args){\nvar G__12316 = arguments.length;\nswitch (G__12316) {\ncase 2:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._catch(promesa.protocols._promise(p),cljs.core.comp.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise,f));\n}));\n\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\nvar accept_QMARK_ = ((cljs.core.ifn_QMARK_(pred_or_type))?pred_or_type:(function (p1__12314_SHARP_){\nreturn (p1__12314_SHARP_ instanceof pred_or_type);\n}));\nreturn promesa.protocols._catch(promesa.protocols._promise(p),(function (e){\nif(cljs.core.truth_((accept_QMARK_.cljs$core$IFn$_invoke$arity$1 ? accept_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : accept_QMARK_.call(null, e)))){\nreturn promesa.protocols._promise((f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null, e)));\n} else {\nreturn promesa.impl.rejected(e);\n}\n}));\n}));\n\n(promesa.core.catch$.cljs$lang$maxFixedArity = 3);\n\npromesa.core.catch_SINGLEQUOTE_ = (function promesa$core$catch_SINGLEQUOTE_(var_args){\nvar G__12318 = arguments.length;\nswitch (G__12318) {\ncase 2:\nreturn promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3(p,pred_or_type,f);\n}));\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$lang$maxFixedArity = 3);\n\npromesa.core.error = (function promesa$core$error(var_args){\nvar G__12320 = arguments.length;\nswitch (G__12320) {\ncase 2:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.error.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.error.cljs$core$IFn$_invoke$arity$3 = (function (f,pred_or_type,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3(p,cljs.core.type,f);\n}));\n\n(promesa.core.error.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a function `f` to be executed when the promise `p` is\n *   rejected. Returns a promise that will mirror the promise returned by\n *   calling `f` with exception as single argument; `f` **must** return a\n *   promise instance.\n * \n *   The computation will be executed in the completion thread by\n *   default; you also can provide a custom executor.\n * \n *   This is intended to be used with `->>`.\n */\npromesa.core.merr = (function promesa$core$merr(var_args){\nvar G__12322 = arguments.length;\nswitch (G__12322) {\ncase 2:\nreturn promesa.core.merr.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.merr.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.merr.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._catch(p,f);\n}));\n\n(promesa.core.merr.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._catch(p,f,executor);\n}));\n\n(promesa.core.merr.cljs$lang$maxFixedArity = 3);\n\n/**\n * Given an array of promises, return a promise that is fulfilled when\n *   all the items in the array are fulfilled.\n * \n *   Example:\n * \n *   ```\n *   (-> (p/all [(promise :first-promise)\n *            (promise :second-promise)])\n *    (then (fn [[first-result second-result]])\n *            (println (str first-result \", \" second-result))))\n *   ```\n * \n *   Will print to out `:first-promise, :second-promise`.\n * \n *   If at least one of the promises is rejected, the resulting promise\n *   will be rejected.\n */\npromesa.core.all = (function promesa$core$all(promises){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(promesa.impl._STAR_default_promise_STAR_.all(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises)),cljs.core.vec);\n});\npromesa.core.race = (function promesa$core$race(promises){\nreturn promesa.impl._STAR_default_promise_STAR_.race(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise,promises)));\n});\n/**\n * Given an array of promises, return a promise that is fulfilled when\n *   first one item in the array is fulfilled.\n */\npromesa.core.any = (function promesa$core$any(var_args){\nvar G__12324 = arguments.length;\nswitch (G__12324) {\ncase 1:\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.any.cljs$core$IFn$_invoke$arity$1 = (function (promises){\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$2(promises,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826));\n}));\n\n(promesa.core.any.cljs$core$IFn$_invoke$arity$2 = (function (promises,default$){\nvar items = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.EMPTY,promises);\nvar state = cljs.core.volatile_BANG_(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727),items,new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.PersistentVector.EMPTY,new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389),false], null));\nvar lock = promesa.util.mutex();\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((function (resolve,reject){\nvar seq__12325 = cljs.core.seq(promises);\nvar chunk__12326 = null;\nvar count__12327 = (0);\nvar i__12328 = (0);\nwhile(true){\nif((i__12328 < count__12327)){\nvar p = chunk__12326.cljs$core$IIndexed$_nth$arity$2(null, i__12328);\npromesa.protocols._handle(promesa.protocols._promise(p),((function (seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock){\nreturn (function (v,exception){\nlock.promesa$protocols$ILock$_lock_BANG_$arity$1(null, );\n\ntry{if(cljs.core.truth_(exception)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\nvar state__$1 = state.cljs$core$IVolatile$_vreset_BANG_$arity$2(null, ((function (seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.update.cljs$core$IFn$_invoke$arity$4(state__$1,new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727),cljs.core.disj,p),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.conj,exception);\n});})(seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock))\n(state.cljs$core$IDeref$_deref$arity$1(null, )));\nif(cljs.core.seq(new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727).cljs$core$IFn$_invoke$arity$1(state__$1))){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(default$,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nvar G__12333 = cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"No promises resolved\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911).cljs$core$IFn$_invoke$arity$1(state__$1)], null));\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(G__12333) : reject.call(null, G__12333));\n} else {\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(default$) : resolve.call(null, default$));\n}\n}\n}\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\nvar map__12334 = state.cljs$core$IVolatile$_vreset_BANG_$arity$2(null, ((function (seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389),true),new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727),cljs.core.disj,p);\n});})(seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock))\n(state.cljs$core$IDeref$_deref$arity$1(null, )));\nvar map__12334__$1 = cljs.core.__destructure_map(map__12334);\nvar pending = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12334__$1,new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727));\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null, v));\n}\n}\n}finally {lock.promesa$protocols$ILock$_unlock_BANG_$arity$1(null, );\n}});})(seq__12325,chunk__12326,count__12327,i__12328,p,items,state,lock))\n);\n\n\nvar G__12405 = seq__12325;\nvar G__12406 = chunk__12326;\nvar G__12407 = count__12327;\nvar G__12408 = (i__12328 + (1));\nseq__12325 = G__12405;\nchunk__12326 = G__12406;\ncount__12327 = G__12407;\ni__12328 = G__12408;\ncontinue;\n} else {\nvar temp__5804__auto__ = cljs.core.seq(seq__12325);\nif(temp__5804__auto__){\nvar seq__12325__$1 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__12325__$1)){\nvar c__5525__auto__ = cljs.core.chunk_first(seq__12325__$1);\nvar G__12409 = cljs.core.chunk_rest(seq__12325__$1);\nvar G__12410 = c__5525__auto__;\nvar G__12411 = cljs.core.count(c__5525__auto__);\nvar G__12412 = (0);\nseq__12325 = G__12409;\nchunk__12326 = G__12410;\ncount__12327 = G__12411;\ni__12328 = G__12412;\ncontinue;\n} else {\nvar p = cljs.core.first(seq__12325__$1);\npromesa.protocols._handle(promesa.protocols._promise(p),((function (seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock){\nreturn (function (v,exception){\nlock.promesa$protocols$ILock$_lock_BANG_$arity$1(null, );\n\ntry{if(cljs.core.truth_(exception)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\nvar state__$1 = state.cljs$core$IVolatile$_vreset_BANG_$arity$2(null, ((function (seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.update.cljs$core$IFn$_invoke$arity$4(state__$1,new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727),cljs.core.disj,p),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.conj,exception);\n});})(seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock))\n(state.cljs$core$IDeref$_deref$arity$1(null, )));\nif(cljs.core.seq(new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727).cljs$core$IFn$_invoke$arity$1(state__$1))){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(default$,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nvar G__12335 = cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"No promises resolved\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911).cljs$core$IFn$_invoke$arity$1(state__$1)], null));\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(G__12335) : reject.call(null, G__12335));\n} else {\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(default$) : resolve.call(null, default$));\n}\n}\n}\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\nvar map__12336 = state.cljs$core$IVolatile$_vreset_BANG_$arity$2(null, ((function (seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"resolved?\",\"resolved?\",862515389),true),new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727),cljs.core.disj,p);\n});})(seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock))\n(state.cljs$core$IDeref$_deref$arity$1(null, )));\nvar map__12336__$1 = cljs.core.__destructure_map(map__12336);\nvar pending = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12336__$1,new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727));\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null, v));\n}\n}\n}finally {lock.promesa$protocols$ILock$_unlock_BANG_$arity$1(null, );\n}});})(seq__12325,chunk__12326,count__12327,i__12328,p,seq__12325__$1,temp__5804__auto__,items,state,lock))\n);\n\n\nvar G__12413 = cljs.core.next(seq__12325__$1);\nvar G__12414 = null;\nvar G__12415 = (0);\nvar G__12416 = (0);\nseq__12325 = G__12413;\nchunk__12326 = G__12414;\ncount__12327 = G__12415;\ni__12328 = G__12416;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}));\n}));\n\n(promesa.core.any.cljs$lang$maxFixedArity = 2);\n\n/**\n * A promise aware run! function. Executed in terms of `then` rules.\n */\npromesa.core.run_BANG_ = (function promesa$core$run_BANG_(var_args){\nvar G__12340 = arguments.length;\nswitch (G__12340) {\ncase 2:\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3(f,coll,promesa.exec.default_current_thread_executor);\n}));\n\n(promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (f,coll,executor){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__12337_SHARP_,p2__12338_SHARP_){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(p1__12337_SHARP_,(function (_){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(p2__12338_SHARP_) : f.call(null, p2__12338_SHARP_));\n}));\n}),promesa.core.promise.cljs$core$IFn$_invoke$arity$2(null,executor),coll);\n}));\n\n(promesa.core.run_BANG_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Cancel the promise.\n */\npromesa.core.cancel_BANG_ = (function promesa$core$cancel_BANG_(p){\npromesa.protocols._cancel_BANG_(p);\n\nreturn p;\n});\n/**\n * Return true if `v` is a cancelled promise.\n */\npromesa.core.cancelled_QMARK_ = (function promesa$core$cancelled_QMARK_(v){\nreturn promesa.protocols._cancelled_QMARK_(v);\n});\n/**\n * Resolve a completable promise with a value.\n */\npromesa.core.resolve_BANG_ = (function promesa$core$resolve_BANG_(var_args){\nvar G__12342 = arguments.length;\nswitch (G__12342) {\ncase 1:\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$1 = (function (o){\nreturn promesa.protocols._resolve_BANG_(o,null);\n}));\n\n(promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (o,v){\nreturn promesa.protocols._resolve_BANG_(o,v);\n}));\n\n(promesa.core.resolve_BANG_.cljs$lang$maxFixedArity = 2);\n\n/**\n * Reject a completable promise with an error.\n */\npromesa.core.reject_BANG_ = (function promesa$core$reject_BANG_(p,e){\nreturn promesa.protocols._reject_BANG_(p,e);\n});\n/**\n * Given a function that accepts a callback as the last argument, return a\n *   function that returns a promise. Callback is expected to take one\n *   parameter (result of a computation).\n */\npromesa.core.promisify = (function promesa$core$promisify(callable){\nreturn (function() { \nvar G__12419__delegate = function (args){\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((function (resolve,reject){\nvar args__$1 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(args),resolve);\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(callable,args__$1);\n}catch (e12343){if((e12343 instanceof Error)){\nvar e = e12343;\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(e) : reject.call(null, e));\n} else {\nthrow e12343;\n\n}\n}}));\n};\nvar G__12419 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__12420__i = 0, G__12420__a = new Array(arguments.length -  0);\nwhile (G__12420__i < G__12420__a.length) {G__12420__a[G__12420__i] = arguments[G__12420__i + 0]; ++G__12420__i;}\n  args = new cljs.core.IndexedSeq(G__12420__a,0,null);\n} \nreturn G__12419__delegate.call(this,args);};\nG__12419.cljs$lang$maxFixedArity = 0;\nG__12419.cljs$lang$applyTo = (function (arglist__12421){\nvar args = cljs.core.seq(arglist__12421);\nreturn G__12419__delegate(args);\n});\nG__12419.cljs$core$IFn$_invoke$arity$variadic = G__12419__delegate;\nreturn G__12419;\n})()\n;\n});\n/**\n * @constructor\n */\npromesa.core.TimeoutException = (function promesa$core$TimeoutException(message){\nvar it = this;\nError.call(it,message,cljs.core.PersistentArrayMap.EMPTY,null);\n\nreturn it;\n});\ngoog.inherits(promesa.core.TimeoutException,Error);\n/**\n * Returns a cancellable promise that will be fulfilled with this\n *   promise's fulfillment value or rejection reason.  However, if this\n *   promise is not fulfilled or rejected within `ms` milliseconds, the\n *   returned promise is cancelled with a TimeoutError.\n */\npromesa.core.timeout = (function promesa$core$timeout(var_args){\nvar G__12345 = arguments.length;\nswitch (G__12345) {\ncase 2:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$2 = (function (p,t){\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4(p,t,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826),new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\n}));\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$3 = (function (p,t,v){\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4(p,t,v,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\n}));\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$4 = (function (p,t,v,scheduler){\nvar timeout = promesa.core.deferred();\nvar tid = promesa.exec.schedule_BANG_.cljs$core$IFn$_invoke$arity$3(scheduler,t,(function (){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(v,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nreturn promesa.core.reject_BANG_(timeout,(new promesa.core.TimeoutException(\"Operation timed out.\")));\n} else {\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2(timeout,v);\n}\n}));\nreturn promesa.core.race(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [promesa.core.fnly.cljs$core$IFn$_invoke$arity$2((function (_,___$1){\nreturn promesa.protocols._cancel_BANG_(tid);\n}),p),timeout], null));\n}));\n\n(promesa.core.timeout.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a timeout in miliseconds and optional value, returns a promise\n *   that will be fulfilled with provided value (or nil) after the time is\n *   reached.\n */\npromesa.core.delay = (function promesa$core$delay(var_args){\nvar G__12347 = arguments.length;\nswitch (G__12347) {\ncase 1:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$1 = (function (t){\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3(t,null,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\n}));\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$2 = (function (t,v){\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3(t,v,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\n}));\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$3 = (function (t,v,scheduler){\nvar d = promesa.core.deferred();\npromesa.exec.schedule_BANG_.cljs$core$IFn$_invoke$arity$3(scheduler,t,(function (){\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2(d,v);\n}));\n\nreturn d;\n}));\n\n(promesa.core.delay.cljs$lang$maxFixedArity = 3);\n\n/**\n * Analogous to `clojure.core.async/thread` that returns a promise\n *   instance instead of the `Future`. Useful for executing synchronous\n *   code in a separate thread (also works in cljs).\n */\npromesa.core.thread_call = (function promesa$core$thread_call(var_args){\nvar G__12353 = arguments.length;\nswitch (G__12353) {\ncase 1:\nreturn promesa.core.thread_call.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.thread_call.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.thread_call.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn promesa.exec.submit_BANG_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"thread\",\"thread\",947001524),promesa.exec.wrap_bindings(f));\n}));\n\n(promesa.core.thread_call.cljs$core$IFn$_invoke$arity$2 = (function (executor,f){\nreturn promesa.exec.submit_BANG_.cljs$core$IFn$_invoke$arity$2(executor,promesa.exec.wrap_bindings(f));\n}));\n\n(promesa.core.thread_call.cljs$lang$maxFixedArity = 2);\n\n/**\n * A shortcut for `(p/thread-call :vthread f)`.\n */\npromesa.core.vthread_call = (function promesa$core$vthread_call(f){\nreturn promesa.core.thread_call.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"vthread\",\"vthread\",441141075),f);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IRecord}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\npromesa.core.Recur = (function (bindings,__meta,__extmap,__hash){\nthis.bindings = bindings;\nthis.__meta = __meta;\nthis.__extmap = __extmap;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2230716170;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\n(promesa.core.Recur.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this__5300__auto__,k__5301__auto__){\nvar self__ = this;\nvar this__5300__auto____$1 = this;\nreturn this__5300__auto____$1.cljs$core$ILookup$_lookup$arity$3(null, k__5301__auto__,null);\n}));\n\n(promesa.core.Recur.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this__5302__auto__,k12355,else__5303__auto__){\nvar self__ = this;\nvar this__5302__auto____$1 = this;\nvar G__12359 = k12355;\nvar G__12359__$1 = (((G__12359 instanceof cljs.core.Keyword))?G__12359.fqn:null);\nswitch (G__12359__$1) {\ncase \"bindings\":\nreturn self__.bindings;\n\nbreak;\ndefault:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k12355,else__5303__auto__);\n\n}\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this__5320__auto__,f__5321__auto__,init__5322__auto__){\nvar self__ = this;\nvar this__5320__auto____$1 = this;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret__5323__auto__,p__12360){\nvar vec__12361 = p__12360;\nvar k__5324__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12361,(0),null);\nvar v__5325__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12361,(1),null);\nreturn (f__5321__auto__.cljs$core$IFn$_invoke$arity$3 ? f__5321__auto__.cljs$core$IFn$_invoke$arity$3(ret__5323__auto__,k__5324__auto__,v__5325__auto__) : f__5321__auto__.call(null, ret__5323__auto__,k__5324__auto__,v__5325__auto__));\n}),init__5322__auto__,this__5320__auto____$1);\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this__5315__auto__,writer__5316__auto__,opts__5317__auto__){\nvar self__ = this;\nvar this__5315__auto____$1 = this;\nvar pr_pair__5318__auto__ = (function (keyval__5319__auto__){\nreturn cljs.core.pr_sequential_writer(writer__5316__auto__,cljs.core.pr_writer,\"\",\" \",\"\",opts__5317__auto__,keyval__5319__auto__);\n});\nreturn cljs.core.pr_sequential_writer(writer__5316__auto__,pr_pair__5318__auto__,\"#promesa.core.Recur{\",\", \",\"}\",opts__5317__auto__,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192),self__.bindings],null))], null),self__.__extmap));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (G__12354){\nvar self__ = this;\nvar G__12354__$1 = this;\nreturn (new cljs.core.RecordIter((0),G__12354__$1,1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192)], null),(cljs.core.truth_(self__.__extmap)?cljs.core._iterator(self__.__extmap):cljs.core.nil_iter())));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this__5298__auto__){\nvar self__ = this;\nvar this__5298__auto____$1 = this;\nreturn self__.__meta;\n}));\n\n(promesa.core.Recur.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (this__5295__auto__){\nvar self__ = this;\nvar this__5295__auto____$1 = this;\nreturn (new promesa.core.Recur(self__.bindings,self__.__meta,self__.__extmap,self__.__hash));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$ICounted$_count$arity$1 = (function (this__5304__auto__){\nvar self__ = this;\nvar this__5304__auto____$1 = this;\nreturn (1 + cljs.core.count(self__.__extmap));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IHash$_hash$arity$1 = (function (this__5296__auto__){\nvar self__ = this;\nvar this__5296__auto____$1 = this;\nvar h__5111__auto__ = self__.__hash;\nif((!((h__5111__auto__ == null)))){\nreturn h__5111__auto__;\n} else {\nvar h__5111__auto____$1 = (function (coll__5297__auto__){\nreturn (-404494900 ^ cljs.core.hash_unordered_coll(coll__5297__auto__));\n})(this__5296__auto____$1);\n(self__.__hash = h__5111__auto____$1);\n\nreturn h__5111__auto____$1;\n}\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this12356,other12357){\nvar self__ = this;\nvar this12356__$1 = this;\nreturn (((!((other12357 == null)))) && ((((this12356__$1.constructor === other12357.constructor)) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this12356__$1.bindings,other12357.bindings)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this12356__$1.__extmap,other12357.__extmap)))))));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (this__5310__auto__,k__5311__auto__){\nvar self__ = this;\nvar this__5310__auto____$1 = this;\nif(cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192),null], null), null),k__5311__auto__)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core._with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,this__5310__auto____$1),self__.__meta),k__5311__auto__);\n} else {\nreturn (new promesa.core.Recur(self__.bindings,self__.__meta,cljs.core.not_empty(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.__extmap,k__5311__auto__)),null));\n}\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (this__5307__auto__,k12355){\nvar self__ = this;\nvar this__5307__auto____$1 = this;\nvar G__12364 = k12355;\nvar G__12364__$1 = (((G__12364 instanceof cljs.core.Keyword))?G__12364.fqn:null);\nswitch (G__12364__$1) {\ncase \"bindings\":\nreturn true;\n\nbreak;\ndefault:\nreturn cljs.core.contains_QMARK_(self__.__extmap,k12355);\n\n}\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this__5308__auto__,k__5309__auto__,G__12354){\nvar self__ = this;\nvar this__5308__auto____$1 = this;\nvar pred__12365 = cljs.core.keyword_identical_QMARK_;\nvar expr__12366 = k__5309__auto__;\nif(cljs.core.truth_((pred__12365.cljs$core$IFn$_invoke$arity$2 ? pred__12365.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192),expr__12366) : pred__12365.call(null, new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192),expr__12366)))){\nreturn (new promesa.core.Recur(G__12354,self__.__meta,self__.__extmap,null));\n} else {\nreturn (new promesa.core.Recur(self__.bindings,self__.__meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k__5309__auto__,G__12354),null));\n}\n}));\n\n(promesa.core.Recur.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this__5313__auto__){\nvar self__ = this;\nvar this__5313__auto____$1 = this;\nreturn cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192),self__.bindings,null))], null),self__.__extmap));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this__5299__auto__,G__12354){\nvar self__ = this;\nvar this__5299__auto____$1 = this;\nreturn (new promesa.core.Recur(self__.bindings,G__12354,self__.__extmap,self__.__hash));\n}));\n\n(promesa.core.Recur.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this__5305__auto__,entry__5306__auto__){\nvar self__ = this;\nvar this__5305__auto____$1 = this;\nif(cljs.core.vector_QMARK_(entry__5306__auto__)){\nreturn this__5305__auto____$1.cljs$core$IAssociative$_assoc$arity$3(null, cljs.core._nth(entry__5306__auto__,(0)),cljs.core._nth(entry__5306__auto__,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,this__5305__auto____$1,entry__5306__auto__);\n}\n}));\n\n(promesa.core.Recur.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"bindings\",\"bindings\",-1383038577,null)], null);\n}));\n\n(promesa.core.Recur.cljs$lang$type = true);\n\n(promesa.core.Recur.cljs$lang$ctorPrSeq = (function (this__5346__auto__){\nreturn (new cljs.core.List(null,\"promesa.core/Recur\",null,(1),null));\n}));\n\n(promesa.core.Recur.cljs$lang$ctorPrWriter = (function (this__5346__auto__,writer__5347__auto__){\nreturn cljs.core._write(writer__5347__auto__,\"promesa.core/Recur\");\n}));\n\n/**\n * Positional factory function for promesa.core/Recur.\n */\npromesa.core.__GT_Recur = (function promesa$core$__GT_Recur(bindings){\nreturn (new promesa.core.Recur(bindings,null,null,null));\n});\n\n/**\n * Factory function for promesa.core/Recur, taking a map of keywords to field values.\n */\npromesa.core.map__GT_Recur = (function promesa$core$map__GT_Recur(G__12358){\nvar extmap__5342__auto__ = (function (){var G__12368 = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(G__12358,new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192));\nif(cljs.core.record_QMARK_(G__12358)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,G__12368);\n} else {\nreturn G__12368;\n}\n})();\nreturn (new promesa.core.Recur(new cljs.core.Keyword(null,\"bindings\",\"bindings\",1271397192).cljs$core$IFn$_invoke$arity$1(G__12358),null,cljs.core.not_empty(extmap__5342__auto__),null));\n});\n\npromesa.core.recur_QMARK_ = (function promesa$core$recur_QMARK_(o){\nreturn (o instanceof promesa.core.Recur);\n});\npromesa.core.wait_all_STAR_ = (function promesa$core$wait_all_STAR_(promises){\nif(cljs.core.set_QMARK_(promises)){\n} else {\nthrow (new Error([\"Assert failed: \",\"expected a set instance\",\"\\n\",\"(set? promises)\"].join('')));\n}\n\nvar state = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(promises);\nvar d = promesa.core.deferred();\ncljs.core.run_BANG_((function (p){\nreturn promesa.core.fnly.cljs$core$IFn$_invoke$arity$2((function (_,___$1){\nif(cljs.core.seq(cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(state,cljs.core.disj,p))){\nreturn null;\n} else {\nreturn promesa.protocols._resolve_BANG_(d,null);\n}\n}),p);\n}),promises);\n\nreturn d;\n});\n/**\n * Given a variable number of promises, returns a promise which resolves\n *   to `nil` when all provided promises complete (rejected or resolved).\n * \n *   **EXPERIMENTAL**\n */\npromesa.core.wait_all = (function promesa$core$wait_all(var_args){\nvar args__5732__auto__ = [];\nvar len__5726__auto___12427 = arguments.length;\nvar i__5727__auto___12428 = (0);\nwhile(true){\nif((i__5727__auto___12428 < len__5726__auto___12427)){\nargs__5732__auto__.push((arguments[i__5727__auto___12428]));\n\nvar G__12429 = (i__5727__auto___12428 + (1));\ni__5727__auto___12428 = G__12429;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5733__auto__ = ((((0) < args__5732__auto__.length))?(new cljs.core.IndexedSeq(args__5732__auto__.slice((0)),(0),null)):null);\nreturn promesa.core.wait_all.cljs$core$IFn$_invoke$arity$variadic(argseq__5733__auto__);\n});\n\n(promesa.core.wait_all.cljs$core$IFn$_invoke$arity$variadic = (function (promises){\nreturn promesa.core.wait_all_STAR_(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.EMPTY,promises));\n}));\n\n(promesa.core.wait_all.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(promesa.core.wait_all.cljs$lang$applyTo = (function (seq12374){\nvar self__5712__auto__ = this;\nreturn self__5712__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq12374));\n}));\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core.cljc","~:line",7,"~:column",5,"~:end-line",7,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$shadow.js.shim.module$react","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$doseq","~$let","~$->","~$future","~$as->","~$do","~$spread","~$promise","~$run!","~$recur","~$loop","~$with-redefs","~$->>"]],"~:macros",["^ ","~$do!",["^ ","~:arglists",["~#list",[["~$&","~$exprs"]]],"~:doc","A convenience alias for `do` macro.","^7",521,"^8",1,"^6","promesa/core.cljc","~:name","~$promesa.core/do!","~:ns","~$promesa.core","~:macro",true],"^M",["^ ","^10",["^11",[[["~$binding","~$xs"],"~$&","~$body"]]],"^13","Simplified version of `doseq` which takes one binding and a seq, and\n  runs over it using `promesa.core/run!`","^7",707,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/doseq","^16","^17","^18",true],"^N",["^ ","^10",["^11",[["~$bindings","~$&","^1;"]]],"^13","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.","^7",535,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/let","^16","^17","^18",true],"^O",["^ ","^10",["^11",[["~$x","~$&","~$forms"]]],"^13","Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",632,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/->","^16","^17","^18",true],"^P",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous macro to `clojure.core/future` that returns promise\n  instance instead of the `Future`. Exposed just for convenience and\n  works as an alias to `thread`.","^7",582,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/future","^16","^17","^18",true],"~$plet",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.","^7",545,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/plet","^16","^17","^18",true],"^Q",["^ ","^10",["^11",[["~$expr","~$name","~$&","^1?"]]],"^13","Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.","^7",674,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/as->","^16","^17","^18",true],"^R",["^ ","^10",["^11",[["~$&","^12"]]],"^13","Execute potentially side effectful code and return a promise resolved\n  to the last expression after awaiting the result of each\n  expression.","^7",511,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/do","^16","^17","^18",true],"~$let*",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","An exception unsafe let-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.","^7",526,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/let*","^16","^17","^18",true],"~$do*",["^ ","^10",["^11",[["~$&","^12"]]],"^13","An exception unsafe do-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.","^7",499,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/do*","^16","^17","^18",true],"^V",["^ ","^10",["^11",[["~$&","~$args"]]],"^7",628,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/recur","^16","^17","^18",true],"^W",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^7",594,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/loop","^16","^17","^18",true],"^X",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.","^7",685,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/with-redefs","^16","^17","^18",true],"~$vthread",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`. Useful for executing synchronous code in a\n  separate thread (also works in cljs).","^7",575,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/vthread","^16","^17","^18",true],"~$thread",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`.","^7",569,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/thread","^16","^17","^18",true],"^Y",["^ ","^10",["^11",[["~$x","~$&","^1?"]]],"^13","Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",652,"^8",1,"^6","promesa/core.cljc","^14","~$promesa.core/->>","^16","^17","^18",true]],"^14","^17","~:reader-aliases",["^ "],"~:op","^16","~:imports",null,"~:requires",["^ ","~$impl","~$promesa.impl","~$promesa.protocols","^1[","^E","^E","~$pt","^1[","~$promesa.util","^21","~$goog","^22","~$exec","~$promesa.exec","^24","^24","^D","^E","~$util","^21","^1Z","^1Z","~$c","^E"],"~:seen",["^H",["~:require","~:require-macros"]],"~:uses",null,"^28",["^ ","^17","^17","^E","^E","^D","^E","~$c","^E"],"~:form",["^11",["~$ns","^17",["^11",["~:refer-clojure","~:exclude",["^J","^S","^T","^L","^I","^K","^U","^P","^N","^W","^V","^O","^Y","^Q","^X","^R","^M"]]],["^11",["^27",["^1[","~:as","^20"],["^D","^2>","~$c"],["^24","^2>","^23"],["^1Z","^2>","^1Y"],["^21","^2>","^25"]]],["^11",["^28",["^17"]]]]],"~:flags",["^ ","^27",["^H",[]],"^28",["^H",[]]],"~:js-deps",[],"~:deps",["^22","^E","^1[","^E","^24","^1Z","^21"]],"^16","^17","~:resource-id",["~:shadow.build.classpath/resource","promesa/core.cljc"],"~:compiled-at",1735689391794,"^1U",["^ ","^1Y","^1Z","^1[","^1[","^17","^17","^E","^E","^20","^1[","^21","^21","^22","^22","^23","^24","^24","^24","^D","^E","^25","^21","^1Z","^1Z","~$c","^E"],"~:resource-name","promesa/core.cljc","~:warnings",[],"~:source",";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur\n                            -> ->> as-> with-redefs do\n                            doseq])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl]\n   [promesa.util :as util])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates an appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v]\n   (pt/-promise v))\n  ([v executor]\n   (pt/-map (pt/-promise v) identity executor)))\n\n(defn wrap\n  \"A convenience alias for `promise` coercion function that only accepts\n  a single argument.\"\n  [v]\n  (pt/-promise v))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Throwable :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (satisfies? pt/IPromise v))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`).\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n#?(:clj\n   (defn resolved?\n     \"Returns true if promise `p` is already fulfilled.\"\n     [p]\n     (pt/-resolved? p)))\n\n#?(:clj\n   (defn rejected?\n     \"Returns true if promise `p` is already rejected.\"\n     [p]\n     (pt/-rejected? p)))\n\n#?(:clj\n   (defn pending?\n     \"Returns true if promise `p` is stil pending.\"\n     [p]\n     (pt/-pending? p)))\n\n#?(:clj\n   (defn extract\n     \"Returns the current promise value.\"\n     [p]\n     (pt/-extract p)))\n\n#?(:clj\n   (def done?\n     \"Returns true if promise `p` is already done.\"\n     (complement pending?)))\n\n;; Chaining\n\n(defn then\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  can return a plain value or promise instance, an automatic\n  unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-bind (pt/-promise p) (comp pt/-promise f)))\n  ([p f executor]\n   (pt/-bind (pt/-promise p) (comp pt/-promise f) executor)))\n\n(defn then'\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  should return a plain value, no automatic unwrapping will be\n  performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-map (pt/-promise p) f))\n  ([p f executor]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn bind\n  \"Chains a function `f` to be executed with when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-bind (pt/-promise p) f))\n  ([p f executor]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn map\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This function is intended to be used with `->>`.\"\n  ([f p]\n   (pt/-map (pt/-promise p) f))\n  ([executor f p]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn fmap\n  \"A convenience alias for `map`.\"\n  ([f p]\n   (pt/-map (pt/-promise p) f))\n  ([executor f p]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn mapcat\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This funciton is intended to be used with `->>`.\"\n  ([f p]\n   (pt/-bind (pt/-promise p) f))\n  ([executor f p]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn mcat\n  \"A convenience alias for `mapcat`.\"\n  ([f p]\n   (pt/-bind (pt/-promise p) f))\n  ([executor f p]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn chain\n  \"Chain variable number of functions to be executed serially using\n  `then`.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce then p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of functions to be executed serially using\n  `map`.\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce #(map %2 %1) (pt/-promise p) (cons f fs))))\n\n(defn handle\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception; `f` can return a new plain value or promise instance,\n  and automatic unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  For performance sensitive code, look at `hmap` and `hcat`.\"\n  ([p f]\n   #?(:cljs (pt/-handle (pt/-promise p) f)\n      :clj  (c/-> (pt/-handle (pt/-promise p) (comp pt/-promise f))\n                  (util/unwrap-completion-stage))))\n  ([p f executor]\n   #?(:cljs (pt/-handle (pt/-promise p) f executor)\n      :clj  (c/-> (pt/-handle (pt/-promise p) (comp pt/-promise f) executor)\n                  (util/unwrap-completion-stage)))))\n\n(defn finally\n  \"Like `handle` but ignores the return value. Returns a promise that\n  will mirror the original one.\"\n  ([p f]\n   (pt/-finally (pt/-promise p) f))\n  ([p f executor]\n   (pt/-finally (pt/-promise p) f executor)))\n\n(defn hmap\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.\"\n  ([f p]\n   (pt/-handle (pt/-promise p) f))\n  ([executor f p]\n   (pt/-handle (pt/-promise p) f executor)))\n\n(defn hcat\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise that will mirror the\n  promise instance returned by calling `f` with both: value and the\n  exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.\"\n  ([f p]\n   #?(:cljs (pt/-handle (pt/-promise p) f)\n      :clj  (c/-> (pt/-handle (pt/-promise p) f)\n                  (util/unwrap-completion-stage))))\n  ([executor f p]\n   #?(:cljs (pt/-handle (pt/-promise p) f executor)\n      :clj  (c/-> (pt/-handle (pt/-promise p) f executor)\n                  (util/unwrap-completion-stage)))))\n\n(defn fnly\n  \"Inverted arguments version of `finally`; intended to be used with\n  `->>`.\"\n  ([f p]\n   (pt/-finally (pt/-promise p) f))\n  ([executor f p]\n   (pt/-finally (pt/-promise p) f executor)))\n\n(defn catch\n  \"Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will be resolved with the return\n  value of calling `f` with exception as single argument; `f` can\n  return a plain value or promise instance, an automatic unwrapping\n  will be performed.\n\n  The computation will be executed in the completion thread, look at\n  `merr` if you want the ability to schedule the computation to other\n  thread.\"\n  ([p f]\n   (pt/-catch (pt/-promise p) (comp pt/-promise f)))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-catch\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (pt/-promise (f e))\n          (impl/rejected e)))))))\n\n(defn catch'\n  {:deprecated \"9.3\" :no-doc true}\n  ([p f] (catch p f))\n  ([p pred-or-type f] (catch p pred-or-type f)))\n\n(defn error\n  {:deprecated \"9.3\" :no-doc true}\n  ([f p] (catch p f))\n  ([f pred-or-type p] (catch p type f)))\n\n(defn merr\n  \"Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will mirror the promise returned by\n  calling `f` with exception as single argument; `f` **must** return a\n  promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This is intended to be used with `->>`.\"\n  ([f p] (pt/-catch p f))\n  ([executor f p] (pt/-catch p f executor)))\n\n(defn all\n  \"Given an array of promises, return a promise that is fulfilled when\n  all the items in the array are fulfilled.\n\n  Example:\n\n  ```\n  (-> (p/all [(promise :first-promise)\n              (promise :second-promise)])\n      (then (fn [[first-result second-result]])\n              (println (str first-result \\\", \\\" second-result))))\n  ```\n\n  Will print to out `:first-promise, :second-promise`.\n\n  If at least one of the promises is rejected, the resulting promise\n  will be rejected.\"\n  [promises]\n  #?(:cljs (c/-> (.all impl/*default-promise* (into-array promises))\n                 (then vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (c/->> (CompletableFuture/allOf (into-array CompletableFuture promises))\n                   (map (fn [_]\n                          (c/mapv pt/-extract promises)))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (c/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (into-array CompletableFuture (c/map pt/-promise promises)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [items (into #{} promises)\n           state (volatile! {:pending items\n                             :rejections []\n                             :resolved? false})\n           lock  (util/mutex)]\n     (create\n      (fn [resolve reject]\n        (c/doseq [p promises]\n          (pt/-handle\n           (pt/-promise p)\n           (fn [v exception]\n             (pt/-lock! lock)\n             (try\n               (if exception\n                 (when-not (:resolved? @state)\n                   (c/let [state (vswap! state (fn [state]\n                                                 (c/-> state\n                                                       (update :pending disj p)\n                                                       (update :rejections conj exception))))]\n                     (when-not (seq (:pending state))\n                       (if (= default ::default)\n                         (reject (ex-info \"No promises resolved\"\n                                          {:rejections (:rejections state)}))\n                         (resolve default)))))\n\n                 (when-not (:resolved? @state)\n                   (c/let [{:keys [pending]} (vswap! state (fn [state]\n                                                             (c/-> state\n                                                                   (assoc :resolved? true)\n                                                                   (update :pending disj p))))]\n                     #?(:clj (c/run! pt/-cancel! pending))\n                     (resolve v))))\n               (finally\n                 (pt/-unlock! lock)))))))))))\n\n\n(defn run!\n  \"A promise aware run! function. Executed in terms of `then` rules.\"\n  ([f coll] (run! f coll exec/default-current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument, return a\n  function that returns a promise. Callback is expected to take one\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (c/-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs\n   (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError.\"\n  ([p t] (timeout p t ::default :default))\n  ([p t v] (timeout p t v :default))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)\n           tid     (exec/schedule! scheduler t #(if (= v ::default)\n                                                  (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                                  (resolve! timeout v)))]\n     (race [(fnly (fn [_ _] (pt/-cancel! tid)) p) timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will be fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil :default))\n  ([t v] (delay t v :default))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do*\n  \"An exception unsafe do-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.\"\n  [& exprs]\n  (condp = (count exprs)\n    0 `(pt/-promise nil)\n    1 `(pt/-promise ~(first exprs))\n    (reduce (fn [acc e]\n              `(pt/-bind (pt/-promise ~e) (fn [_#] ~acc)))\n            `(pt/-promise ~(last exprs))\n            (reverse (butlast exprs)))))\n\n(defmacro do\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression after awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      (promesa.core/do* ~@exprs))))\n\n(defmacro do!\n  \"A convenience alias for `do` macro.\"\n  [& exprs]\n  `(promesa.core/do ~@exprs))\n\n(defmacro let*\n  \"An exception unsafe let-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.\"\n  [bindings & body]\n  (c/->> (reverse (partition 2 bindings))\n         (reduce (fn [acc [l r]]\n                   `(pt/-bind (pt/-promise ~r) (fn [~l] ~acc)))\n                 `(do* ~@body))))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  (if (seq bindings)\n    `(pt/-bind\n      (pt/-promise nil)\n      (fn [_#] (promesa.core/let* ~bindings ~@body)))\n    `(promesa.core/do ~@body)))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/let [bindings (partition 2 bindings)]\n         `(c/-> (all ~(mapv second bindings))\n                (bind (fn [[~@(c/map first bindings)]]\n                        (promesa.core/do* ~@body))))))))\n\n(defn thread-call\n  \"Analogous to `clojure.core.async/thread` that returns a promise\n  instance instead of the `Future`. Useful for executing synchronous\n  code in a separate thread (also works in cljs).\"\n  ([f] (exec/submit! :thread (exec/wrap-bindings f)))\n  ([executor f] (exec/submit! executor (exec/wrap-bindings f))))\n\n(defn vthread-call\n  \"A shortcut for `(p/thread-call :vthread f)`.\"\n  [f]\n  (thread-call :vthread f))\n\n(defmacro thread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`.\"\n  [& body]\n  `(thread-call (^once fn [] ~@body)))\n\n(defmacro vthread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`. Useful for executing synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(vthread-call (^once fn [] ~@body)))\n\n(defmacro future\n  \"Analogous macro to `clojure.core/future` that returns promise\n  instance instead of the `Future`. Exposed just for convenience and\n  works as an alias to `thread`.\"\n  [& body]\n  `(thread-call :default (^once fn [] ~@body)))\n\n(defrecord Recur [bindings])\n(defn recur?\n  [o]\n  (instance? Recur o))\n\n(defmacro loop\n  [bindings & body]\n  (c/let [binds (partition 2 2 bindings)\n          names (c/map first binds)\n          fvals (c/map second binds)\n          tsym  (gensym \"loop-fn-\")\n          res-s (gensym \"res-\")\n          err-s (gensym \"err-\")\n          rej-s (gensym \"reject-fn-\")\n          rsv-s (gensym \"resolve-fn-\")]\n    `(create\n      (fn [~rsv-s ~rej-s]\n        (c/let [~tsym (fn ~tsym [~@names]\n                        (c/->> (promesa.core/let [~@(c/mapcat (fn [nsym] [nsym nsym]) names)] ~@body)\n                               (promesa.core/fnly\n                                (fn [~res-s ~err-s]\n                                  ;; (prn \"result\" res# err#)\n                                  (if (some? ~err-s)\n                                    (~rej-s ~err-s)\n                                    (if (recur? ~res-s)\n                                      (do\n                                        (promesa.exec/run!\n                                         (promesa.exec/wrap-bindings\n                                          ~(if (seq names)\n                                             `(fn [] (apply ~tsym (:bindings ~res-s)))\n                                           tsym)))\n                                      nil)\n                                      (~rsv-s ~res-s)))))))]\n          (promesa.exec/run!\n           (promesa.exec/wrap-bindings\n            ~(if (seq names)\n               `(fn [] (~tsym ~@fvals))\n               tsym))))))))\n\n(defmacro recur\n  [& args]\n  `(->Recur [~@args]))\n\n(defmacro ->\n  \"Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f p# ~@args)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro ->>\n  \"Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f ~@args p#)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro as->\n  \"Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))\n\n(defmacro with-redefs\n  \"Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.\"\n  [bindings & body]\n  (c/let [names         (take-nth 2 bindings)\n          vals          (take-nth 2 (drop 1 bindings))\n          orig-val-syms (c/map (comp gensym #(str % \"-orig-val__\") name) names)\n          temp-val-syms (c/map (comp gensym #(str % \"-temp-val__\") name) names)\n          binds         (c/map vector names temp-val-syms)\n          resets        (reverse (c/map vector names orig-val-syms))\n          bind-value    (if (:ns &env)\n                          (fn [[k v]] (list 'set! k v))\n                          (fn [[k v]] (list 'alter-var-root (list 'var k) (list 'constantly v))))]\n    `(c/let [~@(interleave orig-val-syms names)\n             ~@(interleave temp-val-syms vals)]\n       ~@(c/map bind-value binds)\n       (c/-> (promesa.core/do! ~@body)\n             (promesa.core/finally\n               (fn [_# _#]\n                 ~@(c/map bind-value resets)))))))\n\n(defmacro doseq\n  \"Simplified version of `doseq` which takes one binding and a seq, and\n  runs over it using `promesa.core/run!`\"\n  [[binding xs] & body]\n  `(run! (fn [~binding]\n           (promesa.core/do* ~@body))\n         ~xs))\n\n#?(:clj\n(defn await!\n  \"Generic await operation. Block current thread until some operation\n  terminates. Returns `nil` on timeout; does not catch any other\n  exception.\n\n  Default implementation for Thread, CompletableFuture and\n  CountDownLatch.\n\n  The return value is implementation specific.\"\n  ([resource]\n   (pt/-await! resource))\n  ([resource duration]\n   (try\n     (pt/-await! resource duration)\n     (catch TimeoutException _\n       nil)))))\n\n#?(:clj\n(defn await\n  \"A exception safer variant of `await!`. Returns `nil` on timeout\n  exception, forwards interrupted exception and all other exceptions\n  are returned as value, so user is responsible for checking if the returned\n  value is exception or not.\"\n  ([resource]\n   (try\n     (pt/-await! resource)\n     (catch InterruptedException cause\n       (throw cause))\n     (catch Throwable cause\n       cause)))\n  ([resource duration]\n   (try\n     (pt/-await! resource duration)\n     (catch TimeoutException _\n       nil)\n     (catch InterruptedException cause\n       (throw cause))\n     (catch Throwable cause\n       cause)))))\n\n(defn wait-all*\n  [promises]\n  (assert (set? promises) \"expected a set instance\")\n  (c/let [state (atom promises)\n          d     (deferred)]\n    (c/run! (fn [p]\n              (fnly (fn [_ _]\n                      (when-not (seq (swap! state disj p))\n                        (pt/-resolve! d nil)))\n                    p))\n            promises)\n    d))\n\n(defn wait-all\n  \"Given a variable number of promises, returns a promise which resolves\n  to `nil` when all provided promises complete (rejected or resolved).\n\n  **EXPERIMENTAL**\"\n  [& promises]\n  (wait-all* (into #{} promises)))\n","~:reader-features",["^H",["~:cljs"]],"~:used-var-namespaces",["^H",["^1[","^17","^E","~$js","^21","^22","^24","^1Z"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__12264","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","promesa.core/wrap","G__12270","promesa.core/create","f","d","e12271","G__12272","p1__12265#","G__12273","p1__12266#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e12274","G__12275","p1__12267#","G__12276","p1__12268#","promesa.core/promise?","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IPromise","promesa.core/deferred?","promesa.impl/*default-promise*","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","G__12279","promesa.core/then","p","promesa.protocols/-bind","cljs.core.comp","G__12281","promesa.core/then'","G__12283","promesa.core/bind","G__12285","promesa.core/map","G__12287","promesa.core/fmap","G__12289","promesa.core/mapcat","G__12291","promesa.core/mcat","G__12296","promesa.core/chain","args-arr__5751__auto__","len__5726__auto__","i__5727__auto__","argseq__5752__auto__","cljs.core/IndexedSeq","seq12293","G__12294","cljs.core/first","cljs.core/next","G__12295","self__5711__auto__","promesa.core.then","fs","cljs.core.reduce","cljs.core/cons","G__12303","promesa.core/chain'","seq12300","G__12301","G__12302","promesa.core.then_SINGLEQUOTE_","p1__12298#","p2__12297#","promesa.core.map","G__12305","promesa.core/handle","promesa.protocols/-handle","G__12307","promesa.core/finally","promesa.protocols/-finally","G__12309","promesa.core/hmap","G__12311","promesa.core/hcat","G__12313","promesa.core/fnly","G__12316","promesa.core/catch","promesa.protocols/-catch","pred-or-type","accept?","p1__12314#","cljs.core/ifn?","G__12318","promesa.core/catch'","promesa.core.catch$","G__12320","promesa.core/error","cljs.core/type","G__12322","promesa.core/merr","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__12324","promesa.core/any","promesa.core.any","default","items","cljs.core.into","state","cljs.core/volatile!","lock","promesa.util/mutex","promesa.core.create","resolve","reject","seq__12325","cljs.core/seq","chunk__12326","count__12327","i__12328","temp__5804__auto__","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","exception","cljs.core/deref","cljs.core.update","cljs.core/disj","cljs.core/conj","cljs.core._EQ_","G__12333","G__12335","cljs.core.ex_info","map__12334","cljs.core/--destructure-map","cljs.core.get","map__12336","pending","cljs.core.assoc","G__12340","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/default-current-thread-executor","p1__12337#","p2__12338#","_","promesa.core.promise","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__12342","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e12343","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__12345","promesa.core/timeout","t","promesa.core.timeout","scheduler","timeout","tid","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","promesa.core.fnly","G__12347","promesa.core/delay","promesa.core.delay","G__12353","promesa.core/thread-call","promesa.exec.submit_BANG_","promesa.exec/wrap-bindings","promesa.core/vthread-call","promesa.core.thread_call","this__5300__auto__","k__5301__auto__","this__5302__auto__","k12355","else__5303__auto__","G__12359","cljs.core/Keyword","bindings","__extmap","this__5320__auto__","f__5321__auto__","init__5322__auto__","ret__5323__auto__","p__12360","vec__12361","k__5324__auto__","cljs.core.nth","v__5325__auto__","this__5315__auto__","writer__5316__auto__","opts__5317__auto__","pr-pair__5318__auto__","keyval__5319__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__12354","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__5298__auto__","__meta","this__5295__auto__","__hash","this__5304__auto__","this__5296__auto__","h__5111__auto__","coll__5297__auto__","cljs.core/hash-unordered-coll","this12356","other12357","this__5310__auto__","k__5311__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core/not-empty","this__5307__auto__","G__12364","this__5308__auto__","k__5309__auto__","pred__12365","cljs.core/keyword-identical?","expr__12366","this__5313__auto__","cljs.core/MapEntry","this__5299__auto__","this__5305__auto__","entry__5306__auto__","cljs.core/vector?","cljs.core/-nth","cljs.core/-conj","promesa.core/Recur","this__5346__auto__","cljs.core/List","writer__5347__auto__","cljs.core/-write","G__12358","extmap__5342__auto__","G__12368","cljs.core/record?","promesa.core/->Recur","promesa.core/map->Recur","promesa.core/recur?","promesa.core/wait-all*","cljs.core/set?","cljs.core.atom","cljs.core/run!","cljs.core.swap_BANG_","args__5732__auto__","argseq__5733__auto__","promesa.core/wait-all","seq12374","self__5712__auto__"]],"~:used-vars",["^H",["~$cljs.core/--destructure-map","~$promesa.core/promise","~$promesa.core/resolve!","~$cljs.core/PROTOCOL_SENTINEL","~$cljs.core/comp","~$promesa.core/wait-all*","~$promesa.core/Recur","~$promesa.exec/default-current-thread-executor","~$promesa.core/promisify","~$promesa.protocols/-reject!","~$promesa.core/mapcat","~$promesa.util/mutex","~$cljs.core/pr-sequential-writer","~$promesa.protocols/-resolve!","~$cljs.core/vector?","~$promesa.protocols/-map","~$promesa.core/map->Recur","~$cljs.core/=","~$promesa.core/mcat","~$promesa.core/catch","~$cljs.core/ifn?","~$cljs.core/-assoc","~$cljs.core/into-array","~$cljs.core/-write","~$cljs.core/IndexedSeq","~$cljs.core/-deref","~$promesa.core/fmap","~$cljs.core/-iterator","~$promesa.exec/wrap-bindings","~$cljs.core/count","~$cljs.core/deref","~$cljs.core/reduce","~$promesa.core/thread-call","~$cljs.core/seq","~$cljs.core/chunk-first","~$cljs.core/apply","~$cljs.core/identity","~$cljs.core/Keyword","~$promesa.core/merr","~$promesa.core/rejected","~$promesa.core/run!","~$cljs.core/MapEntry","~$cljs.core/dissoc","~$cljs.core/keyword-identical?","~$promesa.protocols/-promise","~$cljs.core/chunk-rest","~$cljs.core/atom","~$cljs.core/-with-meta","~$cljs.core/concat","~$promesa.exec/submit!","~$promesa.core/TimeoutException","~$promesa.impl/rejected","~$promesa.protocols/-unlock!","~$promesa.core/wrap","~$promesa.core/bind","~$cljs.core/native-satisfies?","~$promesa.core/deferred","~$cljs.core/contains?","~$cljs.core/into","~$cljs.core/conj","~$promesa.core/then'","~$goog/inherits","~$cljs.core/-conj","~$promesa.core/vthread-call","~$cljs.core/update","~$promesa.core/map","~$cljs.core/run!","~$cljs.core/map","~$promesa.core/chain'","~$promesa.core/all","~$cljs.core/fn?","~$promesa.core/->Recur","~$promesa.core/cancelled?","~$promesa.impl/*default-promise*","~$promesa.core/resolved","~$cljs.core/PersistentVector","~$promesa.protocols/-cancelled?","~$cljs.core/volatile!","~$promesa.core/recur?","~$cljs.core/List","~$cljs.core/swap!","~$cljs.core/get","~$promesa.core/hcat","~$promesa.impl/deferred","~$cljs.core/-nth","~$cljs.core/object?","~$cljs.core/not-empty","~$promesa.impl/resolved","~$promesa.core/handle","~$cljs.core/-vreset!","~$promesa.protocols/-lock!","~$promesa.core/catch'","~$cljs.core/record?","~$promesa.core/hmap","~$promesa.core/error","~$cljs.core/-lookup","~$cljs.core/set?","~$promesa.core/race","~$promesa.core/fnly","~$promesa.core/create","~$cljs.core/nth","~$cljs.core/ex-info","~$promesa.core/wait-all","~$promesa.core/thenable?","~$promesa.core/cancel!","~$cljs.core/nil-iter","~$promesa.core/finally","~$promesa.protocols/-handle","~$cljs.core/next","~$cljs.core/vec","~$promesa.core/then","~$cljs.core/RecordIter","~$promesa.core/any","~$promesa.core/deferred?","~$promesa.protocols/-finally","~$cljs.core/not","~$cljs.core/disj","~$cljs.core/cons","~$cljs.core/assoc","~$promesa.protocols/-cancel!","~$promesa.core/delay","~$promesa.core/chain","~$cljs.core/hash-unordered-coll","~$promesa.core/timeout","~$promesa.protocols/-catch","~$cljs.core/first","~$promesa.core/promise?","~$promesa.protocols/IPromise","~$promesa.protocols/-bind","~$promesa.exec/schedule!","~$js/Error","~$cljs.core/type","~$promesa.exec/run!","~$cljs.core/chunked-seq?","~$promesa.core/reject!"]]],"~:cache-keys",["~#cmap",[["^2C","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^22","~$goog.dom.HtmlElement"]]],["^2C","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^2C","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^62"]]],["^2C","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61"]]],["^2C","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","promesa/impl.cljc"],["a4fe657acbb7c1b0539820874bab2fa0b59bb229","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^E","^1[","^21","^24"]]],["^2C","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^5[","^62"]]],["^2C","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61"]]],"~:SHADOW-TIMESTAMP",[1733506754000,1733506754000,1715719162000],["^2C","promesa/util.cljc"],["a4fe657acbb7c1b0539820874bab2fa0b59bb229","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^E","^1["]]],["^2C","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","~$goog.reflect"]]],["^2C","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","~$goog.fs.blob","^65","~$goog.html.SafeScript","~$goog.html.trustedtypes","^67","^68"]]],["^2C","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^67","~$goog.html.SafeUrl","^68","^61","^62"]]],["^2C","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^6<","~$goog.html.SafeStyle","^6>","^66","~$goog.html.uncheckedconversions","^67","^62"]]],["^2C","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.dom.TagName","^61","~$goog.dom.element"]]],["^2C","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^67","^6<","^6C","~$goog.html.SafeStyleSheet","^6>","^6E","^66","^68","^61","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^62","~$goog.dom.tags","^6="]]],["^2C","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^6J"]]],["^2C","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^2C","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^6I","^61","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^2C","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^60"]]],["^2C","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",[]]],["^2C","promesa/core.cljc"],["a4fe657acbb7c1b0539820874bab2fa0b59bb229","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^E","^1[","^E","^24","^1Z","^21"]]],["^2C","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^6I","^6J"]]],["^2C","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.dom.safe","^6D","^67","^62"]]],["^2C","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^62","^64"]]],["^2C","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","promesa/protocols.cljc"],["a4fe657acbb7c1b0539820874bab2fa0b59bb229","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^E"]]],["^2C","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.flags"]]],["^2C","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^6M","^6E"]]],["^2C","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","^6B","^6<","^6C","^6G","^6>","^66","^67","^62"]]],["^2C","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22"]]],["^2C","cljs/core.cljs"],["b89362aeac5c1cafea76c798929ee5d385c461d8","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","~$goog.math.Long","~$goog.math.Integer","^6O","^6J","^6I","~$goog.Uri","~$goog.string.StringBuffer"]]],["^2C","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^67","^68","^6=","^61"]]],["^2C","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^67","^6C","^68","^6J","^61","^62"]]],["^2C","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^6:"]]],["^2C","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","^6O"]]],["^2C","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^61","^68"]]],["^2C","promesa/exec.cljc"],["a4fe657acbb7c1b0539820874bab2fa0b59bb229","^5V",["^ ","^5W",null,"^5X",["^H",[]],"^5Y",["^22","^E","^1[","^21","^6J"]]]]],"~:clj-info",["^ ","jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1690756440000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map.clj",1715719162000,"jar:file:/Users/john/.m2/repository/funcool/promesa/10.0.594/promesa-10.0.594.jar!/promesa/impl.cljc",1735689384000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/passes/and_or.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1715719162000,"jar:file:/Users/john/.m2/repository/funcool/promesa/10.0.594/promesa-10.0.594.jar!/promesa/core.cljc",1735689384000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1690756440000,"jar:file:/Users/john/.m2/repository/funcool/promesa/10.0.594/promesa-10.0.594.jar!/promesa/util.cljc",1735689384000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1690756440000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/compiler.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/util.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/tagged_literals.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/env.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/impl/namespaces.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/funcool/promesa/10.0.594/promesa-10.0.594.jar!/promesa/protocols.cljc",1735689384000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1690756440000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/passes.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map/base64.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/instant.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/impl.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/core.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1690756440000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/js_deps.cljc",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1690756440000,"jar:file:/Users/john/.m2/repository/funcool/promesa/10.0.594/promesa-10.0.594.jar!/promesa/exec.cljc",1735689384000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/data/json.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map/base64_vlq.clj",1715719162000,"jar:file:/Users/john/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1690756440000,"jar:file:/Users/john/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/externs.clj",1715719162000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","promesa/core.cljc","^7",7,"^8",5,"^9",7,"^:",17],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",null,"^G",["^H",["^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R","^S","^T","^U","^V","^W","^X","^Y"]],"^Z",["^ ","^[",["^ ","^10",["^11",[["~$&","^12"]]],"^13","A convenience alias for `do` macro.","^7",521,"^8",1,"^6","promesa/core.cljc","^14","^15","^16","^17","^18",true],"^M",["^ ","^10",["^11",[[["^19","^1:"],"~$&","^1;"]]],"^13","Simplified version of `doseq` which takes one binding and a seq, and\n  runs over it using `promesa.core/run!`","^7",707,"^8",1,"^6","promesa/core.cljc","^14","^1<","^16","^17","^18",true],"^N",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.","^7",535,"^8",1,"^6","promesa/core.cljc","^14","^1>","^16","^17","^18",true],"^O",["^ ","^10",["^11",[["~$x","~$&","^1?"]]],"^13","Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",632,"^8",1,"^6","promesa/core.cljc","^14","^1@","^16","^17","^18",true],"^P",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous macro to `clojure.core/future` that returns promise\n  instance instead of the `Future`. Exposed just for convenience and\n  works as an alias to `thread`.","^7",582,"^8",1,"^6","promesa/core.cljc","^14","^1A","^16","^17","^18",true],"^1B",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.","^7",545,"^8",1,"^6","promesa/core.cljc","^14","^1C","^16","^17","^18",true],"^Q",["^ ","^10",["^11",[["^1D","^1E","~$&","^1?"]]],"^13","Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.","^7",674,"^8",1,"^6","promesa/core.cljc","^14","^1F","^16","^17","^18",true],"^R",["^ ","^10",["^11",[["~$&","^12"]]],"^13","Execute potentially side effectful code and return a promise resolved\n  to the last expression after awaiting the result of each\n  expression.","^7",511,"^8",1,"^6","promesa/core.cljc","^14","^1G","^16","^17","^18",true],"^1H",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","An exception unsafe let-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.","^7",526,"^8",1,"^6","promesa/core.cljc","^14","^1I","^16","^17","^18",true],"^1J",["^ ","^10",["^11",[["~$&","^12"]]],"^13","An exception unsafe do-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.","^7",499,"^8",1,"^6","promesa/core.cljc","^14","^1K","^16","^17","^18",true],"^V",["^ ","^10",["^11",[["~$&","^1L"]]],"^7",628,"^8",1,"^6","promesa/core.cljc","^14","^1M","^16","^17","^18",true],"^W",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^7",594,"^8",1,"^6","promesa/core.cljc","^14","^1N","^16","^17","^18",true],"^X",["^ ","^10",["^11",[["^1=","~$&","^1;"]]],"^13","Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.","^7",685,"^8",1,"^6","promesa/core.cljc","^14","^1O","^16","^17","^18",true],"^1P",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`. Useful for executing synchronous code in a\n  separate thread (also works in cljs).","^7",575,"^8",1,"^6","promesa/core.cljc","^14","^1Q","^16","^17","^18",true],"^1R",["^ ","^10",["^11",[["~$&","^1;"]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`.","^7",569,"^8",1,"^6","promesa/core.cljc","^14","^1S","^16","^17","^18",true],"^Y",["^ ","^10",["^11",[["~$x","~$&","^1?"]]],"^13","Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",652,"^8",1,"^6","promesa/core.cljc","^14","^1T","^16","^17","^18",true]],"^14","^17","^1U",["^ "],"^1W",null,"^1X",["^ ","^1Y","^1Z","^1[","^1[","^E","^E","^20","^1[","^21","^21","^22","^22","^23","^24","^24","^24","^D","^E","^25","^21","^1Z","^1Z","~$c","^E"],"^26",["^H",["^27","^28"]],"~:shadow/js-access-global",["^H",["Error"]],"^29",null,"~:defs",["^ ","~$timeout",["^ ","~:protocol-inline",null,"^5",["^ ","^6","promesa/core.cljc","^7",474,"^8",7,"^9",474,"^:",14,"^10",["^11",["~$quote",["^11",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","~$scheduler"]]]]],"^13","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",4,"~:max-fixed-arity",4,"~:method-params",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]],"^10",["^11",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]]],"~:arglists-meta",["^11",[null,null,null]]]],"^14","^5H","^6","promesa/core.cljc","^:",14,"^7X",["^ ","^7Y",false,"^7Z",4,"^7[",4,"^80",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]],"^10",["^11",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]]],"^81",["^11",[null,null,null]]],"^80",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]],"~:protocol-impl",null,"^7Z",4,"^81",["^11",[null,null,null]],"^8",1,"^7Y",false,"~:methods",[["^ ","^7Z",2,"^7Y",false,"~:tag","~$any"],["^ ","^7Z",3,"^7Y",false,"^84","^85"],["^ ","^7Z",4,"^7Y",false,"^84","^85"]],"^7",474,"^9",474,"^7[",4,"~:fn-var",true,"^10",["^11",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^7W"]]],"^13","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError."],"~$deferred?",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",90,"^8",7,"^9",90,"^:",16,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a promise instance (alias to `promise?`)."],"^14","^5>","^6","promesa/core.cljc","^:",16,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",90,"~:ret-tag","~$boolean","^9",90,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a promise instance (alias to `promise?`)."],"~$merr",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",334,"^8",7,"^9",334,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["~$executor","~$f","~$p"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will mirror the promise returned by\n  calling `f` with exception as single argument; `f` **must** return a\n  promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This is intended to be used with `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^3K","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",334,"^9",334,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will mirror the promise returned by\n  calling `f` with exception as single argument; `f` **must** return a\n  promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This is intended to be used with `->>`."],"^I",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",176,"^8",7,"^9",176,"^:",10,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This function is intended to be used with `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^4:","^6","promesa/core.cljc","^:",10,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",176,"^9",176,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This function is intended to be used with `->>`."],"^J",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",488,"^8",7,"^9",488,"^:",12,"^10",["^11",["^7V",["^11",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]]]]],"^13","Given a timeout in miliseconds and optional value, returns a promise\n  that will be fulfilled with provided value (or nil) after the time is\n  reached.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]],"^10",["^11",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]]],"^81",["^11",[null,null,null]]]],"^14","^5E","^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]],"^10",["^11",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]]],"^81",["^11",[null,null,null]]],"^80",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]],"^82",null,"^7Z",3,"^81",["^11",[null,null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^4B"]],"^7",488,"^9",488,"^7[",3,"^86",true,"^10",["^11",[["~$t"],["~$t","~$v"],["~$t","~$v","^7W"]]],"^13","Given a timeout in miliseconds and optional value, returns a promise\n  that will be fulfilled with provided value (or nil) after the time is\n  reached."],"^K",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",197,"^8",7,"^9",197,"^:",13,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This funciton is intended to be used with `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^2[","^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",197,"^9",197,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This funciton is intended to be used with `->>`."],"~$cancelled?",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",432,"^8",7,"^9",432,"^:",17,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a cancelled promise."],"^14","^4A","^6","promesa/core.cljc","^:",17,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",432,"^88","^85","^9",432,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a cancelled promise."],"~$bind",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",163,"^8",7,"^9",163,"^:",11,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]]]],"^13","Chains a function `f` to be executed with when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^3[","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",163,"^9",163,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^13","Chains a function `f` to be executed with when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor."],"~$resolve!",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",439,"^8",7,"^9",439,"^:",15,"^10",["^11",["^7V",["^11",[["~$o"],["~$o","~$v"]]]]],"^13","Resolve a completable promise with a value.","^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$o"],["~$o","~$v"]],"^10",["^11",[["~$o"],["~$o","~$v"]]],"^81",["^11",[null,null]]]],"^14","^2S","^6","promesa/core.cljc","^:",15,"^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$o"],["~$o","~$v"]],"^10",["^11",[["~$o"],["~$o","~$v"]]],"^81",["^11",[null,null]]],"^80",[["~$o"],["~$o","~$v"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",false,"^84","^85"]],"^7",439,"^9",439,"^7[",2,"^86",true,"^10",["^11",[["~$o"],["~$o","~$v"]]],"^13","Resolve a completable promise with a value."],"^85",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",377,"^8",7,"^9",377,"^:",10,"^10",["^11",["^7V",["^11",[["~$promises"],["^8?","~$default"]]]]],"^13","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.","^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["^8?"],["^8?","^8@"]],"^10",["^11",[["^8?"],["^8?","^8@"]]],"^81",["^11",[null,null]]]],"^14","^5=","^6","promesa/core.cljc","^:",10,"^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["^8?"],["^8?","^8@"]],"^10",["^11",[["^8?"],["^8?","^8@"]]],"^81",["^11",[null,null]]],"^80",[["^8?"],["^8?","^8@"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",false,"^84","^4B"]],"^7",377,"^9",377,"^7[",2,"^86",true,"^10",["^11",[["^8?"],["^8?","^8@"]]],"^13","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled."],"~$finally",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",251,"^8",7,"^9",251,"^:",14,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]]]],"^13","Like `handle` but ignores the return value. Returns a promise that\n  will mirror the original one.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^57","^6","promesa/core.cljc","^:",14,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",251,"^9",251,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^13","Like `handle` but ignores the return value. Returns a promise that\n  will mirror the original one."],"~$then'",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",149,"^8",7,"^9",149,"^:",12,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  should return a plain value, no automatic unwrapping will be\n  performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^45","^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",149,"^9",149,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  should return a plain value, no automatic unwrapping will be\n  performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor."],"~$wait-all",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",769,"^8",7,"^9",769,"^:",15,"^10",["^11",["^7V",["^11",[["~$&","^8?"]]]]],"^13","Given a variable number of promises, returns a promise which resolves\n  to `nil` when all provided promises complete (rejected or resolved).\n\n  **EXPERIMENTAL**","^7X",["^ ","^7Y",true,"^7Z",0,"^7[",0,"^80",[["^11",["^8?"]]],"^10",["^11",[["~$&","^8?"]]],"^81",["^11",[null]]]],"^14","^53","^6","promesa/core.cljc","^:",15,"^7X",["^ ","^7Y",true,"^7Z",0,"^7[",0,"^80",[["^11",["^8?"]]],"^10",["^11",[["~$&","^8?"]]],"^81",["^11",[null]]],"^80",[["^11",["^8?"]]],"^82",null,"^7Z",0,"^81",["^11",[null]],"^8",1,"^7Y",true,"^83",[["^ ","^7Z",0,"^7Y",true,"^84","^4B"]],"^7",769,"^88","^85","^9",769,"^7[",0,"^86",true,"^10",["^11",[["~$&","^8?"]]],"^13","Given a variable number of promises, returns a promise which resolves\n  to `nil` when all provided promises complete (rejected or resolved).\n\n  **EXPERIMENTAL**"],"~$chain'",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",225,"^8",7,"^9",225,"^:",13,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","~$&","~$fs"]]]]],"^13","Chain variable number of functions to be executed serially using\n  `map`.","^7X",["^ ","^7Y",true,"^7Z",2,"^7[",2,"^80",[["~$p","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^81",["^11",[null,null]]]],"^14","^4=","^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",true,"^7Z",2,"^7[",2,"^80",[["~$p","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",true,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",true,"^84",["^H",[null,"^85"]]]],"^7",225,"^9",225,"^7[",2,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^13","Chain variable number of functions to be executed serially using\n  `map`."],"~$wrap",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",56,"^8",7,"^9",56,"^:",11,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","A convenience alias for `promise` coercion function that only accepts\n  a single argument."],"^14","^3Z","^6","promesa/core.cljc","^:",11,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",56,"^88","^85","^9",56,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","A convenience alias for `promise` coercion function that only accepts\n  a single argument."],"~$wait-all*",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",756,"^8",7,"^9",756,"^:",16,"^10",["^11",["^7V",["^11",[["^8?"]]]]]],"^14","^2V","^6","promesa/core.cljc","^:",16,"^80",["^11",[["^8?"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",756,"^88","^4B","^9",756,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^8?"]]]]]],"~$fnly",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",293,"^8",7,"^9",293,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","Inverted arguments version of `finally`; intended to be used with\n  `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^4[","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",293,"^9",293,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Inverted arguments version of `finally`; intended to be used with\n  `->>`."],"~$hmap",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",259,"^8",7,"^9",259,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^4V","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",259,"^9",259,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`."],"~$Recur",["^ ","~:num-fields",1,"~:protocols",["^H",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^14","^2W","^6","promesa/core.cljc","^:",17,"~:type",true,"^8",12,"~:internal-ctor",true,"^7",589,"~:record",true,"^9",589,"^84","~$function","~:skip-protocol-flag",["^H",["^8M","^8N","^8O","^8P","^8Q","^8R","^8S","^8T","^8U","^8V","^8W","^8X","^8Y","^8Z","^8["]]],"~$promisify",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",451,"^8",7,"^9",451,"^:",16,"^10",["^11",["^7V",["^11",[["~$callable"]]]]],"^13","Given a function that accepts a callback as the last argument, return a\n  function that returns a promise. Callback is expected to take one\n  parameter (result of a computation)."],"^14","^2Y","^6","promesa/core.cljc","^:",16,"^80",["^11",[["^96"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",451,"^88","^93","^9",451,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^96"]]]]],"^13","Given a function that accepts a callback as the last argument, return a\n  function that returns a promise. Callback is expected to take one\n  parameter (result of a computation)."],"~$mcat",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",212,"^8",7,"^9",212,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","A convenience alias for `mapcat`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^37","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",212,"^9",212,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","A convenience alias for `mapcat`."],"~$rejected",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",35,"^8",7,"^9",35,"^:",15,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return a rejected promise with provided reason."],"^14","^3L","^6","promesa/core.cljc","^:",15,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",35,"^88","^85","^9",35,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return a rejected promise with provided reason."],"^T",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",45,"^8",7,"^9",45,"^:",14,"^10",["^11",["^7V",["^11",[["~$v"],["~$v","^8;"]]]]],"^13","The coerce based promise constructor. Creates an appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.","^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$v"],["~$v","^8;"]],"^10",["^11",[["~$v"],["~$v","^8;"]]],"^81",["^11",[null,null]]]],"^14","^2R","^6","promesa/core.cljc","^:",14,"^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$v"],["~$v","^8;"]],"^10",["^11",[["~$v"],["~$v","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$v"],["~$v","^8;"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",false,"^84","^85"]],"^7",45,"^9",45,"^7[",2,"^86",true,"^10",["^11",[["~$v"],["~$v","^8;"]]],"^13","The coerce based promise constructor. Creates an appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise."],"~$create",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",62,"^8",7,"^9",62,"^:",13,"^10",["^11",["^7V",["^11",[["~$f"],["~$f","^8;"]]]]],"^13","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.","^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$f"],["~$f","^8;"]],"^10",["^11",[["~$f"],["~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^50","^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$f"],["~$f","^8;"]],"^10",["^11",[["~$f"],["~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$f"],["~$f","^8;"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^4B"],["^ ","^7Z",2,"^7Y",false,"^84","^4B"]],"^7",62,"^9",62,"^7[",2,"^86",true,"^10",["^11",[["~$f"],["~$f","^8;"]]],"^13","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`."],"~$race",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",372,"^8",7,"^9",372,"^:",11,"^10",["^11",["^7V",["^11",[["^8?"]]]]]],"^14","^4Z","^6","promesa/core.cljc","^:",11,"^80",["^11",[["^8?"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",372,"^88","^85","^9",372,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^8?"]]]]]],"~$cancel!",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",426,"^8",7,"^9",426,"^:",14,"^10",["^11",["^7V",["^11",[["~$p"]]]]],"^13","Cancel the promise."],"^14","^55","^6","promesa/core.cljc","^:",14,"^80",["^11",[["~$p"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",426,"^9",426,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$p"]]]]],"^13","Cancel the promise."],"~$thenable?",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",97,"^8",10,"^9",97,"^:",19,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Returns true if `v` is a promise like object."],"^14","^54","^6","promesa/core.cljc","^:",19,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",4,"^7Y",false,"^7",97,"^88","^89","^9",97,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Returns true if `v` is a promise like object."],"~$TimeoutException",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",466,"^8",6,"^9",466,"^:",22,"~:jsdoc",["@constructor"],"^10",["^11",["^7V",["^11",[["~$message"]]]]]],"^14","^3W","^6","promesa/core.cljc","^:",22,"^80",["^11",[["^9?"]]],"^82",null,"^81",["^11",[null,null]],"^8",4,"^7Y",false,"^7",465,"^88","^85","^9",466,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^9?"]]]]],"^9>",["@constructor"]],"~$catch'",["^ ","~:no-doc",true,"^7U",null,"^5",["^ ","^9A",true,"^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]],"^81",["^11",[null,null]]],"^8",7,"^7",324,"~:deprecated","9.3","^9",324,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]]]]],"^14","^4T","^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","^9B","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","^9B","~$f"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",324,"^9C","9.3","^9",324,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]]],"^U",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",419,"^8",7,"^9",419,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$coll"],["~$f","^9D","^8;"]]]]],"^13","A promise aware run! function. Executed in terms of `then` rules.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","^9D"],["~$f","^9D","^8;"]],"^10",["^11",[["~$f","^9D"],["~$f","^9D","^8;"]]],"^81",["^11",[null,null]]]],"^14","^3M","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","^9D"],["~$f","^9D","^8;"]],"^10",["^11",[["~$f","^9D"],["~$f","^9D","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$f","^9D"],["~$f","^9D","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84",["^H",[null,"^85"]]]],"^7",419,"^9",419,"^7[",3,"^86",true,"^10",["^11",[["~$f","^9D"],["~$f","^9D","^8;"]]],"^13","A promise aware run! function. Executed in terms of `then` rules."],"~$vthread-call",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",564,"^8",7,"^9",564,"^:",19,"^10",["^11",["^7V",["^11",[["~$f"]]]]],"^13","A shortcut for `(p/thread-call :vthread f)`."],"^14","^48","^6","promesa/core.cljc","^:",19,"^80",["^11",[["~$f"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",564,"^88","^85","^9",564,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$f"]]]]],"^13","A shortcut for `(p/thread-call :vthread f)`."],"~$all",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",347,"^8",7,"^9",347,"^:",10,"^10",["^11",["^7V",["^11",[["^8?"]]]]],"^13","Given an array of promises, return a promise that is fulfilled when\n  all the items in the array are fulfilled.\n\n  Example:\n\n  ```\n  (-> (p/all [(promise :first-promise)\n              (promise :second-promise)])\n      (then (fn [[first-result second-result]])\n              (println (str first-result \", \" second-result))))\n  ```\n\n  Will print to out `:first-promise, :second-promise`.\n\n  If at least one of the promises is rejected, the resulting promise\n  will be rejected."],"^14","^4>","^6","promesa/core.cljc","^:",10,"^80",["^11",[["^8?"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",347,"^88","^85","^9",347,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^8?"]]]]],"^13","Given an array of promises, return a promise that is fulfilled when\n  all the items in the array are fulfilled.\n\n  Example:\n\n  ```\n  (-> (p/all [(promise :first-promise)\n              (promise :second-promise)])\n      (then (fn [[first-result second-result]])\n              (println (str first-result \", \" second-result))))\n  ```\n\n  Will print to out `:first-promise, :second-promise`.\n\n  If at least one of the promises is rejected, the resulting promise\n  will be rejected."],"~$reject!",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",444,"^8",7,"^9",444,"^:",14,"^10",["^11",["^7V",["^11",[["~$p","~$e"]]]]],"^13","Reject a completable promise with an error."],"^14","^5S","^6","promesa/core.cljc","^:",14,"^80",["^11",[["~$p","~$e"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",444,"^88","^85","^9",444,"^7[",2,"^86",true,"^10",["^11",["^7V",["^11",[["~$p","~$e"]]]]],"^13","Reject a completable promise with an error."],"~$->Recur",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^:",17,"^8",12,"^91",true,"~:factory","~:positional","^7",589,"^9",589,"^10",["^11",["^7V",["^11",[["^1="]]]]],"^13","Positional factory function for promesa.core/Recur."],"^14","^4@","^6","promesa/core.cljc","^:",17,"^80",["^11",[["^1="]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^91",true,"^7Y",false,"^9I","^9J","^7",589,"^88","^2W","^9",589,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^1="]]]]],"^13","Positional factory function for promesa.core/Recur."],"~$promise?",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",85,"^8",7,"^9",85,"^:",15,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a promise instance."],"^14","^5K","^6","promesa/core.cljc","^:",15,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",85,"^88","^89","^9",85,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return true if `v` is a promise instance."],"~$resolved",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",30,"^8",7,"^9",30,"^:",15,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return a resolved promise with provided value."],"^14","^4C","^6","promesa/core.cljc","^:",15,"^80",["^11",[["~$v"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",30,"^88","^85","^9",30,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$v"]]]]],"^13","Return a resolved promise with provided value."],"~$deferred",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",40,"^8",7,"^9",40,"^:",15,"^10",["^11",["^7V",["^11",[[]]]]],"^13","Creates an empty promise instance."],"^14","^41","^6","promesa/core.cljc","^:",15,"^80",["^11",[[]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",40,"^88","^4B","^9",40,"^7[",0,"^86",true,"^10",["^11",["^7V",["^11",[[]]]]],"^13","Creates an empty promise instance."],"~$recur?",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",590,"^8",7,"^9",590,"^:",13,"^10",["^11",["^7V",["^11",[["~$o"]]]]]],"^14","^4G","^6","promesa/core.cljc","^:",13,"^80",["^11",[["~$o"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^7",590,"^88","^89","^9",590,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["~$o"]]]]]],"~$catch",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",301,"^8",7,"^9",301,"^:",12,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will be resolved with the return\n  value of calling `f` with exception as single argument; `f` can\n  return a plain value or promise instance, an automatic unwrapping\n  will be performed.\n\n  The computation will be executed in the completion thread, look at\n  `merr` if you want the ability to schedule the computation to other\n  thread.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","^9B","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]],"^81",["^11",[null,null]]]],"^14","^38","^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","^9B","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","^9B","~$f"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",301,"^9",301,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","^9B","~$f"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will be resolved with the return\n  value of calling `f` with exception as single argument; `f` can\n  return a plain value or promise instance, an automatic unwrapping\n  will be performed.\n\n  The computation will be executed in the completion thread, look at\n  `merr` if you want the ability to schedule the computation to other\n  thread."],"~$chain",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",219,"^8",7,"^9",219,"^:",12,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]]]],"^13","Chain variable number of functions to be executed serially using\n  `then`.","^7X",["^ ","^7Y",true,"^7Z",2,"^7[",2,"^80",[["~$p","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^81",["^11",[null,null]]]],"^14","^5F","^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",true,"^7Z",2,"^7[",2,"^80",[["~$p","~$f"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",true,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",true,"^84",["^H",[null,"^85"]]]],"^7",219,"^9",219,"^7[",2,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","~$&","^8E"]]],"^13","Chain variable number of functions to be executed serially using\n  `then`."],"~$fmap",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",190,"^8",7,"^9",190,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","A convenience alias for `map`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^3?","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",190,"^9",190,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","A convenience alias for `map`."],"~$hcat",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",274,"^8",7,"^9",274,"^:",11,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise that will mirror the\n  promise instance returned by calling `f` with both: value and the\n  exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]]],"^14","^4K","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["^8;","~$f","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",274,"^9",274,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["^8;","~$f","~$p"]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise that will mirror the\n  promise instance returned by calling `f` with both: value and the\n  exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`."],"~$handle",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",231,"^8",7,"^9",231,"^:",13,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception; `f` can return a new plain value or promise instance,\n  and automatic unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  For performance sensitive code, look at `hmap` and `hcat`.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^4Q","^6","promesa/core.cljc","^:",13,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",231,"^9",231,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^13","Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception; `f` can return a new plain value or promise instance,\n  and automatic unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  For performance sensitive code, look at `hmap` and `hcat`."],"~$then",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",135,"^8",7,"^9",135,"^:",11,"^10",["^11",["^7V",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  can return a plain value or promise instance, an automatic\n  unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.","^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]]],"^14","^5;","^6","promesa/core.cljc","^:",11,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^81",["^11",[null,null]]],"^80",[["~$p","~$f"],["~$p","~$f","^8;"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",135,"^9",135,"^7[",3,"^86",true,"^10",["^11",[["~$p","~$f"],["~$p","~$f","^8;"]]],"^13","Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  can return a plain value or promise instance, an automatic\n  unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor."],"~$thread-call",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^7",557,"^8",7,"^9",557,"^:",18,"^10",["^11",["^7V",["^11",[["~$f"],["^8;","~$f"]]]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise\n  instance instead of the `Future`. Useful for executing synchronous\n  code in a separate thread (also works in cljs).","^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$f"],["^8;","~$f"]],"^10",["^11",[["~$f"],["^8;","~$f"]]],"^81",["^11",[null,null]]]],"^14","^3E","^6","promesa/core.cljc","^:",18,"^7X",["^ ","^7Y",false,"^7Z",2,"^7[",2,"^80",[["~$f"],["^8;","~$f"]],"^10",["^11",[["~$f"],["^8;","~$f"]]],"^81",["^11",[null,null]]],"^80",[["~$f"],["^8;","~$f"]],"^82",null,"^7Z",2,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",1,"^7Y",false,"^84","^85"],["^ ","^7Z",2,"^7Y",false,"^84","^85"]],"^7",557,"^9",557,"^7[",2,"^86",true,"^10",["^11",[["~$f"],["^8;","~$f"]]],"^13","Analogous to `clojure.core.async/thread` that returns a promise\n  instance instead of the `Future`. Useful for executing synchronous\n  code in a separate thread (also works in cljs)."],"~$map->Recur",["^ ","^7U",null,"^5",["^ ","^6","promesa/core.cljc","^:",17,"^8",12,"^91",true,"^9I","~:map","^7",589,"^9",589,"^10",["^11",["^7V",["^11",[["~$G__12358"]]]]],"^13","Factory function for promesa.core/Recur, taking a map of keywords to field values."],"^14","^35","^6","promesa/core.cljc","^:",17,"^80",["^11",[["^9X"]]],"^82",null,"^81",["^11",[null,null]],"^8",1,"^91",true,"^7Y",false,"^9I","^9W","^7",589,"^88","^2W","^9",589,"^7[",1,"^86",true,"^10",["^11",["^7V",["^11",[["^9X"]]]]],"^13","Factory function for promesa.core/Recur, taking a map of keywords to field values."],"~$error",["^ ","^9A",true,"^7U",null,"^5",["^ ","^9A",true,"^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["~$f","^9B","~$p"]],"^10",["^11",[["~$f","~$p"],["~$f","^9B","~$p"]]],"^81",["^11",[null,null]]],"^8",7,"^7",329,"^9C","9.3","^9",329,"^10",["^11",["^7V",["^11",[["~$f","~$p"],["~$f","^9B","~$p"]]]]]],"^14","^4W","^6","promesa/core.cljc","^:",12,"^7X",["^ ","^7Y",false,"^7Z",3,"^7[",3,"^80",[["~$f","~$p"],["~$f","^9B","~$p"]],"^10",["^11",[["~$f","~$p"],["~$f","^9B","~$p"]]],"^81",["^11",[null,null]]],"^80",[["~$f","~$p"],["~$f","^9B","~$p"]],"^82",null,"^7Z",3,"^81",["^11",[null,null]],"^8",1,"^7Y",false,"^83",[["^ ","^7Z",2,"^7Y",false,"^84","^85"],["^ ","^7Z",3,"^7Y",false,"^84","^85"]],"^7",329,"^9C","9.3","^9",329,"^7[",3,"^86",true,"^10",["^11",[["~$f","~$p"],["~$f","^9B","~$p"]]]]],"^28",["^ ","^17","^17","^E","^E","^D","^E","~$c","^E"],"~:cljs.analyzer/constants",["^ ","^26",["^H",["~:promesa.core/default","~:else","~:default","~:bindings","~:pending","^1=","~:vthread","~:thread","~:rejections","~:resolved?"]],"~:order",["^9[","^:3","^:6","^:7","^:0","^:1","^:5","^:4","^:2","^1="]],"^2?",["^ ","^27",["^H",[]],"^28",["^H",[]]],"^2@",[],"^2A",["^22","^E","^1[","^E","^24","^1Z","^21"]],"^16","^17","~:ns-specs",["^ "],"~:ns-spec-vars",["^H",[]],"~:compiler-options",["^5U",[["^:;","~:static-fns"],true,["~:js-options","~:use-babel"],null,["^:;","~:shadow-tweaks"],null,["^:;","~:source-map-inline"],null,["^:;","~:shadow-optimize-constants"],null,["^:;","~:elide-asserts"],false,["^:;","~:optimize-constants"],null,["^:;","^2F"],null,["^:;","~:external-config"],null,["^:;","~:tooling-config"],null,["^:;","~:emit-constants"],null,["^:;","~:load-tests"],null,["^:;","~:form-size-threshold"],null,["^:;","~:global-goog-object&array"],null,["^:;","~:data-readers"],null,["^:;","~:infer-externs"],"~:auto",["^:;","^2H"],null,["^:=","~:js-provider"],"^27",["~:mode"],"~:dev",["^:;","~:fn-invoke-direct"],null,["^:;","~:source-map"],"/dev/null"]]]